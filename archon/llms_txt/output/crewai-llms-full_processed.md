# Processed Output for: crewai-llms-full.txt

```json
[
  [
    {
      "content": "Source: https://docs.crewai.com/changelog View the latest updates and changes to CrewAI Converted tabs to spaces in `crew.py` template Enhanced LLM Streaming Response Handling and Event System Included `model_name` Enhanced Event Listener with rich visualization and improved logging Added fingerprints **Bug Fixes** Fixed Mistral issues Fixed a bug in documentation Fixed type check error in fingerprint property **Documentation Updates** Improved tool documentation Updated installation guide for the `uv` tool package Added instructions for upgrading crewAI with the `uv` tool Added documentation for `ApifyActorsTool`\n</Update> Fixed issues with missing template variables and user memory configuration Improved async flow support and addressed agent response formatting Enhanced memory reset functionality and fixed CLI memory commands Fixed type issues, tool calling properties, and telemetry decoupling **New Features & Enhancements** Added Flow state export and improved state utilities Enhanced agent knowledge setup with optional crew embedder Introduced event emitter for better observability and LLM call tracking Added support for Python 3.10 and ChatOllama from langchain\\_ollama Integrated context window size support for the o3-mini model Added support for multiple router calls **Documentation & Guides** Improved documentation layout and hierarchical structure Added QdrantVectorSearchTool guide and clarified event listener usage Fixed typos in prompts and updated Amazon Bedrock model listings\n</Update> Enhanced LLM Support: Improved structured LLM output, parameter handling, and formatting for Anthropic models Crew & Agent Stability: Fixed issues with cloning agents/crews using knowledge sources, multiple task outputs in conditional tasks, and ignored Crew task callbacks Memory & Storage Fixes: Fixed short-term memory handling with Bedrock, ensured correct embedder initialization, and added a reset memories function in the crew class Training & Execution Reliability: Fixed broken training and interpolation issues with dict and list input types **New Features & Enhancements** Advanced Knowledge Management: Improved naming conventions and enhanced embedding configuration with custom embedder support Expanded Logging & Observability: Added JSON format support for logging and integrated MLflow tracing documentation Data Handling Improvements: Updated excel\\_knowledge\\_source.py to process multi-tab files General Performance & Codebase Clean-Up: Streamlined enterprise code alignment and resolved linting issues Adding new tool: `QdrantVectorSearchTool` **Documentation & Guides** Updated AI & Memory Docs: Improved Bedrock, Google AI, and long-term memory documentation Task & Workflow Clarity: Added \"Human Input\" row to Task Attributes, Langfuse guide, and FileWriterTool documentation Fixed Various Typos & Formatting Issues\n</Update> Add Composio docs Add SageMaker as a LLM provider **Fixes** Overall LLM connection issues Using safe accessors on training Add version check to crew\\_chat.py **Documentation** New docs for crewai chat Improve formatting and clarity in CLI and Composio Tool docs\n</Update> Conversation crew v1 Add unique ID to flow states Add @persist decorator with FlowPersistence interface **Integrations** Add SambaNova integration Add NVIDIA NIM provider in cli Introducing VoyageAI **Fixes** Fix API Key Behavior and Entity Handling in Mem0 Integration Fixed core invoke loop logic and relevant tests Make tool inputs actual objects and not strings Add important missing parts to creating tools Drop litellm version to prevent windows issue Before kickoff if inputs are none Fixed typos, nested pydantic model issue, and docling issues\n</Update> Adding Multimodal Abilities to Crew Programatic Guardrails HITL multiple rounds Gemini 2.0 Support CrewAI Flows Improvements Add Workflow Permissions Add support for langfuse with litellm Portkey Integration with CrewAI Add interpolate\\_only method and improve error handling Docling Support Weviate Support **Fixes** output\\_file not respecting system path disk I/O error when resetting short-term memory CrewJSONEncoder now accepts enums Python max version Interpolation for output\\_file in Task Handle coworker role name case/whitespace properly Add tiktoken as explicit dependency and document Rust requirement Include agent knowledge in planning process Change storage initialization to None for KnowledgeStorage Fix optional storage checks include event emitter in flows Docstring, Error Handling, and Type Hints Improvements Suppressed userWarnings from litellm pydantic issues\n</Update> Remove all references to pipeline and pipeline router Add Nvidia NIM as provider in Custom LLM Add knowledge demo + improve knowledge docs Add HITL multiple rounds of followup New docs about yaml crew with decorators Simplify template crew\n</Update> Added knowledge to agent level Feat/remove langchain Improve typed task outputs Log in to Tool Repository on crewai login **Fixes** Fixes issues with result as answer not properly exiting LLM loop Fix missing key name when running with ollama provider Fix spelling issue found **Documentation** Update readme for running mypy Add knowledge to mint.json Update Github actions Update Agents docs to include two approaches for creating an agent Improvements to LLM Configuration and Usage\n</Update> New before\\_kickoff and after\\_kickoff crew callbacks Support to pre-seed agents with Knowledge Add support for retrieving user preferences and memories using Mem0 **Fixes** Fix Async Execution Upgrade chroma and adjust embedder function generator Update CLI Watson supported models + docs Reduce level for Bandit Fixing all tests **Documentation** Update Docs\n</Update> Fixing Tokens callback replacement bug Fixing Step callback issue Add cached prompt tokens info on usage metrics Fix crew\\_train\\_success test\n</Update>",
      "title": "Changelog",
      "type": "descriptive_text_oversized",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Changelog",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Changelog",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Changelog"
      },
      "enhanced_content": "Context: Changelog > Changelog\n\n# Changelog\n\nSource: https://docs.crewai.com/changelog View the latest updates and changes to CrewAI Converted tabs to spaces in `crew.py` template Enhanced LLM Streaming Response Handling and Event System Included `model_name` Enhanced Event Listener with rich visualization and improved logging Added fingerprints **Bug Fixes** Fixed Mistral issues Fixed a bug in documentation Fixed type check error in fingerprint property **Documentation Updates** Improved tool documentation Updated installation guide for the `uv` tool package Added instructions for upgrading crewAI with the `uv` tool Added documentation for `ApifyActorsTool`\n</Update> Fixed issues with missing template variables and user memory configuration Improved async flow support and addressed agent response formatting Enhanced memory reset functionality and fixed CLI memory commands Fixed type issues, tool calling properties, and telemetry decoupling **New Features & Enhancements** Added Flow state export and improved state utilities Enhanced agent knowledge setup with optional crew embedder Introduced event emitter for better observability and LLM call tracking Added support for Python 3.10 and ChatOllama from langchain\\_ollama Integrated context window size support for the o3-mini model Added support for multiple router calls **Documentation & Guides** Improved documentation layout and hierarchical structure Added QdrantVectorSearchTool guide and clarified event listener usage Fixed typos in prompts and updated Amazon Bedrock model listings\n</Update> Enhanced LLM Support: Improved structured LLM output, parameter handling, and formatting for Anthropic models Crew & Agent Stability: Fixed issues with cloning agents/crews using knowledge sources, multiple task outputs in conditional tasks, and ignored Crew task callbacks Memory & Storage Fixes: Fixed short-term memory handling with Bedrock, ensured correct embedder initialization, and added a reset memories function in the crew class Training & Execution Reliability: Fixed broken training and interpolation issues with dict and list input types **New Features & Enhancements** Advanced Knowledge Management: Improved naming conventions and enhanced embedding configuration with custom embedder support Expanded Logging & Observability: Added JSON format support for logging and integrated MLflow tracing documentation Data Handling Improvements: Updated excel\\_knowledge\\_source.py to process multi-tab files General Performance & Codebase Clean-Up: Streamlined enterprise code alignment and resolved linting issues Adding new tool: `QdrantVectorSearchTool` **Documentation & Guides** Updated AI & Memory Docs: Improved Bedrock, Google AI, and long-term memory documentation Task & Workflow Clarity: Added \"Human Input\" row to Task Attributes, Langfuse guide, and FileWriterTool documentation Fixed Various Typos & Formatting Issues\n</Update> Add Composio docs Add SageMaker as a LLM provider **Fixes** Overall LLM connection issues Using safe accessors on training Add version check to crew\\_chat.py **Documentation** New docs for crewai chat Improve formatting and clarity in CLI and Composio Tool docs\n</Update> Conversation crew v1 Add unique ID to flow states Add @persist decorator with FlowPersistence interface **Integrations** Add SambaNova integration Add NVIDIA NIM provider in cli Introducing VoyageAI **Fixes** Fix API Key Behavior and Entity Handling in Mem0 Integration Fixed core invoke loop logic and relevant tests Make tool inputs actual objects and not strings Add important missing parts to creating tools Drop litellm version to prevent windows issue Before kickoff if inputs are none Fixed typos, nested pydantic model issue, and docling issues\n</Update> Adding Multimodal Abilities to Crew Programatic Guardrails HITL multiple rounds Gemini 2.0 Support CrewAI Flows Improvements Add Workflow Permissions Add support for langfuse with litellm Portkey Integration with CrewAI Add interpolate\\_only method and improve error handling Docling Support Weviate Support **Fixes** output\\_file not respecting system path disk I/O error when resetting short-term memory CrewJSONEncoder now accepts enums Python max version Interpolation for output\\_file in Task Handle coworker role name case/whitespace properly Add tiktoken as explicit dependency and document Rust requirement Include agent knowledge in planning process Change storage initialization to None for KnowledgeStorage Fix optional storage checks include event emitter in flows Docstring, Error Handling, and Type Hints Improvements Suppressed userWarnings from litellm pydantic issues\n</Update> Remove all references to pipeline and pipeline router Add Nvidia NIM as provider in Custom LLM Add knowledge demo + improve knowledge docs Add HITL multiple rounds of followup New docs about yaml crew with decorators Simplify template crew\n</Update> Added knowledge to agent level Feat/remove langchain Improve typed task outputs Log in to Tool Repository on crewai login **Fixes** Fixes issues with result as answer not properly exiting LLM loop Fix missing key name when running with ollama provider Fix spelling issue found **Documentation** Update readme for running mypy Add knowledge to mint.json Update Github actions Update Agents docs to include two approaches for creating an agent Improvements to LLM Configuration and Usage\n</Update> New before\\_kickoff and after\\_kickoff crew callbacks Support to pre-seed agents with Knowledge Add support for retrieving user preferences and memories using Mem0 **Fixes** Fix Async Execution Upgrade chroma and adjust embedder function generator Update CLI Watson supported models + docs Reduce level for Bandit Fixing all tests **Documentation** Update Docs\n</Update> Fixing Tokens callback replacement bug Fixing Step callback issue Add cached prompt tokens info on usage metrics Fix crew\\_train\\_success test\n</Update>",
      "formatted_path": "Changelog > Changelog",
      "enhanced_text": "Context: Changelog > Changelog\n\n Changelog\n\nSource: https://docs.crewai.com/changelog View the latest updates and changes to CrewAI Converted tabs to spaces in `crew.py` template Enhanced LLM Streaming Response Handling and Event System Included `model_name` Enhanced Event Listener with rich visualization and improved logging Added fingerprints **Bug Fixes** Fixed Mistral issues Fixed a bug in documentation Fixed type check error in fingerprint property **Documentation Updates** Improved tool documentation Updated installation guide for the `uv` tool package Added instructions for upgrading crewAI with the `uv` tool Added documentation for `ApifyActorsTool`\n</Update> Fixed issues with missing template variables and user memory configuration Improved async flow support and addressed agent response formatting Enhanced memory reset functionality and fixed CLI memory commands Fixed type issues, tool calling properties, and telemetry decoupling **New Features & Enhancements** Added Flow state export and improved state utilities Enhanced agent knowledge setup with optional crew embedder Introduced event emitter for better observability and LLM call tracking Added support for Python 3.10 and ChatOllama from langchain\\_ollama Integrated context window size support for the o3-mini model Added support for multiple router calls **Documentation & Guides** Improved documentation layout and hierarchical structure Added QdrantVectorSearchTool guide and clarified event listener usage Fixed typos in prompts and updated Amazon Bedrock model listings\n</Update> Enhanced LLM Support: Improved structured LLM output, parameter handling, and formatting for Anthropic models Crew & Agent Stability: Fixed issues with cloning agents/crews using knowledge sources, multiple task outputs in conditional tasks, and ignored Crew task callbacks Memory & Storage Fixes: Fixed short-term memory handling with Bedrock, ensured correct embedder initialization, and added a reset memories function in the crew class Training & Execution Reliability: Fixed broken training and interpolation issues with dict and list input types **New Features & Enhancements** Advanced Knowledge Management: Improved naming conventions and enhanced embedding configuration with custom embedder support Expanded Logging & Observability: Added JSON format support for logging and integrated MLflow tracing documentation Data Handling Improvements: Updated excel\\_knowledge\\_source.py to process multi-tab files General Performance & Codebase Clean-Up: Streamlined enterprise code alignment and resolved linting issues Adding new tool: `QdrantVectorSearchTool` **Documentation & Guides** Updated AI & Memory Docs: Improved Bedrock, Google AI, and long-term memory documentation Task & Workflow Clarity: Added \"Human Input\" row to Task Attributes, Langfuse guide, and FileWriterTool documentation Fixed Various Typos & Formatting Issues\n</Update> Add Composio docs Add SageMaker as a LLM provider **Fixes** Overall LLM connection issues Using safe accessors on training Add version check to crew\\_chat.py **Documentation** New docs for crewai chat Improve formatting and clarity in CLI and Composio Tool docs\n</Update> Conversation crew v1 Add unique ID to flow states Add @persist decorator with FlowPersistence interface **Integrations** Add SambaNova integration Add NVIDIA NIM provider in cli Introducing VoyageAI **Fixes** Fix API Key Behavior and Entity Handling in Mem0 Integration Fixed core invoke loop logic and relevant tests Make tool inputs actual objects and not strings Add important missing parts to creating tools Drop litellm version to prevent windows issue Before kickoff if inputs are none Fixed typos, nested pydantic model issue, and docling issues\n</Update> Adding Multimodal Abilities to Crew Programatic Guardrails HITL multiple rounds Gemini 2.0 Support CrewAI Flows Improvements Add Workflow Permissions Add support for langfuse with litellm Portkey Integration with CrewAI Add interpolate\\_only method and improve error handling Docling Support Weviate Support **Fixes** output\\_file not respecting system path disk I/O error when resetting short-term memory CrewJSONEncoder now accepts enums Python max version Interpolation for output\\_file in Task Handle coworker role name case/whitespace properly Add tiktoken as explicit dependency and document Rust requirement Include agent knowledge in planning process Change storage initialization to None for KnowledgeStorage Fix optional storage checks include event emitter in flows Docstring, Error Handling, and Type Hints Improvements Suppressed userWarnings from litellm pydantic issues\n</Update> Remove all references to pipeline and pipeline router Add Nvidia NIM as provider in Custom LLM Add knowledge demo + improve knowledge docs Add HITL multiple rounds of followup New docs about yaml crew with decorators Simplify template crew\n</Update> Added knowledge to agent level Feat/remove langchain Improve typed task outputs Log in to Tool Repository on crewai login **Fixes** Fixes issues with result as answer not properly exiting LLM loop Fix missing key name when running with ollama provider Fix spelling issue found **Documentation** Update readme for running mypy Add knowledge to mint.json Update Github actions Update Agents docs to include two approaches for creating an agent Improvements to LLM Configuration and Usage\n</Update> New before\\_kickoff and after\\_kickoff crew callbacks Support to pre-seed agents with Knowledge Add support for retrieving user preferences and memories using Mem0 **Fixes** Fix Async Execution Upgrade chroma and adjust embedder function generator Update CLI Watson supported models + docs Reduce level for Bandit Fixing all tests **Documentation** Update Docs\n</Update> Fixing Tokens callback replacement bug Fixing Step callback issue Add cached prompt tokens info on usage metrics Fix crew\\_train\\_success test\n</Update>"
    },
    {
      "content": "Source: https://docs.crewai.com/concepts/agents Detailed guide on creating and managing agents within the CrewAI framework.",
      "title": "Agents",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Agents",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Agents",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Agents"
      },
      "enhanced_content": "Context: Changelog > Agents\n\n# Agents\n\nSource: https://docs.crewai.com/concepts/agents Detailed guide on creating and managing agents within the CrewAI framework.",
      "formatted_path": "Changelog > Agents",
      "enhanced_text": "Context: Changelog > Agents\n\n Agents\n\nSource: https://docs.crewai.com/concepts/agents Detailed guide on creating and managing agents within the CrewAI framework.\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "In the CrewAI framework, an `Agent` is an autonomous unit that can: Perform specific tasks Make decisions based on its role and goal Use tools to accomplish objectives Communicate and collaborate with other agents Maintain memory of interactions Delegate tasks when allowed",
      "title": "Overview of an Agent",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Agents",
          "level": 1
        },
        {
          "title": "Overview of an Agent",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Agents",
            "level": 1
          },
          {
            "title": "Overview of an Agent",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Agents > Overview of an Agent"
      },
      "enhanced_content": "Context: Changelog > Agents > Overview of an Agent\n\n## Overview of an Agent\n\nIn the CrewAI framework, an `Agent` is an autonomous unit that can: Perform specific tasks Make decisions based on its role and goal Use tools to accomplish objectives Communicate and collaborate with other agents Maintain memory of interactions Delegate tasks when allowed",
      "formatted_path": "Changelog > Agents > Overview of an Agent",
      "enhanced_text": "Context: Changelog > Agents > Overview of an Agent\n\n Overview of an Agent\n\nIn the CrewAI framework, an `Agent` is an autonomous unit that can: Perform specific tasks Make decisions based on its role and goal Use tools to accomplish objectives Communicate and collaborate with other agents Maintain memory of interactions Delegate tasks when allowed\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "| Attribute                               | Parameter                | Type                                  | Description                                                                                              |\n| :-------------------------------------- | :----------------------- | :------------------------------------ | :------------------------------------------------------------------------------------------------------- |\n| **Role**                                | `role`                   | `str`                                 | Defines the agent's function and expertise within the crew.                                              |\n| **Goal**                                | `goal`                   | `str`                                 | The individual objective that guides the agent's decision-making.                                        |\n| **Backstory**                           | `backstory`              | `str`                                 | Provides context and personality to the agent, enriching interactions.                                   |\n| **LLM** *(optional)*                    | `llm`                    | `Union[str, LLM, Any]`                | Language model that powers the agent. Defaults to the model specified in `OPENAI_MODEL_NAME` or \"gpt-4\". |\n| **Tools** *(optional)*                  | `tools`                  | `List[BaseTool]`                      | Capabilities or functions available to the agent. Defaults to an empty list.                             |\n| **Function Calling LLM** *(optional)*   | `function_calling_llm`   | `Optional[Any]`                       | Language model for tool calling, overrides crew's LLM if specified.                                      |\n| **Max Iterations** *(optional)*         | `max_iter`               | `int`                                 | Maximum iterations before the agent must provide its best answer. Default is 20.                         |\n| **Max RPM** *(optional)*                | `max_rpm`                | `Optional[int]`                       | Maximum requests per minute to avoid rate limits.                                                        |\n| **Max Execution Time** *(optional)*     | `max_execution_time`     | `Optional[int]`                       | Maximum time (in seconds) for task execution.                                                            |\n| **Memory** *(optional)*                 | `memory`                 | `bool`                                | Whether the agent should maintain memory of interactions. Default is True.                               |\n| **Verbose** *(optional)*                | `verbose`                | `bool`                                | Enable detailed execution logs for debugging. Default is False.                                          |\n| **Allow Delegation** *(optional)*       | `allow_delegation`       | `bool`                                | Allow the agent to delegate tasks to other agents. Default is False.                                     |\n| **Step Callback** *(optional)*          | `step_callback`          | `Optional[Any]`                       | Function called after each agent step, overrides crew callback.                                          |\n| **Cache** *(optional)*                  | `cache`                  | `bool`                                | Enable caching for tool usage. Default is True.                                                          |\n| **System Template** *(optional)*        | `system_template`        | `Optional[str]`                       | Custom system prompt template for the agent.                                                             |\n| **Prompt Template** *(optional)*        | `prompt_template`        | `Optional[str]`                       | Custom prompt template for the agent.                                                                    |\n| **Response Template** *(optional)*      | `response_template`      | `Optional[str]`                       | Custom response template for the agent.                                                                  |\n| **Allow Code Execution** *(optional)*   | `allow_code_execution`   | `Optional[bool]`                      | Enable code execution for the agent. Default is False.                                                   |\n| **Max Retry Limit** *(optional)*        | `max_retry_limit`        | `int`                                 | Maximum number of retries when an error occurs. Default is 2.                                            |\n| **Respect Context Window** *(optional)* | `respect_context_window` | `bool`                                | Keep messages under context window size by summarizing. Default is True.                                 |\n| **Code Execution Mode** *(optional)*    | `code_execution_mode`    | `Literal[\"safe\", \"unsafe\"]`           | Mode for code execution: 'safe' (using Docker) or 'unsafe' (direct). Default is 'safe'.                  |\n| **Embedder** *(optional)*               | `embedder`               | `Optional[Dict[str, Any]]`            | Configuration for the embedder used by the agent.                                                        |\n| **Knowledge Sources** *(optional)*      | `knowledge_sources`      | `Optional[List[BaseKnowledgeSource]]` | Knowledge sources available to the agent.                                                                |\n| **Use System Prompt** *(optional)*      | `use_system_prompt`      | `Optional[bool]`                      | Whether to use system prompt (for o1 model support). Default is True.                                    |",
      "title": "Agent Attributes",
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Agents",
          "level": 1
        },
        {
          "title": "Agent Attributes",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Agents",
            "level": 1
          },
          {
            "title": "Agent Attributes",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Agents > Agent Attributes"
      },
      "enhanced_content": "Context: Changelog > Agents > Agent Attributes\n\n## Agent Attributes\n\n| Attribute                               | Parameter                | Type                                  | Description                                                                                              |\n| :-------------------------------------- | :----------------------- | :------------------------------------ | :------------------------------------------------------------------------------------------------------- |\n| **Role**                                | `role`                   | `str`                                 | Defines the agent's function and expertise within the crew.                                              |\n| **Goal**                                | `goal`                   | `str`                                 | The individual objective that guides the agent's decision-making.                                        |\n| **Backstory**                           | `backstory`              | `str`                                 | Provides context and personality to the agent, enriching interactions.                                   |\n| **LLM** *(optional)*                    | `llm`                    | `Union[str, LLM, Any]`                | Language model that powers the agent. Defaults to the model specified in `OPENAI_MODEL_NAME` or \"gpt-4\". |\n| **Tools** *(optional)*                  | `tools`                  | `List[BaseTool]`                      | Capabilities or functions available to the agent. Defaults to an empty list.                             |\n| **Function Calling LLM** *(optional)*   | `function_calling_llm`   | `Optional[Any]`                       | Language model for tool calling, overrides crew's LLM if specified.                                      |\n| **Max Iterations** *(optional)*         | `max_iter`               | `int`                                 | Maximum iterations before the agent must provide its best answer. Default is 20.                         |\n| **Max RPM** *(optional)*                | `max_rpm`                | `Optional[int]`                       | Maximum requests per minute to avoid rate limits.                                                        |\n| **Max Execution Time** *(optional)*     | `max_execution_time`     | `Optional[int]`                       | Maximum time (in seconds) for task execution.                                                            |\n| **Memory** *(optional)*                 | `memory`                 | `bool`                                | Whether the agent should maintain memory of interactions. Default is True.                               |\n| **Verbose** *(optional)*                | `verbose`                | `bool`                                | Enable detailed execution logs for debugging. Default is False.                                          |\n| **Allow Delegation** *(optional)*       | `allow_delegation`       | `bool`                                | Allow the agent to delegate tasks to other agents. Default is False.                                     |\n| **Step Callback** *(optional)*          | `step_callback`          | `Optional[Any]`                       | Function called after each agent step, overrides crew callback.                                          |\n| **Cache** *(optional)*                  | `cache`                  | `bool`                                | Enable caching for tool usage. Default is True.                                                          |\n| **System Template** *(optional)*        | `system_template`        | `Optional[str]`                       | Custom system prompt template for the agent.                                                             |\n| **Prompt Template** *(optional)*        | `prompt_template`        | `Optional[str]`                       | Custom prompt template for the agent.                                                                    |\n| **Response Template** *(optional)*      | `response_template`      | `Optional[str]`                       | Custom response template for the agent.                                                                  |\n| **Allow Code Execution** *(optional)*   | `allow_code_execution`   | `Optional[bool]`                      | Enable code execution for the agent. Default is False.                                                   |\n| **Max Retry Limit** *(optional)*        | `max_retry_limit`        | `int`                                 | Maximum number of retries when an error occurs. Default is 2.                                            |\n| **Respect Context Window** *(optional)* | `respect_context_window` | `bool`                                | Keep messages under context window size by summarizing. Default is True.                                 |\n| **Code Execution Mode** *(optional)*    | `code_execution_mode`    | `Literal[\"safe\", \"unsafe\"]`           | Mode for code execution: 'safe' (using Docker) or 'unsafe' (direct). Default is 'safe'.                  |\n| **Embedder** *(optional)*               | `embedder`               | `Optional[Dict[str, Any]]`            | Configuration for the embedder used by the agent.                                                        |\n| **Knowledge Sources** *(optional)*      | `knowledge_sources`      | `Optional[List[BaseKnowledgeSource]]` | Knowledge sources available to the agent.                                                                |\n| **Use System Prompt** *(optional)*      | `use_system_prompt`      | `Optional[bool]`                      | Whether to use system prompt (for o1 model support). Default is True.                                    |",
      "formatted_path": "Changelog > Agents > Agent Attributes",
      "enhanced_text": "Context: Changelog > Agents > Agent Attributes\n\n Agent Attributes\n\n| Attribute                               | Parameter                | Type                                  | Description                                                                                              |\n| :-------------------------------------- | :----------------------- | :------------------------------------ | :------------------------------------------------------------------------------------------------------- |\n| **Role**                                | `role`                   | `str`                                 | Defines the agent's function and expertise within the crew.                                              |\n| **Goal**                                | `goal`                   | `str`                                 | The individual objective that guides the agent's decision-making.                                        |\n| **Backstory**                           | `backstory`              | `str`                                 | Provides context and personality to the agent, enriching interactions.                                   |\n| **LLM** *(optional)*                    | `llm`                    | `Union[str, LLM, Any]`                | Language model that powers the agent. Defaults to the model specified in `OPENAI_MODEL_NAME` or \"gpt-4\". |\n| **Tools** *(optional)*                  | `tools`                  | `List[BaseTool]`                      | Capabilities or functions available to the agent. Defaults to an empty list.                             |\n| **Function Calling LLM** *(optional)*   | `function_calling_llm`   | `Optional[Any]`                       | Language model for tool calling, overrides crew's LLM if specified.                                      |\n| **Max Iterations** *(optional)*         | `max_iter`               | `int`                                 | Maximum iterations before the agent must provide its best answer. Default is 20.                         |\n| **Max RPM** *(optional)*                | `max_rpm`                | `Optional[int]`                       | Maximum requests per minute to avoid rate limits.                                                        |\n| **Max Execution Time** *(optional)*     | `max_execution_time`     | `Optional[int]`                       | Maximum time (in seconds) for task execution.                                                            |\n| **Memory** *(optional)*                 | `memory`                 | `bool`                                | Whether the agent should maintain memory of interactions. Default is True.                               |\n| **Verbose** *(optional)*                | `verbose`                | `bool`                                | Enable detailed execution logs for debugging. Default is False.                                          |\n| **Allow Delegation** *(optional)*       | `allow_delegation`       | `bool`                                | Allow the agent to delegate tasks to other agents. Default is False.                                     |\n| **Step Callback** *(optional)*          | `step_callback`          | `Optional[Any]`                       | Function called after each agent step, overrides crew callback.                                          |\n| **Cache** *(optional)*                  | `cache`                  | `bool`                                | Enable caching for tool usage. Default is True.                                                          |\n| **System Template** *(optional)*        | `system_template`        | `Optional[str]`                       | Custom system prompt template for the agent.                                                             |\n| **Prompt Template** *(optional)*        | `prompt_template`        | `Optional[str]`                       | Custom prompt template for the agent.                                                                    |\n| **Response Template** *(optional)*      | `response_template`      | `Optional[str]`                       | Custom response template for the agent.                                                                  |\n| **Allow Code Execution** *(optional)*   | `allow_code_execution`   | `Optional[bool]`                      | Enable code execution for the agent. Default is False.                                                   |\n| **Max Retry Limit** *(optional)*        | `max_retry_limit`        | `int`                                 | Maximum number of retries when an error occurs. Default is 2.                                            |\n| **Respect Context Window** *(optional)* | `respect_context_window` | `bool`                                | Keep messages under context window size by summarizing. Default is True.                                 |\n| **Code Execution Mode** *(optional)*    | `code_execution_mode`    | `Literal[\"safe\", \"unsafe\"]`           | Mode for code execution: 'safe' (using Docker) or 'unsafe' (direct). Default is 'safe'.                  |\n| **Embedder** *(optional)*               | `embedder`               | `Optional[Dict[str, Any]]`            | Configuration for the embedder used by the agent.                                                        |\n| **Knowledge Sources** *(optional)*      | `knowledge_sources`      | `Optional[List[BaseKnowledgeSource]]` | Knowledge sources available to the agent.                                                                |\n| **Use System Prompt** *(optional)*      | `use_system_prompt`      | `Optional[bool]`                      | Whether to use system prompt (for o1 model support). Default is True.                                    |"
    },
    {
      "content": "There are two ways to create agents in CrewAI: using **YAML configuration (recommended)** or defining them **directly in code**.",
      "title": "Creating Agents",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Agents",
          "level": 1
        },
        {
          "title": "Creating Agents",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Agents",
            "level": 1
          },
          {
            "title": "Creating Agents",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Agents > Creating Agents"
      },
      "enhanced_content": "Context: Changelog > Agents > Creating Agents\n\n## Creating Agents\n\nThere are two ways to create agents in CrewAI: using **YAML configuration (recommended)** or defining them **directly in code**.",
      "formatted_path": "Changelog > Agents > Creating Agents",
      "enhanced_text": "Context: Changelog > Agents > Creating Agents\n\n Creating Agents\n\nThere are two ways to create agents in CrewAI: using **YAML configuration (recommended)** or defining them **directly in code**.\n\nRelated sections:\n- \n"
    },
    {
      "content": "from crewai import Agent\nfrom crewai_tools import SerperDevTool\n\n# Create an agent with all available parameters\nagent = Agent(\n    role=\"Senior Data Scientist\",\n    goal=\"Analyze and interpret complex datasets to provide actionable insights\",\n    backstory=\"With over 10 years of experience in data science and machine learning, \"\n              \"you excel at finding patterns in complex datasets.\",\n    llm=\"gpt-4\",  # Default: OPENAI_MODEL_NAME or \"gpt-4\"\n    function_calling_llm=None,  # Optional: Separate LLM for tool calling\n    memory=True,  # Default: True\n    verbose=False,  # Default: False\n    allow_delegation=False,  # Default: False\n    max_iter=20,  # Default: 20 iterations\n    max_rpm=None,  # Optional: Rate limit for API calls\n    max_execution_time=None,  # Optional: Maximum execution time in seconds\n    max_retry_limit=2,  # Default: 2 retries on error\n    allow_code_execution=False,  # Default: False\n    code_execution_mode=\"safe\",  # Default: \"safe\" (options: \"safe\", \"unsafe\")\n    respect_context_window=True,  # Default: True\n    use_system_prompt=True,  # Default: True\n    tools=[SerperDevTool()],  # Optional: List of tools\n    knowledge_sources=None,  # Optional: List of knowledge sources\n    embedder=None,  # Optional: Custom embedder configuration\n    system_template=None,  # Optional: Custom system prompt template\n    prompt_template=None,  # Optional: Custom prompt template\n    response_template=None,  # Optional: Custom response template\n    step_callback=None,  # Optional: Callback function for monitoring\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Agents",
          "level": 1
        },
        {
          "title": "Creating Agents",
          "level": 2
        },
        {
          "title": "Direct Code Definition",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Agents",
            "level": 1
          },
          {
            "title": "Creating Agents",
            "level": 2
          },
          {
            "title": "Direct Code Definition",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Agents > Creating Agents > Direct Code Definition"
      },
      "enhanced_content": "Context: Changelog > Agents > Creating Agents > Direct Code Definition\n\nfrom crewai import Agent\nfrom crewai_tools import SerperDevTool\n\n# Create an agent with all available parameters\nagent = Agent(\n    role=\"Senior Data Scientist\",\n    goal=\"Analyze and interpret complex datasets to provide actionable insights\",\n    backstory=\"With over 10 years of experience in data science and machine learning, \"\n              \"you excel at finding patterns in complex datasets.\",\n    llm=\"gpt-4\",  # Default: OPENAI_MODEL_NAME or \"gpt-4\"\n    function_calling_llm=None,  # Optional: Separate LLM for tool calling\n    memory=True,  # Default: True\n    verbose=False,  # Default: False\n    allow_delegation=False,  # Default: False\n    max_iter=20,  # Default: 20 iterations\n    max_rpm=None,  # Optional: Rate limit for API calls\n    max_execution_time=None,  # Optional: Maximum execution time in seconds\n    max_retry_limit=2,  # Default: 2 retries on error\n    allow_code_execution=False,  # Default: False\n    code_execution_mode=\"safe\",  # Default: \"safe\" (options: \"safe\", \"unsafe\")\n    respect_context_window=True,  # Default: True\n    use_system_prompt=True,  # Default: True\n    tools=[SerperDevTool()],  # Optional: List of tools\n    knowledge_sources=None,  # Optional: List of knowledge sources\n    embedder=None,  # Optional: Custom embedder configuration\n    system_template=None,  # Optional: Custom system prompt template\n    prompt_template=None,  # Optional: Custom prompt template\n    response_template=None,  # Optional: Custom response template\n    step_callback=None,  # Optional: Callback function for monitoring\n)",
      "formatted_path": "Changelog > Agents > Creating Agents > Direct Code Definition",
      "enhanced_text": "Context: Changelog > Agents > Creating Agents > Direct Code Definition\n\nfrom crewai import Agent\nfrom crewai_tools import SerperDevTool\n\n# Create an agent with all available parameters\nagent = Agent(\n    role=\"Senior Data Scientist\",\n    goal=\"Analyze and interpret complex datasets to provide actionable insights\",\n    backstory=\"With over 10 years of experience in data science and machine learning, \"\n              \"you excel at finding patterns in complex datasets.\",\n    llm=\"gpt-4\",  # Default: OPENAI_MODEL_NAME or \"gpt-4\"\n    function_calling_llm=None,  # Optional: Separate LLM for tool calling\n    memory=True,  # Default: True\n    verbose=False,  # Default: False\n    allow_delegation=False,  # Default: False\n    max_iter=20,  # Default: 20 iterations\n    max_rpm=None,  # Optional: Rate limit for API calls\n    max_execution_time=None,  # Optional: Maximum execution time in seconds\n    max_retry_limit=2,  # Default: 2 retries on error\n    allow_code_execution=False,  # Default: False\n    code_execution_mode=\"safe\",  # Default: \"safe\" (options: \"safe\", \"unsafe\")\n    respect_context_window=True,  # Default: True\n    use_system_prompt=True,  # Default: True\n    tools=[SerperDevTool()],  # Optional: List of tools\n    knowledge_sources=None,  # Optional: List of knowledge sources\n    embedder=None,  # Optional: Custom embedder configuration\n    system_template=None,  # Optional: Custom system prompt template\n    prompt_template=None,  # Optional: Custom prompt template\n    response_template=None,  # Optional: Custom response template\n    step_callback=None,  # Optional: Callback function for monitoring\n)"
    },
    {
      "content": "research_agent = Agent(\n    role=\"Research Analyst\",\n    goal=\"Find and summarize information about specific topics\",\n    backstory=\"You are an experienced researcher with attention to detail\",\n    tools=[SerperDevTool()],\n    verbose=True  # Enable logging for debugging\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Agents",
          "level": 1
        },
        {
          "title": "Creating Agents",
          "level": 2
        },
        {
          "title": "Direct Code Definition",
          "level": 3
        },
        {
          "title": "Basic Research Agent",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Agents",
            "level": 1
          },
          {
            "title": "Creating Agents",
            "level": 2
          },
          {
            "title": "Direct Code Definition",
            "level": 3
          },
          {
            "title": "Basic Research Agent",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Agents > Creating Agents > Direct Code Definition > Basic Research Agent"
      },
      "enhanced_content": "Context: Changelog > Agents > Creating Agents > Direct Code Definition > Basic Research Agent\n\nresearch_agent = Agent(\n    role=\"Research Analyst\",\n    goal=\"Find and summarize information about specific topics\",\n    backstory=\"You are an experienced researcher with attention to detail\",\n    tools=[SerperDevTool()],\n    verbose=True  # Enable logging for debugging\n)",
      "formatted_path": "Changelog > Agents > Creating Agents > Direct Code Definition > Basic Research Agent",
      "enhanced_text": "Context: Changelog > Agents > Creating Agents > Direct Code Definition > Basic Research Agent\n\nresearch_agent = Agent(\n    role=\"Research Analyst\",\n    goal=\"Find and summarize information about specific topics\",\n    backstory=\"You are an experienced researcher with attention to detail\",\n    tools=[SerperDevTool()],\n    verbose=True  # Enable logging for debugging\n)"
    },
    {
      "content": "dev_agent = Agent(\n    role=\"Senior Python Developer\",\n    goal=\"Write and debug Python code\",\n    backstory=\"Expert Python developer with 10 years of experience\",\n    allow_code_execution=True,\n    code_execution_mode=\"safe\",  # Uses Docker for safety\n    max_execution_time=300,  # 5-minute timeout\n    max_retry_limit=3  # More retries for complex code tasks\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Agents",
          "level": 1
        },
        {
          "title": "Creating Agents",
          "level": 2
        },
        {
          "title": "Direct Code Definition",
          "level": 3
        },
        {
          "title": "Code Development Agent",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Agents",
            "level": 1
          },
          {
            "title": "Creating Agents",
            "level": 2
          },
          {
            "title": "Direct Code Definition",
            "level": 3
          },
          {
            "title": "Code Development Agent",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Agents > Creating Agents > Direct Code Definition > Code Development Agent"
      },
      "enhanced_content": "Context: Changelog > Agents > Creating Agents > Direct Code Definition > Code Development Agent\n\ndev_agent = Agent(\n    role=\"Senior Python Developer\",\n    goal=\"Write and debug Python code\",\n    backstory=\"Expert Python developer with 10 years of experience\",\n    allow_code_execution=True,\n    code_execution_mode=\"safe\",  # Uses Docker for safety\n    max_execution_time=300,  # 5-minute timeout\n    max_retry_limit=3  # More retries for complex code tasks\n)",
      "formatted_path": "Changelog > Agents > Creating Agents > Direct Code Definition > Code Development Agent",
      "enhanced_text": "Context: Changelog > Agents > Creating Agents > Direct Code Definition > Code Development Agent\n\ndev_agent = Agent(\n    role=\"Senior Python Developer\",\n    goal=\"Write and debug Python code\",\n    backstory=\"Expert Python developer with 10 years of experience\",\n    allow_code_execution=True,\n    code_execution_mode=\"safe\",  # Uses Docker for safety\n    max_execution_time=300,  # 5-minute timeout\n    max_retry_limit=3  # More retries for complex code tasks\n)"
    },
    {
      "content": "analysis_agent = Agent(\n    role=\"Data Analyst\",\n    goal=\"Perform deep analysis of large datasets\",\n    backstory=\"Specialized in big data analysis and pattern recognition\",\n    memory=True,\n    respect_context_window=True,\n    max_rpm=10,  # Limit API calls\n    function_calling_llm=\"gpt-4o-mini\"  # Cheaper model for tool calls\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Agents",
          "level": 1
        },
        {
          "title": "Creating Agents",
          "level": 2
        },
        {
          "title": "Direct Code Definition",
          "level": 3
        },
        {
          "title": "Long-Running Analysis Agent",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Agents",
            "level": 1
          },
          {
            "title": "Creating Agents",
            "level": 2
          },
          {
            "title": "Direct Code Definition",
            "level": 3
          },
          {
            "title": "Long-Running Analysis Agent",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Agents > Creating Agents > Direct Code Definition > Long-Running Analysis Agent"
      },
      "enhanced_content": "Context: Changelog > Agents > Creating Agents > Direct Code Definition > Long-Running Analysis Agent\n\nanalysis_agent = Agent(\n    role=\"Data Analyst\",\n    goal=\"Perform deep analysis of large datasets\",\n    backstory=\"Specialized in big data analysis and pattern recognition\",\n    memory=True,\n    respect_context_window=True,\n    max_rpm=10,  # Limit API calls\n    function_calling_llm=\"gpt-4o-mini\"  # Cheaper model for tool calls\n)",
      "formatted_path": "Changelog > Agents > Creating Agents > Direct Code Definition > Long-Running Analysis Agent",
      "enhanced_text": "Context: Changelog > Agents > Creating Agents > Direct Code Definition > Long-Running Analysis Agent\n\nanalysis_agent = Agent(\n    role=\"Data Analyst\",\n    goal=\"Perform deep analysis of large datasets\",\n    backstory=\"Specialized in big data analysis and pattern recognition\",\n    memory=True,\n    respect_context_window=True,\n    max_rpm=10,  # Limit API calls\n    function_calling_llm=\"gpt-4o-mini\"  # Cheaper model for tool calls\n)"
    },
    {
      "content": "custom_agent = Agent(\n    role=\"Customer Service Representative\",\n    goal=\"Assist customers with their inquiries\",\n    backstory=\"Experienced in customer support with a focus on satisfaction\",\n    system_template=\"\"\"<|start_header_id|>system<|end_header_id|>\n                        {{ .System }}<|eot_id|>\"\"\",\n    prompt_template=\"\"\"<|start_header_id|>user<|end_header_id|>\n                        {{ .Prompt }}<|eot_id|>\"\"\",\n    response_template=\"\"\"<|start_header_id|>assistant<|end_header_id|>\n                        {{ .Response }}<|eot_id|>\"\"\",\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Agents",
          "level": 1
        },
        {
          "title": "Creating Agents",
          "level": 2
        },
        {
          "title": "Direct Code Definition",
          "level": 3
        },
        {
          "title": "Custom Template Agent",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Agents",
            "level": 1
          },
          {
            "title": "Creating Agents",
            "level": 2
          },
          {
            "title": "Direct Code Definition",
            "level": 3
          },
          {
            "title": "Custom Template Agent",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Agents > Creating Agents > Direct Code Definition > Custom Template Agent"
      },
      "enhanced_content": "Context: Changelog > Agents > Creating Agents > Direct Code Definition > Custom Template Agent\n\ncustom_agent = Agent(\n    role=\"Customer Service Representative\",\n    goal=\"Assist customers with their inquiries\",\n    backstory=\"Experienced in customer support with a focus on satisfaction\",\n    system_template=\"\"\"<|start_header_id|>system<|end_header_id|>\n                        {{ .System }}<|eot_id|>\"\"\",\n    prompt_template=\"\"\"<|start_header_id|>user<|end_header_id|>\n                        {{ .Prompt }}<|eot_id|>\"\"\",\n    response_template=\"\"\"<|start_header_id|>assistant<|end_header_id|>\n                        {{ .Response }}<|eot_id|>\"\"\",\n)",
      "formatted_path": "Changelog > Agents > Creating Agents > Direct Code Definition > Custom Template Agent",
      "enhanced_text": "Context: Changelog > Agents > Creating Agents > Direct Code Definition > Custom Template Agent\n\ncustom_agent = Agent(\n    role=\"Customer Service Representative\",\n    goal=\"Assist customers with their inquiries\",\n    backstory=\"Experienced in customer support with a focus on satisfaction\",\n    system_template=\"\"\"<|start_header_id|>system<|end_header_id|>\n                        {{ .System }}<|eot_id|>\"\"\",\n    prompt_template=\"\"\"<|start_header_id|>user<|end_header_id|>\n                        {{ .Prompt }}<|eot_id|>\"\"\",\n    response_template=\"\"\"<|start_header_id|>assistant<|end_header_id|>\n                        {{ .Response }}<|eot_id|>\"\"\",\n)"
    },
    {
      "content": "`role`, `goal`, and `backstory` are required and shape the agent's behavior `llm` determines the language model used (default: OpenAI's GPT-4)",
      "title": "Critical Parameters",
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Agents",
          "level": 1
        },
        {
          "title": "Creating Agents",
          "level": 2
        },
        {
          "title": "Parameter Details",
          "level": 3
        },
        {
          "title": "Critical Parameters",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Agents",
            "level": 1
          },
          {
            "title": "Creating Agents",
            "level": 2
          },
          {
            "title": "Parameter Details",
            "level": 3
          },
          {
            "title": "Critical Parameters",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Agents > Creating Agents > Parameter Details > Critical Parameters"
      },
      "enhanced_content": "Context: Changelog > Agents > Creating Agents > Parameter Details > Critical Parameters\n\n#### Critical Parameters\n\n`role`, `goal`, and `backstory` are required and shape the agent's behavior `llm` determines the language model used (default: OpenAI's GPT-4)",
      "formatted_path": "Changelog > Agents > Creating Agents > Parameter Details > Critical Parameters",
      "enhanced_text": "Context: Changelog > Agents > Creating Agents > Parameter Details > Critical Parameters\n\n Critical Parameters\n\n`role`, `goal`, and `backstory` are required and shape the agent's behavior `llm` determines the language model used (default: OpenAI's GPT-4)\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "`memory`: Enable to maintain conversation history `respect_context_window`: Prevents token limit issues `knowledge_sources`: Add domain-specific knowledge bases",
      "title": "Memory and Context",
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Agents",
          "level": 1
        },
        {
          "title": "Creating Agents",
          "level": 2
        },
        {
          "title": "Parameter Details",
          "level": 3
        },
        {
          "title": "Memory and Context",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Agents",
            "level": 1
          },
          {
            "title": "Creating Agents",
            "level": 2
          },
          {
            "title": "Parameter Details",
            "level": 3
          },
          {
            "title": "Memory and Context",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Agents > Creating Agents > Parameter Details > Memory and Context"
      },
      "enhanced_content": "Context: Changelog > Agents > Creating Agents > Parameter Details > Memory and Context\n\n#### Memory and Context\n\n`memory`: Enable to maintain conversation history `respect_context_window`: Prevents token limit issues `knowledge_sources`: Add domain-specific knowledge bases",
      "formatted_path": "Changelog > Agents > Creating Agents > Parameter Details > Memory and Context",
      "enhanced_text": "Context: Changelog > Agents > Creating Agents > Parameter Details > Memory and Context\n\n Memory and Context\n\n`memory`: Enable to maintain conversation history `respect_context_window`: Prevents token limit issues `knowledge_sources`: Add domain-specific knowledge bases\n\nRelated sections:\n- \n- \n- \n"
    },
    {
      "content": "`max_iter`: Maximum attempts before giving best answer `max_execution_time`: Timeout in seconds `max_rpm`: Rate limiting for API calls `max_retry_limit`: Retries on error",
      "title": "Execution Control",
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Agents",
          "level": 1
        },
        {
          "title": "Creating Agents",
          "level": 2
        },
        {
          "title": "Parameter Details",
          "level": 3
        },
        {
          "title": "Execution Control",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Agents",
            "level": 1
          },
          {
            "title": "Creating Agents",
            "level": 2
          },
          {
            "title": "Parameter Details",
            "level": 3
          },
          {
            "title": "Execution Control",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Agents > Creating Agents > Parameter Details > Execution Control"
      },
      "enhanced_content": "Context: Changelog > Agents > Creating Agents > Parameter Details > Execution Control\n\n#### Execution Control\n\n`max_iter`: Maximum attempts before giving best answer `max_execution_time`: Timeout in seconds `max_rpm`: Rate limiting for API calls `max_retry_limit`: Retries on error",
      "formatted_path": "Changelog > Agents > Creating Agents > Parameter Details > Execution Control",
      "enhanced_text": "Context: Changelog > Agents > Creating Agents > Parameter Details > Execution Control\n\n Execution Control\n\n`max_iter`: Maximum attempts before giving best answer `max_execution_time`: Timeout in seconds `max_rpm`: Rate limiting for API calls `max_retry_limit`: Retries on error"
    },
    {
      "content": "`allow_code_execution`: Must be True to run code `code_execution_mode`: `\"safe\"`: Uses Docker (recommended for production) `\"unsafe\"`: Direct execution (use only in trusted environments)",
      "title": "Code Execution",
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Agents",
          "level": 1
        },
        {
          "title": "Creating Agents",
          "level": 2
        },
        {
          "title": "Parameter Details",
          "level": 3
        },
        {
          "title": "Code Execution",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Agents",
            "level": 1
          },
          {
            "title": "Creating Agents",
            "level": 2
          },
          {
            "title": "Parameter Details",
            "level": 3
          },
          {
            "title": "Code Execution",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Agents > Creating Agents > Parameter Details > Code Execution"
      },
      "enhanced_content": "Context: Changelog > Agents > Creating Agents > Parameter Details > Code Execution\n\n#### Code Execution\n\n`allow_code_execution`: Must be True to run code `code_execution_mode`: `\"safe\"`: Uses Docker (recommended for production) `\"unsafe\"`: Direct execution (use only in trusted environments)",
      "formatted_path": "Changelog > Agents > Creating Agents > Parameter Details > Code Execution",
      "enhanced_text": "Context: Changelog > Agents > Creating Agents > Parameter Details > Code Execution\n\n Code Execution\n\n`allow_code_execution`: Must be True to run code `code_execution_mode`: `\"safe\"`: Uses Docker (recommended for production) `\"unsafe\"`: Direct execution (use only in trusted environments)\n\nRelated sections:\n- \n- \n- \n"
    },
    {
      "content": "`system_template`: Defines agent's core behavior `prompt_template`: Structures input format `response_template`: Formats agent responses",
      "title": "Templates",
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Agents",
          "level": 1
        },
        {
          "title": "Creating Agents",
          "level": 2
        },
        {
          "title": "Parameter Details",
          "level": 3
        },
        {
          "title": "Templates",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Agents",
            "level": 1
          },
          {
            "title": "Creating Agents",
            "level": 2
          },
          {
            "title": "Parameter Details",
            "level": 3
          },
          {
            "title": "Templates",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Agents > Creating Agents > Parameter Details > Templates"
      },
      "enhanced_content": "Context: Changelog > Agents > Creating Agents > Parameter Details > Templates\n\n#### Templates\n\n`system_template`: Defines agent's core behavior `prompt_template`: Structures input format `response_template`: Formats agent responses",
      "formatted_path": "Changelog > Agents > Creating Agents > Parameter Details > Templates",
      "enhanced_text": "Context: Changelog > Agents > Creating Agents > Parameter Details > Templates\n\n Templates\n\n`system_template`: Defines agent's core behavior `prompt_template`: Structures input format `response_template`: Formats agent responses"
    },
    {
      "content": "from crewai import Agent\nfrom crewai_tools import SerperDevTool, WikipediaTools\n\n# Create tools\nsearch_tool = SerperDevTool()\nwiki_tool = WikipediaTools()\n\n# Add tools to agent\nresearcher = Agent(\n    role=\"AI Technology Researcher\",\n    goal=\"Research the latest AI developments\",\n    tools=[search_tool, wiki_tool],\n    verbose=True\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Agents",
          "level": 1
        },
        {
          "title": "Agent Tools",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Agents",
            "level": 1
          },
          {
            "title": "Agent Tools",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Agents > Agent Tools"
      },
      "enhanced_content": "Context: Changelog > Agents > Agent Tools\n\nfrom crewai import Agent\nfrom crewai_tools import SerperDevTool, WikipediaTools\n\n# Create tools\nsearch_tool = SerperDevTool()\nwiki_tool = WikipediaTools()\n\n# Add tools to agent\nresearcher = Agent(\n    role=\"AI Technology Researcher\",\n    goal=\"Research the latest AI developments\",\n    tools=[search_tool, wiki_tool],\n    verbose=True\n)",
      "formatted_path": "Changelog > Agents > Agent Tools",
      "enhanced_text": "Context: Changelog > Agents > Agent Tools\n\nfrom crewai import Agent\nfrom crewai_tools import SerperDevTool, WikipediaTools\n\n# Create tools\nsearch_tool = SerperDevTool()\nwiki_tool = WikipediaTools()\n\n# Add tools to agent\nresearcher = Agent(\n    role=\"AI Technology Researcher\",\n    goal=\"Research the latest AI developments\",\n    tools=[search_tool, wiki_tool],\n    verbose=True\n)"
    },
    {
      "content": "from crewai import Agent\n\nanalyst = Agent(\n    role=\"Data Analyst\",\n    goal=\"Analyze and remember complex data patterns\",\n    memory=True,  # Enable memory\n    verbose=True\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Agents",
          "level": 1
        },
        {
          "title": "Agent Memory and Context",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Agents",
            "level": 1
          },
          {
            "title": "Agent Memory and Context",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Agents > Agent Memory and Context"
      },
      "enhanced_content": "Context: Changelog > Agents > Agent Memory and Context\n\nfrom crewai import Agent\n\nanalyst = Agent(\n    role=\"Data Analyst\",\n    goal=\"Analyze and remember complex data patterns\",\n    memory=True,  # Enable memory\n    verbose=True\n)",
      "formatted_path": "Changelog > Agents > Agent Memory and Context",
      "enhanced_text": "Context: Changelog > Agents > Agent Memory and Context\n\nfrom crewai import Agent\n\nanalyst = Agent(\n    role=\"Data Analyst\",\n    goal=\"Analyze and remember complex data patterns\",\n    memory=True,  # Enable memory\n    verbose=True\n)"
    },
    {
      "content": "When using `allow_code_execution`, be cautious with user input and always validate it Use `code_execution_mode: \"safe\"` (Docker) in production environments Consider setting appropriate `max_execution_time` limits to prevent infinite loops",
      "title": "Security and Code Execution",
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Agents",
          "level": 1
        },
        {
          "title": "Important Considerations and Best Practices",
          "level": 2
        },
        {
          "title": "Security and Code Execution",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Agents",
            "level": 1
          },
          {
            "title": "Important Considerations and Best Practices",
            "level": 2
          },
          {
            "title": "Security and Code Execution",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Agents > Important Considerations and Best Practices > Security and Code Execution"
      },
      "enhanced_content": "Context: Changelog > Agents > Important Considerations and Best Practices > Security and Code Execution\n\n### Security and Code Execution\n\nWhen using `allow_code_execution`, be cautious with user input and always validate it Use `code_execution_mode: \"safe\"` (Docker) in production environments Consider setting appropriate `max_execution_time` limits to prevent infinite loops",
      "formatted_path": "Changelog > Agents > Important Considerations and Best Practices > Security and Code Execution",
      "enhanced_text": "Context: Changelog > Agents > Important Considerations and Best Practices > Security and Code Execution\n\n Security and Code Execution\n\nWhen using `allow_code_execution`, be cautious with user input and always validate it Use `code_execution_mode: \"safe\"` (Docker) in production environments Consider setting appropriate `max_execution_time` limits to prevent infinite loops\n\nRelated sections:\n- \n"
    },
    {
      "content": "Use `respect_context_window: true` to prevent token limit issues Set appropriate `max_rpm` to avoid rate limiting Enable `cache: true` to improve performance for repetitive tasks Adjust `max_iter` and `max_retry_limit` based on task complexity",
      "title": "Performance Optimization",
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Agents",
          "level": 1
        },
        {
          "title": "Important Considerations and Best Practices",
          "level": 2
        },
        {
          "title": "Performance Optimization",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Agents",
            "level": 1
          },
          {
            "title": "Important Considerations and Best Practices",
            "level": 2
          },
          {
            "title": "Performance Optimization",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Agents > Important Considerations and Best Practices > Performance Optimization"
      },
      "enhanced_content": "Context: Changelog > Agents > Important Considerations and Best Practices > Performance Optimization\n\n### Performance Optimization\n\nUse `respect_context_window: true` to prevent token limit issues Set appropriate `max_rpm` to avoid rate limiting Enable `cache: true` to improve performance for repetitive tasks Adjust `max_iter` and `max_retry_limit` based on task complexity",
      "formatted_path": "Changelog > Agents > Important Considerations and Best Practices > Performance Optimization",
      "enhanced_text": "Context: Changelog > Agents > Important Considerations and Best Practices > Performance Optimization\n\n Performance Optimization\n\nUse `respect_context_window: true` to prevent token limit issues Set appropriate `max_rpm` to avoid rate limiting Enable `cache: true` to improve performance for repetitive tasks Adjust `max_iter` and `max_retry_limit` based on task complexity"
    },
    {
      "content": "Use `memory: true` for tasks requiring historical context Leverage `knowledge_sources` for domain-specific information Configure `embedder_config` when using custom embedding models Use custom templates (`system_template`, `prompt_template`, `response_template`) for fine-grained control over agent behavior",
      "title": "Memory and Context Management",
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Agents",
          "level": 1
        },
        {
          "title": "Important Considerations and Best Practices",
          "level": 2
        },
        {
          "title": "Memory and Context Management",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Agents",
            "level": 1
          },
          {
            "title": "Important Considerations and Best Practices",
            "level": 2
          },
          {
            "title": "Memory and Context Management",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Agents > Important Considerations and Best Practices > Memory and Context Management"
      },
      "enhanced_content": "Context: Changelog > Agents > Important Considerations and Best Practices > Memory and Context Management\n\n### Memory and Context Management\n\nUse `memory: true` for tasks requiring historical context Leverage `knowledge_sources` for domain-specific information Configure `embedder_config` when using custom embedding models Use custom templates (`system_template`, `prompt_template`, `response_template`) for fine-grained control over agent behavior",
      "formatted_path": "Changelog > Agents > Important Considerations and Best Practices > Memory and Context Management",
      "enhanced_text": "Context: Changelog > Agents > Important Considerations and Best Practices > Memory and Context Management\n\n Memory and Context Management\n\nUse `memory: true` for tasks requiring historical context Leverage `knowledge_sources` for domain-specific information Configure `embedder_config` when using custom embedding models Use custom templates (`system_template`, `prompt_template`, `response_template`) for fine-grained control over agent behavior\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "Enable `allow_delegation: true` when agents need to work together Use `step_callback` to monitor and log agent interactions Consider using different LLMs for different purposes: Main `llm` for complex reasoning `function_calling_llm` for efficient tool usage",
      "title": "Agent Collaboration",
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Agents",
          "level": 1
        },
        {
          "title": "Important Considerations and Best Practices",
          "level": 2
        },
        {
          "title": "Agent Collaboration",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Agents",
            "level": 1
          },
          {
            "title": "Important Considerations and Best Practices",
            "level": 2
          },
          {
            "title": "Agent Collaboration",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Agents > Important Considerations and Best Practices > Agent Collaboration"
      },
      "enhanced_content": "Context: Changelog > Agents > Important Considerations and Best Practices > Agent Collaboration\n\n### Agent Collaboration\n\nEnable `allow_delegation: true` when agents need to work together Use `step_callback` to monitor and log agent interactions Consider using different LLMs for different purposes: Main `llm` for complex reasoning `function_calling_llm` for efficient tool usage",
      "formatted_path": "Changelog > Agents > Important Considerations and Best Practices > Agent Collaboration",
      "enhanced_text": "Context: Changelog > Agents > Important Considerations and Best Practices > Agent Collaboration\n\n Agent Collaboration\n\nEnable `allow_delegation: true` when agents need to work together Use `step_callback` to monitor and log agent interactions Consider using different LLMs for different purposes: Main `llm` for complex reasoning `function_calling_llm` for efficient tool usage\n\nRelated sections:\n- \n- \n- \n"
    },
    {
      "content": "Set `use_system_prompt: false` for older models that don't support system messages Ensure your chosen `llm` supports the features you need (like function calling)",
      "title": "Model Compatibility",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Agents",
          "level": 1
        },
        {
          "title": "Important Considerations and Best Practices",
          "level": 2
        },
        {
          "title": "Model Compatibility",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Agents",
            "level": 1
          },
          {
            "title": "Important Considerations and Best Practices",
            "level": 2
          },
          {
            "title": "Model Compatibility",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Agents > Important Considerations and Best Practices > Model Compatibility"
      },
      "enhanced_content": "Context: Changelog > Agents > Important Considerations and Best Practices > Model Compatibility\n\n### Model Compatibility\n\nSet `use_system_prompt: false` for older models that don't support system messages Ensure your chosen `llm` supports the features you need (like function calling)",
      "formatted_path": "Changelog > Agents > Important Considerations and Best Practices > Model Compatibility",
      "enhanced_text": "Context: Changelog > Agents > Important Considerations and Best Practices > Model Compatibility\n\n Model Compatibility\n\nSet `use_system_prompt: false` for older models that don't support system messages Ensure your chosen `llm` supports the features you need (like function calling)"
    },
    {
      "content": "**Rate Limiting**: If you're hitting API rate limits: Implement appropriate `max_rpm` Use caching for repetitive operations Consider batching requests **Context Window Errors**: If you're exceeding context limits: Enable `respect_context_window` Use more efficient prompts Clear agent memory periodically **Code Execution Issues**: If code execution fails: Verify Docker is installed for safe mode Check execution permissions Review code sandbox settings **Memory Issues**: If agent responses seem inconsistent: Verify memory is enabled Check knowledge source configuration Review conversation history management Remember that agents are most effective when configured according to their specific use case. Take time to understand your requirements and adjust these parameters accordingly.",
      "title": "Troubleshooting Common Issues",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Agents",
          "level": 1
        },
        {
          "title": "Troubleshooting Common Issues",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Agents",
            "level": 1
          },
          {
            "title": "Troubleshooting Common Issues",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Agents > Troubleshooting Common Issues"
      },
      "enhanced_content": "Context: Changelog > Agents > Troubleshooting Common Issues\n\n## Troubleshooting Common Issues\n\n**Rate Limiting**: If you're hitting API rate limits: Implement appropriate `max_rpm` Use caching for repetitive operations Consider batching requests **Context Window Errors**: If you're exceeding context limits: Enable `respect_context_window` Use more efficient prompts Clear agent memory periodically **Code Execution Issues**: If code execution fails: Verify Docker is installed for safe mode Check execution permissions Review code sandbox settings **Memory Issues**: If agent responses seem inconsistent: Verify memory is enabled Check knowledge source configuration Review conversation history management Remember that agents are most effective when configured according to their specific use case. Take time to understand your requirements and adjust these parameters accordingly.",
      "formatted_path": "Changelog > Agents > Troubleshooting Common Issues",
      "enhanced_text": "Context: Changelog > Agents > Troubleshooting Common Issues\n\n Troubleshooting Common Issues\n\n**Rate Limiting**: If you're hitting API rate limits: Implement appropriate `max_rpm` Use caching for repetitive operations Consider batching requests **Context Window Errors**: If you're exceeding context limits: Enable `respect_context_window` Use more efficient prompts Clear agent memory periodically **Code Execution Issues**: If code execution fails: Verify Docker is installed for safe mode Check execution permissions Review code sandbox settings **Memory Issues**: If agent responses seem inconsistent: Verify memory is enabled Check knowledge source configuration Review conversation history management Remember that agents are most effective when configured according to their specific use case. Take time to understand your requirements and adjust these parameters accordingly."
    },
    {
      "content": "Source: https://docs.crewai.com/concepts/cli Learn how to use the CrewAI CLI to interact with CrewAI.",
      "title": "CLI",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "CLI",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "CLI",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > CLI"
      },
      "enhanced_content": "Context: Changelog > CLI\n\n# CLI\n\nSource: https://docs.crewai.com/concepts/cli Learn how to use the CrewAI CLI to interact with CrewAI.",
      "formatted_path": "Changelog > CLI",
      "enhanced_text": "Context: Changelog > CLI\n\n CLI\n\nSource: https://docs.crewai.com/concepts/cli Learn how to use the CrewAI CLI to interact with CrewAI.\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "The CrewAI CLI provides a set of commands to interact with CrewAI, allowing you to create, train, run, and manage crews & flows.",
      "title": "CrewAI CLI Documentation",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "CrewAI CLI Documentation",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "CrewAI CLI Documentation",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > CrewAI CLI Documentation"
      },
      "enhanced_content": "Context: Changelog > CrewAI CLI Documentation\n\n# CrewAI CLI Documentation\n\nThe CrewAI CLI provides a set of commands to interact with CrewAI, allowing you to create, train, run, and manage crews & flows.",
      "formatted_path": "Changelog > CrewAI CLI Documentation",
      "enhanced_text": "Context: Changelog > CrewAI CLI Documentation\n\n CrewAI CLI Documentation\n\nThe CrewAI CLI provides a set of commands to interact with CrewAI, allowing you to create, train, run, and manage crews & flows.\n\nRelated sections:\n- \n"
    },
    {
      "content": "crewai create [OPTIONS] TYPE NAME",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "CrewAI CLI Documentation",
          "level": 1
        },
        {
          "title": "Available Commands",
          "level": 2
        },
        {
          "title": "1. Create",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "CrewAI CLI Documentation",
            "level": 1
          },
          {
            "title": "Available Commands",
            "level": 2
          },
          {
            "title": "1. Create",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > CrewAI CLI Documentation > Available Commands > 1. Create"
      },
      "enhanced_content": "Context: Changelog > CrewAI CLI Documentation > Available Commands > 1. Create\n\ncrewai create [OPTIONS] TYPE NAME",
      "formatted_path": "Changelog > CrewAI CLI Documentation > Available Commands > 1. Create",
      "enhanced_text": "Context: Changelog > CrewAI CLI Documentation > Available Commands > 1. Create\n\ncrewai create [OPTIONS] TYPE NAME"
    },
    {
      "content": "crewai create crew my_new_crew\ncrewai create flow my_new_flow",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "CrewAI CLI Documentation",
          "level": 1
        },
        {
          "title": "Available Commands",
          "level": 2
        },
        {
          "title": "1. Create",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "CrewAI CLI Documentation",
            "level": 1
          },
          {
            "title": "Available Commands",
            "level": 2
          },
          {
            "title": "1. Create",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > CrewAI CLI Documentation > Available Commands > 1. Create"
      },
      "enhanced_content": "Context: Changelog > CrewAI CLI Documentation > Available Commands > 1. Create\n\ncrewai create crew my_new_crew\ncrewai create flow my_new_flow",
      "formatted_path": "Changelog > CrewAI CLI Documentation > Available Commands > 1. Create",
      "enhanced_text": "Context: Changelog > CrewAI CLI Documentation > Available Commands > 1. Create\n\ncrewai create crew my_new_crew\ncrewai create flow my_new_flow"
    },
    {
      "content": "crewai version [OPTIONS]",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "CrewAI CLI Documentation",
          "level": 1
        },
        {
          "title": "Available Commands",
          "level": 2
        },
        {
          "title": "2. Version",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "CrewAI CLI Documentation",
            "level": 1
          },
          {
            "title": "Available Commands",
            "level": 2
          },
          {
            "title": "2. Version",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > CrewAI CLI Documentation > Available Commands > 2. Version"
      },
      "enhanced_content": "Context: Changelog > CrewAI CLI Documentation > Available Commands > 2. Version\n\ncrewai version [OPTIONS]",
      "formatted_path": "Changelog > CrewAI CLI Documentation > Available Commands > 2. Version",
      "enhanced_text": "Context: Changelog > CrewAI CLI Documentation > Available Commands > 2. Version\n\ncrewai version [OPTIONS]"
    },
    {
      "content": "crewai version\ncrewai version --tools",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "CrewAI CLI Documentation",
          "level": 1
        },
        {
          "title": "Available Commands",
          "level": 2
        },
        {
          "title": "2. Version",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "CrewAI CLI Documentation",
            "level": 1
          },
          {
            "title": "Available Commands",
            "level": 2
          },
          {
            "title": "2. Version",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > CrewAI CLI Documentation > Available Commands > 2. Version"
      },
      "enhanced_content": "Context: Changelog > CrewAI CLI Documentation > Available Commands > 2. Version\n\ncrewai version\ncrewai version --tools",
      "formatted_path": "Changelog > CrewAI CLI Documentation > Available Commands > 2. Version",
      "enhanced_text": "Context: Changelog > CrewAI CLI Documentation > Available Commands > 2. Version\n\ncrewai version\ncrewai version --tools"
    },
    {
      "content": "crewai train [OPTIONS]",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "CrewAI CLI Documentation",
          "level": 1
        },
        {
          "title": "Available Commands",
          "level": 2
        },
        {
          "title": "3. Train",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "CrewAI CLI Documentation",
            "level": 1
          },
          {
            "title": "Available Commands",
            "level": 2
          },
          {
            "title": "3. Train",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > CrewAI CLI Documentation > Available Commands > 3. Train"
      },
      "enhanced_content": "Context: Changelog > CrewAI CLI Documentation > Available Commands > 3. Train\n\ncrewai train [OPTIONS]",
      "formatted_path": "Changelog > CrewAI CLI Documentation > Available Commands > 3. Train",
      "enhanced_text": "Context: Changelog > CrewAI CLI Documentation > Available Commands > 3. Train\n\ncrewai train [OPTIONS]"
    },
    {
      "content": "crewai train -n 10 -f my_training_data.pkl",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "CrewAI CLI Documentation",
          "level": 1
        },
        {
          "title": "Available Commands",
          "level": 2
        },
        {
          "title": "3. Train",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "CrewAI CLI Documentation",
            "level": 1
          },
          {
            "title": "Available Commands",
            "level": 2
          },
          {
            "title": "3. Train",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > CrewAI CLI Documentation > Available Commands > 3. Train"
      },
      "enhanced_content": "Context: Changelog > CrewAI CLI Documentation > Available Commands > 3. Train\n\ncrewai train -n 10 -f my_training_data.pkl",
      "formatted_path": "Changelog > CrewAI CLI Documentation > Available Commands > 3. Train",
      "enhanced_text": "Context: Changelog > CrewAI CLI Documentation > Available Commands > 3. Train\n\ncrewai train -n 10 -f my_training_data.pkl"
    },
    {
      "content": "crewai replay [OPTIONS]",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "CrewAI CLI Documentation",
          "level": 1
        },
        {
          "title": "Available Commands",
          "level": 2
        },
        {
          "title": "4. Replay",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "CrewAI CLI Documentation",
            "level": 1
          },
          {
            "title": "Available Commands",
            "level": 2
          },
          {
            "title": "4. Replay",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > CrewAI CLI Documentation > Available Commands > 4. Replay"
      },
      "enhanced_content": "Context: Changelog > CrewAI CLI Documentation > Available Commands > 4. Replay\n\ncrewai replay [OPTIONS]",
      "formatted_path": "Changelog > CrewAI CLI Documentation > Available Commands > 4. Replay",
      "enhanced_text": "Context: Changelog > CrewAI CLI Documentation > Available Commands > 4. Replay\n\ncrewai replay [OPTIONS]"
    },
    {
      "content": "crewai replay -t task_123456",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "CrewAI CLI Documentation",
          "level": 1
        },
        {
          "title": "Available Commands",
          "level": 2
        },
        {
          "title": "4. Replay",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "CrewAI CLI Documentation",
            "level": 1
          },
          {
            "title": "Available Commands",
            "level": 2
          },
          {
            "title": "4. Replay",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > CrewAI CLI Documentation > Available Commands > 4. Replay"
      },
      "enhanced_content": "Context: Changelog > CrewAI CLI Documentation > Available Commands > 4. Replay\n\ncrewai replay -t task_123456",
      "formatted_path": "Changelog > CrewAI CLI Documentation > Available Commands > 4. Replay",
      "enhanced_text": "Context: Changelog > CrewAI CLI Documentation > Available Commands > 4. Replay\n\ncrewai replay -t task_123456"
    },
    {
      "content": "crewai log-tasks-outputs",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "CrewAI CLI Documentation",
          "level": 1
        },
        {
          "title": "Available Commands",
          "level": 2
        },
        {
          "title": "5. Log-tasks-outputs",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "CrewAI CLI Documentation",
            "level": 1
          },
          {
            "title": "Available Commands",
            "level": 2
          },
          {
            "title": "5. Log-tasks-outputs",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > CrewAI CLI Documentation > Available Commands > 5. Log-tasks-outputs"
      },
      "enhanced_content": "Context: Changelog > CrewAI CLI Documentation > Available Commands > 5. Log-tasks-outputs\n\ncrewai log-tasks-outputs",
      "formatted_path": "Changelog > CrewAI CLI Documentation > Available Commands > 5. Log-tasks-outputs",
      "enhanced_text": "Context: Changelog > CrewAI CLI Documentation > Available Commands > 5. Log-tasks-outputs\n\ncrewai log-tasks-outputs"
    },
    {
      "content": "crewai reset-memories [OPTIONS]",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "CrewAI CLI Documentation",
          "level": 1
        },
        {
          "title": "Available Commands",
          "level": 2
        },
        {
          "title": "6. Reset-memories",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "CrewAI CLI Documentation",
            "level": 1
          },
          {
            "title": "Available Commands",
            "level": 2
          },
          {
            "title": "6. Reset-memories",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > CrewAI CLI Documentation > Available Commands > 6. Reset-memories"
      },
      "enhanced_content": "Context: Changelog > CrewAI CLI Documentation > Available Commands > 6. Reset-memories\n\ncrewai reset-memories [OPTIONS]",
      "formatted_path": "Changelog > CrewAI CLI Documentation > Available Commands > 6. Reset-memories",
      "enhanced_text": "Context: Changelog > CrewAI CLI Documentation > Available Commands > 6. Reset-memories\n\ncrewai reset-memories [OPTIONS]"
    },
    {
      "content": "crewai reset-memories --long --short\ncrewai reset-memories --all",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "CrewAI CLI Documentation",
          "level": 1
        },
        {
          "title": "Available Commands",
          "level": 2
        },
        {
          "title": "6. Reset-memories",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "CrewAI CLI Documentation",
            "level": 1
          },
          {
            "title": "Available Commands",
            "level": 2
          },
          {
            "title": "6. Reset-memories",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > CrewAI CLI Documentation > Available Commands > 6. Reset-memories"
      },
      "enhanced_content": "Context: Changelog > CrewAI CLI Documentation > Available Commands > 6. Reset-memories\n\ncrewai reset-memories --long --short\ncrewai reset-memories --all",
      "formatted_path": "Changelog > CrewAI CLI Documentation > Available Commands > 6. Reset-memories",
      "enhanced_text": "Context: Changelog > CrewAI CLI Documentation > Available Commands > 6. Reset-memories\n\ncrewai reset-memories --long --short\ncrewai reset-memories --all"
    },
    {
      "content": "crewai test [OPTIONS]",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "CrewAI CLI Documentation",
          "level": 1
        },
        {
          "title": "Available Commands",
          "level": 2
        },
        {
          "title": "7. Test",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "CrewAI CLI Documentation",
            "level": 1
          },
          {
            "title": "Available Commands",
            "level": 2
          },
          {
            "title": "7. Test",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > CrewAI CLI Documentation > Available Commands > 7. Test"
      },
      "enhanced_content": "Context: Changelog > CrewAI CLI Documentation > Available Commands > 7. Test\n\ncrewai test [OPTIONS]",
      "formatted_path": "Changelog > CrewAI CLI Documentation > Available Commands > 7. Test",
      "enhanced_text": "Context: Changelog > CrewAI CLI Documentation > Available Commands > 7. Test\n\ncrewai test [OPTIONS]"
    },
    {
      "content": "crewai test -n 5 -m gpt-3.5-turbo",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "CrewAI CLI Documentation",
          "level": 1
        },
        {
          "title": "Available Commands",
          "level": 2
        },
        {
          "title": "7. Test",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "CrewAI CLI Documentation",
            "level": 1
          },
          {
            "title": "Available Commands",
            "level": 2
          },
          {
            "title": "7. Test",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > CrewAI CLI Documentation > Available Commands > 7. Test"
      },
      "enhanced_content": "Context: Changelog > CrewAI CLI Documentation > Available Commands > 7. Test\n\ncrewai test -n 5 -m gpt-3.5-turbo",
      "formatted_path": "Changelog > CrewAI CLI Documentation > Available Commands > 7. Test",
      "enhanced_text": "Context: Changelog > CrewAI CLI Documentation > Available Commands > 7. Test\n\ncrewai test -n 5 -m gpt-3.5-turbo"
    },
    {
      "content": "crewai run",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "CrewAI CLI Documentation",
          "level": 1
        },
        {
          "title": "Available Commands",
          "level": 2
        },
        {
          "title": "8. Run",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "CrewAI CLI Documentation",
            "level": 1
          },
          {
            "title": "Available Commands",
            "level": 2
          },
          {
            "title": "8. Run",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > CrewAI CLI Documentation > Available Commands > 8. Run"
      },
      "enhanced_content": "Context: Changelog > CrewAI CLI Documentation > Available Commands > 8. Run\n\ncrewai run",
      "formatted_path": "Changelog > CrewAI CLI Documentation > Available Commands > 8. Run",
      "enhanced_text": "Context: Changelog > CrewAI CLI Documentation > Available Commands > 8. Run\n\ncrewai run"
    },
    {
      "content": "crewai chat",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "CrewAI CLI Documentation",
          "level": 1
        },
        {
          "title": "Available Commands",
          "level": 2
        },
        {
          "title": "9. Chat",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "CrewAI CLI Documentation",
            "level": 1
          },
          {
            "title": "Available Commands",
            "level": 2
          },
          {
            "title": "9. Chat",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > CrewAI CLI Documentation > Available Commands > 9. Chat"
      },
      "enhanced_content": "Context: Changelog > CrewAI CLI Documentation > Available Commands > 9. Chat\n\ncrewai chat",
      "formatted_path": "Changelog > CrewAI CLI Documentation > Available Commands > 9. Chat",
      "enhanced_text": "Context: Changelog > CrewAI CLI Documentation > Available Commands > 9. Chat\n\ncrewai chat"
    },
    {
      "content": "@crew\ndef crew(self) -> Crew:\n    return Crew(\n        agents=self.agents,\n        tasks=self.tasks,\n        process=Process.sequential,\n        verbose=True,\n        chat_llm=\"gpt-4o\",  # LLM for chat orchestration\n    )",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "CrewAI CLI Documentation",
          "level": 1
        },
        {
          "title": "Available Commands",
          "level": 2
        },
        {
          "title": "9. Chat",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "CrewAI CLI Documentation",
            "level": 1
          },
          {
            "title": "Available Commands",
            "level": 2
          },
          {
            "title": "9. Chat",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > CrewAI CLI Documentation > Available Commands > 9. Chat"
      },
      "enhanced_content": "Context: Changelog > CrewAI CLI Documentation > Available Commands > 9. Chat\n\n@crew\ndef crew(self) -> Crew:\n    return Crew(\n        agents=self.agents,\n        tasks=self.tasks,\n        process=Process.sequential,\n        verbose=True,\n        chat_llm=\"gpt-4o\",  # LLM for chat orchestration\n    )",
      "formatted_path": "Changelog > CrewAI CLI Documentation > Available Commands > 9. Chat",
      "enhanced_text": "Context: Changelog > CrewAI CLI Documentation > Available Commands > 9. Chat\n\n@crew\ndef crew(self) -> Crew:\n    return Crew(\n        agents=self.agents,\n        tasks=self.tasks,\n        process=Process.sequential,\n        verbose=True,\n        chat_llm=\"gpt-4o\",  # LLM for chat orchestration\n    )"
    },
    {
      "content": "When running `crewai create crew` command, the CLI will first show you the top 5 most common LLM providers and ask you to select one. Once you've selected an LLM provider, you will be prompted for API keys.",
      "title": "10. API Keys",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "CrewAI CLI Documentation",
          "level": 1
        },
        {
          "title": "Available Commands",
          "level": 2
        },
        {
          "title": "10. API Keys",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "CrewAI CLI Documentation",
            "level": 1
          },
          {
            "title": "Available Commands",
            "level": 2
          },
          {
            "title": "10. API Keys",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > CrewAI CLI Documentation > Available Commands > 10. API Keys"
      },
      "enhanced_content": "Context: Changelog > CrewAI CLI Documentation > Available Commands > 10. API Keys\n\n### 10. API Keys\n\nWhen running `crewai create crew` command, the CLI will first show you the top 5 most common LLM providers and ask you to select one. Once you've selected an LLM provider, you will be prompted for API keys.",
      "formatted_path": "Changelog > CrewAI CLI Documentation > Available Commands > 10. API Keys",
      "enhanced_text": "Context: Changelog > CrewAI CLI Documentation > Available Commands > 10. API Keys\n\n 10. API Keys\n\nWhen running `crewai create crew` command, the CLI will first show you the top 5 most common LLM providers and ask you to select one. Once you've selected an LLM provider, you will be prompted for API keys."
    },
    {
      "content": "The CLI will initially prompt for API keys for the following services: OpenAI Groq Anthropic Google Gemini SambaNova When you select a provider, the CLI will prompt you to enter your API key.",
      "title": "Initial API key providers",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "CrewAI CLI Documentation",
          "level": 1
        },
        {
          "title": "Available Commands",
          "level": 2
        },
        {
          "title": "10. API Keys",
          "level": 3
        },
        {
          "title": "Initial API key providers",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "CrewAI CLI Documentation",
            "level": 1
          },
          {
            "title": "Available Commands",
            "level": 2
          },
          {
            "title": "10. API Keys",
            "level": 3
          },
          {
            "title": "Initial API key providers",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > CrewAI CLI Documentation > Available Commands > 10. API Keys > Initial API key providers"
      },
      "enhanced_content": "Context: Changelog > CrewAI CLI Documentation > Available Commands > 10. API Keys > Initial API key providers\n\n#### Initial API key providers\n\nThe CLI will initially prompt for API keys for the following services: OpenAI Groq Anthropic Google Gemini SambaNova When you select a provider, the CLI will prompt you to enter your API key.",
      "formatted_path": "Changelog > CrewAI CLI Documentation > Available Commands > 10. API Keys > Initial API key providers",
      "enhanced_text": "Context: Changelog > CrewAI CLI Documentation > Available Commands > 10. API Keys > Initial API key providers\n\n Initial API key providers\n\nThe CLI will initially prompt for API keys for the following services: OpenAI Groq Anthropic Google Gemini SambaNova When you select a provider, the CLI will prompt you to enter your API key."
    },
    {
      "content": "If you select option 6, you will be able to select from a list of LiteLLM supported providers. When you select a provider, the CLI will prompt you to enter the Key name and the API key. See the following link for each provider's key name: [LiteLLM Providers](https://docs.litellm.ai/docs/providers)",
      "title": "Other Options",
      "type": "link_list",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "CrewAI CLI Documentation",
          "level": 1
        },
        {
          "title": "Available Commands",
          "level": 2
        },
        {
          "title": "10. API Keys",
          "level": 3
        },
        {
          "title": "Other Options",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "CrewAI CLI Documentation",
            "level": 1
          },
          {
            "title": "Available Commands",
            "level": 2
          },
          {
            "title": "10. API Keys",
            "level": 3
          },
          {
            "title": "Other Options",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 1,
        "formatted_path": "Changelog > CrewAI CLI Documentation > Available Commands > 10. API Keys > Other Options"
      },
      "enhanced_content": "Context: Changelog > CrewAI CLI Documentation > Available Commands > 10. API Keys > Other Options\n\n#### Other Options\n\nIf you select option 6, you will be able to select from a list of LiteLLM supported providers. When you select a provider, the CLI will prompt you to enter the Key name and the API key. See the following link for each provider's key name: [LiteLLM Providers](https://docs.litellm.ai/docs/providers)",
      "formatted_path": "Changelog > CrewAI CLI Documentation > Available Commands > 10. API Keys > Other Options",
      "enhanced_text": "Context: Changelog > CrewAI CLI Documentation > Available Commands > 10. API Keys > Other Options\n\n Other Options\n\nIf you select option 6, you will be able to select from a list of LiteLLM supported providers. When you select a provider, the CLI will prompt you to enter the Key name and the API key. See the following link for each provider's key name: [LiteLLM Providers](https://docs.litellm.ai/docs/providers)"
    },
    {
      "content": "Source: https://docs.crewai.com/concepts/collaboration Exploring the dynamics of agent collaboration within the CrewAI framework, focusing on the newly integrated features for enhanced functionality.",
      "title": "Collaboration",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Collaboration",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Collaboration",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Collaboration"
      },
      "enhanced_content": "Context: Changelog > Collaboration\n\n# Collaboration\n\nSource: https://docs.crewai.com/concepts/collaboration Exploring the dynamics of agent collaboration within the CrewAI framework, focusing on the newly integrated features for enhanced functionality.",
      "formatted_path": "Changelog > Collaboration",
      "enhanced_text": "Context: Changelog > Collaboration\n\n Collaboration\n\nSource: https://docs.crewai.com/concepts/collaboration Exploring the dynamics of agent collaboration within the CrewAI framework, focusing on the newly integrated features for enhanced functionality.\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "Collaboration in CrewAI is fundamental, enabling agents to combine their skills, share information, and assist each other in task execution, embodying a truly cooperative ecosystem. **Information Sharing**: Ensures all agents are well-informed and can contribute effectively by sharing data and findings. **Task Assistance**: Allows agents to seek help from peers with the required expertise for specific tasks. **Resource Allocation**: Optimizes task execution through the efficient distribution and sharing of resources among agents.",
      "title": "Collaboration Fundamentals",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Collaboration",
          "level": 1
        },
        {
          "title": "Collaboration Fundamentals",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Collaboration",
            "level": 1
          },
          {
            "title": "Collaboration Fundamentals",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Collaboration > Collaboration Fundamentals"
      },
      "enhanced_content": "Context: Changelog > Collaboration > Collaboration Fundamentals\n\n## Collaboration Fundamentals\n\nCollaboration in CrewAI is fundamental, enabling agents to combine their skills, share information, and assist each other in task execution, embodying a truly cooperative ecosystem. **Information Sharing**: Ensures all agents are well-informed and can contribute effectively by sharing data and findings. **Task Assistance**: Allows agents to seek help from peers with the required expertise for specific tasks. **Resource Allocation**: Optimizes task execution through the efficient distribution and sharing of resources among agents.",
      "formatted_path": "Changelog > Collaboration > Collaboration Fundamentals",
      "enhanced_text": "Context: Changelog > Collaboration > Collaboration Fundamentals\n\n Collaboration Fundamentals\n\nCollaboration in CrewAI is fundamental, enabling agents to combine their skills, share information, and assist each other in task execution, embodying a truly cooperative ecosystem. **Information Sharing**: Ensures all agents are well-informed and can contribute effectively by sharing data and findings. **Task Assistance**: Allows agents to seek help from peers with the required expertise for specific tasks. **Resource Allocation**: Optimizes task execution through the efficient distribution and sharing of resources among agents.\n\nRelated sections:\n- \n"
    },
    {
      "content": "The `Crew` class has been enriched with several attributes to support advanced functionalities: | Feature                                                               | Description                                                                                                                                                                                              |\n| :-------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Language Model Management** (`manager_llm`, `function_calling_llm`) | Manages language models for executing tasks and tools. `manager_llm` is required for hierarchical processes, while `function_calling_llm` is optional with a default value for streamlined interactions. |\n| **Custom Manager Agent** (`manager_agent`)                            | Specifies a custom agent as the manager, replacing the default CrewAI manager.                                                                                                                           |\n| **Process Flow** (`process`)                                          | Defines execution logic (e.g., sequential, hierarchical) for task distribution.                                                                                                                          |\n| **Verbose Logging** (`verbose`)                                       | Provides detailed logging for monitoring and debugging. Accepts integer and boolean values to control verbosity level.                                                                                   |\n| **Rate Limiting** (`max_rpm`)                                         | Limits requests per minute to optimize resource usage. Setting guidelines depend on task complexity and load.                                                                                            |\n| **Internationalization / Customization** (`language`, `prompt_file`)  | Supports prompt customization for global usability. [Example of file](https://github.com/joaomdmoura/crewAI/blob/main/src/crewai/translations/en.json)                                                   |\n| **Execution and Output Handling** (`full_output`)                     | Controls output granularity, distinguishing between full and final outputs.                                                                                                                              |\n| **Callback and Telemetry** (`step_callback`, `task_callback`)         | Enables step-wise and task-level execution monitoring and telemetry for performance analytics.                                                                                                           |\n| **Crew Sharing** (`share_crew`)                                       | Allows sharing crew data with CrewAI for model improvement. Privacy implications and benefits should be considered.                                                                                      |\n| **Usage Metrics** (`usage_metrics`)                                   | Logs all LLM usage metrics during task execution for performance insights.                                                                                                                               |\n| **Memory Usage** (`memory`)                                           | Enables memory for storing execution history, aiding in agent learning and task efficiency.                                                                                                              |\n| **Embedder Configuration** (`embedder`)                               | Configures the embedder for language understanding and generation, with support for provider customization.                                                                                              |\n| **Cache Management** (`cache`)                                        | Specifies whether to cache tool execution results, enhancing performance.                                                                                                                                |\n| **Output Logging** (`output_log_file`)                                | Defines the file path for logging crew execution output.                                                                                                                                                 |\n| **Planning Mode** (`planning`)                                        | Enables action planning before task execution. Set `planning=True` to activate.                                                                                                                          |\n| **Replay Feature** (`replay`)                                         | Provides CLI for listing tasks from the last run and replaying from specific tasks, aiding in task management and troubleshooting.                                                                       |",
      "title": "Enhanced Attributes for Improved Collaboration",
      "type": "descriptive_text_oversized",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Collaboration",
          "level": 1
        },
        {
          "title": "Enhanced Attributes for Improved Collaboration",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Collaboration",
            "level": 1
          },
          {
            "title": "Enhanced Attributes for Improved Collaboration",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 1,
        "formatted_path": "Changelog > Collaboration > Enhanced Attributes for Improved Collaboration"
      },
      "enhanced_content": "Context: Changelog > Collaboration > Enhanced Attributes for Improved Collaboration\n\n## Enhanced Attributes for Improved Collaboration\n\nThe `Crew` class has been enriched with several attributes to support advanced functionalities: | Feature                                                               | Description                                                                                                                                                                                              |\n| :-------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Language Model Management** (`manager_llm`, `function_calling_llm`) | Manages language models for executing tasks and tools. `manager_llm` is required for hierarchical processes, while `function_calling_llm` is optional with a default value for streamlined interactions. |\n| **Custom Manager Agent** (`manager_agent`)                            | Specifies a custom agent as the manager, replacing the default CrewAI manager.                                                                                                                           |\n| **Process Flow** (`process`)                                          | Defines execution logic (e.g., sequential, hierarchical) for task distribution.                                                                                                                          |\n| **Verbose Logging** (`verbose`)                                       | Provides detailed logging for monitoring and debugging. Accepts integer and boolean values to control verbosity level.                                                                                   |\n| **Rate Limiting** (`max_rpm`)                                         | Limits requests per minute to optimize resource usage. Setting guidelines depend on task complexity and load.                                                                                            |\n| **Internationalization / Customization** (`language`, `prompt_file`)  | Supports prompt customization for global usability. [Example of file](https://github.com/joaomdmoura/crewAI/blob/main/src/crewai/translations/en.json)                                                   |\n| **Execution and Output Handling** (`full_output`)                     | Controls output granularity, distinguishing between full and final outputs.                                                                                                                              |\n| **Callback and Telemetry** (`step_callback`, `task_callback`)         | Enables step-wise and task-level execution monitoring and telemetry for performance analytics.                                                                                                           |\n| **Crew Sharing** (`share_crew`)                                       | Allows sharing crew data with CrewAI for model improvement. Privacy implications and benefits should be considered.                                                                                      |\n| **Usage Metrics** (`usage_metrics`)                                   | Logs all LLM usage metrics during task execution for performance insights.                                                                                                                               |\n| **Memory Usage** (`memory`)                                           | Enables memory for storing execution history, aiding in agent learning and task efficiency.                                                                                                              |\n| **Embedder Configuration** (`embedder`)                               | Configures the embedder for language understanding and generation, with support for provider customization.                                                                                              |\n| **Cache Management** (`cache`)                                        | Specifies whether to cache tool execution results, enhancing performance.                                                                                                                                |\n| **Output Logging** (`output_log_file`)                                | Defines the file path for logging crew execution output.                                                                                                                                                 |\n| **Planning Mode** (`planning`)                                        | Enables action planning before task execution. Set `planning=True` to activate.                                                                                                                          |\n| **Replay Feature** (`replay`)                                         | Provides CLI for listing tasks from the last run and replaying from specific tasks, aiding in task management and troubleshooting.                                                                       |",
      "formatted_path": "Changelog > Collaboration > Enhanced Attributes for Improved Collaboration",
      "enhanced_text": "Context: Changelog > Collaboration > Enhanced Attributes for Improved Collaboration\n\n Enhanced Attributes for Improved Collaboration\n\nThe `Crew` class has been enriched with several attributes to support advanced functionalities: | Feature                                                               | Description                                                                                                                                                                                              |\n| :-------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Language Model Management** (`manager_llm`, `function_calling_llm`) | Manages language models for executing tasks and tools. `manager_llm` is required for hierarchical processes, while `function_calling_llm` is optional with a default value for streamlined interactions. |\n| **Custom Manager Agent** (`manager_agent`)                            | Specifies a custom agent as the manager, replacing the default CrewAI manager.                                                                                                                           |\n| **Process Flow** (`process`)                                          | Defines execution logic (e.g., sequential, hierarchical) for task distribution.                                                                                                                          |\n| **Verbose Logging** (`verbose`)                                       | Provides detailed logging for monitoring and debugging. Accepts integer and boolean values to control verbosity level.                                                                                   |\n| **Rate Limiting** (`max_rpm`)                                         | Limits requests per minute to optimize resource usage. Setting guidelines depend on task complexity and load.                                                                                            |\n| **Internationalization / Customization** (`language`, `prompt_file`)  | Supports prompt customization for global usability. [Example of file](https://github.com/joaomdmoura/crewAI/blob/main/src/crewai/translations/en.json)                                                   |\n| **Execution and Output Handling** (`full_output`)                     | Controls output granularity, distinguishing between full and final outputs.                                                                                                                              |\n| **Callback and Telemetry** (`step_callback`, `task_callback`)         | Enables step-wise and task-level execution monitoring and telemetry for performance analytics.                                                                                                           |\n| **Crew Sharing** (`share_crew`)                                       | Allows sharing crew data with CrewAI for model improvement. Privacy implications and benefits should be considered.                                                                                      |\n| **Usage Metrics** (`usage_metrics`)                                   | Logs all LLM usage metrics during task execution for performance insights.                                                                                                                               |\n| **Memory Usage** (`memory`)                                           | Enables memory for storing execution history, aiding in agent learning and task efficiency.                                                                                                              |\n| **Embedder Configuration** (`embedder`)                               | Configures the embedder for language understanding and generation, with support for provider customization.                                                                                              |\n| **Cache Management** (`cache`)                                        | Specifies whether to cache tool execution results, enhancing performance.                                                                                                                                |\n| **Output Logging** (`output_log_file`)                                | Defines the file path for logging crew execution output.                                                                                                                                                 |\n| **Planning Mode** (`planning`)                                        | Enables action planning before task execution. Set `planning=True` to activate.                                                                                                                          |\n| **Replay Feature** (`replay`)                                         | Provides CLI for listing tasks from the last run and replaying from specific tasks, aiding in task management and troubleshooting.                                                                       |\n\nRelated sections:\n- \n"
    },
    {
      "content": "Delegation enhances functionality by allowing agents to intelligently assign tasks or seek help, thereby amplifying the crew's overall capability.",
      "title": "Delegation (Dividing to Conquer)",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Collaboration",
          "level": 1
        },
        {
          "title": "Delegation (Dividing to Conquer)",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Collaboration",
            "level": 1
          },
          {
            "title": "Delegation (Dividing to Conquer)",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Collaboration > Delegation (Dividing to Conquer)"
      },
      "enhanced_content": "Context: Changelog > Collaboration > Delegation (Dividing to Conquer)\n\n## Delegation (Dividing to Conquer)\n\nDelegation enhances functionality by allowing agents to intelligently assign tasks or seek help, thereby amplifying the crew's overall capability.",
      "formatted_path": "Changelog > Collaboration > Delegation (Dividing to Conquer)",
      "enhanced_text": "Context: Changelog > Collaboration > Delegation (Dividing to Conquer)\n\n Delegation (Dividing to Conquer)\n\nDelegation enhances functionality by allowing agents to intelligently assign tasks or seek help, thereby amplifying the crew's overall capability."
    },
    {
      "content": "Setting up a crew involves defining the roles and capabilities of each agent. CrewAI seamlessly manages their interactions, ensuring efficient collaboration and delegation, with enhanced customization and monitoring features to adapt to various operational needs.",
      "title": "Implementing Collaboration and Delegation",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Collaboration",
          "level": 1
        },
        {
          "title": "Implementing Collaboration and Delegation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Collaboration",
            "level": 1
          },
          {
            "title": "Implementing Collaboration and Delegation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Collaboration > Implementing Collaboration and Delegation"
      },
      "enhanced_content": "Context: Changelog > Collaboration > Implementing Collaboration and Delegation\n\n## Implementing Collaboration and Delegation\n\nSetting up a crew involves defining the roles and capabilities of each agent. CrewAI seamlessly manages their interactions, ensuring efficient collaboration and delegation, with enhanced customization and monitoring features to adapt to various operational needs.",
      "formatted_path": "Changelog > Collaboration > Implementing Collaboration and Delegation",
      "enhanced_text": "Context: Changelog > Collaboration > Implementing Collaboration and Delegation\n\n Implementing Collaboration and Delegation\n\nSetting up a crew involves defining the roles and capabilities of each agent. CrewAI seamlessly manages their interactions, ensuring efficient collaboration and delegation, with enhanced customization and monitoring features to adapt to various operational needs.\n\nRelated sections:\n- \n"
    },
    {
      "content": "Consider a crew with a researcher agent tasked with data gathering and a writer agent responsible for compiling reports. The integration of advanced language model management and process flow attributes allows for more sophisticated interactions, such as the writer delegating complex research tasks to the researcher or querying specific information, thereby facilitating a seamless workflow.",
      "title": "Example Scenario",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Collaboration",
          "level": 1
        },
        {
          "title": "Example Scenario",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Collaboration",
            "level": 1
          },
          {
            "title": "Example Scenario",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Collaboration > Example Scenario"
      },
      "enhanced_content": "Context: Changelog > Collaboration > Example Scenario\n\n## Example Scenario\n\nConsider a crew with a researcher agent tasked with data gathering and a writer agent responsible for compiling reports. The integration of advanced language model management and process flow attributes allows for more sophisticated interactions, such as the writer delegating complex research tasks to the researcher or querying specific information, thereby facilitating a seamless workflow.",
      "formatted_path": "Changelog > Collaboration > Example Scenario",
      "enhanced_text": "Context: Changelog > Collaboration > Example Scenario\n\n Example Scenario\n\nConsider a crew with a researcher agent tasked with data gathering and a writer agent responsible for compiling reports. The integration of advanced language model management and process flow attributes allows for more sophisticated interactions, such as the writer delegating complex research tasks to the researcher or querying specific information, thereby facilitating a seamless workflow.\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "Source: https://docs.crewai.com/concepts/crews Understanding and utilizing crews in the crewAI framework with comprehensive attributes and functionalities.",
      "title": "Crews",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crews",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crews",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crews"
      },
      "enhanced_content": "Context: Changelog > Crews\n\n# Crews\n\nSource: https://docs.crewai.com/concepts/crews Understanding and utilizing crews in the crewAI framework with comprehensive attributes and functionalities.",
      "formatted_path": "Changelog > Crews",
      "enhanced_text": "Context: Changelog > Crews\n\n Crews\n\nSource: https://docs.crewai.com/concepts/crews Understanding and utilizing crews in the crewAI framework with comprehensive attributes and functionalities.\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "A crew in crewAI represents a collaborative group of agents working together to achieve a set of tasks. Each crew defines the strategy for task execution, agent collaboration, and the overall workflow.",
      "title": "What is a Crew?",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crews",
          "level": 1
        },
        {
          "title": "What is a Crew?",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crews",
            "level": 1
          },
          {
            "title": "What is a Crew?",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crews > What is a Crew?"
      },
      "enhanced_content": "Context: Changelog > Crews > What is a Crew?\n\n## What is a Crew?\n\nA crew in crewAI represents a collaborative group of agents working together to achieve a set of tasks. Each crew defines the strategy for task execution, agent collaboration, and the overall workflow.",
      "formatted_path": "Changelog > Crews > What is a Crew?",
      "enhanced_text": "Context: Changelog > Crews > What is a Crew?\n\n What is a Crew?\n\nA crew in crewAI represents a collaborative group of agents working together to achieve a set of tasks. Each crew defines the strategy for task execution, agent collaboration, and the overall workflow."
    },
    {
      "content": "| Attribute                             | Parameters             | Description                                                                                                                                                                                           |\n| :------------------------------------ | :--------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Tasks**                             | `tasks`                | A list of tasks assigned to the crew.                                                                                                                                                                 |\n| **Agents**                            | `agents`               | A list of agents that are part of the crew.                                                                                                                                                           |\n| **Process** *(optional)*              | `process`              | The process flow (e.g., sequential, hierarchical) the crew follows. Default is `sequential`.                                                                                                          |\n| **Verbose** *(optional)*              | `verbose`              | The verbosity level for logging during execution. Defaults to `False`.                                                                                                                                |\n| **Manager LLM** *(optional)*          | `manager_llm`          | The language model used by the manager agent in a hierarchical process. **Required when using a hierarchical process.**                                                                               |\n| **Function Calling LLM** *(optional)* | `function_calling_llm` | If passed, the crew will use this LLM to do function calling for tools for all agents in the crew. Each agent can have its own LLM, which overrides the crew's LLM for function calling.              |\n| **Config** *(optional)*               | `config`               | Optional configuration settings for the crew, in `Json` or `Dict[str, Any]` format.                                                                                                                   |\n| **Max RPM** *(optional)*              | `max_rpm`              | Maximum requests per minute the crew adheres to during execution. Defaults to `None`.                                                                                                                 |\n| **Language** *(optional)*             | `language`             | Language used for the crew, defaults to English.                                                                                                                                                      |\n| **Language File** *(optional)*        | `language_file`        | Path to the language file to be used for the crew.                                                                                                                                                    |\n| **Memory** *(optional)*               | `memory`               | Utilized for storing execution memories (short-term, long-term, entity memory).                                                                                                                       |\n| **Memory Config** *(optional)*        | `memory_config`        | Configuration for the memory provider to be used by the crew.                                                                                                                                         |\n| **Cache** *(optional)*                | `cache`                | Specifies whether to use a cache for storing the results of tools' execution. Defaults to `True`.                                                                                                     |\n| **Embedder** *(optional)*             | `embedder`             | Configuration for the embedder to be used by the crew. Mostly used by memory for now. Default is `{\"provider\": \"openai\"}`.                                                                            |\n| **Full Output** *(optional)*          | `full_output`          | Whether the crew should return the full output with all tasks outputs or just the final output. Defaults to `False`.                                                                                  |\n| **Step Callback** *(optional)*        | `step_callback`        | A function that is called after each step of every agent. This can be used to log the agent's actions or to perform other operations; it won't override the agent-specific `step_callback`.           |\n| **Task Callback** *(optional)*        | `task_callback`        | A function that is called after the completion of each task. Useful for monitoring or additional operations post-task execution.                                                                      |\n| **Share Crew** *(optional)*           | `share_crew`           | Whether you want to share the complete crew information and execution with the crewAI team to make the library better, and allow us to train models.                                                  |\n| **Output Log File** *(optional)*      | `output_log_file`      | Set to True to save logs as logs.txt in the current directory or provide a file path. Logs will be in JSON format if the filename ends in .json, otherwise .txt. Defautls to `None`.                  |\n| **Manager Agent** *(optional)*        | `manager_agent`        | `manager` sets a custom agent that will be used as a manager.                                                                                                                                         |\n| **Prompt File** *(optional)*          | `prompt_file`          | Path to the prompt JSON file to be used for the crew.                                                                                                                                                 |\n| **Planning** *(optional)*             | `planning`             | Adds planning ability to the Crew. When activated before each Crew iteration, all Crew data is sent to an AgentPlanner that will plan the tasks and this plan will be added to each task description. |\n| **Planning LLM** *(optional)*         | `planning_llm`         | The language model used by the AgentPlanner in a planning process.                                                                                                                                    |",
      "title": "Crew Attributes",
      "type": "descriptive_text_oversized",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crews",
          "level": 1
        },
        {
          "title": "Crew Attributes",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crews",
            "level": 1
          },
          {
            "title": "Crew Attributes",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crews > Crew Attributes"
      },
      "enhanced_content": "Context: Changelog > Crews > Crew Attributes\n\n## Crew Attributes\n\n| Attribute                             | Parameters             | Description                                                                                                                                                                                           |\n| :------------------------------------ | :--------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Tasks**                             | `tasks`                | A list of tasks assigned to the crew.                                                                                                                                                                 |\n| **Agents**                            | `agents`               | A list of agents that are part of the crew.                                                                                                                                                           |\n| **Process** *(optional)*              | `process`              | The process flow (e.g., sequential, hierarchical) the crew follows. Default is `sequential`.                                                                                                          |\n| **Verbose** *(optional)*              | `verbose`              | The verbosity level for logging during execution. Defaults to `False`.                                                                                                                                |\n| **Manager LLM** *(optional)*          | `manager_llm`          | The language model used by the manager agent in a hierarchical process. **Required when using a hierarchical process.**                                                                               |\n| **Function Calling LLM** *(optional)* | `function_calling_llm` | If passed, the crew will use this LLM to do function calling for tools for all agents in the crew. Each agent can have its own LLM, which overrides the crew's LLM for function calling.              |\n| **Config** *(optional)*               | `config`               | Optional configuration settings for the crew, in `Json` or `Dict[str, Any]` format.                                                                                                                   |\n| **Max RPM** *(optional)*              | `max_rpm`              | Maximum requests per minute the crew adheres to during execution. Defaults to `None`.                                                                                                                 |\n| **Language** *(optional)*             | `language`             | Language used for the crew, defaults to English.                                                                                                                                                      |\n| **Language File** *(optional)*        | `language_file`        | Path to the language file to be used for the crew.                                                                                                                                                    |\n| **Memory** *(optional)*               | `memory`               | Utilized for storing execution memories (short-term, long-term, entity memory).                                                                                                                       |\n| **Memory Config** *(optional)*        | `memory_config`        | Configuration for the memory provider to be used by the crew.                                                                                                                                         |\n| **Cache** *(optional)*                | `cache`                | Specifies whether to use a cache for storing the results of tools' execution. Defaults to `True`.                                                                                                     |\n| **Embedder** *(optional)*             | `embedder`             | Configuration for the embedder to be used by the crew. Mostly used by memory for now. Default is `{\"provider\": \"openai\"}`.                                                                            |\n| **Full Output** *(optional)*          | `full_output`          | Whether the crew should return the full output with all tasks outputs or just the final output. Defaults to `False`.                                                                                  |\n| **Step Callback** *(optional)*        | `step_callback`        | A function that is called after each step of every agent. This can be used to log the agent's actions or to perform other operations; it won't override the agent-specific `step_callback`.           |\n| **Task Callback** *(optional)*        | `task_callback`        | A function that is called after the completion of each task. Useful for monitoring or additional operations post-task execution.                                                                      |\n| **Share Crew** *(optional)*           | `share_crew`           | Whether you want to share the complete crew information and execution with the crewAI team to make the library better, and allow us to train models.                                                  |\n| **Output Log File** *(optional)*      | `output_log_file`      | Set to True to save logs as logs.txt in the current directory or provide a file path. Logs will be in JSON format if the filename ends in .json, otherwise .txt. Defautls to `None`.                  |\n| **Manager Agent** *(optional)*        | `manager_agent`        | `manager` sets a custom agent that will be used as a manager.                                                                                                                                         |\n| **Prompt File** *(optional)*          | `prompt_file`          | Path to the prompt JSON file to be used for the crew.                                                                                                                                                 |\n| **Planning** *(optional)*             | `planning`             | Adds planning ability to the Crew. When activated before each Crew iteration, all Crew data is sent to an AgentPlanner that will plan the tasks and this plan will be added to each task description. |\n| **Planning LLM** *(optional)*         | `planning_llm`         | The language model used by the AgentPlanner in a planning process.                                                                                                                                    |",
      "formatted_path": "Changelog > Crews > Crew Attributes",
      "enhanced_text": "Context: Changelog > Crews > Crew Attributes\n\n Crew Attributes\n\n| Attribute                             | Parameters             | Description                                                                                                                                                                                           |\n| :------------------------------------ | :--------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Tasks**                             | `tasks`                | A list of tasks assigned to the crew.                                                                                                                                                                 |\n| **Agents**                            | `agents`               | A list of agents that are part of the crew.                                                                                                                                                           |\n| **Process** *(optional)*              | `process`              | The process flow (e.g., sequential, hierarchical) the crew follows. Default is `sequential`.                                                                                                          |\n| **Verbose** *(optional)*              | `verbose`              | The verbosity level for logging during execution. Defaults to `False`.                                                                                                                                |\n| **Manager LLM** *(optional)*          | `manager_llm`          | The language model used by the manager agent in a hierarchical process. **Required when using a hierarchical process.**                                                                               |\n| **Function Calling LLM** *(optional)* | `function_calling_llm` | If passed, the crew will use this LLM to do function calling for tools for all agents in the crew. Each agent can have its own LLM, which overrides the crew's LLM for function calling.              |\n| **Config** *(optional)*               | `config`               | Optional configuration settings for the crew, in `Json` or `Dict[str, Any]` format.                                                                                                                   |\n| **Max RPM** *(optional)*              | `max_rpm`              | Maximum requests per minute the crew adheres to during execution. Defaults to `None`.                                                                                                                 |\n| **Language** *(optional)*             | `language`             | Language used for the crew, defaults to English.                                                                                                                                                      |\n| **Language File** *(optional)*        | `language_file`        | Path to the language file to be used for the crew.                                                                                                                                                    |\n| **Memory** *(optional)*               | `memory`               | Utilized for storing execution memories (short-term, long-term, entity memory).                                                                                                                       |\n| **Memory Config** *(optional)*        | `memory_config`        | Configuration for the memory provider to be used by the crew.                                                                                                                                         |\n| **Cache** *(optional)*                | `cache`                | Specifies whether to use a cache for storing the results of tools' execution. Defaults to `True`.                                                                                                     |\n| **Embedder** *(optional)*             | `embedder`             | Configuration for the embedder to be used by the crew. Mostly used by memory for now. Default is `{\"provider\": \"openai\"}`.                                                                            |\n| **Full Output** *(optional)*          | `full_output`          | Whether the crew should return the full output with all tasks outputs or just the final output. Defaults to `False`.                                                                                  |\n| **Step Callback** *(optional)*        | `step_callback`        | A function that is called after each step of every agent. This can be used to log the agent's actions or to perform other operations; it won't override the agent-specific `step_callback`.           |\n| **Task Callback** *(optional)*        | `task_callback`        | A function that is called after the completion of each task. Useful for monitoring or additional operations post-task execution.                                                                      |\n| **Share Crew** *(optional)*           | `share_crew`           | Whether you want to share the complete crew information and execution with the crewAI team to make the library better, and allow us to train models.                                                  |\n| **Output Log File** *(optional)*      | `output_log_file`      | Set to True to save logs as logs.txt in the current directory or provide a file path. Logs will be in JSON format if the filename ends in .json, otherwise .txt. Defautls to `None`.                  |\n| **Manager Agent** *(optional)*        | `manager_agent`        | `manager` sets a custom agent that will be used as a manager.                                                                                                                                         |\n| **Prompt File** *(optional)*          | `prompt_file`          | Path to the prompt JSON file to be used for the crew.                                                                                                                                                 |\n| **Planning** *(optional)*             | `planning`             | Adds planning ability to the Crew. When activated before each Crew iteration, all Crew data is sent to an AgentPlanner that will plan the tasks and this plan will be added to each task description. |\n| **Planning LLM** *(optional)*         | `planning_llm`         | The language model used by the AgentPlanner in a planning process.                                                                                                                                    |"
    },
    {
      "content": "There are two ways to create crews in CrewAI: using **YAML configuration (recommended)** or defining them **directly in code**.",
      "title": "Creating Crews",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crews",
          "level": 1
        },
        {
          "title": "Creating Crews",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crews",
            "level": 1
          },
          {
            "title": "Creating Crews",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crews > Creating Crews"
      },
      "enhanced_content": "Context: Changelog > Crews > Creating Crews\n\n## Creating Crews\n\nThere are two ways to create crews in CrewAI: using **YAML configuration (recommended)** or defining them **directly in code**.",
      "formatted_path": "Changelog > Crews > Creating Crews",
      "enhanced_text": "Context: Changelog > Crews > Creating Crews\n\n Creating Crews\n\nThere are two ways to create crews in CrewAI: using **YAML configuration (recommended)** or defining them **directly in code**.\n\nRelated sections:\n- \n"
    },
    {
      "content": "from crewai import Agent, Crew, Task, Process\nfrom crewai.project import CrewBase, agent, task, crew, before_kickoff, after_kickoff\n\n\n@CrewBase\nclass YourCrewName:\n    \"\"\"Description of your crew\"\"\"\n\n    # Paths to your YAML configuration files\n    # To see an example agent and task defined in YAML, checkout the following:\n    # - Task: https://docs.crewai.com/concepts/tasks#yaml-configuration-recommended\n    # - Agents: https://docs.crewai.com/concepts/agents#yaml-configuration-recommended\n    agents_config = 'config/agents.yaml' \n    tasks_config = 'config/tasks.yaml' \n\n    @before_kickoff\n    def prepare_inputs(self, inputs):\n        # Modify inputs before the crew starts\n        inputs['additional_data'] = \"Some extra information\"\n        return inputs\n\n    @after_kickoff\n    def process_output(self, output):\n        # Modify output after the crew finishes\n        output.raw += \"\\nProcessed after kickoff.\"\n        return output\n\n    @agent\n    def agent_one(self) -> Agent:\n        return Agent(\n            config=self.agents_config['agent_one'],\n            verbose=True\n        )\n\n    @agent\n    def agent_two(self) -> Agent:\n        return Agent(\n            config=self.agents_config['agent_two'],\n            verbose=True\n        )\n\n    @task\n    def task_one(self) -> Task:\n        return Task(\n            config=self.tasks_config['task_one']\n        )\n\n    @task\n    def task_two(self) -> Task:\n        return Task(\n            config=self.tasks_config['task_two']\n        )\n\n    @crew\n    def crew(self) -> Crew:\n        return Crew(\n            agents=self.agents,  # Automatically collected by the @agent decorator\n            tasks=self.tasks,    # Automatically collected by the @task decorator. \n            process=Process.sequential,\n            verbose=True,\n        )",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crews",
          "level": 1
        },
        {
          "title": "Creating Crews",
          "level": 2
        },
        {
          "title": "YAML Configuration (Recommended)",
          "level": 3
        },
        {
          "title": "Example Crew Class with Decorators",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crews",
            "level": 1
          },
          {
            "title": "Creating Crews",
            "level": 2
          },
          {
            "title": "YAML Configuration (Recommended)",
            "level": 3
          },
          {
            "title": "Example Crew Class with Decorators",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crews > Creating Crews > YAML Configuration (Recommended) > Example Crew Class with Decorators"
      },
      "enhanced_content": "Context: Changelog > Crews > Creating Crews > YAML Configuration (Recommended) > Example Crew Class with Decorators\n\nfrom crewai import Agent, Crew, Task, Process\nfrom crewai.project import CrewBase, agent, task, crew, before_kickoff, after_kickoff\n\n\n@CrewBase\nclass YourCrewName:\n    \"\"\"Description of your crew\"\"\"\n\n    # Paths to your YAML configuration files\n    # To see an example agent and task defined in YAML, checkout the following:\n    # - Task: https://docs.crewai.com/concepts/tasks#yaml-configuration-recommended\n    # - Agents: https://docs.crewai.com/concepts/agents#yaml-configuration-recommended\n    agents_config = 'config/agents.yaml' \n    tasks_config = 'config/tasks.yaml' \n\n    @before_kickoff\n    def prepare_inputs(self, inputs):\n        # Modify inputs before the crew starts\n        inputs['additional_data'] = \"Some extra information\"\n        return inputs\n\n    @after_kickoff\n    def process_output(self, output):\n        # Modify output after the crew finishes\n        output.raw += \"\\nProcessed after kickoff.\"\n        return output\n\n    @agent\n    def agent_one(self) -> Agent:\n        return Agent(\n            config=self.agents_config['agent_one'],\n            verbose=True\n        )\n\n    @agent\n    def agent_two(self) -> Agent:\n        return Agent(\n            config=self.agents_config['agent_two'],\n            verbose=True\n        )\n\n    @task\n    def task_one(self) -> Task:\n        return Task(\n            config=self.tasks_config['task_one']\n        )\n\n    @task\n    def task_two(self) -> Task:\n        return Task(\n            config=self.tasks_config['task_two']\n        )\n\n    @crew\n    def crew(self) -> Crew:\n        return Crew(\n            agents=self.agents,  # Automatically collected by the @agent decorator\n            tasks=self.tasks,    # Automatically collected by the @task decorator. \n            process=Process.sequential,\n            verbose=True,\n        )",
      "formatted_path": "Changelog > Crews > Creating Crews > YAML Configuration (Recommended) > Example Crew Class with Decorators",
      "enhanced_text": "Context: Changelog > Crews > Creating Crews > YAML Configuration (Recommended) > Example Crew Class with Decorators\n\nfrom crewai import Agent, Crew, Task, Process\nfrom crewai.project import CrewBase, agent, task, crew, before_kickoff, after_kickoff\n\n\n@CrewBase\nclass YourCrewName:\n    \"\"\"Description of your crew\"\"\"\n\n    # Paths to your YAML configuration files\n    # To see an example agent and task defined in YAML, checkout the following:\n    # - Task: https://docs.crewai.com/concepts/tasks#yaml-configuration-recommended\n    # - Agents: https://docs.crewai.com/concepts/agents#yaml-configuration-recommended\n    agents_config = 'config/agents.yaml' \n    tasks_config = 'config/tasks.yaml' \n\n    @before_kickoff\n    def prepare_inputs(self, inputs):\n        # Modify inputs before the crew starts\n        inputs['additional_data'] = \"Some extra information\"\n        return inputs\n\n    @after_kickoff\n    def process_output(self, output):\n        # Modify output after the crew finishes\n        output.raw += \"\\nProcessed after kickoff.\"\n        return output\n\n    @agent\n    def agent_one(self) -> Agent:\n        return Agent(\n            config=self.agents_config['agent_one'],\n            verbose=True\n        )\n\n    @agent\n    def agent_two(self) -> Agent:\n        return Agent(\n            config=self.agents_config['agent_two'],\n            verbose=True\n        )\n\n    @task\n    def task_one(self) -> Task:\n        return Task(\n            config=self.tasks_config['task_one']\n        )\n\n    @task\n    def task_two(self) -> Task:\n        return Task(\n            config=self.tasks_config['task_two']\n        )\n\n    @crew\n    def crew(self) -> Crew:\n        return Crew(\n            agents=self.agents,  # Automatically collected by the @agent decorator\n            tasks=self.tasks,    # Automatically collected by the @task decorator. \n            process=Process.sequential,\n            verbose=True,\n        )"
    },
    {
      "content": "CrewAI provides several decorators in the `annotations.py` file that are used to mark methods within your crew class for special handling: `@CrewBase`: Marks the class as a crew base class. `@agent`: Denotes a method that returns an `Agent` object. `@task`: Denotes a method that returns a `Task` object. `@crew`: Denotes the method that returns the `Crew` object. `@before_kickoff`: (Optional) Marks a method to be executed before the crew starts. `@after_kickoff`: (Optional) Marks a method to be executed after the crew finishes. These decorators help in organizing your crew's structure and automatically collecting agents and tasks without manually listing them.",
      "title": "Decorators overview from `annotations.py`",
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crews",
          "level": 1
        },
        {
          "title": "Creating Crews",
          "level": 2
        },
        {
          "title": "YAML Configuration (Recommended)",
          "level": 3
        },
        {
          "title": "Decorators overview from `annotations.py`",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crews",
            "level": 1
          },
          {
            "title": "Creating Crews",
            "level": 2
          },
          {
            "title": "YAML Configuration (Recommended)",
            "level": 3
          },
          {
            "title": "Decorators overview from `annotations.py`",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crews > Creating Crews > YAML Configuration (Recommended) > Decorators overview from `annotations.py`"
      },
      "enhanced_content": "Context: Changelog > Crews > Creating Crews > YAML Configuration (Recommended) > Decorators overview from `annotations.py`\n\n#### Decorators overview from `annotations.py`\n\nCrewAI provides several decorators in the `annotations.py` file that are used to mark methods within your crew class for special handling: `@CrewBase`: Marks the class as a crew base class. `@agent`: Denotes a method that returns an `Agent` object. `@task`: Denotes a method that returns a `Task` object. `@crew`: Denotes the method that returns the `Crew` object. `@before_kickoff`: (Optional) Marks a method to be executed before the crew starts. `@after_kickoff`: (Optional) Marks a method to be executed after the crew finishes. These decorators help in organizing your crew's structure and automatically collecting agents and tasks without manually listing them.",
      "formatted_path": "Changelog > Crews > Creating Crews > YAML Configuration (Recommended) > Decorators overview from `annotations.py`",
      "enhanced_text": "Context: Changelog > Crews > Creating Crews > YAML Configuration (Recommended) > Decorators overview from `annotations.py`\n\n Decorators overview from `annotations.py`\n\nCrewAI provides several decorators in the `annotations.py` file that are used to mark methods within your crew class for special handling: `@CrewBase`: Marks the class as a crew base class. `@agent`: Denotes a method that returns an `Agent` object. `@task`: Denotes a method that returns a `Task` object. `@crew`: Denotes the method that returns the `Crew` object. `@before_kickoff`: (Optional) Marks a method to be executed before the crew starts. `@after_kickoff`: (Optional) Marks a method to be executed after the crew finishes. These decorators help in organizing your crew's structure and automatically collecting agents and tasks without manually listing them."
    },
    {
      "content": "The output of a crew in the CrewAI framework is encapsulated within the `CrewOutput` class.\nThis class provides a structured way to access results of the crew's execution, including various formats such as raw strings, JSON, and Pydantic models.\nThe `CrewOutput` includes the results from the final task output, token usage, and individual task outputs.",
      "title": "Crew Output",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crews",
          "level": 1
        },
        {
          "title": "Crew Output",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crews",
            "level": 1
          },
          {
            "title": "Crew Output",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crews > Crew Output"
      },
      "enhanced_content": "Context: Changelog > Crews > Crew Output\n\n## Crew Output\n\nThe output of a crew in the CrewAI framework is encapsulated within the `CrewOutput` class.\nThis class provides a structured way to access results of the crew's execution, including various formats such as raw strings, JSON, and Pydantic models.\nThe `CrewOutput` includes the results from the final task output, token usage, and individual task outputs.",
      "formatted_path": "Changelog > Crews > Crew Output",
      "enhanced_text": "Context: Changelog > Crews > Crew Output\n\n Crew Output\n\nThe output of a crew in the CrewAI framework is encapsulated within the `CrewOutput` class.\nThis class provides a structured way to access results of the crew's execution, including various formats such as raw strings, JSON, and Pydantic models.\nThe `CrewOutput` includes the results from the final task output, token usage, and individual task outputs.\n\nRelated sections:\n- \n- \n- \n- \n"
    },
    {
      "content": "| Attribute        | Parameters     | Type                       | Description                                                                                          |\n| :--------------- | :------------- | :------------------------- | :--------------------------------------------------------------------------------------------------- |\n| **Raw**          | `raw`          | `str`                      | The raw output of the crew. This is the default format for the output.                               |\n| **Pydantic**     | `pydantic`     | `Optional[BaseModel]`      | A Pydantic model object representing the structured output of the crew.                              |\n| **JSON Dict**    | `json_dict`    | `Optional[Dict[str, Any]]` | A dictionary representing the JSON output of the crew.                                               |\n| **Tasks Output** | `tasks_output` | `List[TaskOutput]`         | A list of `TaskOutput` objects, each representing the output of a task in the crew.                  |\n| **Token Usage**  | `token_usage`  | `Dict[str, Any]`           | A summary of token usage, providing insights into the language model's performance during execution. |",
      "title": "Crew Output Attributes",
      "type": "descriptive_text_oversized",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crews",
          "level": 1
        },
        {
          "title": "Crew Output",
          "level": 2
        },
        {
          "title": "Crew Output Attributes",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crews",
            "level": 1
          },
          {
            "title": "Crew Output",
            "level": 2
          },
          {
            "title": "Crew Output Attributes",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crews > Crew Output > Crew Output Attributes"
      },
      "enhanced_content": "Context: Changelog > Crews > Crew Output > Crew Output Attributes\n\n### Crew Output Attributes\n\n| Attribute        | Parameters     | Type                       | Description                                                                                          |\n| :--------------- | :------------- | :------------------------- | :--------------------------------------------------------------------------------------------------- |\n| **Raw**          | `raw`          | `str`                      | The raw output of the crew. This is the default format for the output.                               |\n| **Pydantic**     | `pydantic`     | `Optional[BaseModel]`      | A Pydantic model object representing the structured output of the crew.                              |\n| **JSON Dict**    | `json_dict`    | `Optional[Dict[str, Any]]` | A dictionary representing the JSON output of the crew.                                               |\n| **Tasks Output** | `tasks_output` | `List[TaskOutput]`         | A list of `TaskOutput` objects, each representing the output of a task in the crew.                  |\n| **Token Usage**  | `token_usage`  | `Dict[str, Any]`           | A summary of token usage, providing insights into the language model's performance during execution. |",
      "formatted_path": "Changelog > Crews > Crew Output > Crew Output Attributes",
      "enhanced_text": "Context: Changelog > Crews > Crew Output > Crew Output Attributes\n\n Crew Output Attributes\n\n| Attribute        | Parameters     | Type                       | Description                                                                                          |\n| :--------------- | :------------- | :------------------------- | :--------------------------------------------------------------------------------------------------- |\n| **Raw**          | `raw`          | `str`                      | The raw output of the crew. This is the default format for the output.                               |\n| **Pydantic**     | `pydantic`     | `Optional[BaseModel]`      | A Pydantic model object representing the structured output of the crew.                              |\n| **JSON Dict**    | `json_dict`    | `Optional[Dict[str, Any]]` | A dictionary representing the JSON output of the crew.                                               |\n| **Tasks Output** | `tasks_output` | `List[TaskOutput]`         | A list of `TaskOutput` objects, each representing the output of a task in the crew.                  |\n| **Token Usage**  | `token_usage`  | `Dict[str, Any]`           | A summary of token usage, providing insights into the language model's performance during execution. |\n\nRelated sections:\n- \n"
    },
    {
      "content": "| Method/Property | Description                                                                                       |\n| :-------------- | :------------------------------------------------------------------------------------------------ |\n| **json**        | Returns the JSON string representation of the crew output if the output format is JSON.           |\n| **to\\_dict**    | Converts the JSON and Pydantic outputs to a dictionary.                                           |\n| \\***\\*str\\*\\*** | Returns the string representation of the crew output, prioritizing Pydantic, then JSON, then raw. |",
      "title": "Crew Output Methods and Properties",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crews",
          "level": 1
        },
        {
          "title": "Crew Output",
          "level": 2
        },
        {
          "title": "Crew Output Methods and Properties",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crews",
            "level": 1
          },
          {
            "title": "Crew Output",
            "level": 2
          },
          {
            "title": "Crew Output Methods and Properties",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crews > Crew Output > Crew Output Methods and Properties"
      },
      "enhanced_content": "Context: Changelog > Crews > Crew Output > Crew Output Methods and Properties\n\n### Crew Output Methods and Properties\n\n| Method/Property | Description                                                                                       |\n| :-------------- | :------------------------------------------------------------------------------------------------ |\n| **json**        | Returns the JSON string representation of the crew output if the output format is JSON.           |\n| **to\\_dict**    | Converts the JSON and Pydantic outputs to a dictionary.                                           |\n| \\***\\*str\\*\\*** | Returns the string representation of the crew output, prioritizing Pydantic, then JSON, then raw. |",
      "formatted_path": "Changelog > Crews > Crew Output > Crew Output Methods and Properties",
      "enhanced_text": "Context: Changelog > Crews > Crew Output > Crew Output Methods and Properties\n\n Crew Output Methods and Properties\n\n| Method/Property | Description                                                                                       |\n| :-------------- | :------------------------------------------------------------------------------------------------ |\n| **json**        | Returns the JSON string representation of the crew output if the output format is JSON.           |\n| **to\\_dict**    | Converts the JSON and Pydantic outputs to a dictionary.                                           |\n| \\***\\*str\\*\\*** | Returns the string representation of the crew output, prioritizing Pydantic, then JSON, then raw. |\n\nRelated sections:\n- \n"
    },
    {
      "content": "Once a crew has been executed, its output can be accessed through the `output` attribute of the `Crew` object. The `CrewOutput` class provides various ways to interact with and present this output.",
      "title": "Accessing Crew Outputs",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crews",
          "level": 1
        },
        {
          "title": "Crew Output",
          "level": 2
        },
        {
          "title": "Accessing Crew Outputs",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crews",
            "level": 1
          },
          {
            "title": "Crew Output",
            "level": 2
          },
          {
            "title": "Accessing Crew Outputs",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crews > Crew Output > Accessing Crew Outputs"
      },
      "enhanced_content": "Context: Changelog > Crews > Crew Output > Accessing Crew Outputs\n\n### Accessing Crew Outputs\n\nOnce a crew has been executed, its output can be accessed through the `output` attribute of the `Crew` object. The `CrewOutput` class provides various ways to interact with and present this output.",
      "formatted_path": "Changelog > Crews > Crew Output > Accessing Crew Outputs",
      "enhanced_text": "Context: Changelog > Crews > Crew Output > Accessing Crew Outputs\n\n Accessing Crew Outputs\n\nOnce a crew has been executed, its output can be accessed through the `output` attribute of the `Crew` object. The `CrewOutput` class provides various ways to interact with and present this output.\n\nRelated sections:\n- \n"
    },
    {
      "content": "# Save crew logs\ncrew = Crew(output_log_file = True)  # Logs will be saved as logs.txt\ncrew = Crew(output_log_file = file_name)  # Logs will be saved as file_name.txt\ncrew = Crew(output_log_file = file_name.txt)  # Logs will be saved as file_name.txt\ncrew = Crew(output_log_file = file_name.json)  # Logs will be saved as file_name.json",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crews",
          "level": 1
        },
        {
          "title": "Accessing Crew Logs",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crews",
            "level": 1
          },
          {
            "title": "Accessing Crew Logs",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crews > Accessing Crew Logs"
      },
      "enhanced_content": "Context: Changelog > Crews > Accessing Crew Logs\n\n# Save crew logs\ncrew = Crew(output_log_file = True)  # Logs will be saved as logs.txt\ncrew = Crew(output_log_file = file_name)  # Logs will be saved as file_name.txt\ncrew = Crew(output_log_file = file_name.txt)  # Logs will be saved as file_name.txt\ncrew = Crew(output_log_file = file_name.json)  # Logs will be saved as file_name.json",
      "formatted_path": "Changelog > Crews > Accessing Crew Logs",
      "enhanced_text": "Context: Changelog > Crews > Accessing Crew Logs\n\n# Save crew logs\ncrew = Crew(output_log_file = True)  # Logs will be saved as logs.txt\ncrew = Crew(output_log_file = file_name)  # Logs will be saved as file_name.txt\ncrew = Crew(output_log_file = file_name.txt)  # Logs will be saved as file_name.txt\ncrew = Crew(output_log_file = file_name.json)  # Logs will be saved as file_name.json"
    },
    {
      "content": "Crews can utilize memory (short-term, long-term, and entity memory) to enhance their execution and learning over time. This feature allows crews to store and recall execution memories, aiding in decision-making and task execution strategies.",
      "title": "Memory Utilization",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crews",
          "level": 1
        },
        {
          "title": "Memory Utilization",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crews",
            "level": 1
          },
          {
            "title": "Memory Utilization",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crews > Memory Utilization"
      },
      "enhanced_content": "Context: Changelog > Crews > Memory Utilization\n\n## Memory Utilization\n\nCrews can utilize memory (short-term, long-term, and entity memory) to enhance their execution and learning over time. This feature allows crews to store and recall execution memories, aiding in decision-making and task execution strategies.",
      "formatted_path": "Changelog > Crews > Memory Utilization",
      "enhanced_text": "Context: Changelog > Crews > Memory Utilization\n\n Memory Utilization\n\nCrews can utilize memory (short-term, long-term, and entity memory) to enhance their execution and learning over time. This feature allows crews to store and recall execution memories, aiding in decision-making and task execution strategies.\n\nRelated sections:\n- \n"
    },
    {
      "content": "Caches can be employed to store the results of tools' execution, making the process more efficient by reducing the need to re-execute identical tasks.",
      "title": "Cache Utilization",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crews",
          "level": 1
        },
        {
          "title": "Cache Utilization",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crews",
            "level": 1
          },
          {
            "title": "Cache Utilization",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crews > Cache Utilization"
      },
      "enhanced_content": "Context: Changelog > Crews > Cache Utilization\n\n## Cache Utilization\n\nCaches can be employed to store the results of tools' execution, making the process more efficient by reducing the need to re-execute identical tasks.",
      "formatted_path": "Changelog > Crews > Cache Utilization",
      "enhanced_text": "Context: Changelog > Crews > Cache Utilization\n\n Cache Utilization\n\nCaches can be employed to store the results of tools' execution, making the process more efficient by reducing the need to re-execute identical tasks."
    },
    {
      "content": "# Access the crew's usage metrics\ncrew = Crew(agents=[agent1, agent2], tasks=[task1, task2])\ncrew.kickoff()\nprint(crew.usage_metrics)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crews",
          "level": 1
        },
        {
          "title": "Crew Usage Metrics",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crews",
            "level": 1
          },
          {
            "title": "Crew Usage Metrics",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crews > Crew Usage Metrics"
      },
      "enhanced_content": "Context: Changelog > Crews > Crew Usage Metrics\n\n# Access the crew's usage metrics\ncrew = Crew(agents=[agent1, agent2], tasks=[task1, task2])\ncrew.kickoff()\nprint(crew.usage_metrics)",
      "formatted_path": "Changelog > Crews > Crew Usage Metrics",
      "enhanced_text": "Context: Changelog > Crews > Crew Usage Metrics\n\n# Access the crew's usage metrics\ncrew = Crew(agents=[agent1, agent2], tasks=[task1, task2])\ncrew.kickoff()\nprint(crew.usage_metrics)"
    },
    {
      "content": "**Sequential Process**: Tasks are executed one after another, allowing for a linear flow of work. **Hierarchical Process**: A manager agent coordinates the crew, delegating tasks and validating outcomes before proceeding. **Note**: A `manager_llm` or `manager_agent` is required for this process and it's essential for validating the process flow.",
      "title": "Crew Execution Process",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crews",
          "level": 1
        },
        {
          "title": "Crew Execution Process",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crews",
            "level": 1
          },
          {
            "title": "Crew Execution Process",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crews > Crew Execution Process"
      },
      "enhanced_content": "Context: Changelog > Crews > Crew Execution Process\n\n## Crew Execution Process\n\n**Sequential Process**: Tasks are executed one after another, allowing for a linear flow of work. **Hierarchical Process**: A manager agent coordinates the crew, delegating tasks and validating outcomes before proceeding. **Note**: A `manager_llm` or `manager_agent` is required for this process and it's essential for validating the process flow.",
      "formatted_path": "Changelog > Crews > Crew Execution Process",
      "enhanced_text": "Context: Changelog > Crews > Crew Execution Process\n\n Crew Execution Process\n\n**Sequential Process**: Tasks are executed one after another, allowing for a linear flow of work. **Hierarchical Process**: A manager agent coordinates the crew, delegating tasks and validating outcomes before proceeding. **Note**: A `manager_llm` or `manager_agent` is required for this process and it's essential for validating the process flow."
    },
    {
      "content": "# Start the crew's task execution\nresult = my_crew.kickoff()\nprint(result)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crews",
          "level": 1
        },
        {
          "title": "Crew Execution Process",
          "level": 2
        },
        {
          "title": "Kicking Off a Crew",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crews",
            "level": 1
          },
          {
            "title": "Crew Execution Process",
            "level": 2
          },
          {
            "title": "Kicking Off a Crew",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crews > Crew Execution Process > Kicking Off a Crew"
      },
      "enhanced_content": "Context: Changelog > Crews > Crew Execution Process > Kicking Off a Crew\n\n# Start the crew's task execution\nresult = my_crew.kickoff()\nprint(result)",
      "formatted_path": "Changelog > Crews > Crew Execution Process > Kicking Off a Crew",
      "enhanced_text": "Context: Changelog > Crews > Crew Execution Process > Kicking Off a Crew\n\n# Start the crew's task execution\nresult = my_crew.kickoff()\nprint(result)"
    },
    {
      "content": "# Start the crew's task execution\nresult = my_crew.kickoff()\nprint(result)\n\n# Example of using kickoff_for_each\ninputs_array = [{'topic': 'AI in healthcare'}, {'topic': 'AI in finance'}]\nresults = my_crew.kickoff_for_each(inputs=inputs_array)\nfor result in results:\n    print(result)\n\n# Example of using kickoff_async\ninputs = {'topic': 'AI in healthcare'}\nasync_result = my_crew.kickoff_async(inputs=inputs)\nprint(async_result)\n\n# Example of using kickoff_for_each_async\ninputs_array = [{'topic': 'AI in healthcare'}, {'topic': 'AI in finance'}]\nasync_results = my_crew.kickoff_for_each_async(inputs=inputs_array)\nfor async_result in async_results:\n    print(async_result)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crews",
          "level": 1
        },
        {
          "title": "Crew Execution Process",
          "level": 2
        },
        {
          "title": "Different Ways to Kick Off a Crew",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crews",
            "level": 1
          },
          {
            "title": "Crew Execution Process",
            "level": 2
          },
          {
            "title": "Different Ways to Kick Off a Crew",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crews > Crew Execution Process > Different Ways to Kick Off a Crew"
      },
      "enhanced_content": "Context: Changelog > Crews > Crew Execution Process > Different Ways to Kick Off a Crew\n\n# Start the crew's task execution\nresult = my_crew.kickoff()\nprint(result)\n\n# Example of using kickoff_for_each\ninputs_array = [{'topic': 'AI in healthcare'}, {'topic': 'AI in finance'}]\nresults = my_crew.kickoff_for_each(inputs=inputs_array)\nfor result in results:\n    print(result)\n\n# Example of using kickoff_async\ninputs = {'topic': 'AI in healthcare'}\nasync_result = my_crew.kickoff_async(inputs=inputs)\nprint(async_result)\n\n# Example of using kickoff_for_each_async\ninputs_array = [{'topic': 'AI in healthcare'}, {'topic': 'AI in finance'}]\nasync_results = my_crew.kickoff_for_each_async(inputs=inputs_array)\nfor async_result in async_results:\n    print(async_result)",
      "formatted_path": "Changelog > Crews > Crew Execution Process > Different Ways to Kick Off a Crew",
      "enhanced_text": "Context: Changelog > Crews > Crew Execution Process > Different Ways to Kick Off a Crew\n\n# Start the crew's task execution\nresult = my_crew.kickoff()\nprint(result)\n\n# Example of using kickoff_for_each\ninputs_array = [{'topic': 'AI in healthcare'}, {'topic': 'AI in finance'}]\nresults = my_crew.kickoff_for_each(inputs=inputs_array)\nfor result in results:\n    print(result)\n\n# Example of using kickoff_async\ninputs = {'topic': 'AI in healthcare'}\nasync_result = my_crew.kickoff_async(inputs=inputs)\nprint(async_result)\n\n# Example of using kickoff_for_each_async\ninputs_array = [{'topic': 'AI in healthcare'}, {'topic': 'AI in finance'}]\nasync_results = my_crew.kickoff_for_each_async(inputs=inputs_array)\nfor async_result in async_results:\n    print(async_result)"
    },
    {
      "content": "You can now replay from a specific task using our CLI command `replay`. The replay feature in CrewAI allows you to replay from a specific task using the command-line interface (CLI). By running the command `crewai replay -t <task_id>`, you can specify the `task_id` for the replay process. Kickoffs will now save the latest kickoffs returned task outputs locally for you to be able to replay from.",
      "title": "Replaying from a Specific Task",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crews",
          "level": 1
        },
        {
          "title": "Crew Execution Process",
          "level": 2
        },
        {
          "title": "Replaying from a Specific Task",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crews",
            "level": 1
          },
          {
            "title": "Crew Execution Process",
            "level": 2
          },
          {
            "title": "Replaying from a Specific Task",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crews > Crew Execution Process > Replaying from a Specific Task"
      },
      "enhanced_content": "Context: Changelog > Crews > Crew Execution Process > Replaying from a Specific Task\n\n### Replaying from a Specific Task\n\nYou can now replay from a specific task using our CLI command `replay`. The replay feature in CrewAI allows you to replay from a specific task using the command-line interface (CLI). By running the command `crewai replay -t <task_id>`, you can specify the `task_id` for the replay process. Kickoffs will now save the latest kickoffs returned task outputs locally for you to be able to replay from.",
      "formatted_path": "Changelog > Crews > Crew Execution Process > Replaying from a Specific Task",
      "enhanced_text": "Context: Changelog > Crews > Crew Execution Process > Replaying from a Specific Task\n\n Replaying from a Specific Task\n\nYou can now replay from a specific task using our CLI command `replay`. The replay feature in CrewAI allows you to replay from a specific task using the command-line interface (CLI). By running the command `crewai replay -t <task_id>`, you can specify the `task_id` for the replay process. Kickoffs will now save the latest kickoffs returned task outputs locally for you to be able to replay from.\n\nRelated sections:\n- \n"
    },
    {
      "content": "crewai log-tasks-outputs",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crews",
          "level": 1
        },
        {
          "title": "Crew Execution Process",
          "level": 2
        },
        {
          "title": "Replaying from a Specific Task Using the CLI",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crews",
            "level": 1
          },
          {
            "title": "Crew Execution Process",
            "level": 2
          },
          {
            "title": "Replaying from a Specific Task Using the CLI",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crews > Crew Execution Process > Replaying from a Specific Task Using the CLI"
      },
      "enhanced_content": "Context: Changelog > Crews > Crew Execution Process > Replaying from a Specific Task Using the CLI\n\ncrewai log-tasks-outputs",
      "formatted_path": "Changelog > Crews > Crew Execution Process > Replaying from a Specific Task Using the CLI",
      "enhanced_text": "Context: Changelog > Crews > Crew Execution Process > Replaying from a Specific Task Using the CLI\n\ncrewai log-tasks-outputs"
    },
    {
      "content": "crewai replay -t <task_id>",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crews",
          "level": 1
        },
        {
          "title": "Crew Execution Process",
          "level": 2
        },
        {
          "title": "Replaying from a Specific Task Using the CLI",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crews",
            "level": 1
          },
          {
            "title": "Crew Execution Process",
            "level": 2
          },
          {
            "title": "Replaying from a Specific Task Using the CLI",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crews > Crew Execution Process > Replaying from a Specific Task Using the CLI"
      },
      "enhanced_content": "Context: Changelog > Crews > Crew Execution Process > Replaying from a Specific Task Using the CLI\n\ncrewai replay -t <task_id>",
      "formatted_path": "Changelog > Crews > Crew Execution Process > Replaying from a Specific Task Using the CLI",
      "enhanced_text": "Context: Changelog > Crews > Crew Execution Process > Replaying from a Specific Task Using the CLI\n\ncrewai replay -t <task_id>"
    },
    {
      "content": "Source: https://docs.crewai.com/concepts/event-listener Tap into CrewAI events to build custom integrations and monitoring\n\nCrewAI provides a powerful event system that allows you to listen for and react to various events that occur during the execution of your Crew. This feature enables you to build custom integrations, monitoring solutions, logging systems, or any other functionality that needs to be triggered based on CrewAI's internal events.",
      "title": "Event Listeners",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Event Listeners",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Event Listeners",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Event Listeners"
      },
      "enhanced_content": "Context: Changelog > Event Listeners\n\n# Event Listeners\n\nSource: https://docs.crewai.com/concepts/event-listener Tap into CrewAI events to build custom integrations and monitoring\n\nCrewAI provides a powerful event system that allows you to listen for and react to various events that occur during the execution of your Crew. This feature enables you to build custom integrations, monitoring solutions, logging systems, or any other functionality that needs to be triggered based on CrewAI's internal events.",
      "formatted_path": "Changelog > Event Listeners",
      "enhanced_text": "Context: Changelog > Event Listeners\n\n Event Listeners\n\nSource: https://docs.crewai.com/concepts/event-listener Tap into CrewAI events to build custom integrations and monitoring\n\nCrewAI provides a powerful event system that allows you to listen for and react to various events that occur during the execution of your Crew. This feature enables you to build custom integrations, monitoring solutions, logging systems, or any other functionality that needs to be triggered based on CrewAI's internal events."
    },
    {
      "content": "from crewai.utilities.events import (\n    CrewKickoffStartedEvent,\n    CrewKickoffCompletedEvent,\n    AgentExecutionCompletedEvent,\n)\nfrom crewai.utilities.events.base_event_listener import BaseEventListener\n\nclass MyCustomListener(BaseEventListener):\n    def __init__(self):\n        super().__init__()\n    \n    def setup_listeners(self, crewai_event_bus):\n        @crewai_event_bus.on(CrewKickoffStartedEvent)\n        def on_crew_started(source, event):\n            print(f\"Crew '{event.crew_name}' has started execution!\")\n        \n        @crewai_event_bus.on(CrewKickoffCompletedEvent)\n        def on_crew_completed(source, event):\n            print(f\"Crew '{event.crew_name}' has completed execution!\")\n            print(f\"Output: {event.output}\")\n        \n        @crewai_event_bus.on(AgentExecutionCompletedEvent)\n        def on_agent_execution_completed(source, event):\n            print(f\"Agent '{event.agent.role}' completed task\")\n            print(f\"Output: {event.output}\")",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Event Listeners",
          "level": 1
        },
        {
          "title": "Creating a Custom Event Listener",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Event Listeners",
            "level": 1
          },
          {
            "title": "Creating a Custom Event Listener",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Event Listeners > Creating a Custom Event Listener"
      },
      "enhanced_content": "Context: Changelog > Event Listeners > Creating a Custom Event Listener\n\nfrom crewai.utilities.events import (\n    CrewKickoffStartedEvent,\n    CrewKickoffCompletedEvent,\n    AgentExecutionCompletedEvent,\n)\nfrom crewai.utilities.events.base_event_listener import BaseEventListener\n\nclass MyCustomListener(BaseEventListener):\n    def __init__(self):\n        super().__init__()\n    \n    def setup_listeners(self, crewai_event_bus):\n        @crewai_event_bus.on(CrewKickoffStartedEvent)\n        def on_crew_started(source, event):\n            print(f\"Crew '{event.crew_name}' has started execution!\")\n        \n        @crewai_event_bus.on(CrewKickoffCompletedEvent)\n        def on_crew_completed(source, event):\n            print(f\"Crew '{event.crew_name}' has completed execution!\")\n            print(f\"Output: {event.output}\")\n        \n        @crewai_event_bus.on(AgentExecutionCompletedEvent)\n        def on_agent_execution_completed(source, event):\n            print(f\"Agent '{event.agent.role}' completed task\")\n            print(f\"Output: {event.output}\")",
      "formatted_path": "Changelog > Event Listeners > Creating a Custom Event Listener",
      "enhanced_text": "Context: Changelog > Event Listeners > Creating a Custom Event Listener\n\nfrom crewai.utilities.events import (\n    CrewKickoffStartedEvent,\n    CrewKickoffCompletedEvent,\n    AgentExecutionCompletedEvent,\n)\nfrom crewai.utilities.events.base_event_listener import BaseEventListener\n\nclass MyCustomListener(BaseEventListener):\n    def __init__(self):\n        super().__init__()\n    \n    def setup_listeners(self, crewai_event_bus):\n        @crewai_event_bus.on(CrewKickoffStartedEvent)\n        def on_crew_started(source, event):\n            print(f\"Crew '{event.crew_name}' has started execution!\")\n        \n        @crewai_event_bus.on(CrewKickoffCompletedEvent)\n        def on_crew_completed(source, event):\n            print(f\"Crew '{event.crew_name}' has completed execution!\")\n            print(f\"Output: {event.output}\")\n        \n        @crewai_event_bus.on(AgentExecutionCompletedEvent)\n        def on_agent_execution_completed(source, event):\n            print(f\"Agent '{event.agent.role}' completed task\")\n            print(f\"Output: {event.output}\")"
    },
    {
      "content": "Simply defining your listener class isn't enough. You need to create an instance of it and ensure it's imported in your application. This ensures that: The event handlers are registered with the event bus The listener instance remains in memory (not garbage collected) The listener is active when events are emitted",
      "title": "Properly Registering Your Listener",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Event Listeners",
          "level": 1
        },
        {
          "title": "Properly Registering Your Listener",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Event Listeners",
            "level": 1
          },
          {
            "title": "Properly Registering Your Listener",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Event Listeners > Properly Registering Your Listener"
      },
      "enhanced_content": "Context: Changelog > Event Listeners > Properly Registering Your Listener\n\n## Properly Registering Your Listener\n\nSimply defining your listener class isn't enough. You need to create an instance of it and ensure it's imported in your application. This ensures that: The event handlers are registered with the event bus The listener instance remains in memory (not garbage collected) The listener is active when events are emitted",
      "formatted_path": "Changelog > Event Listeners > Properly Registering Your Listener",
      "enhanced_text": "Context: Changelog > Event Listeners > Properly Registering Your Listener\n\n Properly Registering Your Listener\n\nSimply defining your listener class isn't enough. You need to create an instance of it and ensure it's imported in your application. This ensures that: The event handlers are registered with the event bus The listener instance remains in memory (not garbage collected) The listener is active when events are emitted"
    },
    {
      "content": "The most important thing is to create an instance of your listener in the file where your Crew or Flow is defined and executed:",
      "title": "Option 1: Import and Instantiate in Your Crew or Flow Implementation",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Event Listeners",
          "level": 1
        },
        {
          "title": "Properly Registering Your Listener",
          "level": 2
        },
        {
          "title": "Option 1: Import and Instantiate in Your Crew or Flow Implementation",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Event Listeners",
            "level": 1
          },
          {
            "title": "Properly Registering Your Listener",
            "level": 2
          },
          {
            "title": "Option 1: Import and Instantiate in Your Crew or Flow Implementation",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Event Listeners > Properly Registering Your Listener > Option 1: Import and Instantiate in Your Crew or Flow Implementation"
      },
      "enhanced_content": "Context: Changelog > Event Listeners > Properly Registering Your Listener > Option 1: Import and Instantiate in Your Crew or Flow Implementation\n\n### Option 1: Import and Instantiate in Your Crew or Flow Implementation\n\nThe most important thing is to create an instance of your listener in the file where your Crew or Flow is defined and executed:",
      "formatted_path": "Changelog > Event Listeners > Properly Registering Your Listener > Option 1: Import and Instantiate in Your Crew or Flow Implementation",
      "enhanced_text": "Context: Changelog > Event Listeners > Properly Registering Your Listener > Option 1: Import and Instantiate in Your Crew or Flow Implementation\n\n Option 1: Import and Instantiate in Your Crew or Flow Implementation\n\nThe most important thing is to create an instance of your listener in the file where your Crew or Flow is defined and executed:"
    },
    {
      "content": "# In your crew.py file\nfrom crewai import Agent, Crew, Task\nfrom my_listeners import MyCustomListener\n\n# Create an instance of your listener\nmy_listener = MyCustomListener()\n\nclass MyCustomCrew:\n    # Your crew implementation...\n    \n    def crew(self):\n        return Crew(\n            agents=[...],\n            tasks=[...],\n            # ...\n        )",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Event Listeners",
          "level": 1
        },
        {
          "title": "Properly Registering Your Listener",
          "level": 2
        },
        {
          "title": "Option 1: Import and Instantiate in Your Crew or Flow Implementation",
          "level": 3
        },
        {
          "title": "For Crew-based Applications",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Event Listeners",
            "level": 1
          },
          {
            "title": "Properly Registering Your Listener",
            "level": 2
          },
          {
            "title": "Option 1: Import and Instantiate in Your Crew or Flow Implementation",
            "level": 3
          },
          {
            "title": "For Crew-based Applications",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Event Listeners > Properly Registering Your Listener > Option 1: Import and Instantiate in Your Crew or Flow Implementation > For Crew-based Applications"
      },
      "enhanced_content": "Context: Changelog > Event Listeners > Properly Registering Your Listener > Option 1: Import and Instantiate in Your Crew or Flow Implementation > For Crew-based Applications\n\n# In your crew.py file\nfrom crewai import Agent, Crew, Task\nfrom my_listeners import MyCustomListener\n\n# Create an instance of your listener\nmy_listener = MyCustomListener()\n\nclass MyCustomCrew:\n    # Your crew implementation...\n    \n    def crew(self):\n        return Crew(\n            agents=[...],\n            tasks=[...],\n            # ...\n        )",
      "formatted_path": "Changelog > Event Listeners > Properly Registering Your Listener > Option 1: Import and Instantiate in Your Crew or Flow Implementation > For Crew-based Applications",
      "enhanced_text": "Context: Changelog > Event Listeners > Properly Registering Your Listener > Option 1: Import and Instantiate in Your Crew or Flow Implementation > For Crew-based Applications\n\n# In your crew.py file\nfrom crewai import Agent, Crew, Task\nfrom my_listeners import MyCustomListener\n\n# Create an instance of your listener\nmy_listener = MyCustomListener()\n\nclass MyCustomCrew:\n    # Your crew implementation...\n    \n    def crew(self):\n        return Crew(\n            agents=[...],\n            tasks=[...],\n            # ...\n        )"
    },
    {
      "content": "# In your main.py or flow.py file\nfrom crewai.flow import Flow, listen, start\nfrom my_listeners import MyCustomListener\n\n# Create an instance of your listener\nmy_listener = MyCustomListener()\n\nclass MyCustomFlow(Flow):\n    # Your flow implementation...\n    \n    @start()\n    def first_step(self):\n        # ...",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Event Listeners",
          "level": 1
        },
        {
          "title": "Properly Registering Your Listener",
          "level": 2
        },
        {
          "title": "Option 1: Import and Instantiate in Your Crew or Flow Implementation",
          "level": 3
        },
        {
          "title": "For Flow-based Applications",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Event Listeners",
            "level": 1
          },
          {
            "title": "Properly Registering Your Listener",
            "level": 2
          },
          {
            "title": "Option 1: Import and Instantiate in Your Crew or Flow Implementation",
            "level": 3
          },
          {
            "title": "For Flow-based Applications",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Event Listeners > Properly Registering Your Listener > Option 1: Import and Instantiate in Your Crew or Flow Implementation > For Flow-based Applications"
      },
      "enhanced_content": "Context: Changelog > Event Listeners > Properly Registering Your Listener > Option 1: Import and Instantiate in Your Crew or Flow Implementation > For Flow-based Applications\n\n# In your main.py or flow.py file\nfrom crewai.flow import Flow, listen, start\nfrom my_listeners import MyCustomListener\n\n# Create an instance of your listener\nmy_listener = MyCustomListener()\n\nclass MyCustomFlow(Flow):\n    # Your flow implementation...\n    \n    @start()\n    def first_step(self):\n        # ...",
      "formatted_path": "Changelog > Event Listeners > Properly Registering Your Listener > Option 1: Import and Instantiate in Your Crew or Flow Implementation > For Flow-based Applications",
      "enhanced_text": "Context: Changelog > Event Listeners > Properly Registering Your Listener > Option 1: Import and Instantiate in Your Crew or Flow Implementation > For Flow-based Applications\n\n# In your main.py or flow.py file\nfrom crewai.flow import Flow, listen, start\nfrom my_listeners import MyCustomListener\n\n# Create an instance of your listener\nmy_listener = MyCustomListener()\n\nclass MyCustomFlow(Flow):\n    # Your flow implementation...\n    \n    @start()\n    def first_step(self):\n        # ..."
    },
    {
      "content": "my_project/\n  \u251c\u2500\u2500 listeners/\n  \u2502   \u251c\u2500\u2500 __init__.py\n  \u2502   \u251c\u2500\u2500 my_custom_listener.py\n  \u2502   \u2514\u2500\u2500 another_listener.py",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Event Listeners",
          "level": 1
        },
        {
          "title": "Properly Registering Your Listener",
          "level": 2
        },
        {
          "title": "Option 2: Create a Package for Your Listeners",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Event Listeners",
            "level": 1
          },
          {
            "title": "Properly Registering Your Listener",
            "level": 2
          },
          {
            "title": "Option 2: Create a Package for Your Listeners",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Event Listeners > Properly Registering Your Listener > Option 2: Create a Package for Your Listeners"
      },
      "enhanced_content": "Context: Changelog > Event Listeners > Properly Registering Your Listener > Option 2: Create a Package for Your Listeners\n\nmy_project/\n  \u251c\u2500\u2500 listeners/\n  \u2502   \u251c\u2500\u2500 __init__.py\n  \u2502   \u251c\u2500\u2500 my_custom_listener.py\n  \u2502   \u2514\u2500\u2500 another_listener.py",
      "formatted_path": "Changelog > Event Listeners > Properly Registering Your Listener > Option 2: Create a Package for Your Listeners",
      "enhanced_text": "Context: Changelog > Event Listeners > Properly Registering Your Listener > Option 2: Create a Package for Your Listeners\n\nmy_project/\n  \u251c\u2500\u2500 listeners/\n  \u2502   \u251c\u2500\u2500 __init__.py\n  \u2502   \u251c\u2500\u2500 my_custom_listener.py\n  \u2502   \u2514\u2500\u2500 another_listener.py"
    },
    {
      "content": "# my_custom_listener.py\nfrom crewai.utilities.events.base_event_listener import BaseEventListener\n# ... import events ...\n\nclass MyCustomListener(BaseEventListener):\n    # ... implementation ...\n\n# Create an instance of your listener\nmy_custom_listener = MyCustomListener()",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Event Listeners",
          "level": 1
        },
        {
          "title": "Properly Registering Your Listener",
          "level": 2
        },
        {
          "title": "Option 2: Create a Package for Your Listeners",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Event Listeners",
            "level": 1
          },
          {
            "title": "Properly Registering Your Listener",
            "level": 2
          },
          {
            "title": "Option 2: Create a Package for Your Listeners",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Event Listeners > Properly Registering Your Listener > Option 2: Create a Package for Your Listeners"
      },
      "enhanced_content": "Context: Changelog > Event Listeners > Properly Registering Your Listener > Option 2: Create a Package for Your Listeners\n\n# my_custom_listener.py\nfrom crewai.utilities.events.base_event_listener import BaseEventListener\n# ... import events ...\n\nclass MyCustomListener(BaseEventListener):\n    # ... implementation ...\n\n# Create an instance of your listener\nmy_custom_listener = MyCustomListener()",
      "formatted_path": "Changelog > Event Listeners > Properly Registering Your Listener > Option 2: Create a Package for Your Listeners",
      "enhanced_text": "Context: Changelog > Event Listeners > Properly Registering Your Listener > Option 2: Create a Package for Your Listeners\n\n# my_custom_listener.py\nfrom crewai.utilities.events.base_event_listener import BaseEventListener\n# ... import events ...\n\nclass MyCustomListener(BaseEventListener):\n    # ... implementation ...\n\n# Create an instance of your listener\nmy_custom_listener = MyCustomListener()"
    },
    {
      "content": "# __init__.py\nfrom .my_custom_listener import my_custom_listener\nfrom .another_listener import another_listener\n\n# Optionally export them if you need to access them elsewhere\n__all__ = ['my_custom_listener', 'another_listener']",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Event Listeners",
          "level": 1
        },
        {
          "title": "Properly Registering Your Listener",
          "level": 2
        },
        {
          "title": "Option 2: Create a Package for Your Listeners",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Event Listeners",
            "level": 1
          },
          {
            "title": "Properly Registering Your Listener",
            "level": 2
          },
          {
            "title": "Option 2: Create a Package for Your Listeners",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Event Listeners > Properly Registering Your Listener > Option 2: Create a Package for Your Listeners"
      },
      "enhanced_content": "Context: Changelog > Event Listeners > Properly Registering Your Listener > Option 2: Create a Package for Your Listeners\n\n# __init__.py\nfrom .my_custom_listener import my_custom_listener\nfrom .another_listener import another_listener\n\n# Optionally export them if you need to access them elsewhere\n__all__ = ['my_custom_listener', 'another_listener']",
      "formatted_path": "Changelog > Event Listeners > Properly Registering Your Listener > Option 2: Create a Package for Your Listeners",
      "enhanced_text": "Context: Changelog > Event Listeners > Properly Registering Your Listener > Option 2: Create a Package for Your Listeners\n\n# __init__.py\nfrom .my_custom_listener import my_custom_listener\nfrom .another_listener import another_listener\n\n# Optionally export them if you need to access them elsewhere\n__all__ = ['my_custom_listener', 'another_listener']"
    },
    {
      "content": "# In your crew.py or flow.py file\nimport my_project.listeners  # This loads all your listeners\n\nclass MyCustomCrew:\n    # Your crew implementation...",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Event Listeners",
          "level": 1
        },
        {
          "title": "Properly Registering Your Listener",
          "level": 2
        },
        {
          "title": "Option 2: Create a Package for Your Listeners",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Event Listeners",
            "level": 1
          },
          {
            "title": "Properly Registering Your Listener",
            "level": 2
          },
          {
            "title": "Option 2: Create a Package for Your Listeners",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Event Listeners > Properly Registering Your Listener > Option 2: Create a Package for Your Listeners"
      },
      "enhanced_content": "Context: Changelog > Event Listeners > Properly Registering Your Listener > Option 2: Create a Package for Your Listeners\n\n# In your crew.py or flow.py file\nimport my_project.listeners  # This loads all your listeners\n\nclass MyCustomCrew:\n    # Your crew implementation...",
      "formatted_path": "Changelog > Event Listeners > Properly Registering Your Listener > Option 2: Create a Package for Your Listeners",
      "enhanced_text": "Context: Changelog > Event Listeners > Properly Registering Your Listener > Option 2: Create a Package for Your Listeners\n\n# In your crew.py or flow.py file\nimport my_project.listeners  # This loads all your listeners\n\nclass MyCustomCrew:\n    # Your crew implementation..."
    },
    {
      "content": "# src/crewai/utilities/events/third_party/__init__.py\nfrom .agentops_listener import agentops_listener",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Event Listeners",
          "level": 1
        },
        {
          "title": "Properly Registering Your Listener",
          "level": 2
        },
        {
          "title": "Option 2: Create a Package for Your Listeners",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Event Listeners",
            "level": 1
          },
          {
            "title": "Properly Registering Your Listener",
            "level": 2
          },
          {
            "title": "Option 2: Create a Package for Your Listeners",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Event Listeners > Properly Registering Your Listener > Option 2: Create a Package for Your Listeners"
      },
      "enhanced_content": "Context: Changelog > Event Listeners > Properly Registering Your Listener > Option 2: Create a Package for Your Listeners\n\n# src/crewai/utilities/events/third_party/__init__.py\nfrom .agentops_listener import agentops_listener",
      "formatted_path": "Changelog > Event Listeners > Properly Registering Your Listener > Option 2: Create a Package for Your Listeners",
      "enhanced_text": "Context: Changelog > Event Listeners > Properly Registering Your Listener > Option 2: Create a Package for Your Listeners\n\n# src/crewai/utilities/events/third_party/__init__.py\nfrom .agentops_listener import agentops_listener"
    },
    {
      "content": "CrewAI provides a wide range of events that you can listen for:",
      "title": "Available Event Types",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Event Listeners",
          "level": 1
        },
        {
          "title": "Available Event Types",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Event Listeners",
            "level": 1
          },
          {
            "title": "Available Event Types",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Event Listeners > Available Event Types"
      },
      "enhanced_content": "Context: Changelog > Event Listeners > Available Event Types\n\n## Available Event Types\n\nCrewAI provides a wide range of events that you can listen for:",
      "formatted_path": "Changelog > Event Listeners > Available Event Types",
      "enhanced_text": "Context: Changelog > Event Listeners > Available Event Types\n\n Available Event Types\n\nCrewAI provides a wide range of events that you can listen for:"
    },
    {
      "content": "**CrewKickoffStartedEvent**: Emitted when a Crew starts execution **CrewKickoffCompletedEvent**: Emitted when a Crew completes execution **CrewKickoffFailedEvent**: Emitted when a Crew fails to complete execution **CrewTestStartedEvent**: Emitted when a Crew starts testing **CrewTestCompletedEvent**: Emitted when a Crew completes testing **CrewTestFailedEvent**: Emitted when a Crew fails to complete testing **CrewTrainStartedEvent**: Emitted when a Crew starts training **CrewTrainCompletedEvent**: Emitted when a Crew completes training **CrewTrainFailedEvent**: Emitted when a Crew fails to complete training",
      "title": "Crew Events",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Event Listeners",
          "level": 1
        },
        {
          "title": "Available Event Types",
          "level": 2
        },
        {
          "title": "Crew Events",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Event Listeners",
            "level": 1
          },
          {
            "title": "Available Event Types",
            "level": 2
          },
          {
            "title": "Crew Events",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Event Listeners > Available Event Types > Crew Events"
      },
      "enhanced_content": "Context: Changelog > Event Listeners > Available Event Types > Crew Events\n\n### Crew Events\n\n**CrewKickoffStartedEvent**: Emitted when a Crew starts execution **CrewKickoffCompletedEvent**: Emitted when a Crew completes execution **CrewKickoffFailedEvent**: Emitted when a Crew fails to complete execution **CrewTestStartedEvent**: Emitted when a Crew starts testing **CrewTestCompletedEvent**: Emitted when a Crew completes testing **CrewTestFailedEvent**: Emitted when a Crew fails to complete testing **CrewTrainStartedEvent**: Emitted when a Crew starts training **CrewTrainCompletedEvent**: Emitted when a Crew completes training **CrewTrainFailedEvent**: Emitted when a Crew fails to complete training",
      "formatted_path": "Changelog > Event Listeners > Available Event Types > Crew Events",
      "enhanced_text": "Context: Changelog > Event Listeners > Available Event Types > Crew Events\n\n Crew Events\n\n**CrewKickoffStartedEvent**: Emitted when a Crew starts execution **CrewKickoffCompletedEvent**: Emitted when a Crew completes execution **CrewKickoffFailedEvent**: Emitted when a Crew fails to complete execution **CrewTestStartedEvent**: Emitted when a Crew starts testing **CrewTestCompletedEvent**: Emitted when a Crew completes testing **CrewTestFailedEvent**: Emitted when a Crew fails to complete testing **CrewTrainStartedEvent**: Emitted when a Crew starts training **CrewTrainCompletedEvent**: Emitted when a Crew completes training **CrewTrainFailedEvent**: Emitted when a Crew fails to complete training"
    },
    {
      "content": "**AgentExecutionStartedEvent**: Emitted when an Agent starts executing a task **AgentExecutionCompletedEvent**: Emitted when an Agent completes executing a task **AgentExecutionErrorEvent**: Emitted when an Agent encounters an error during execution",
      "title": "Agent Events",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Event Listeners",
          "level": 1
        },
        {
          "title": "Available Event Types",
          "level": 2
        },
        {
          "title": "Agent Events",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Event Listeners",
            "level": 1
          },
          {
            "title": "Available Event Types",
            "level": 2
          },
          {
            "title": "Agent Events",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Event Listeners > Available Event Types > Agent Events"
      },
      "enhanced_content": "Context: Changelog > Event Listeners > Available Event Types > Agent Events\n\n### Agent Events\n\n**AgentExecutionStartedEvent**: Emitted when an Agent starts executing a task **AgentExecutionCompletedEvent**: Emitted when an Agent completes executing a task **AgentExecutionErrorEvent**: Emitted when an Agent encounters an error during execution",
      "formatted_path": "Changelog > Event Listeners > Available Event Types > Agent Events",
      "enhanced_text": "Context: Changelog > Event Listeners > Available Event Types > Agent Events\n\n Agent Events\n\n**AgentExecutionStartedEvent**: Emitted when an Agent starts executing a task **AgentExecutionCompletedEvent**: Emitted when an Agent completes executing a task **AgentExecutionErrorEvent**: Emitted when an Agent encounters an error during execution"
    },
    {
      "content": "**TaskStartedEvent**: Emitted when a Task starts execution **TaskCompletedEvent**: Emitted when a Task completes execution **TaskFailedEvent**: Emitted when a Task fails to complete execution **TaskEvaluationEvent**: Emitted when a Task is evaluated",
      "title": "Task Events",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Event Listeners",
          "level": 1
        },
        {
          "title": "Available Event Types",
          "level": 2
        },
        {
          "title": "Task Events",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Event Listeners",
            "level": 1
          },
          {
            "title": "Available Event Types",
            "level": 2
          },
          {
            "title": "Task Events",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Event Listeners > Available Event Types > Task Events"
      },
      "enhanced_content": "Context: Changelog > Event Listeners > Available Event Types > Task Events\n\n### Task Events\n\n**TaskStartedEvent**: Emitted when a Task starts execution **TaskCompletedEvent**: Emitted when a Task completes execution **TaskFailedEvent**: Emitted when a Task fails to complete execution **TaskEvaluationEvent**: Emitted when a Task is evaluated",
      "formatted_path": "Changelog > Event Listeners > Available Event Types > Task Events",
      "enhanced_text": "Context: Changelog > Event Listeners > Available Event Types > Task Events\n\n Task Events\n\n**TaskStartedEvent**: Emitted when a Task starts execution **TaskCompletedEvent**: Emitted when a Task completes execution **TaskFailedEvent**: Emitted when a Task fails to complete execution **TaskEvaluationEvent**: Emitted when a Task is evaluated"
    },
    {
      "content": "**ToolUsageStartedEvent**: Emitted when a tool execution is started **ToolUsageFinishedEvent**: Emitted when a tool execution is completed **ToolUsageErrorEvent**: Emitted when a tool execution encounters an error **ToolValidateInputErrorEvent**: Emitted when a tool input validation encounters an error **ToolExecutionErrorEvent**: Emitted when a tool execution encounters an error **ToolSelectionErrorEvent**: Emitted when there's an error selecting a tool",
      "title": "Tool Usage Events",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Event Listeners",
          "level": 1
        },
        {
          "title": "Available Event Types",
          "level": 2
        },
        {
          "title": "Tool Usage Events",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Event Listeners",
            "level": 1
          },
          {
            "title": "Available Event Types",
            "level": 2
          },
          {
            "title": "Tool Usage Events",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Event Listeners > Available Event Types > Tool Usage Events"
      },
      "enhanced_content": "Context: Changelog > Event Listeners > Available Event Types > Tool Usage Events\n\n### Tool Usage Events\n\n**ToolUsageStartedEvent**: Emitted when a tool execution is started **ToolUsageFinishedEvent**: Emitted when a tool execution is completed **ToolUsageErrorEvent**: Emitted when a tool execution encounters an error **ToolValidateInputErrorEvent**: Emitted when a tool input validation encounters an error **ToolExecutionErrorEvent**: Emitted when a tool execution encounters an error **ToolSelectionErrorEvent**: Emitted when there's an error selecting a tool",
      "formatted_path": "Changelog > Event Listeners > Available Event Types > Tool Usage Events",
      "enhanced_text": "Context: Changelog > Event Listeners > Available Event Types > Tool Usage Events\n\n Tool Usage Events\n\n**ToolUsageStartedEvent**: Emitted when a tool execution is started **ToolUsageFinishedEvent**: Emitted when a tool execution is completed **ToolUsageErrorEvent**: Emitted when a tool execution encounters an error **ToolValidateInputErrorEvent**: Emitted when a tool input validation encounters an error **ToolExecutionErrorEvent**: Emitted when a tool execution encounters an error **ToolSelectionErrorEvent**: Emitted when there's an error selecting a tool\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "**FlowCreatedEvent**: Emitted when a Flow is created **FlowStartedEvent**: Emitted when a Flow starts execution **FlowFinishedEvent**: Emitted when a Flow completes execution **FlowPlotEvent**: Emitted when a Flow is plotted **MethodExecutionStartedEvent**: Emitted when a Flow method starts execution **MethodExecutionFinishedEvent**: Emitted when a Flow method completes execution **MethodExecutionFailedEvent**: Emitted when a Flow method fails to complete execution",
      "title": "Flow Events",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Event Listeners",
          "level": 1
        },
        {
          "title": "Available Event Types",
          "level": 2
        },
        {
          "title": "Flow Events",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Event Listeners",
            "level": 1
          },
          {
            "title": "Available Event Types",
            "level": 2
          },
          {
            "title": "Flow Events",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Event Listeners > Available Event Types > Flow Events"
      },
      "enhanced_content": "Context: Changelog > Event Listeners > Available Event Types > Flow Events\n\n### Flow Events\n\n**FlowCreatedEvent**: Emitted when a Flow is created **FlowStartedEvent**: Emitted when a Flow starts execution **FlowFinishedEvent**: Emitted when a Flow completes execution **FlowPlotEvent**: Emitted when a Flow is plotted **MethodExecutionStartedEvent**: Emitted when a Flow method starts execution **MethodExecutionFinishedEvent**: Emitted when a Flow method completes execution **MethodExecutionFailedEvent**: Emitted when a Flow method fails to complete execution",
      "formatted_path": "Changelog > Event Listeners > Available Event Types > Flow Events",
      "enhanced_text": "Context: Changelog > Event Listeners > Available Event Types > Flow Events\n\n Flow Events\n\n**FlowCreatedEvent**: Emitted when a Flow is created **FlowStartedEvent**: Emitted when a Flow starts execution **FlowFinishedEvent**: Emitted when a Flow completes execution **FlowPlotEvent**: Emitted when a Flow is plotted **MethodExecutionStartedEvent**: Emitted when a Flow method starts execution **MethodExecutionFinishedEvent**: Emitted when a Flow method completes execution **MethodExecutionFailedEvent**: Emitted when a Flow method fails to complete execution"
    },
    {
      "content": "**LLMCallStartedEvent**: Emitted when an LLM call starts **LLMCallCompletedEvent**: Emitted when an LLM call completes **LLMCallFailedEvent**: Emitted when an LLM call fails **LLMStreamChunkEvent**: Emitted for each chunk received during streaming LLM responses",
      "title": "LLM Events",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Event Listeners",
          "level": 1
        },
        {
          "title": "Available Event Types",
          "level": 2
        },
        {
          "title": "LLM Events",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Event Listeners",
            "level": 1
          },
          {
            "title": "Available Event Types",
            "level": 2
          },
          {
            "title": "LLM Events",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Event Listeners > Available Event Types > LLM Events"
      },
      "enhanced_content": "Context: Changelog > Event Listeners > Available Event Types > LLM Events\n\n### LLM Events\n\n**LLMCallStartedEvent**: Emitted when an LLM call starts **LLMCallCompletedEvent**: Emitted when an LLM call completes **LLMCallFailedEvent**: Emitted when an LLM call fails **LLMStreamChunkEvent**: Emitted for each chunk received during streaming LLM responses",
      "formatted_path": "Changelog > Event Listeners > Available Event Types > LLM Events",
      "enhanced_text": "Context: Changelog > Event Listeners > Available Event Types > LLM Events\n\n LLM Events\n\n**LLMCallStartedEvent**: Emitted when an LLM call starts **LLMCallCompletedEvent**: Emitted when an LLM call completes **LLMCallFailedEvent**: Emitted when an LLM call fails **LLMStreamChunkEvent**: Emitted for each chunk received during streaming LLM responses"
    },
    {
      "content": "Each event handler receives two parameters: **source**: The object that emitted the event **event**: The event instance, containing event-specific data The structure of the event object depends on the event type, but all events inherit from `CrewEvent` and include: **timestamp**: The time when the event was emitted **type**: A string identifier for the event type Additional fields vary by event type. For example, `CrewKickoffCompletedEvent` includes `crew_name` and `output` fields.",
      "title": "Event Handler Structure",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Event Listeners",
          "level": 1
        },
        {
          "title": "Event Handler Structure",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Event Listeners",
            "level": 1
          },
          {
            "title": "Event Handler Structure",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Event Listeners > Event Handler Structure"
      },
      "enhanced_content": "Context: Changelog > Event Listeners > Event Handler Structure\n\n## Event Handler Structure\n\nEach event handler receives two parameters: **source**: The object that emitted the event **event**: The event instance, containing event-specific data The structure of the event object depends on the event type, but all events inherit from `CrewEvent` and include: **timestamp**: The time when the event was emitted **type**: A string identifier for the event type Additional fields vary by event type. For example, `CrewKickoffCompletedEvent` includes `crew_name` and `output` fields.",
      "formatted_path": "Changelog > Event Listeners > Event Handler Structure",
      "enhanced_text": "Context: Changelog > Event Listeners > Event Handler Structure\n\n Event Handler Structure\n\nEach event handler receives two parameters: **source**: The object that emitted the event **event**: The event instance, containing event-specific data The structure of the event object depends on the event type, but all events inherit from `CrewEvent` and include: **timestamp**: The time when the event was emitted **type**: A string identifier for the event type Additional fields vary by event type. For example, `CrewKickoffCompletedEvent` includes `crew_name` and `output` fields."
    },
    {
      "content": "from typing import Optional\n\nfrom crewai.utilities.events import (\n    CrewKickoffCompletedEvent,\n    ToolUsageErrorEvent,\n    ToolUsageStartedEvent,\n)\nfrom crewai.utilities.events.base_event_listener import BaseEventListener\nfrom crewai.utilities.events.crew_events import CrewKickoffStartedEvent\nfrom crewai.utilities.events.task_events import TaskEvaluationEvent\n\ntry:\n    import agentops\n    AGENTOPS_INSTALLED = True\nexcept ImportError:\n    AGENTOPS_INSTALLED = False\n\nclass AgentOpsListener(BaseEventListener):\n    tool_event: Optional[\"agentops.ToolEvent\"] = None\n    session: Optional[\"agentops.Session\"] = None\n\n    def __init__(self):\n        super().__init__()\n\n    def setup_listeners(self, crewai_event_bus):\n        if not AGENTOPS_INSTALLED:\n            return\n\n        @crewai_event_bus.on(CrewKickoffStartedEvent)\n        def on_crew_kickoff_started(source, event: CrewKickoffStartedEvent):\n            self.session = agentops.init()\n            for agent in source.agents:\n                if self.session:\n                    self.session.create_agent(\n                        name=agent.role,\n                        agent_id=str(agent.id),\n                    )\n\n        @crewai_event_bus.on(CrewKickoffCompletedEvent)\n        def on_crew_kickoff_completed(source, event: CrewKickoffCompletedEvent):\n            if self.session:\n                self.session.end_session(\n                    end_state=\"Success\",\n                    end_state_reason=\"Finished Execution\",\n                )\n\n        @crewai_event_bus.on(ToolUsageStartedEvent)\n        def on_tool_usage_started(source, event: ToolUsageStartedEvent):\n            self.tool_event = agentops.ToolEvent(name=event.tool_name)\n            if self.session:\n                self.session.record(self.tool_event)\n\n        @crewai_event_bus.on(ToolUsageErrorEvent)\n        def on_tool_usage_error(source, event: ToolUsageErrorEvent):\n            agentops.ErrorEvent(exception=event.error, trigger_event=self.tool_event)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Event Listeners",
          "level": 1
        },
        {
          "title": "Real-World Example: Integration with AgentOps",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Event Listeners",
            "level": 1
          },
          {
            "title": "Real-World Example: Integration with AgentOps",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Event Listeners > Real-World Example: Integration with AgentOps"
      },
      "enhanced_content": "Context: Changelog > Event Listeners > Real-World Example: Integration with AgentOps\n\nfrom typing import Optional\n\nfrom crewai.utilities.events import (\n    CrewKickoffCompletedEvent,\n    ToolUsageErrorEvent,\n    ToolUsageStartedEvent,\n)\nfrom crewai.utilities.events.base_event_listener import BaseEventListener\nfrom crewai.utilities.events.crew_events import CrewKickoffStartedEvent\nfrom crewai.utilities.events.task_events import TaskEvaluationEvent\n\ntry:\n    import agentops\n    AGENTOPS_INSTALLED = True\nexcept ImportError:\n    AGENTOPS_INSTALLED = False\n\nclass AgentOpsListener(BaseEventListener):\n    tool_event: Optional[\"agentops.ToolEvent\"] = None\n    session: Optional[\"agentops.Session\"] = None\n\n    def __init__(self):\n        super().__init__()\n\n    def setup_listeners(self, crewai_event_bus):\n        if not AGENTOPS_INSTALLED:\n            return\n\n        @crewai_event_bus.on(CrewKickoffStartedEvent)\n        def on_crew_kickoff_started(source, event: CrewKickoffStartedEvent):\n            self.session = agentops.init()\n            for agent in source.agents:\n                if self.session:\n                    self.session.create_agent(\n                        name=agent.role,\n                        agent_id=str(agent.id),\n                    )\n\n        @crewai_event_bus.on(CrewKickoffCompletedEvent)\n        def on_crew_kickoff_completed(source, event: CrewKickoffCompletedEvent):\n            if self.session:\n                self.session.end_session(\n                    end_state=\"Success\",\n                    end_state_reason=\"Finished Execution\",\n                )\n\n        @crewai_event_bus.on(ToolUsageStartedEvent)\n        def on_tool_usage_started(source, event: ToolUsageStartedEvent):\n            self.tool_event = agentops.ToolEvent(name=event.tool_name)\n            if self.session:\n                self.session.record(self.tool_event)\n\n        @crewai_event_bus.on(ToolUsageErrorEvent)\n        def on_tool_usage_error(source, event: ToolUsageErrorEvent):\n            agentops.ErrorEvent(exception=event.error, trigger_event=self.tool_event)",
      "formatted_path": "Changelog > Event Listeners > Real-World Example: Integration with AgentOps",
      "enhanced_text": "Context: Changelog > Event Listeners > Real-World Example: Integration with AgentOps\n\nfrom typing import Optional\n\nfrom crewai.utilities.events import (\n    CrewKickoffCompletedEvent,\n    ToolUsageErrorEvent,\n    ToolUsageStartedEvent,\n)\nfrom crewai.utilities.events.base_event_listener import BaseEventListener\nfrom crewai.utilities.events.crew_events import CrewKickoffStartedEvent\nfrom crewai.utilities.events.task_events import TaskEvaluationEvent\n\ntry:\n    import agentops\n    AGENTOPS_INSTALLED = True\nexcept ImportError:\n    AGENTOPS_INSTALLED = False\n\nclass AgentOpsListener(BaseEventListener):\n    tool_event: Optional[\"agentops.ToolEvent\"] = None\n    session: Optional[\"agentops.Session\"] = None\n\n    def __init__(self):\n        super().__init__()\n\n    def setup_listeners(self, crewai_event_bus):\n        if not AGENTOPS_INSTALLED:\n            return\n\n        @crewai_event_bus.on(CrewKickoffStartedEvent)\n        def on_crew_kickoff_started(source, event: CrewKickoffStartedEvent):\n            self.session = agentops.init()\n            for agent in source.agents:\n                if self.session:\n                    self.session.create_agent(\n                        name=agent.role,\n                        agent_id=str(agent.id),\n                    )\n\n        @crewai_event_bus.on(CrewKickoffCompletedEvent)\n        def on_crew_kickoff_completed(source, event: CrewKickoffCompletedEvent):\n            if self.session:\n                self.session.end_session(\n                    end_state=\"Success\",\n                    end_state_reason=\"Finished Execution\",\n                )\n\n        @crewai_event_bus.on(ToolUsageStartedEvent)\n        def on_tool_usage_started(source, event: ToolUsageStartedEvent):\n            self.tool_event = agentops.ToolEvent(name=event.tool_name)\n            if self.session:\n                self.session.record(self.tool_event)\n\n        @crewai_event_bus.on(ToolUsageErrorEvent)\n        def on_tool_usage_error(source, event: ToolUsageErrorEvent):\n            agentops.ErrorEvent(exception=event.error, trigger_event=self.tool_event)"
    },
    {
      "content": "from .agentops_listener import agentops_listener",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Event Listeners",
          "level": 1
        },
        {
          "title": "Real-World Example: Integration with AgentOps",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Event Listeners",
            "level": 1
          },
          {
            "title": "Real-World Example: Integration with AgentOps",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Event Listeners > Real-World Example: Integration with AgentOps"
      },
      "enhanced_content": "Context: Changelog > Event Listeners > Real-World Example: Integration with AgentOps\n\nfrom .agentops_listener import agentops_listener",
      "formatted_path": "Changelog > Event Listeners > Real-World Example: Integration with AgentOps",
      "enhanced_text": "Context: Changelog > Event Listeners > Real-World Example: Integration with AgentOps\n\nfrom .agentops_listener import agentops_listener"
    },
    {
      "content": "from crewai.utilities.events import crewai_event_bus, CrewKickoffStartedEvent\n\nwith crewai_event_bus.scoped_handlers():\n    @crewai_event_bus.on(CrewKickoffStartedEvent)\n    def temp_handler(source, event):\n        print(\"This handler only exists within this context\")\n    \n    # Do something that emits events\n    \n# Outside the context, the temporary handler is removed",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Event Listeners",
          "level": 1
        },
        {
          "title": "Advanced Usage: Scoped Handlers",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Event Listeners",
            "level": 1
          },
          {
            "title": "Advanced Usage: Scoped Handlers",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Event Listeners > Advanced Usage: Scoped Handlers"
      },
      "enhanced_content": "Context: Changelog > Event Listeners > Advanced Usage: Scoped Handlers\n\nfrom crewai.utilities.events import crewai_event_bus, CrewKickoffStartedEvent\n\nwith crewai_event_bus.scoped_handlers():\n    @crewai_event_bus.on(CrewKickoffStartedEvent)\n    def temp_handler(source, event):\n        print(\"This handler only exists within this context\")\n    \n    # Do something that emits events\n    \n# Outside the context, the temporary handler is removed",
      "formatted_path": "Changelog > Event Listeners > Advanced Usage: Scoped Handlers",
      "enhanced_text": "Context: Changelog > Event Listeners > Advanced Usage: Scoped Handlers\n\nfrom crewai.utilities.events import crewai_event_bus, CrewKickoffStartedEvent\n\nwith crewai_event_bus.scoped_handlers():\n    @crewai_event_bus.on(CrewKickoffStartedEvent)\n    def temp_handler(source, event):\n        print(\"This handler only exists within this context\")\n    \n    # Do something that emits events\n    \n# Outside the context, the temporary handler is removed"
    },
    {
      "content": "Source: https://docs.crewai.com/concepts/flows Learn how to create and manage AI workflows using CrewAI Flows.",
      "title": "Flows",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Flows",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Flows",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Flows"
      },
      "enhanced_content": "Context: Changelog > Flows\n\n# Flows\n\nSource: https://docs.crewai.com/concepts/flows Learn how to create and manage AI workflows using CrewAI Flows.",
      "formatted_path": "Changelog > Flows",
      "enhanced_text": "Context: Changelog > Flows\n\n Flows\n\nSource: https://docs.crewai.com/concepts/flows Learn how to create and manage AI workflows using CrewAI Flows.\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "The `@start()` decorator is used to mark a method as the starting point of a Flow. When a Flow is started, all the methods decorated with `@start()` are executed in parallel. You can have multiple start methods in a Flow, and they will all be executed when the Flow is started.",
      "title": "@start()",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Flows",
          "level": 1
        },
        {
          "title": "Getting Started",
          "level": 2
        },
        {
          "title": "@start()",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Flows",
            "level": 1
          },
          {
            "title": "Getting Started",
            "level": 2
          },
          {
            "title": "@start()",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Flows > Getting Started > @start()"
      },
      "enhanced_content": "Context: Changelog > Flows > Getting Started > @start()\n\n### @start()\n\nThe `@start()` decorator is used to mark a method as the starting point of a Flow. When a Flow is started, all the methods decorated with `@start()` are executed in parallel. You can have multiple start methods in a Flow, and they will all be executed when the Flow is started.",
      "formatted_path": "Changelog > Flows > Getting Started > @start()",
      "enhanced_text": "Context: Changelog > Flows > Getting Started > @start()\n\n @start()\n\nThe `@start()` decorator is used to mark a method as the starting point of a Flow. When a Flow is started, all the methods decorated with `@start()` are executed in parallel. You can have multiple start methods in a Flow, and they will all be executed when the Flow is started."
    },
    {
      "content": "The `@listen()` decorator is used to mark a method as a listener for the output of another task in the Flow. The method decorated with `@listen()` will be executed when the specified task emits an output. The method can access the output of the task it is listening to as an argument.",
      "title": "@listen()",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Flows",
          "level": 1
        },
        {
          "title": "Getting Started",
          "level": 2
        },
        {
          "title": "@listen()",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Flows",
            "level": 1
          },
          {
            "title": "Getting Started",
            "level": 2
          },
          {
            "title": "@listen()",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Flows > Getting Started > @listen()"
      },
      "enhanced_content": "Context: Changelog > Flows > Getting Started > @listen()\n\n### @listen()\n\nThe `@listen()` decorator is used to mark a method as a listener for the output of another task in the Flow. The method decorated with `@listen()` will be executed when the specified task emits an output. The method can access the output of the task it is listening to as an argument.",
      "formatted_path": "Changelog > Flows > Getting Started > @listen()",
      "enhanced_text": "Context: Changelog > Flows > Getting Started > @listen()\n\n @listen()\n\nThe `@listen()` decorator is used to mark a method as a listener for the output of another task in the Flow. The method decorated with `@listen()` will be executed when the specified task emits an output. The method can access the output of the task it is listening to as an argument."
    },
    {
      "content": "Accessing and handling the output of a Flow is essential for integrating your AI workflows into larger applications or systems. CrewAI Flows provide straightforward mechanisms to retrieve the final output, access intermediate results, and manage the overall state of your Flow.",
      "title": "Flow Output",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Flows",
          "level": 1
        },
        {
          "title": "Getting Started",
          "level": 2
        },
        {
          "title": "Flow Output",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Flows",
            "level": 1
          },
          {
            "title": "Getting Started",
            "level": 2
          },
          {
            "title": "Flow Output",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Flows > Getting Started > Flow Output"
      },
      "enhanced_content": "Context: Changelog > Flows > Getting Started > Flow Output\n\n### Flow Output\n\nAccessing and handling the output of a Flow is essential for integrating your AI workflows into larger applications or systems. CrewAI Flows provide straightforward mechanisms to retrieve the final output, access intermediate results, and manage the overall state of your Flow.",
      "formatted_path": "Changelog > Flows > Getting Started > Flow Output",
      "enhanced_text": "Context: Changelog > Flows > Getting Started > Flow Output\n\n Flow Output\n\nAccessing and handling the output of a Flow is essential for integrating your AI workflows into larger applications or systems. CrewAI Flows provide straightforward mechanisms to retrieve the final output, access intermediate results, and manage the overall state of your Flow."
    },
    {
      "content": "```text Output\n---- Final Output ----\nSecond method received: Output from first_method",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Flows",
          "level": 1
        },
        {
          "title": "Getting Started",
          "level": 2
        },
        {
          "title": "Flow Output",
          "level": 3
        },
        {
          "title": "Retrieving the Final Output",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Flows",
            "level": 1
          },
          {
            "title": "Getting Started",
            "level": 2
          },
          {
            "title": "Flow Output",
            "level": 3
          },
          {
            "title": "Retrieving the Final Output",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Flows > Getting Started > Flow Output > Retrieving the Final Output"
      },
      "enhanced_content": "Context: Changelog > Flows > Getting Started > Flow Output > Retrieving the Final Output\n\n```text Output\n---- Final Output ----\nSecond method received: Output from first_method",
      "formatted_path": "Changelog > Flows > Getting Started > Flow Output > Retrieving the Final Output",
      "enhanced_text": "Context: Changelog > Flows > Getting Started > Flow Output > Retrieving the Final Output\n\n```text Output\n---- Final Output ----\nSecond method received: Output from first_method"
    },
    {
      "content": "```text Output\nFinal Output: Hello from first_method - updated by second_method\nFinal State:\ncounter=2 message='Hello from first_method - updated by second_method'",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Flows",
          "level": 1
        },
        {
          "title": "Getting Started",
          "level": 2
        },
        {
          "title": "Flow Output",
          "level": 3
        },
        {
          "title": "Accessing and Updating State",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Flows",
            "level": 1
          },
          {
            "title": "Getting Started",
            "level": 2
          },
          {
            "title": "Flow Output",
            "level": 3
          },
          {
            "title": "Accessing and Updating State",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Flows > Getting Started > Flow Output > Accessing and Updating State"
      },
      "enhanced_content": "Context: Changelog > Flows > Getting Started > Flow Output > Accessing and Updating State\n\n```text Output\nFinal Output: Hello from first_method - updated by second_method\nFinal State:\ncounter=2 message='Hello from first_method - updated by second_method'",
      "formatted_path": "Changelog > Flows > Getting Started > Flow Output > Accessing and Updating State",
      "enhanced_text": "Context: Changelog > Flows > Getting Started > Flow Output > Accessing and Updating State\n\n```text Output\nFinal Output: Hello from first_method - updated by second_method\nFinal State:\ncounter=2 message='Hello from first_method - updated by second_method'"
    },
    {
      "content": "Managing state effectively is crucial for building reliable and maintainable AI workflows. CrewAI Flows provides robust mechanisms for both unstructured and structured state management,\nallowing developers to choose the approach that best fits their application's needs.",
      "title": "Flow State Management",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Flows",
          "level": 1
        },
        {
          "title": "Flow State Management",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Flows",
            "level": 1
          },
          {
            "title": "Flow State Management",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Flows > Flow State Management"
      },
      "enhanced_content": "Context: Changelog > Flows > Flow State Management\n\n## Flow State Management\n\nManaging state effectively is crucial for building reliable and maintainable AI workflows. CrewAI Flows provides robust mechanisms for both unstructured and structured state management,\nallowing developers to choose the approach that best fits their application's needs.",
      "formatted_path": "Changelog > Flows > Flow State Management",
      "enhanced_text": "Context: Changelog > Flows > Flow State Management\n\n Flow State Management\n\nManaging state effectively is crucial for building reliable and maintainable AI workflows. CrewAI Flows provides robust mechanisms for both unstructured and structured state management,\nallowing developers to choose the approach that best fits their application's needs.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "**Use Unstructured State Management when:** The workflow's state is simple or highly dynamic. Flexibility is prioritized over strict state definitions. Rapid prototyping is required without the overhead of defining schemas. **Use Structured State Management when:** The workflow requires a well-defined and consistent state structure. Type safety and validation are important for your application's reliability. You want to leverage IDE features like auto-completion and type checking for better developer experience. By providing both unstructured and structured state management options, CrewAI Flows empowers developers to build AI workflows that are both flexible and robust, catering to a wide range of application requirements.",
      "title": "Choosing Between Unstructured and Structured State Management",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Flows",
          "level": 1
        },
        {
          "title": "Flow State Management",
          "level": 2
        },
        {
          "title": "Choosing Between Unstructured and Structured State Management",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Flows",
            "level": 1
          },
          {
            "title": "Flow State Management",
            "level": 2
          },
          {
            "title": "Choosing Between Unstructured and Structured State Management",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Flows > Flow State Management > Choosing Between Unstructured and Structured State Management"
      },
      "enhanced_content": "Context: Changelog > Flows > Flow State Management > Choosing Between Unstructured and Structured State Management\n\n### Choosing Between Unstructured and Structured State Management\n\n**Use Unstructured State Management when:** The workflow's state is simple or highly dynamic. Flexibility is prioritized over strict state definitions. Rapid prototyping is required without the overhead of defining schemas. **Use Structured State Management when:** The workflow requires a well-defined and consistent state structure. Type safety and validation are important for your application's reliability. You want to leverage IDE features like auto-completion and type checking for better developer experience. By providing both unstructured and structured state management options, CrewAI Flows empowers developers to build AI workflows that are both flexible and robust, catering to a wide range of application requirements.",
      "formatted_path": "Changelog > Flows > Flow State Management > Choosing Between Unstructured and Structured State Management",
      "enhanced_text": "Context: Changelog > Flows > Flow State Management > Choosing Between Unstructured and Structured State Management\n\n Choosing Between Unstructured and Structured State Management\n\n**Use Unstructured State Management when:** The workflow's state is simple or highly dynamic. Flexibility is prioritized over strict state definitions. Rapid prototyping is required without the overhead of defining schemas. **Use Structured State Management when:** The workflow requires a well-defined and consistent state structure. Type safety and validation are important for your application's reliability. You want to leverage IDE features like auto-completion and type checking for better developer experience. By providing both unstructured and structured state management options, CrewAI Flows empowers developers to build AI workflows that are both flexible and robust, catering to a wide range of application requirements.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "The @persist decorator enables automatic state persistence in CrewAI Flows, allowing you to maintain flow state across restarts or different workflow executions. This decorator can be applied at either the class level or method level, providing flexibility in how you manage state persistence.",
      "title": "Flow Persistence",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Flows",
          "level": 1
        },
        {
          "title": "Flow Persistence",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Flows",
            "level": 1
          },
          {
            "title": "Flow Persistence",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Flows > Flow Persistence"
      },
      "enhanced_content": "Context: Changelog > Flows > Flow Persistence\n\n## Flow Persistence\n\nThe @persist decorator enables automatic state persistence in CrewAI Flows, allowing you to maintain flow state across restarts or different workflow executions. This decorator can be applied at either the class level or method level, providing flexibility in how you manage state persistence.",
      "formatted_path": "Changelog > Flows > Flow Persistence",
      "enhanced_text": "Context: Changelog > Flows > Flow Persistence\n\n Flow Persistence\n\nThe @persist decorator enables automatic state persistence in CrewAI Flows, allowing you to maintain flow state across restarts or different workflow executions. This decorator can be applied at either the class level or method level, providing flexibility in how you manage state persistence."
    },
    {
      "content": "**Precise Control Through Low-Level Access** Direct access to persistence operations for advanced use cases Fine-grained control via method-level persistence decorators Built-in state inspection and debugging capabilities Full visibility into state changes and persistence operations **Enhanced Reliability** Automatic state recovery after system failures or restarts Transaction-based state updates for data integrity Comprehensive error handling with clear error messages Robust validation during state save and load operations **Extensible Architecture** Customizable persistence backend through FlowPersistence interface Support for specialized storage solutions beyond SQLite Compatible with both structured (Pydantic) and unstructured (dict) states Seamless integration with existing CrewAI flow patterns The persistence system's architecture emphasizes technical precision and customization options, allowing developers to maintain full control over state management while benefiting from built-in reliability features.",
      "title": "Technical Advantages",
      "type": "descriptive_text_oversized",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Flows",
          "level": 1
        },
        {
          "title": "Flow Persistence",
          "level": 2
        },
        {
          "title": "Technical Advantages",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Flows",
            "level": 1
          },
          {
            "title": "Flow Persistence",
            "level": 2
          },
          {
            "title": "Technical Advantages",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Flows > Flow Persistence > Technical Advantages"
      },
      "enhanced_content": "Context: Changelog > Flows > Flow Persistence > Technical Advantages\n\n### Technical Advantages\n\n**Precise Control Through Low-Level Access** Direct access to persistence operations for advanced use cases Fine-grained control via method-level persistence decorators Built-in state inspection and debugging capabilities Full visibility into state changes and persistence operations **Enhanced Reliability** Automatic state recovery after system failures or restarts Transaction-based state updates for data integrity Comprehensive error handling with clear error messages Robust validation during state save and load operations **Extensible Architecture** Customizable persistence backend through FlowPersistence interface Support for specialized storage solutions beyond SQLite Compatible with both structured (Pydantic) and unstructured (dict) states Seamless integration with existing CrewAI flow patterns The persistence system's architecture emphasizes technical precision and customization options, allowing developers to maintain full control over state management while benefiting from built-in reliability features.",
      "formatted_path": "Changelog > Flows > Flow Persistence > Technical Advantages",
      "enhanced_text": "Context: Changelog > Flows > Flow Persistence > Technical Advantages\n\n Technical Advantages\n\n**Precise Control Through Low-Level Access** Direct access to persistence operations for advanced use cases Fine-grained control via method-level persistence decorators Built-in state inspection and debugging capabilities Full visibility into state changes and persistence operations **Enhanced Reliability** Automatic state recovery after system failures or restarts Transaction-based state updates for data integrity Comprehensive error handling with clear error messages Robust validation during state save and load operations **Extensible Architecture** Customizable persistence backend through FlowPersistence interface Support for specialized storage solutions beyond SQLite Compatible with both structured (Pydantic) and unstructured (dict) states Seamless integration with existing CrewAI flow patterns The persistence system's architecture emphasizes technical precision and customization options, allowing developers to maintain full control over state management while benefiting from built-in reliability features."
    },
    {
      "content": "```text Output\nLogger: Hello from the start method\nLogger: Hello from the second method",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Flows",
          "level": 1
        },
        {
          "title": "Flow Control",
          "level": 2
        },
        {
          "title": "Conditional Logic: `or`",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Flows",
            "level": 1
          },
          {
            "title": "Flow Control",
            "level": 2
          },
          {
            "title": "Conditional Logic: `or`",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Flows > Flow Control > Conditional Logic: `or`"
      },
      "enhanced_content": "Context: Changelog > Flows > Flow Control > Conditional Logic: `or`\n\n```text Output\nLogger: Hello from the start method\nLogger: Hello from the second method",
      "formatted_path": "Changelog > Flows > Flow Control > Conditional Logic: `or`",
      "enhanced_text": "Context: Changelog > Flows > Flow Control > Conditional Logic: `or`\n\n```text Output\nLogger: Hello from the start method\nLogger: Hello from the second method"
    },
    {
      "content": "```text Output\n---- Logger ----\n{'greeting': 'Hello from the start method', 'joke': 'What do computers eat? Microchips.'}",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Flows",
          "level": 1
        },
        {
          "title": "Flow Control",
          "level": 2
        },
        {
          "title": "Conditional Logic: `and`",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Flows",
            "level": 1
          },
          {
            "title": "Flow Control",
            "level": 2
          },
          {
            "title": "Conditional Logic: `and`",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Flows > Flow Control > Conditional Logic: `and`"
      },
      "enhanced_content": "Context: Changelog > Flows > Flow Control > Conditional Logic: `and`\n\n```text Output\n---- Logger ----\n{'greeting': 'Hello from the start method', 'joke': 'What do computers eat? Microchips.'}",
      "formatted_path": "Changelog > Flows > Flow Control > Conditional Logic: `and`",
      "enhanced_text": "Context: Changelog > Flows > Flow Control > Conditional Logic: `and`\n\n```text Output\n---- Logger ----\n{'greeting': 'Hello from the start method', 'joke': 'What do computers eat? Microchips.'}"
    },
    {
      "content": "```text Output\nStarting the structured flow\nThird method running\nFourth method running",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Flows",
          "level": 1
        },
        {
          "title": "Flow Control",
          "level": 2
        },
        {
          "title": "Router",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Flows",
            "level": 1
          },
          {
            "title": "Flow Control",
            "level": 2
          },
          {
            "title": "Router",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Flows > Flow Control > Router"
      },
      "enhanced_content": "Context: Changelog > Flows > Flow Control > Router\n\n```text Output\nStarting the structured flow\nThird method running\nFourth method running",
      "formatted_path": "Changelog > Flows > Flow Control > Router",
      "enhanced_text": "Context: Changelog > Flows > Flow Control > Router\n\n```text Output\nStarting the structured flow\nThird method running\nFourth method running"
    },
    {
      "content": "crewai create flow name_of_flow",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Flows",
          "level": 1
        },
        {
          "title": "Adding Crews to Flows",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Flows",
            "level": 1
          },
          {
            "title": "Adding Crews to Flows",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Flows > Adding Crews to Flows"
      },
      "enhanced_content": "Context: Changelog > Flows > Adding Crews to Flows\n\ncrewai create flow name_of_flow",
      "formatted_path": "Changelog > Flows > Adding Crews to Flows",
      "enhanced_text": "Context: Changelog > Flows > Adding Crews to Flows\n\ncrewai create flow name_of_flow"
    },
    {
      "content": "After running the `crewai create flow name_of_flow` command, you will see a folder structure similar to the following: | Directory/File         | Description                                                         |\n| :--------------------- | :------------------------------------------------------------------ |\n| `name_of_flow/`        | Root directory for the flow.                                        |\n| \u251c\u2500\u2500 `crews/`           | Contains directories for specific crews.                            |\n| \u2502 \u2514\u2500\u2500 `poem_crew/`     | Directory for the \"poem\\_crew\" with its configurations and scripts. |\n| \u2502 \u251c\u2500\u2500 `config/`        | Configuration files directory for the \"poem\\_crew\".                 |\n| \u2502 \u2502 \u251c\u2500\u2500 `agents.yaml`  | YAML file defining the agents for \"poem\\_crew\".                     |\n| \u2502 \u2502 \u2514\u2500\u2500 `tasks.yaml`   | YAML file defining the tasks for \"poem\\_crew\".                      |\n| \u2502 \u251c\u2500\u2500 `poem_crew.py`   | Script for \"poem\\_crew\" functionality.                              |\n| \u251c\u2500\u2500 `tools/`           | Directory for additional tools used in the flow.                    |\n| \u2502 \u2514\u2500\u2500 `custom_tool.py` | Custom tool implementation.                                         |\n| \u251c\u2500\u2500 `main.py`          | Main script for running the flow.                                   |\n| \u251c\u2500\u2500 `README.md`        | Project description and instructions.                               |\n| \u251c\u2500\u2500 `pyproject.toml`   | Configuration file for project dependencies and settings.           |\n| \u2514\u2500\u2500 `.gitignore`       | Specifies files and directories to ignore in version control.       |",
      "title": "Folder Structure",
      "type": "descriptive_text_oversized",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Flows",
          "level": 1
        },
        {
          "title": "Adding Crews to Flows",
          "level": 2
        },
        {
          "title": "Folder Structure",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Flows",
            "level": 1
          },
          {
            "title": "Adding Crews to Flows",
            "level": 2
          },
          {
            "title": "Folder Structure",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Flows > Adding Crews to Flows > Folder Structure"
      },
      "enhanced_content": "Context: Changelog > Flows > Adding Crews to Flows > Folder Structure\n\n### Folder Structure\n\nAfter running the `crewai create flow name_of_flow` command, you will see a folder structure similar to the following: | Directory/File         | Description                                                         |\n| :--------------------- | :------------------------------------------------------------------ |\n| `name_of_flow/`        | Root directory for the flow.                                        |\n| \u251c\u2500\u2500 `crews/`           | Contains directories for specific crews.                            |\n| \u2502 \u2514\u2500\u2500 `poem_crew/`     | Directory for the \"poem\\_crew\" with its configurations and scripts. |\n| \u2502 \u251c\u2500\u2500 `config/`        | Configuration files directory for the \"poem\\_crew\".                 |\n| \u2502 \u2502 \u251c\u2500\u2500 `agents.yaml`  | YAML file defining the agents for \"poem\\_crew\".                     |\n| \u2502 \u2502 \u2514\u2500\u2500 `tasks.yaml`   | YAML file defining the tasks for \"poem\\_crew\".                      |\n| \u2502 \u251c\u2500\u2500 `poem_crew.py`   | Script for \"poem\\_crew\" functionality.                              |\n| \u251c\u2500\u2500 `tools/`           | Directory for additional tools used in the flow.                    |\n| \u2502 \u2514\u2500\u2500 `custom_tool.py` | Custom tool implementation.                                         |\n| \u251c\u2500\u2500 `main.py`          | Main script for running the flow.                                   |\n| \u251c\u2500\u2500 `README.md`        | Project description and instructions.                               |\n| \u251c\u2500\u2500 `pyproject.toml`   | Configuration file for project dependencies and settings.           |\n| \u2514\u2500\u2500 `.gitignore`       | Specifies files and directories to ignore in version control.       |",
      "formatted_path": "Changelog > Flows > Adding Crews to Flows > Folder Structure",
      "enhanced_text": "Context: Changelog > Flows > Adding Crews to Flows > Folder Structure\n\n Folder Structure\n\nAfter running the `crewai create flow name_of_flow` command, you will see a folder structure similar to the following: | Directory/File         | Description                                                         |\n| :--------------------- | :------------------------------------------------------------------ |\n| `name_of_flow/`        | Root directory for the flow.                                        |\n| \u251c\u2500\u2500 `crews/`           | Contains directories for specific crews.                            |\n| \u2502 \u2514\u2500\u2500 `poem_crew/`     | Directory for the \"poem\\_crew\" with its configurations and scripts. |\n| \u2502 \u251c\u2500\u2500 `config/`        | Configuration files directory for the \"poem\\_crew\".                 |\n| \u2502 \u2502 \u251c\u2500\u2500 `agents.yaml`  | YAML file defining the agents for \"poem\\_crew\".                     |\n| \u2502 \u2502 \u2514\u2500\u2500 `tasks.yaml`   | YAML file defining the tasks for \"poem\\_crew\".                      |\n| \u2502 \u251c\u2500\u2500 `poem_crew.py`   | Script for \"poem\\_crew\" functionality.                              |\n| \u251c\u2500\u2500 `tools/`           | Directory for additional tools used in the flow.                    |\n| \u2502 \u2514\u2500\u2500 `custom_tool.py` | Custom tool implementation.                                         |\n| \u251c\u2500\u2500 `main.py`          | Main script for running the flow.                                   |\n| \u251c\u2500\u2500 `README.md`        | Project description and instructions.                               |\n| \u251c\u2500\u2500 `pyproject.toml`   | Configuration file for project dependencies and settings.           |\n| \u2514\u2500\u2500 `.gitignore`       | Specifies files and directories to ignore in version control.       |"
    },
    {
      "content": "In the `crews` folder, you can define multiple crews. Each crew will have its own folder containing configuration files and the crew definition file. For example, the `poem_crew` folder contains: `config/agents.yaml`: Defines the agents for the crew. `config/tasks.yaml`: Defines the tasks for the crew. `poem_crew.py`: Contains the crew definition, including agents, tasks, and the crew itself. You can copy, paste, and edit the `poem_crew` to create other crews.",
      "title": "Building Your Crews",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Flows",
          "level": 1
        },
        {
          "title": "Adding Crews to Flows",
          "level": 2
        },
        {
          "title": "Building Your Crews",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Flows",
            "level": 1
          },
          {
            "title": "Adding Crews to Flows",
            "level": 2
          },
          {
            "title": "Building Your Crews",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Flows > Adding Crews to Flows > Building Your Crews"
      },
      "enhanced_content": "Context: Changelog > Flows > Adding Crews to Flows > Building Your Crews\n\n### Building Your Crews\n\nIn the `crews` folder, you can define multiple crews. Each crew will have its own folder containing configuration files and the crew definition file. For example, the `poem_crew` folder contains: `config/agents.yaml`: Defines the agents for the crew. `config/tasks.yaml`: Defines the tasks for the crew. `poem_crew.py`: Contains the crew definition, including agents, tasks, and the crew itself. You can copy, paste, and edit the `poem_crew` to create other crews.",
      "formatted_path": "Changelog > Flows > Adding Crews to Flows > Building Your Crews",
      "enhanced_text": "Context: Changelog > Flows > Adding Crews to Flows > Building Your Crews\n\n Building Your Crews\n\nIn the `crews` folder, you can define multiple crews. Each crew will have its own folder containing configuration files and the crew definition file. For example, the `poem_crew` folder contains: `config/agents.yaml`: Defines the agents for the crew. `config/tasks.yaml`: Defines the tasks for the crew. `poem_crew.py`: Contains the crew definition, including agents, tasks, and the crew itself. You can copy, paste, and edit the `poem_crew` to create other crews.\n\nRelated sections:\n- \n"
    },
    {
      "content": "#!/usr/bin/env python\nfrom random import randint\n\nfrom pydantic import BaseModel\nfrom crewai.flow.flow import Flow, listen, start\nfrom .crews.poem_crew.poem_crew import PoemCrew\n\nclass PoemState(BaseModel):\n    sentence_count: int = 1\n    poem: str = \"\"\n\nclass PoemFlow(Flow[PoemState]):\n\n    @start()\n    def generate_sentence_count(self):\n        print(\"Generating sentence count\")\n        self.state.sentence_count = randint(1, 5)\n\n    @listen(generate_sentence_count)\n    def generate_poem(self):\n        print(\"Generating poem\")\n        result = PoemCrew().crew().kickoff(inputs={\"sentence_count\": self.state.sentence_count})\n\n        print(\"Poem generated\", result.raw)\n        self.state.poem = result.raw\n\n    @listen(generate_poem)\n    def save_poem(self):\n        print(\"Saving poem\")\n        with open(\"poem.txt\", \"w\") as f:\n            f.write(self.state.poem)\n\ndef kickoff():\n    poem_flow = PoemFlow()\n    poem_flow.kickoff()\n\n\ndef plot():\n    poem_flow = PoemFlow()\n    poem_flow.plot()\n\nif __name__ == \"__main__\":\n    kickoff()",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Flows",
          "level": 1
        },
        {
          "title": "Adding Crews to Flows",
          "level": 2
        },
        {
          "title": "Connecting Crews in `main.py`",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Flows",
            "level": 1
          },
          {
            "title": "Adding Crews to Flows",
            "level": 2
          },
          {
            "title": "Connecting Crews in `main.py`",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Flows > Adding Crews to Flows > Connecting Crews in `main.py`"
      },
      "enhanced_content": "Context: Changelog > Flows > Adding Crews to Flows > Connecting Crews in `main.py`\n\n#!/usr/bin/env python\nfrom random import randint\n\nfrom pydantic import BaseModel\nfrom crewai.flow.flow import Flow, listen, start\nfrom .crews.poem_crew.poem_crew import PoemCrew\n\nclass PoemState(BaseModel):\n    sentence_count: int = 1\n    poem: str = \"\"\n\nclass PoemFlow(Flow[PoemState]):\n\n    @start()\n    def generate_sentence_count(self):\n        print(\"Generating sentence count\")\n        self.state.sentence_count = randint(1, 5)\n\n    @listen(generate_sentence_count)\n    def generate_poem(self):\n        print(\"Generating poem\")\n        result = PoemCrew().crew().kickoff(inputs={\"sentence_count\": self.state.sentence_count})\n\n        print(\"Poem generated\", result.raw)\n        self.state.poem = result.raw\n\n    @listen(generate_poem)\n    def save_poem(self):\n        print(\"Saving poem\")\n        with open(\"poem.txt\", \"w\") as f:\n            f.write(self.state.poem)\n\ndef kickoff():\n    poem_flow = PoemFlow()\n    poem_flow.kickoff()\n\n\ndef plot():\n    poem_flow = PoemFlow()\n    poem_flow.plot()\n\nif __name__ == \"__main__\":\n    kickoff()",
      "formatted_path": "Changelog > Flows > Adding Crews to Flows > Connecting Crews in `main.py`",
      "enhanced_text": "Context: Changelog > Flows > Adding Crews to Flows > Connecting Crews in `main.py`\n\n#!/usr/bin/env python\nfrom random import randint\n\nfrom pydantic import BaseModel\nfrom crewai.flow.flow import Flow, listen, start\nfrom .crews.poem_crew.poem_crew import PoemCrew\n\nclass PoemState(BaseModel):\n    sentence_count: int = 1\n    poem: str = \"\"\n\nclass PoemFlow(Flow[PoemState]):\n\n    @start()\n    def generate_sentence_count(self):\n        print(\"Generating sentence count\")\n        self.state.sentence_count = randint(1, 5)\n\n    @listen(generate_sentence_count)\n    def generate_poem(self):\n        print(\"Generating poem\")\n        result = PoemCrew().crew().kickoff(inputs={\"sentence_count\": self.state.sentence_count})\n\n        print(\"Poem generated\", result.raw)\n        self.state.poem = result.raw\n\n    @listen(generate_poem)\n    def save_poem(self):\n        print(\"Saving poem\")\n        with open(\"poem.txt\", \"w\") as f:\n            f.write(self.state.poem)\n\ndef kickoff():\n    poem_flow = PoemFlow()\n    poem_flow.kickoff()\n\n\ndef plot():\n    poem_flow = PoemFlow()\n    poem_flow.plot()\n\nif __name__ == \"__main__\":\n    kickoff()"
    },
    {
      "content": "crewai install",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Flows",
          "level": 1
        },
        {
          "title": "Adding Crews to Flows",
          "level": 2
        },
        {
          "title": "Running the Flow",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Flows",
            "level": 1
          },
          {
            "title": "Adding Crews to Flows",
            "level": 2
          },
          {
            "title": "Running the Flow",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Flows > Adding Crews to Flows > Running the Flow"
      },
      "enhanced_content": "Context: Changelog > Flows > Adding Crews to Flows > Running the Flow\n\ncrewai install",
      "formatted_path": "Changelog > Flows > Adding Crews to Flows > Running the Flow",
      "enhanced_text": "Context: Changelog > Flows > Adding Crews to Flows > Running the Flow\n\ncrewai install"
    },
    {
      "content": "source .venv/bin/activate",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Flows",
          "level": 1
        },
        {
          "title": "Adding Crews to Flows",
          "level": 2
        },
        {
          "title": "Running the Flow",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Flows",
            "level": 1
          },
          {
            "title": "Adding Crews to Flows",
            "level": 2
          },
          {
            "title": "Running the Flow",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Flows > Adding Crews to Flows > Running the Flow"
      },
      "enhanced_content": "Context: Changelog > Flows > Adding Crews to Flows > Running the Flow\n\nsource .venv/bin/activate",
      "formatted_path": "Changelog > Flows > Adding Crews to Flows > Running the Flow",
      "enhanced_text": "Context: Changelog > Flows > Adding Crews to Flows > Running the Flow\n\nsource .venv/bin/activate"
    },
    {
      "content": "crewai flow kickoff",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Flows",
          "level": 1
        },
        {
          "title": "Adding Crews to Flows",
          "level": 2
        },
        {
          "title": "Running the Flow",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Flows",
            "level": 1
          },
          {
            "title": "Adding Crews to Flows",
            "level": 2
          },
          {
            "title": "Running the Flow",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Flows > Adding Crews to Flows > Running the Flow"
      },
      "enhanced_content": "Context: Changelog > Flows > Adding Crews to Flows > Running the Flow\n\ncrewai flow kickoff",
      "formatted_path": "Changelog > Flows > Adding Crews to Flows > Running the Flow",
      "enhanced_text": "Context: Changelog > Flows > Adding Crews to Flows > Running the Flow\n\ncrewai flow kickoff"
    },
    {
      "content": "uv run kickoff",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Flows",
          "level": 1
        },
        {
          "title": "Adding Crews to Flows",
          "level": 2
        },
        {
          "title": "Running the Flow",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Flows",
            "level": 1
          },
          {
            "title": "Adding Crews to Flows",
            "level": 2
          },
          {
            "title": "Running the Flow",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Flows > Adding Crews to Flows > Running the Flow"
      },
      "enhanced_content": "Context: Changelog > Flows > Adding Crews to Flows > Running the Flow\n\nuv run kickoff",
      "formatted_path": "Changelog > Flows > Adding Crews to Flows > Running the Flow",
      "enhanced_text": "Context: Changelog > Flows > Adding Crews to Flows > Running the Flow\n\nuv run kickoff"
    },
    {
      "content": "Visualizing your AI workflows can provide valuable insights into the structure and execution paths of your flows. CrewAI offers a powerful visualization tool that allows you to generate interactive plots of your flows, making it easier to understand and optimize your AI workflows.",
      "title": "Plot Flows",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Flows",
          "level": 1
        },
        {
          "title": "Plot Flows",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Flows",
            "level": 1
          },
          {
            "title": "Plot Flows",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Flows > Plot Flows"
      },
      "enhanced_content": "Context: Changelog > Flows > Plot Flows\n\n## Plot Flows\n\nVisualizing your AI workflows can provide valuable insights into the structure and execution paths of your flows. CrewAI offers a powerful visualization tool that allows you to generate interactive plots of your flows, making it easier to understand and optimize your AI workflows.",
      "formatted_path": "Changelog > Flows > Plot Flows",
      "enhanced_text": "Context: Changelog > Flows > Plot Flows\n\n Plot Flows\n\nVisualizing your AI workflows can provide valuable insights into the structure and execution paths of your flows. CrewAI offers a powerful visualization tool that allows you to generate interactive plots of your flows, making it easier to understand and optimize your AI workflows.\n\nRelated sections:\n- \n"
    },
    {
      "content": "Plots in CrewAI are graphical representations of your AI workflows. They display the various tasks, their connections, and the flow of data between them. This visualization helps in understanding the sequence of operations, identifying bottlenecks, and ensuring that the workflow logic aligns with your expectations.",
      "title": "What are Plots?",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Flows",
          "level": 1
        },
        {
          "title": "Plot Flows",
          "level": 2
        },
        {
          "title": "What are Plots?",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Flows",
            "level": 1
          },
          {
            "title": "Plot Flows",
            "level": 2
          },
          {
            "title": "What are Plots?",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Flows > Plot Flows > What are Plots?"
      },
      "enhanced_content": "Context: Changelog > Flows > Plot Flows > What are Plots?\n\n### What are Plots?\n\nPlots in CrewAI are graphical representations of your AI workflows. They display the various tasks, their connections, and the flow of data between them. This visualization helps in understanding the sequence of operations, identifying bottlenecks, and ensuring that the workflow logic aligns with your expectations.",
      "formatted_path": "Changelog > Flows > Plot Flows > What are Plots?",
      "enhanced_text": "Context: Changelog > Flows > Plot Flows > What are Plots?\n\n What are Plots?\n\nPlots in CrewAI are graphical representations of your AI workflows. They display the various tasks, their connections, and the flow of data between them. This visualization helps in understanding the sequence of operations, identifying bottlenecks, and ensuring that the workflow logic aligns with your expectations."
    },
    {
      "content": "CrewAI provides two convenient methods to generate plots of your flows:",
      "title": "How to Generate a Plot",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Flows",
          "level": 1
        },
        {
          "title": "Plot Flows",
          "level": 2
        },
        {
          "title": "How to Generate a Plot",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Flows",
            "level": 1
          },
          {
            "title": "Plot Flows",
            "level": 2
          },
          {
            "title": "How to Generate a Plot",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Flows > Plot Flows > How to Generate a Plot"
      },
      "enhanced_content": "Context: Changelog > Flows > Plot Flows > How to Generate a Plot\n\n### How to Generate a Plot\n\nCrewAI provides two convenient methods to generate plots of your flows:",
      "formatted_path": "Changelog > Flows > Plot Flows > How to Generate a Plot",
      "enhanced_text": "Context: Changelog > Flows > Plot Flows > How to Generate a Plot\n\n How to Generate a Plot\n\nCrewAI provides two convenient methods to generate plots of your flows:"
    },
    {
      "content": "# Assuming you have a flow instance\nflow.plot(\"my_flow_plot\")",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Flows",
          "level": 1
        },
        {
          "title": "Plot Flows",
          "level": 2
        },
        {
          "title": "How to Generate a Plot",
          "level": 3
        },
        {
          "title": "Option 1: Using the `plot()` Method",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Flows",
            "level": 1
          },
          {
            "title": "Plot Flows",
            "level": 2
          },
          {
            "title": "How to Generate a Plot",
            "level": 3
          },
          {
            "title": "Option 1: Using the `plot()` Method",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Flows > Plot Flows > How to Generate a Plot > Option 1: Using the `plot()` Method"
      },
      "enhanced_content": "Context: Changelog > Flows > Plot Flows > How to Generate a Plot > Option 1: Using the `plot()` Method\n\n# Assuming you have a flow instance\nflow.plot(\"my_flow_plot\")",
      "formatted_path": "Changelog > Flows > Plot Flows > How to Generate a Plot > Option 1: Using the `plot()` Method",
      "enhanced_text": "Context: Changelog > Flows > Plot Flows > How to Generate a Plot > Option 1: Using the `plot()` Method\n\n# Assuming you have a flow instance\nflow.plot(\"my_flow_plot\")"
    },
    {
      "content": "crewai flow plot",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Flows",
          "level": 1
        },
        {
          "title": "Plot Flows",
          "level": 2
        },
        {
          "title": "How to Generate a Plot",
          "level": 3
        },
        {
          "title": "Option 2: Using the Command Line",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Flows",
            "level": 1
          },
          {
            "title": "Plot Flows",
            "level": 2
          },
          {
            "title": "How to Generate a Plot",
            "level": 3
          },
          {
            "title": "Option 2: Using the Command Line",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Flows > Plot Flows > How to Generate a Plot > Option 2: Using the Command Line"
      },
      "enhanced_content": "Context: Changelog > Flows > Plot Flows > How to Generate a Plot > Option 2: Using the Command Line\n\ncrewai flow plot",
      "formatted_path": "Changelog > Flows > Plot Flows > How to Generate a Plot > Option 2: Using the Command Line",
      "enhanced_text": "Context: Changelog > Flows > Plot Flows > How to Generate a Plot > Option 2: Using the Command Line\n\ncrewai flow plot"
    },
    {
      "content": "The generated plot will display nodes representing the tasks in your flow, with directed edges indicating the flow of execution. The plot is interactive, allowing you to zoom in and out, and hover over nodes to see additional details. By visualizing your flows, you can gain a clearer understanding of the workflow's structure, making it easier to debug, optimize, and communicate your AI processes to others.",
      "title": "Understanding the Plot",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Flows",
          "level": 1
        },
        {
          "title": "Plot Flows",
          "level": 2
        },
        {
          "title": "Understanding the Plot",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Flows",
            "level": 1
          },
          {
            "title": "Plot Flows",
            "level": 2
          },
          {
            "title": "Understanding the Plot",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Flows > Plot Flows > Understanding the Plot"
      },
      "enhanced_content": "Context: Changelog > Flows > Plot Flows > Understanding the Plot\n\n### Understanding the Plot\n\nThe generated plot will display nodes representing the tasks in your flow, with directed edges indicating the flow of execution. The plot is interactive, allowing you to zoom in and out, and hover over nodes to see additional details. By visualizing your flows, you can gain a clearer understanding of the workflow's structure, making it easier to debug, optimize, and communicate your AI processes to others.",
      "formatted_path": "Changelog > Flows > Plot Flows > Understanding the Plot",
      "enhanced_text": "Context: Changelog > Flows > Plot Flows > Understanding the Plot\n\n Understanding the Plot\n\nThe generated plot will display nodes representing the tasks in your flow, with directed edges indicating the flow of execution. The plot is interactive, allowing you to zoom in and out, and hover over nodes to see additional details. By visualizing your flows, you can gain a clearer understanding of the workflow's structure, making it easier to debug, optimize, and communicate your AI processes to others."
    },
    {
      "content": "There are two ways to run a flow:",
      "title": "Running Flows",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Flows",
          "level": 1
        },
        {
          "title": "Running Flows",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Flows",
            "level": 1
          },
          {
            "title": "Running Flows",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Flows > Running Flows"
      },
      "enhanced_content": "Context: Changelog > Flows > Running Flows\n\n## Running Flows\n\nThere are two ways to run a flow:",
      "formatted_path": "Changelog > Flows > Running Flows",
      "enhanced_text": "Context: Changelog > Flows > Running Flows\n\n Running Flows\n\nThere are two ways to run a flow:\n\nRelated sections:\n- \n"
    },
    {
      "content": "flow = ExampleFlow()\nresult = flow.kickoff()",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Flows",
          "level": 1
        },
        {
          "title": "Running Flows",
          "level": 2
        },
        {
          "title": "Using the Flow API",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Flows",
            "level": 1
          },
          {
            "title": "Running Flows",
            "level": 2
          },
          {
            "title": "Using the Flow API",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Flows > Running Flows > Using the Flow API"
      },
      "enhanced_content": "Context: Changelog > Flows > Running Flows > Using the Flow API\n\nflow = ExampleFlow()\nresult = flow.kickoff()",
      "formatted_path": "Changelog > Flows > Running Flows > Using the Flow API",
      "enhanced_text": "Context: Changelog > Flows > Running Flows > Using the Flow API\n\nflow = ExampleFlow()\nresult = flow.kickoff()"
    },
    {
      "content": "crewai run",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Flows",
          "level": 1
        },
        {
          "title": "Running Flows",
          "level": 2
        },
        {
          "title": "Using the CLI",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Flows",
            "level": 1
          },
          {
            "title": "Running Flows",
            "level": 2
          },
          {
            "title": "Using the CLI",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Flows > Running Flows > Using the CLI"
      },
      "enhanced_content": "Context: Changelog > Flows > Running Flows > Using the CLI\n\ncrewai run",
      "formatted_path": "Changelog > Flows > Running Flows > Using the CLI",
      "enhanced_text": "Context: Changelog > Flows > Running Flows > Using the CLI\n\ncrewai run"
    },
    {
      "content": "crewai flow kickoff",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Flows",
          "level": 1
        },
        {
          "title": "Running Flows",
          "level": 2
        },
        {
          "title": "Using the CLI",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Flows",
            "level": 1
          },
          {
            "title": "Running Flows",
            "level": 2
          },
          {
            "title": "Using the CLI",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Flows > Running Flows > Using the CLI"
      },
      "enhanced_content": "Context: Changelog > Flows > Running Flows > Using the CLI\n\ncrewai flow kickoff",
      "formatted_path": "Changelog > Flows > Running Flows > Using the CLI",
      "enhanced_text": "Context: Changelog > Flows > Running Flows > Using the CLI\n\ncrewai flow kickoff"
    },
    {
      "content": "Source: https://docs.crewai.com/concepts/knowledge What is knowledge in CrewAI and how to use it.",
      "title": "Knowledge",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Knowledge",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Knowledge",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Knowledge"
      },
      "enhanced_content": "Context: Changelog > Knowledge\n\n# Knowledge\n\nSource: https://docs.crewai.com/concepts/knowledge What is knowledge in CrewAI and how to use it.",
      "formatted_path": "Changelog > Knowledge",
      "enhanced_text": "Context: Changelog > Knowledge\n\n Knowledge\n\nSource: https://docs.crewai.com/concepts/knowledge What is knowledge in CrewAI and how to use it.\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "Knowledge in CrewAI is a powerful system that allows AI agents to access and utilize external information sources during their tasks.\nThink of it as giving your agents a reference library they can consult while working. Enhance agents with domain-specific information Support decisions with real-world data Maintain context across conversations Ground responses in factual information\n</Info>",
      "title": "What is Knowledge?",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Knowledge",
          "level": 1
        },
        {
          "title": "What is Knowledge?",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Knowledge",
            "level": 1
          },
          {
            "title": "What is Knowledge?",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Knowledge > What is Knowledge?"
      },
      "enhanced_content": "Context: Changelog > Knowledge > What is Knowledge?\n\n## What is Knowledge?\n\nKnowledge in CrewAI is a powerful system that allows AI agents to access and utilize external information sources during their tasks.\nThink of it as giving your agents a reference library they can consult while working. Enhance agents with domain-specific information Support decisions with real-world data Maintain context across conversations Ground responses in factual information\n</Info>",
      "formatted_path": "Changelog > Knowledge > What is Knowledge?",
      "enhanced_text": "Context: Changelog > Knowledge > What is Knowledge?\n\n What is Knowledge?\n\nKnowledge in CrewAI is a powerful system that allows AI agents to access and utilize external information sources during their tasks.\nThink of it as giving your agents a reference library they can consult while working. Enhance agents with domain-specific information Support decisions with real-world data Maintain context across conversations Ground responses in factual information\n</Info>\n\nRelated sections:\n- \n"
    },
    {
      "content": "CrewAI supports various types of knowledge sources out of the box:",
      "title": "Supported Knowledge Sources",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Knowledge",
          "level": 1
        },
        {
          "title": "Supported Knowledge Sources",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Knowledge",
            "level": 1
          },
          {
            "title": "Supported Knowledge Sources",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Knowledge > Supported Knowledge Sources"
      },
      "enhanced_content": "Context: Changelog > Knowledge > Supported Knowledge Sources\n\n## Supported Knowledge Sources\n\nCrewAI supports various types of knowledge sources out of the box:",
      "formatted_path": "Changelog > Knowledge > Supported Knowledge Sources",
      "enhanced_text": "Context: Changelog > Knowledge > Supported Knowledge Sources\n\n Supported Knowledge Sources\n\nCrewAI supports various types of knowledge sources out of the box:\n\nRelated sections:\n- \n"
    },
    {
      "content": "| Parameter         | Type                            | Required | Description                                                                                                                                       |\n| :---------------- | :------------------------------ | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------ |\n| `sources`         | **List\\[BaseKnowledgeSource]**  | Yes      | List of knowledge sources that provide content to be stored and queried. Can include PDF, CSV, Excel, JSON, text files, or string content.        |\n| `collection_name` | **str**                         | No       | Name of the collection where the knowledge will be stored. Used to identify different sets of knowledge. Defaults to \"knowledge\" if not provided. |\n| `storage`         | **Optional\\[KnowledgeStorage]** | No       | Custom storage configuration for managing how the knowledge is stored and retrieved. If not provided, a default storage will be created.          |",
      "title": "Supported Knowledge Parameters",
      "type": "descriptive_text_oversized",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Knowledge",
          "level": 1
        },
        {
          "title": "Supported Knowledge Parameters",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Knowledge",
            "level": 1
          },
          {
            "title": "Supported Knowledge Parameters",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Knowledge > Supported Knowledge Parameters"
      },
      "enhanced_content": "Context: Changelog > Knowledge > Supported Knowledge Parameters\n\n## Supported Knowledge Parameters\n\n| Parameter         | Type                            | Required | Description                                                                                                                                       |\n| :---------------- | :------------------------------ | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------ |\n| `sources`         | **List\\[BaseKnowledgeSource]**  | Yes      | List of knowledge sources that provide content to be stored and queried. Can include PDF, CSV, Excel, JSON, text files, or string content.        |\n| `collection_name` | **str**                         | No       | Name of the collection where the knowledge will be stored. Used to identify different sets of knowledge. Defaults to \"knowledge\" if not provided. |\n| `storage`         | **Optional\\[KnowledgeStorage]** | No       | Custom storage configuration for managing how the knowledge is stored and retrieved. If not provided, a default storage will be created.          |",
      "formatted_path": "Changelog > Knowledge > Supported Knowledge Parameters",
      "enhanced_text": "Context: Changelog > Knowledge > Supported Knowledge Parameters\n\n Supported Knowledge Parameters\n\n| Parameter         | Type                            | Required | Description                                                                                                                                       |\n| :---------------- | :------------------------------ | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------ |\n| `sources`         | **List\\[BaseKnowledgeSource]**  | Yes      | List of knowledge sources that provide content to be stored and queried. Can include PDF, CSV, Excel, JSON, text files, or string content.        |\n| `collection_name` | **str**                         | No       | Name of the collection where the knowledge will be stored. Used to identify different sets of knowledge. Defaults to \"knowledge\" if not provided. |\n| `storage`         | **Optional\\[KnowledgeStorage]** | No       | Custom storage configuration for managing how the knowledge is stored and retrieved. If not provided, a default storage will be created.          |\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "from crewai import Agent, Task, Crew, Process, LLM\nfrom crewai.knowledge.source.string_knowledge_source import StringKnowledgeSource\n\n# Create a knowledge source\ncontent = \"Users name is John. He is 30 years old and lives in San Francisco.\"\nstring_source = StringKnowledgeSource(\n    content=content,\n)\n\n# Create an LLM with a temperature of 0 to ensure deterministic outputs\nllm = LLM(model=\"gpt-4o-mini\", temperature=0)\n\n# Create an agent with the knowledge store\nagent = Agent(\n    role=\"About User\",\n    goal=\"You know everything about the user.\",\n    backstory=\"\"\"You are a master at understanding people and their preferences.\"\"\",\n    verbose=True,\n    allow_delegation=False,\n    llm=llm,\n)\ntask = Task(\n    description=\"Answer the following questions about the user: {question}\",\n    expected_output=\"An answer to the question.\",\n    agent=agent,\n)\n\ncrew = Crew(\n    agents=[agent],\n    tasks=[task],\n    verbose=True,\n    process=Process.sequential,\n    knowledge_sources=[string_source], # Enable knowledge by adding the sources here. You can also add more sources to the sources list.\n)\n\nresult = crew.kickoff(inputs={\"question\": \"What city does John live in and how old is he?\"})",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Knowledge",
          "level": 1
        },
        {
          "title": "Quickstart Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Knowledge",
            "level": 1
          },
          {
            "title": "Quickstart Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Knowledge > Quickstart Example"
      },
      "enhanced_content": "Context: Changelog > Knowledge > Quickstart Example\n\nfrom crewai import Agent, Task, Crew, Process, LLM\nfrom crewai.knowledge.source.string_knowledge_source import StringKnowledgeSource\n\n# Create a knowledge source\ncontent = \"Users name is John. He is 30 years old and lives in San Francisco.\"\nstring_source = StringKnowledgeSource(\n    content=content,\n)\n\n# Create an LLM with a temperature of 0 to ensure deterministic outputs\nllm = LLM(model=\"gpt-4o-mini\", temperature=0)\n\n# Create an agent with the knowledge store\nagent = Agent(\n    role=\"About User\",\n    goal=\"You know everything about the user.\",\n    backstory=\"\"\"You are a master at understanding people and their preferences.\"\"\",\n    verbose=True,\n    allow_delegation=False,\n    llm=llm,\n)\ntask = Task(\n    description=\"Answer the following questions about the user: {question}\",\n    expected_output=\"An answer to the question.\",\n    agent=agent,\n)\n\ncrew = Crew(\n    agents=[agent],\n    tasks=[task],\n    verbose=True,\n    process=Process.sequential,\n    knowledge_sources=[string_source], # Enable knowledge by adding the sources here. You can also add more sources to the sources list.\n)\n\nresult = crew.kickoff(inputs={\"question\": \"What city does John live in and how old is he?\"})",
      "formatted_path": "Changelog > Knowledge > Quickstart Example",
      "enhanced_text": "Context: Changelog > Knowledge > Quickstart Example\n\nfrom crewai import Agent, Task, Crew, Process, LLM\nfrom crewai.knowledge.source.string_knowledge_source import StringKnowledgeSource\n\n# Create a knowledge source\ncontent = \"Users name is John. He is 30 years old and lives in San Francisco.\"\nstring_source = StringKnowledgeSource(\n    content=content,\n)\n\n# Create an LLM with a temperature of 0 to ensure deterministic outputs\nllm = LLM(model=\"gpt-4o-mini\", temperature=0)\n\n# Create an agent with the knowledge store\nagent = Agent(\n    role=\"About User\",\n    goal=\"You know everything about the user.\",\n    backstory=\"\"\"You are a master at understanding people and their preferences.\"\"\",\n    verbose=True,\n    allow_delegation=False,\n    llm=llm,\n)\ntask = Task(\n    description=\"Answer the following questions about the user: {question}\",\n    expected_output=\"An answer to the question.\",\n    agent=agent,\n)\n\ncrew = Crew(\n    agents=[agent],\n    tasks=[task],\n    verbose=True,\n    process=Process.sequential,\n    knowledge_sources=[string_source], # Enable knowledge by adding the sources here. You can also add more sources to the sources list.\n)\n\nresult = crew.kickoff(inputs={\"question\": \"What city does John live in and how old is he?\"})"
    },
    {
      "content": "from crewai import LLM, Agent, Crew, Process, Task\nfrom crewai.knowledge.source.crew_docling_source import CrewDoclingSource\n\n# Create a knowledge source\ncontent_source = CrewDoclingSource(\n    file_paths=[\n        \"https://lilianweng.github.io/posts/2024-11-28-reward-hacking\",\n        \"https://lilianweng.github.io/posts/2024-07-07-hallucination\",\n    ],\n)\n\n# Create an LLM with a temperature of 0 to ensure deterministic outputs\nllm = LLM(model=\"gpt-4o-mini\", temperature=0)\n\n# Create an agent with the knowledge store\nagent = Agent(\n    role=\"About papers\",\n    goal=\"You know everything about the papers.\",\n    backstory=\"\"\"You are a master at understanding papers and their content.\"\"\",\n    verbose=True,\n    allow_delegation=False,\n    llm=llm,\n)\ntask = Task(\n    description=\"Answer the following questions about the papers: {question}\",\n    expected_output=\"An answer to the question.\",\n    agent=agent,\n)\n\ncrew = Crew(\n    agents=[agent],\n    tasks=[task],\n    verbose=True,\n    process=Process.sequential,\n    knowledge_sources=[\n        content_source\n    ],  # Enable knowledge by adding the sources here. You can also add more sources to the sources list.\n)\n\nresult = crew.kickoff(\n    inputs={\n        \"question\": \"What is the reward hacking paper about? Be sure to provide sources.\"\n    }\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Knowledge",
          "level": 1
        },
        {
          "title": "Quickstart Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Knowledge",
            "level": 1
          },
          {
            "title": "Quickstart Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Knowledge > Quickstart Example"
      },
      "enhanced_content": "Context: Changelog > Knowledge > Quickstart Example\n\nfrom crewai import LLM, Agent, Crew, Process, Task\nfrom crewai.knowledge.source.crew_docling_source import CrewDoclingSource\n\n# Create a knowledge source\ncontent_source = CrewDoclingSource(\n    file_paths=[\n        \"https://lilianweng.github.io/posts/2024-11-28-reward-hacking\",\n        \"https://lilianweng.github.io/posts/2024-07-07-hallucination\",\n    ],\n)\n\n# Create an LLM with a temperature of 0 to ensure deterministic outputs\nllm = LLM(model=\"gpt-4o-mini\", temperature=0)\n\n# Create an agent with the knowledge store\nagent = Agent(\n    role=\"About papers\",\n    goal=\"You know everything about the papers.\",\n    backstory=\"\"\"You are a master at understanding papers and their content.\"\"\",\n    verbose=True,\n    allow_delegation=False,\n    llm=llm,\n)\ntask = Task(\n    description=\"Answer the following questions about the papers: {question}\",\n    expected_output=\"An answer to the question.\",\n    agent=agent,\n)\n\ncrew = Crew(\n    agents=[agent],\n    tasks=[task],\n    verbose=True,\n    process=Process.sequential,\n    knowledge_sources=[\n        content_source\n    ],  # Enable knowledge by adding the sources here. You can also add more sources to the sources list.\n)\n\nresult = crew.kickoff(\n    inputs={\n        \"question\": \"What is the reward hacking paper about? Be sure to provide sources.\"\n    }\n)",
      "formatted_path": "Changelog > Knowledge > Quickstart Example",
      "enhanced_text": "Context: Changelog > Knowledge > Quickstart Example\n\nfrom crewai import LLM, Agent, Crew, Process, Task\nfrom crewai.knowledge.source.crew_docling_source import CrewDoclingSource\n\n# Create a knowledge source\ncontent_source = CrewDoclingSource(\n    file_paths=[\n        \"https://lilianweng.github.io/posts/2024-11-28-reward-hacking\",\n        \"https://lilianweng.github.io/posts/2024-07-07-hallucination\",\n    ],\n)\n\n# Create an LLM with a temperature of 0 to ensure deterministic outputs\nllm = LLM(model=\"gpt-4o-mini\", temperature=0)\n\n# Create an agent with the knowledge store\nagent = Agent(\n    role=\"About papers\",\n    goal=\"You know everything about the papers.\",\n    backstory=\"\"\"You are a master at understanding papers and their content.\"\"\",\n    verbose=True,\n    allow_delegation=False,\n    llm=llm,\n)\ntask = Task(\n    description=\"Answer the following questions about the papers: {question}\",\n    expected_output=\"An answer to the question.\",\n    agent=agent,\n)\n\ncrew = Crew(\n    agents=[agent],\n    tasks=[task],\n    verbose=True,\n    process=Process.sequential,\n    knowledge_sources=[\n        content_source\n    ],  # Enable knowledge by adding the sources here. You can also add more sources to the sources list.\n)\n\nresult = crew.kickoff(\n    inputs={\n        \"question\": \"What is the reward hacking paper about? Be sure to provide sources.\"\n    }\n)"
    },
    {
      "content": "Here are examples of how to use different types of knowledge sources: Note: Please ensure that you create the ./knowldge folder. All source files (e.g., .txt, .pdf, .xlsx, .json) should be placed in this folder for centralized management.",
      "title": "More Examples",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Knowledge",
          "level": 1
        },
        {
          "title": "More Examples",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Knowledge",
            "level": 1
          },
          {
            "title": "More Examples",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Knowledge > More Examples"
      },
      "enhanced_content": "Context: Changelog > Knowledge > More Examples\n\n## More Examples\n\nHere are examples of how to use different types of knowledge sources: Note: Please ensure that you create the ./knowldge folder. All source files (e.g., .txt, .pdf, .xlsx, .json) should be placed in this folder for centralized management.",
      "formatted_path": "Changelog > Knowledge > More Examples",
      "enhanced_text": "Context: Changelog > Knowledge > More Examples\n\n More Examples\n\nHere are examples of how to use different types of knowledge sources: Note: Please ensure that you create the ./knowldge folder. All source files (e.g., .txt, .pdf, .xlsx, .json) should be placed in this folder for centralized management.\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "from crewai.knowledge.source.text_file_knowledge_source import TextFileKnowledgeSource\n\n# Create a text file knowledge source\ntext_source = TextFileKnowledgeSource(\n    file_paths=[\"document.txt\", \"another.txt\"]\n)\n\n# Create crew with text file source on agents or crew level\nagent = Agent(\n    ...\n    knowledge_sources=[text_source]\n)\n\ncrew = Crew(\n    ...\n    knowledge_sources=[text_source]\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Knowledge",
          "level": 1
        },
        {
          "title": "More Examples",
          "level": 2
        },
        {
          "title": "Text File Knowledge Source",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Knowledge",
            "level": 1
          },
          {
            "title": "More Examples",
            "level": 2
          },
          {
            "title": "Text File Knowledge Source",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Knowledge > More Examples > Text File Knowledge Source"
      },
      "enhanced_content": "Context: Changelog > Knowledge > More Examples > Text File Knowledge Source\n\nfrom crewai.knowledge.source.text_file_knowledge_source import TextFileKnowledgeSource\n\n# Create a text file knowledge source\ntext_source = TextFileKnowledgeSource(\n    file_paths=[\"document.txt\", \"another.txt\"]\n)\n\n# Create crew with text file source on agents or crew level\nagent = Agent(\n    ...\n    knowledge_sources=[text_source]\n)\n\ncrew = Crew(\n    ...\n    knowledge_sources=[text_source]\n)",
      "formatted_path": "Changelog > Knowledge > More Examples > Text File Knowledge Source",
      "enhanced_text": "Context: Changelog > Knowledge > More Examples > Text File Knowledge Source\n\nfrom crewai.knowledge.source.text_file_knowledge_source import TextFileKnowledgeSource\n\n# Create a text file knowledge source\ntext_source = TextFileKnowledgeSource(\n    file_paths=[\"document.txt\", \"another.txt\"]\n)\n\n# Create crew with text file source on agents or crew level\nagent = Agent(\n    ...\n    knowledge_sources=[text_source]\n)\n\ncrew = Crew(\n    ...\n    knowledge_sources=[text_source]\n)"
    },
    {
      "content": "from crewai.knowledge.source.pdf_knowledge_source import PDFKnowledgeSource\n\n# Create a PDF knowledge source\npdf_source = PDFKnowledgeSource(\n    file_paths=[\"document.pdf\", \"another.pdf\"]\n)\n\n# Create crew with PDF knowledge source on agents or crew level\nagent = Agent(\n    ...\n    knowledge_sources=[pdf_source]\n)\n\ncrew = Crew(\n    ...\n    knowledge_sources=[pdf_source]\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Knowledge",
          "level": 1
        },
        {
          "title": "More Examples",
          "level": 2
        },
        {
          "title": "PDF Knowledge Source",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Knowledge",
            "level": 1
          },
          {
            "title": "More Examples",
            "level": 2
          },
          {
            "title": "PDF Knowledge Source",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Knowledge > More Examples > PDF Knowledge Source"
      },
      "enhanced_content": "Context: Changelog > Knowledge > More Examples > PDF Knowledge Source\n\nfrom crewai.knowledge.source.pdf_knowledge_source import PDFKnowledgeSource\n\n# Create a PDF knowledge source\npdf_source = PDFKnowledgeSource(\n    file_paths=[\"document.pdf\", \"another.pdf\"]\n)\n\n# Create crew with PDF knowledge source on agents or crew level\nagent = Agent(\n    ...\n    knowledge_sources=[pdf_source]\n)\n\ncrew = Crew(\n    ...\n    knowledge_sources=[pdf_source]\n)",
      "formatted_path": "Changelog > Knowledge > More Examples > PDF Knowledge Source",
      "enhanced_text": "Context: Changelog > Knowledge > More Examples > PDF Knowledge Source\n\nfrom crewai.knowledge.source.pdf_knowledge_source import PDFKnowledgeSource\n\n# Create a PDF knowledge source\npdf_source = PDFKnowledgeSource(\n    file_paths=[\"document.pdf\", \"another.pdf\"]\n)\n\n# Create crew with PDF knowledge source on agents or crew level\nagent = Agent(\n    ...\n    knowledge_sources=[pdf_source]\n)\n\ncrew = Crew(\n    ...\n    knowledge_sources=[pdf_source]\n)"
    },
    {
      "content": "from crewai.knowledge.source.csv_knowledge_source import CSVKnowledgeSource\n\n# Create a CSV knowledge source\ncsv_source = CSVKnowledgeSource(\n    file_paths=[\"data.csv\"]\n)\n\n# Create crew with CSV knowledge source or on agent level\nagent = Agent(\n    ...\n    knowledge_sources=[csv_source]\n)\n\ncrew = Crew(\n    ...\n    knowledge_sources=[csv_source]\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Knowledge",
          "level": 1
        },
        {
          "title": "More Examples",
          "level": 2
        },
        {
          "title": "CSV Knowledge Source",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Knowledge",
            "level": 1
          },
          {
            "title": "More Examples",
            "level": 2
          },
          {
            "title": "CSV Knowledge Source",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Knowledge > More Examples > CSV Knowledge Source"
      },
      "enhanced_content": "Context: Changelog > Knowledge > More Examples > CSV Knowledge Source\n\nfrom crewai.knowledge.source.csv_knowledge_source import CSVKnowledgeSource\n\n# Create a CSV knowledge source\ncsv_source = CSVKnowledgeSource(\n    file_paths=[\"data.csv\"]\n)\n\n# Create crew with CSV knowledge source or on agent level\nagent = Agent(\n    ...\n    knowledge_sources=[csv_source]\n)\n\ncrew = Crew(\n    ...\n    knowledge_sources=[csv_source]\n)",
      "formatted_path": "Changelog > Knowledge > More Examples > CSV Knowledge Source",
      "enhanced_text": "Context: Changelog > Knowledge > More Examples > CSV Knowledge Source\n\nfrom crewai.knowledge.source.csv_knowledge_source import CSVKnowledgeSource\n\n# Create a CSV knowledge source\ncsv_source = CSVKnowledgeSource(\n    file_paths=[\"data.csv\"]\n)\n\n# Create crew with CSV knowledge source or on agent level\nagent = Agent(\n    ...\n    knowledge_sources=[csv_source]\n)\n\ncrew = Crew(\n    ...\n    knowledge_sources=[csv_source]\n)"
    },
    {
      "content": "from crewai.knowledge.source.excel_knowledge_source import ExcelKnowledgeSource\n\n# Create an Excel knowledge source\nexcel_source = ExcelKnowledgeSource(\n    file_paths=[\"spreadsheet.xlsx\"]\n)\n\n# Create crew with Excel knowledge source on agents or crew level\nagent = Agent(\n    ...\n    knowledge_sources=[excel_source]\n)\n\ncrew = Crew(\n    ...\n    knowledge_sources=[excel_source]\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Knowledge",
          "level": 1
        },
        {
          "title": "More Examples",
          "level": 2
        },
        {
          "title": "Excel Knowledge Source",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Knowledge",
            "level": 1
          },
          {
            "title": "More Examples",
            "level": 2
          },
          {
            "title": "Excel Knowledge Source",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Knowledge > More Examples > Excel Knowledge Source"
      },
      "enhanced_content": "Context: Changelog > Knowledge > More Examples > Excel Knowledge Source\n\nfrom crewai.knowledge.source.excel_knowledge_source import ExcelKnowledgeSource\n\n# Create an Excel knowledge source\nexcel_source = ExcelKnowledgeSource(\n    file_paths=[\"spreadsheet.xlsx\"]\n)\n\n# Create crew with Excel knowledge source on agents or crew level\nagent = Agent(\n    ...\n    knowledge_sources=[excel_source]\n)\n\ncrew = Crew(\n    ...\n    knowledge_sources=[excel_source]\n)",
      "formatted_path": "Changelog > Knowledge > More Examples > Excel Knowledge Source",
      "enhanced_text": "Context: Changelog > Knowledge > More Examples > Excel Knowledge Source\n\nfrom crewai.knowledge.source.excel_knowledge_source import ExcelKnowledgeSource\n\n# Create an Excel knowledge source\nexcel_source = ExcelKnowledgeSource(\n    file_paths=[\"spreadsheet.xlsx\"]\n)\n\n# Create crew with Excel knowledge source on agents or crew level\nagent = Agent(\n    ...\n    knowledge_sources=[excel_source]\n)\n\ncrew = Crew(\n    ...\n    knowledge_sources=[excel_source]\n)"
    },
    {
      "content": "from crewai.knowledge.source.json_knowledge_source import JSONKnowledgeSource\n\n# Create a JSON knowledge source\njson_source = JSONKnowledgeSource(\n    file_paths=[\"data.json\"]\n)\n\n# Create crew with JSON knowledge source on agents or crew level\nagent = Agent(\n    ...\n    knowledge_sources=[json_source]\n)\n\ncrew = Crew(\n    ...\n    knowledge_sources=[json_source]\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Knowledge",
          "level": 1
        },
        {
          "title": "More Examples",
          "level": 2
        },
        {
          "title": "JSON Knowledge Source",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Knowledge",
            "level": 1
          },
          {
            "title": "More Examples",
            "level": 2
          },
          {
            "title": "JSON Knowledge Source",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Knowledge > More Examples > JSON Knowledge Source"
      },
      "enhanced_content": "Context: Changelog > Knowledge > More Examples > JSON Knowledge Source\n\nfrom crewai.knowledge.source.json_knowledge_source import JSONKnowledgeSource\n\n# Create a JSON knowledge source\njson_source = JSONKnowledgeSource(\n    file_paths=[\"data.json\"]\n)\n\n# Create crew with JSON knowledge source on agents or crew level\nagent = Agent(\n    ...\n    knowledge_sources=[json_source]\n)\n\ncrew = Crew(\n    ...\n    knowledge_sources=[json_source]\n)",
      "formatted_path": "Changelog > Knowledge > More Examples > JSON Knowledge Source",
      "enhanced_text": "Context: Changelog > Knowledge > More Examples > JSON Knowledge Source\n\nfrom crewai.knowledge.source.json_knowledge_source import JSONKnowledgeSource\n\n# Create a JSON knowledge source\njson_source = JSONKnowledgeSource(\n    file_paths=[\"data.json\"]\n)\n\n# Create crew with JSON knowledge source on agents or crew level\nagent = Agent(\n    ...\n    knowledge_sources=[json_source]\n)\n\ncrew = Crew(\n    ...\n    knowledge_sources=[json_source]\n)"
    },
    {
      "content": "from crewai.knowledge.source.string_knowledge_source import StringKnowledgeSource\n\nsource = StringKnowledgeSource(\n    content=\"Your content here\",\n    chunk_size=4000,      # Maximum size of each chunk (default: 4000)\n    chunk_overlap=200     # Overlap between chunks (default: 200)\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Knowledge",
          "level": 1
        },
        {
          "title": "Knowledge Configuration",
          "level": 2
        },
        {
          "title": "Chunking Configuration",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Knowledge",
            "level": 1
          },
          {
            "title": "Knowledge Configuration",
            "level": 2
          },
          {
            "title": "Chunking Configuration",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Knowledge > Knowledge Configuration > Chunking Configuration"
      },
      "enhanced_content": "Context: Changelog > Knowledge > Knowledge Configuration > Chunking Configuration\n\nfrom crewai.knowledge.source.string_knowledge_source import StringKnowledgeSource\n\nsource = StringKnowledgeSource(\n    content=\"Your content here\",\n    chunk_size=4000,      # Maximum size of each chunk (default: 4000)\n    chunk_overlap=200     # Overlap between chunks (default: 200)\n)",
      "formatted_path": "Changelog > Knowledge > Knowledge Configuration > Chunking Configuration",
      "enhanced_text": "Context: Changelog > Knowledge > Knowledge Configuration > Chunking Configuration\n\nfrom crewai.knowledge.source.string_knowledge_source import StringKnowledgeSource\n\nsource = StringKnowledgeSource(\n    content=\"Your content here\",\n    chunk_size=4000,      # Maximum size of each chunk (default: 4000)\n    chunk_overlap=200     # Overlap between chunks (default: 200)\n)"
    },
    {
      "content": "You can also configure the embedder for the knowledge store.\nThis is useful if you want to use a different embedder for the knowledge store than the one used for the agents.\nThe `embedder` parameter supports various embedding model providers that include: `openai`: OpenAI's embedding models `google`: Google's text embedding models `azure`: Azure OpenAI embeddings `ollama`: Local embeddings with Ollama `vertexai`: Google Cloud VertexAI embeddings `cohere`: Cohere's embedding models `voyageai`: VoyageAI's embedding models `bedrock`: AWS Bedrock embeddings `huggingface`: Hugging Face models `watson`: IBM Watson embeddings Here's an example of how to configure the embedder for the knowledge store using Google's `text-embedding-004` model:",
      "title": "Embeddings Configuration",
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Knowledge",
          "level": 1
        },
        {
          "title": "Knowledge Configuration",
          "level": 2
        },
        {
          "title": "Embeddings Configuration",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Knowledge",
            "level": 1
          },
          {
            "title": "Knowledge Configuration",
            "level": 2
          },
          {
            "title": "Embeddings Configuration",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Knowledge > Knowledge Configuration > Embeddings Configuration"
      },
      "enhanced_content": "Context: Changelog > Knowledge > Knowledge Configuration > Embeddings Configuration\n\n### Embeddings Configuration\n\nYou can also configure the embedder for the knowledge store.\nThis is useful if you want to use a different embedder for the knowledge store than the one used for the agents.\nThe `embedder` parameter supports various embedding model providers that include: `openai`: OpenAI's embedding models `google`: Google's text embedding models `azure`: Azure OpenAI embeddings `ollama`: Local embeddings with Ollama `vertexai`: Google Cloud VertexAI embeddings `cohere`: Cohere's embedding models `voyageai`: VoyageAI's embedding models `bedrock`: AWS Bedrock embeddings `huggingface`: Hugging Face models `watson`: IBM Watson embeddings Here's an example of how to configure the embedder for the knowledge store using Google's `text-embedding-004` model:",
      "formatted_path": "Changelog > Knowledge > Knowledge Configuration > Embeddings Configuration",
      "enhanced_text": "Context: Changelog > Knowledge > Knowledge Configuration > Embeddings Configuration\n\n Embeddings Configuration\n\nYou can also configure the embedder for the knowledge store.\nThis is useful if you want to use a different embedder for the knowledge store than the one used for the agents.\nThe `embedder` parameter supports various embedding model providers that include: `openai`: OpenAI's embedding models `google`: Google's text embedding models `azure`: Azure OpenAI embeddings `ollama`: Local embeddings with Ollama `vertexai`: Google Cloud VertexAI embeddings `cohere`: Cohere's embedding models `voyageai`: VoyageAI's embedding models `bedrock`: AWS Bedrock embeddings `huggingface`: Hugging Face models `watson`: IBM Watson embeddings Here's an example of how to configure the embedder for the knowledge store using Google's `text-embedding-004` model:\n\nRelated sections:\n- \n"
    },
    {
      "content": "GEMINI_API_KEY = os.environ.get(\"GEMINI_API_KEY\")",
      "title": "Get the GEMINI API key",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Get the GEMINI API key",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Get the GEMINI API key",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Get the GEMINI API key"
      },
      "enhanced_content": "Context: Changelog > Get the GEMINI API key\n\n# Get the GEMINI API key\n\nGEMINI_API_KEY = os.environ.get(\"GEMINI_API_KEY\")",
      "formatted_path": "Changelog > Get the GEMINI API key",
      "enhanced_text": "Context: Changelog > Get the GEMINI API key\n\n Get the GEMINI API key\n\nGEMINI_API_KEY = os.environ.get(\"GEMINI_API_KEY\")"
    },
    {
      "content": "content = \"Users name is John. He is 30 years old and lives in San Francisco.\"\n  string_source = StringKnowledgeSource(\n      content=content,\n  )",
      "title": "Create a knowledge source",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Create a knowledge source",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Create a knowledge source",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Create a knowledge source"
      },
      "enhanced_content": "Context: Changelog > Create a knowledge source\n\n# Create a knowledge source\n\ncontent = \"Users name is John. He is 30 years old and lives in San Francisco.\"\n  string_source = StringKnowledgeSource(\n      content=content,\n  )",
      "formatted_path": "Changelog > Create a knowledge source",
      "enhanced_text": "Context: Changelog > Create a knowledge source\n\n Create a knowledge source\n\ncontent = \"Users name is John. He is 30 years old and lives in San Francisco.\"\n  string_source = StringKnowledgeSource(\n      content=content,\n  )"
    },
    {
      "content": "gemini_llm = LLM(\n      model=\"gemini/gemini-1.5-pro-002\",\n      api_key=GEMINI_API_KEY,\n      temperature=0,\n  )",
      "title": "Create an LLM with a temperature of 0 to ensure deterministic outputs",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Create an LLM with a temperature of 0 to ensure deterministic outputs",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Create an LLM with a temperature of 0 to ensure deterministic outputs",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Create an LLM with a temperature of 0 to ensure deterministic outputs"
      },
      "enhanced_content": "Context: Changelog > Create an LLM with a temperature of 0 to ensure deterministic outputs\n\n# Create an LLM with a temperature of 0 to ensure deterministic outputs\n\ngemini_llm = LLM(\n      model=\"gemini/gemini-1.5-pro-002\",\n      api_key=GEMINI_API_KEY,\n      temperature=0,\n  )",
      "formatted_path": "Changelog > Create an LLM with a temperature of 0 to ensure deterministic outputs",
      "enhanced_text": "Context: Changelog > Create an LLM with a temperature of 0 to ensure deterministic outputs\n\n Create an LLM with a temperature of 0 to ensure deterministic outputs\n\ngemini_llm = LLM(\n      model=\"gemini/gemini-1.5-pro-002\",\n      api_key=GEMINI_API_KEY,\n      temperature=0,\n  )"
    },
    {
      "content": "```text Output\n# Agent: About User\n## Task: Answer the following questions about the user: What city does John live in and how old is he?\n\n# Agent: About User\n## Final Answer: \nJohn is 30 years old and lives in San Francisco.",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Create an agent with the knowledge store",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Create an agent with the knowledge store",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Create an agent with the knowledge store"
      },
      "enhanced_content": "Context: Changelog > Create an agent with the knowledge store\n\n```text Output\n# Agent: About User\n## Task: Answer the following questions about the user: What city does John live in and how old is he?\n\n# Agent: About User\n## Final Answer: \nJohn is 30 years old and lives in San Francisco.",
      "formatted_path": "Changelog > Create an agent with the knowledge store",
      "enhanced_text": "Context: Changelog > Create an agent with the knowledge store\n\n```text Output\n# Agent: About User\n## Task: Answer the following questions about the user: What city does John live in and how old is he?\n\n# Agent: About User\n## Final Answer: \nJohn is 30 years old and lives in San Francisco."
    },
    {
      "content": "crewai reset-memories --knowledge",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Create an agent with the knowledge store",
          "level": 1
        },
        {
          "title": "Clearing Knowledge",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Create an agent with the knowledge store",
            "level": 1
          },
          {
            "title": "Clearing Knowledge",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Create an agent with the knowledge store > Clearing Knowledge"
      },
      "enhanced_content": "Context: Changelog > Create an agent with the knowledge store > Clearing Knowledge\n\ncrewai reset-memories --knowledge",
      "formatted_path": "Changelog > Create an agent with the knowledge store > Clearing Knowledge",
      "enhanced_text": "Context: Changelog > Create an agent with the knowledge store > Clearing Knowledge\n\ncrewai reset-memories --knowledge"
    },
    {
      "content": "from crewai import Agent, Task, Crew\nfrom crewai.knowledge.source.string_knowledge_source import StringKnowledgeSource\n\n# Create agent-specific knowledge about a product\nproduct_specs = StringKnowledgeSource(\n    content=\"\"\"The XPS 13 laptop features:\n    - 13.4-inch 4K display\n    - Intel Core i7 processor\n    - 16GB RAM\n    - 512GB SSD storage\n    - 12-hour battery life\"\"\",\n    metadata={\"category\": \"product_specs\"}\n)\n\n# Create a support agent with product knowledge\nsupport_agent = Agent(\n    role=\"Technical Support Specialist\",\n    goal=\"Provide accurate product information and support.\",\n    backstory=\"You are an expert on our laptop products and specifications.\",\n    knowledge_sources=[product_specs]  # Agent-specific knowledge\n)\n\n# Create a task that requires product knowledge\nsupport_task = Task(\n    description=\"Answer this customer question: {question}\",\n    agent=support_agent\n)\n\n# Create and run the crew\ncrew = Crew(\n    agents=[support_agent],\n    tasks=[support_task]\n)\n\n# Get answer about the laptop's specifications\nresult = crew.kickoff(\n    inputs={\"question\": \"What is the storage capacity of the XPS 13?\"}\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Create an agent with the knowledge store",
          "level": 1
        },
        {
          "title": "Agent-Specific Knowledge",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Create an agent with the knowledge store",
            "level": 1
          },
          {
            "title": "Agent-Specific Knowledge",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Create an agent with the knowledge store > Agent-Specific Knowledge"
      },
      "enhanced_content": "Context: Changelog > Create an agent with the knowledge store > Agent-Specific Knowledge\n\nfrom crewai import Agent, Task, Crew\nfrom crewai.knowledge.source.string_knowledge_source import StringKnowledgeSource\n\n# Create agent-specific knowledge about a product\nproduct_specs = StringKnowledgeSource(\n    content=\"\"\"The XPS 13 laptop features:\n    - 13.4-inch 4K display\n    - Intel Core i7 processor\n    - 16GB RAM\n    - 512GB SSD storage\n    - 12-hour battery life\"\"\",\n    metadata={\"category\": \"product_specs\"}\n)\n\n# Create a support agent with product knowledge\nsupport_agent = Agent(\n    role=\"Technical Support Specialist\",\n    goal=\"Provide accurate product information and support.\",\n    backstory=\"You are an expert on our laptop products and specifications.\",\n    knowledge_sources=[product_specs]  # Agent-specific knowledge\n)\n\n# Create a task that requires product knowledge\nsupport_task = Task(\n    description=\"Answer this customer question: {question}\",\n    agent=support_agent\n)\n\n# Create and run the crew\ncrew = Crew(\n    agents=[support_agent],\n    tasks=[support_task]\n)\n\n# Get answer about the laptop's specifications\nresult = crew.kickoff(\n    inputs={\"question\": \"What is the storage capacity of the XPS 13?\"}\n)",
      "formatted_path": "Changelog > Create an agent with the knowledge store > Agent-Specific Knowledge",
      "enhanced_text": "Context: Changelog > Create an agent with the knowledge store > Agent-Specific Knowledge\n\nfrom crewai import Agent, Task, Crew\nfrom crewai.knowledge.source.string_knowledge_source import StringKnowledgeSource\n\n# Create agent-specific knowledge about a product\nproduct_specs = StringKnowledgeSource(\n    content=\"\"\"The XPS 13 laptop features:\n    - 13.4-inch 4K display\n    - Intel Core i7 processor\n    - 16GB RAM\n    - 512GB SSD storage\n    - 12-hour battery life\"\"\",\n    metadata={\"category\": \"product_specs\"}\n)\n\n# Create a support agent with product knowledge\nsupport_agent = Agent(\n    role=\"Technical Support Specialist\",\n    goal=\"Provide accurate product information and support.\",\n    backstory=\"You are an expert on our laptop products and specifications.\",\n    knowledge_sources=[product_specs]  # Agent-specific knowledge\n)\n\n# Create a task that requires product knowledge\nsupport_task = Task(\n    description=\"Answer this customer question: {question}\",\n    agent=support_agent\n)\n\n# Create and run the crew\ncrew = Crew(\n    agents=[support_agent],\n    tasks=[support_task]\n)\n\n# Get answer about the laptop's specifications\nresult = crew.kickoff(\n    inputs={\"question\": \"What is the storage capacity of the XPS 13?\"}\n)"
    },
    {
      "content": "CrewAI allows you to create custom knowledge sources for any type of data by extending the `BaseKnowledgeSource` class. Let's create a practical example that fetches and processes space news articles.",
      "title": "Custom Knowledge Sources",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Create an agent with the knowledge store",
          "level": 1
        },
        {
          "title": "Custom Knowledge Sources",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Create an agent with the knowledge store",
            "level": 1
          },
          {
            "title": "Custom Knowledge Sources",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Create an agent with the knowledge store > Custom Knowledge Sources"
      },
      "enhanced_content": "Context: Changelog > Create an agent with the knowledge store > Custom Knowledge Sources\n\n## Custom Knowledge Sources\n\nCrewAI allows you to create custom knowledge sources for any type of data by extending the `BaseKnowledgeSource` class. Let's create a practical example that fetches and processes space news articles.",
      "formatted_path": "Changelog > Create an agent with the knowledge store > Custom Knowledge Sources",
      "enhanced_text": "Context: Changelog > Create an agent with the knowledge store > Custom Knowledge Sources\n\n Custom Knowledge Sources\n\nCrewAI allows you to create custom knowledge sources for any type of data by extending the `BaseKnowledgeSource` class. Let's create a practical example that fetches and processes space news articles.\n\nRelated sections:\n- \n"
    },
    {
      "content": "class SpaceNewsKnowledgeSource(BaseKnowledgeSource):\n      \"\"\"Knowledge source that fetches data from Space News API.\"\"\"",
      "title": "Space News Knowledge Source Example",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Create an agent with the knowledge store",
          "level": 1
        },
        {
          "title": "Custom Knowledge Sources",
          "level": 2
        },
        {
          "title": "Space News Knowledge Source Example",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Create an agent with the knowledge store",
            "level": 1
          },
          {
            "title": "Custom Knowledge Sources",
            "level": 2
          },
          {
            "title": "Space News Knowledge Source Example",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Create an agent with the knowledge store > Custom Knowledge Sources > Space News Knowledge Source Example"
      },
      "enhanced_content": "Context: Changelog > Create an agent with the knowledge store > Custom Knowledge Sources > Space News Knowledge Source Example\n\n#### Space News Knowledge Source Example\n\nclass SpaceNewsKnowledgeSource(BaseKnowledgeSource):\n      \"\"\"Knowledge source that fetches data from Space News API.\"\"\"",
      "formatted_path": "Changelog > Create an agent with the knowledge store > Custom Knowledge Sources > Space News Knowledge Source Example",
      "enhanced_text": "Context: Changelog > Create an agent with the knowledge store > Custom Knowledge Sources > Space News Knowledge Source Example\n\n Space News Knowledge Source Example\n\nclass SpaceNewsKnowledgeSource(BaseKnowledgeSource):\n      \"\"\"Knowledge source that fetches data from Space News API.\"\"\"\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "recent_news = SpaceNewsKnowledgeSource(\n      api_endpoint=\"https://api.spaceflightnewsapi.net/v4/articles\",\n      limit=10,\n  )",
      "title": "Create knowledge source",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Create knowledge source",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Create knowledge source",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Create knowledge source"
      },
      "enhanced_content": "Context: Changelog > Create knowledge source\n\n# Create knowledge source\n\nrecent_news = SpaceNewsKnowledgeSource(\n      api_endpoint=\"https://api.spaceflightnewsapi.net/v4/articles\",\n      limit=10,\n  )",
      "formatted_path": "Changelog > Create knowledge source",
      "enhanced_text": "Context: Changelog > Create knowledge source\n\n Create knowledge source\n\nrecent_news = SpaceNewsKnowledgeSource(\n      api_endpoint=\"https://api.spaceflightnewsapi.net/v4/articles\",\n      limit=10,\n  )"
    },
    {
      "content": "space_analyst = Agent(\n      role=\"Space News Analyst\",\n      goal=\"Answer questions about space news accurately and comprehensively\",\n      backstory=\"\"\"You are a space industry analyst with expertise in space exploration,\n      satellite technology, and space industry trends. You excel at answering questions\n      about space news and providing detailed, accurate information.\"\"\",\n      knowledge_sources=[recent_news],\n      llm=LLM(model=\"gpt-4\", temperature=0.0)\n  )",
      "title": "Create specialized agent",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Create specialized agent",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Create specialized agent",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Create specialized agent"
      },
      "enhanced_content": "Context: Changelog > Create specialized agent\n\n# Create specialized agent\n\nspace_analyst = Agent(\n      role=\"Space News Analyst\",\n      goal=\"Answer questions about space news accurately and comprehensively\",\n      backstory=\"\"\"You are a space industry analyst with expertise in space exploration,\n      satellite technology, and space industry trends. You excel at answering questions\n      about space news and providing detailed, accurate information.\"\"\",\n      knowledge_sources=[recent_news],\n      llm=LLM(model=\"gpt-4\", temperature=0.0)\n  )",
      "formatted_path": "Changelog > Create specialized agent",
      "enhanced_text": "Context: Changelog > Create specialized agent\n\n Create specialized agent\n\nspace_analyst = Agent(\n      role=\"Space News Analyst\",\n      goal=\"Answer questions about space news accurately and comprehensively\",\n      backstory=\"\"\"You are a space industry analyst with expertise in space exploration,\n      satellite technology, and space industry trends. You excel at answering questions\n      about space news and providing detailed, accurate information.\"\"\",\n      knowledge_sources=[recent_news],\n      llm=LLM(model=\"gpt-4\", temperature=0.0)\n  )"
    },
    {
      "content": "analysis_task = Task(\n      description=\"Answer this question about space news: {user_question}\",\n      expected_output=\"A detailed answer based on the recent space news articles\",\n      agent=space_analyst\n  )",
      "title": "Create task that handles user questions",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Create task that handles user questions",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Create task that handles user questions",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Create task that handles user questions"
      },
      "enhanced_content": "Context: Changelog > Create task that handles user questions\n\n# Create task that handles user questions\n\nanalysis_task = Task(\n      description=\"Answer this question about space news: {user_question}\",\n      expected_output=\"A detailed answer based on the recent space news articles\",\n      agent=space_analyst\n  )",
      "formatted_path": "Changelog > Create task that handles user questions",
      "enhanced_text": "Context: Changelog > Create task that handles user questions\n\n Create task that handles user questions\n\nanalysis_task = Task(\n      description=\"Answer this question about space news: {user_question}\",\n      expected_output=\"A detailed answer based on the recent space news articles\",\n      agent=space_analyst\n  )"
    },
    {
      "content": "crew = Crew(\n      agents=[space_analyst],\n      tasks=[analysis_task],\n      verbose=True,\n      process=Process.sequential\n  )",
      "title": "Create and run the crew",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Create and run the crew",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Create and run the crew",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Create and run the crew"
      },
      "enhanced_content": "Context: Changelog > Create and run the crew\n\n# Create and run the crew\n\ncrew = Crew(\n      agents=[space_analyst],\n      tasks=[analysis_task],\n      verbose=True,\n      process=Process.sequential\n  )",
      "formatted_path": "Changelog > Create and run the crew",
      "enhanced_text": "Context: Changelog > Create and run the crew\n\n Create and run the crew\n\ncrew = Crew(\n      agents=[space_analyst],\n      tasks=[analysis_task],\n      verbose=True,\n      process=Process.sequential\n  )"
    },
    {
      "content": "```output Output\n# Agent: Space News Analyst\n## Task: Answer this question about space news: What are the latest developments in space exploration?\n\n\n# Agent: Space News Analyst\n## Final Answer:\nThe latest developments in space exploration, based on recent space news articles, include the following:\n\n1. SpaceX has received the final regulatory approvals to proceed with the second integrated Starship/Super Heavy launch, scheduled for as soon as the morning of Nov. 17, 2023. This is a significant step in SpaceX's ambitious plans for space exploration and colonization. [Source: SpaceNews](https://spacenews.com/starship-cleared-for-nov-17-launch/)\n\n2. SpaceX has also informed the US Federal Communications Commission (FCC) that it plans to begin launching its first next-generation Starlink Gen2 satellites. This represents a major upgrade to the Starlink satellite internet service, which aims to provide high-speed internet access worldwide. [Source: Teslarati](https://www.teslarati.com/spacex-first-starlink-gen2-satellite-launch-2022/)\n\n3. AI startup Synthetaic has raised $15 million in Series B funding. The company uses artificial intelligence to analyze data from space and air sensors, which could have significant applications in space exploration and satellite technology. [Source: SpaceNews](https://spacenews.com/ai-startup-synthetaic-raises-15-million-in-series-b-funding/)\n\n4. The Space Force has formally established a unit within the U.S. Indo-Pacific Command, marking a permanent presence in the Indo-Pacific region. This could have significant implications for space security and geopolitics. [Source: SpaceNews](https://spacenews.com/space-force-establishes-permanent-presence-in-indo-pacific-region/)\n\n5. Slingshot Aerospace, a space tracking and data analytics company, is expanding its network of ground-based optical telescopes to increase coverage of low Earth orbit. This could improve our ability to track and analyze objects in low Earth orbit, including satellites and space debris. [Source: SpaceNews](https://spacenews.com/slingshots-space-tracking-network-to-extend-coverage-of-low-earth-orbit/)\n\n6. The National Natural Science Foundation of China has outlined a five-year project for researchers to study the assembly of ultra-large spacecraft. This could lead to significant advancements in spacecraft technology and space exploration capabilities. [Source: SpaceNews](https://spacenews.com/china-researching-challenges-of-kilometer-scale-ultra-large-spacecraft/)\n\n7. The Center for AEroSpace Autonomy Research (CAESAR) at Stanford University is focusing on spacecraft autonomy. The center held a kickoff event on May 22, 2024, to highlight the industry, academia, and government collaboration it seeks to foster. This could lead to significant advancements in autonomous spacecraft technology. [Source: SpaceNews](https://spacenews.com/stanford-center-focuses-on-spacecraft-autonomy/)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Example usage",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Example usage",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 7,
        "formatted_path": "Changelog > Example usage"
      },
      "enhanced_content": "Context: Changelog > Example usage\n\n```output Output\n# Agent: Space News Analyst\n## Task: Answer this question about space news: What are the latest developments in space exploration?\n\n\n# Agent: Space News Analyst\n## Final Answer:\nThe latest developments in space exploration, based on recent space news articles, include the following:\n\n1. SpaceX has received the final regulatory approvals to proceed with the second integrated Starship/Super Heavy launch, scheduled for as soon as the morning of Nov. 17, 2023. This is a significant step in SpaceX's ambitious plans for space exploration and colonization. [Source: SpaceNews](https://spacenews.com/starship-cleared-for-nov-17-launch/)\n\n2. SpaceX has also informed the US Federal Communications Commission (FCC) that it plans to begin launching its first next-generation Starlink Gen2 satellites. This represents a major upgrade to the Starlink satellite internet service, which aims to provide high-speed internet access worldwide. [Source: Teslarati](https://www.teslarati.com/spacex-first-starlink-gen2-satellite-launch-2022/)\n\n3. AI startup Synthetaic has raised $15 million in Series B funding. The company uses artificial intelligence to analyze data from space and air sensors, which could have significant applications in space exploration and satellite technology. [Source: SpaceNews](https://spacenews.com/ai-startup-synthetaic-raises-15-million-in-series-b-funding/)\n\n4. The Space Force has formally established a unit within the U.S. Indo-Pacific Command, marking a permanent presence in the Indo-Pacific region. This could have significant implications for space security and geopolitics. [Source: SpaceNews](https://spacenews.com/space-force-establishes-permanent-presence-in-indo-pacific-region/)\n\n5. Slingshot Aerospace, a space tracking and data analytics company, is expanding its network of ground-based optical telescopes to increase coverage of low Earth orbit. This could improve our ability to track and analyze objects in low Earth orbit, including satellites and space debris. [Source: SpaceNews](https://spacenews.com/slingshots-space-tracking-network-to-extend-coverage-of-low-earth-orbit/)\n\n6. The National Natural Science Foundation of China has outlined a five-year project for researchers to study the assembly of ultra-large spacecraft. This could lead to significant advancements in spacecraft technology and space exploration capabilities. [Source: SpaceNews](https://spacenews.com/china-researching-challenges-of-kilometer-scale-ultra-large-spacecraft/)\n\n7. The Center for AEroSpace Autonomy Research (CAESAR) at Stanford University is focusing on spacecraft autonomy. The center held a kickoff event on May 22, 2024, to highlight the industry, academia, and government collaboration it seeks to foster. This could lead to significant advancements in autonomous spacecraft technology. [Source: SpaceNews](https://spacenews.com/stanford-center-focuses-on-spacecraft-autonomy/)",
      "formatted_path": "Changelog > Example usage",
      "enhanced_text": "Context: Changelog > Example usage\n\n```output Output\n# Agent: Space News Analyst\n## Task: Answer this question about space news: What are the latest developments in space exploration?\n\n\n# Agent: Space News Analyst\n## Final Answer:\nThe latest developments in space exploration, based on recent space news articles, include the following:\n\n1. SpaceX has received the final regulatory approvals to proceed with the second integrated Starship/Super Heavy launch, scheduled for as soon as the morning of Nov. 17, 2023. This is a significant step in SpaceX's ambitious plans for space exploration and colonization. [Source: SpaceNews](https://spacenews.com/starship-cleared-for-nov-17-launch/)\n\n2. SpaceX has also informed the US Federal Communications Commission (FCC) that it plans to begin launching its first next-generation Starlink Gen2 satellites. This represents a major upgrade to the Starlink satellite internet service, which aims to provide high-speed internet access worldwide. [Source: Teslarati](https://www.teslarati.com/spacex-first-starlink-gen2-satellite-launch-2022/)\n\n3. AI startup Synthetaic has raised $15 million in Series B funding. The company uses artificial intelligence to analyze data from space and air sensors, which could have significant applications in space exploration and satellite technology. [Source: SpaceNews](https://spacenews.com/ai-startup-synthetaic-raises-15-million-in-series-b-funding/)\n\n4. The Space Force has formally established a unit within the U.S. Indo-Pacific Command, marking a permanent presence in the Indo-Pacific region. This could have significant implications for space security and geopolitics. [Source: SpaceNews](https://spacenews.com/space-force-establishes-permanent-presence-in-indo-pacific-region/)\n\n5. Slingshot Aerospace, a space tracking and data analytics company, is expanding its network of ground-based optical telescopes to increase coverage of low Earth orbit. This could improve our ability to track and analyze objects in low Earth orbit, including satellites and space debris. [Source: SpaceNews](https://spacenews.com/slingshots-space-tracking-network-to-extend-coverage-of-low-earth-orbit/)\n\n6. The National Natural Science Foundation of China has outlined a five-year project for researchers to study the assembly of ultra-large spacecraft. This could lead to significant advancements in spacecraft technology and space exploration capabilities. [Source: SpaceNews](https://spacenews.com/china-researching-challenges-of-kilometer-scale-ultra-large-spacecraft/)\n\n7. The Center for AEroSpace Autonomy Research (CAESAR) at Stanford University is focusing on spacecraft autonomy. The center held a kickoff event on May 22, 2024, to highlight the industry, academia, and government collaboration it seeks to foster. This could lead to significant advancements in autonomous spacecraft technology. [Source: SpaceNews](https://spacenews.com/stanford-center-focuses-on-spacecraft-autonomy/)"
    },
    {
      "content": "**Custom Knowledge Source (`SpaceNewsKnowledgeSource`)**: Extends `BaseKnowledgeSource` for integration with CrewAI Configurable API endpoint and article limit Implements three key methods: `load_content()`: Fetches articles from the API `_format_articles()`: Structures the articles into readable text `add()`: Processes and stores the content **Agent Configuration**: Specialized role as a Space News Analyst Uses the knowledge source to access space news **Task Setup**: Takes a user question as input through `{user_question}` Designed to provide detailed answers based on the knowledge source **Crew Orchestration**: Manages the workflow between agent and task Handles input/output through the kickoff method This example demonstrates how to: Create a custom knowledge source that fetches real-time data Process and format external data for AI consumption Use the knowledge source to answer specific user questions Integrate everything seamlessly with CrewAI's agent system",
      "title": "Key Components Explained",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Example usage",
          "level": 1
        },
        {
          "title": "Key Components Explained",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Example usage",
            "level": 1
          },
          {
            "title": "Key Components Explained",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Example usage > Key Components Explained"
      },
      "enhanced_content": "Context: Changelog > Example usage > Key Components Explained\n\n#### Key Components Explained\n\n**Custom Knowledge Source (`SpaceNewsKnowledgeSource`)**: Extends `BaseKnowledgeSource` for integration with CrewAI Configurable API endpoint and article limit Implements three key methods: `load_content()`: Fetches articles from the API `_format_articles()`: Structures the articles into readable text `add()`: Processes and stores the content **Agent Configuration**: Specialized role as a Space News Analyst Uses the knowledge source to access space news **Task Setup**: Takes a user question as input through `{user_question}` Designed to provide detailed answers based on the knowledge source **Crew Orchestration**: Manages the workflow between agent and task Handles input/output through the kickoff method This example demonstrates how to: Create a custom knowledge source that fetches real-time data Process and format external data for AI consumption Use the knowledge source to answer specific user questions Integrate everything seamlessly with CrewAI's agent system",
      "formatted_path": "Changelog > Example usage > Key Components Explained",
      "enhanced_text": "Context: Changelog > Example usage > Key Components Explained\n\n Key Components Explained\n\n**Custom Knowledge Source (`SpaceNewsKnowledgeSource`)**: Extends `BaseKnowledgeSource` for integration with CrewAI Configurable API endpoint and article limit Implements three key methods: `load_content()`: Fetches articles from the API `_format_articles()`: Structures the articles into readable text `add()`: Processes and stores the content **Agent Configuration**: Specialized role as a Space News Analyst Uses the knowledge source to access space news **Task Setup**: Takes a user question as input through `{user_question}` Designed to provide detailed answers based on the knowledge source **Crew Orchestration**: Manages the workflow between agent and task Handles input/output through the kickoff method This example demonstrates how to: Create a custom knowledge source that fetches real-time data Process and format external data for AI consumption Use the knowledge source to answer specific user questions Integrate everything seamlessly with CrewAI's agent system"
    },
    {
      "content": "# Fetch more articles\nrecent_news = SpaceNewsKnowledgeSource(\n    api_endpoint=\"https://api.spaceflightnewsapi.net/v4/articles\",\n    limit=20,  # Increase the number of articles\n)\n\n# Add search parameters\nrecent_news = SpaceNewsKnowledgeSource(\n    api_endpoint=\"https://api.spaceflightnewsapi.net/v4/articles?search=NASA\", # Search for NASA news\n    limit=10,\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Example usage",
          "level": 1
        },
        {
          "title": "About the Spaceflight News API",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Example usage",
            "level": 1
          },
          {
            "title": "About the Spaceflight News API",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Example usage > About the Spaceflight News API"
      },
      "enhanced_content": "Context: Changelog > Example usage > About the Spaceflight News API\n\n# Fetch more articles\nrecent_news = SpaceNewsKnowledgeSource(\n    api_endpoint=\"https://api.spaceflightnewsapi.net/v4/articles\",\n    limit=20,  # Increase the number of articles\n)\n\n# Add search parameters\nrecent_news = SpaceNewsKnowledgeSource(\n    api_endpoint=\"https://api.spaceflightnewsapi.net/v4/articles?search=NASA\", # Search for NASA news\n    limit=10,\n)",
      "formatted_path": "Changelog > Example usage > About the Spaceflight News API",
      "enhanced_text": "Context: Changelog > Example usage > About the Spaceflight News API\n\n# Fetch more articles\nrecent_news = SpaceNewsKnowledgeSource(\n    api_endpoint=\"https://api.spaceflightnewsapi.net/v4/articles\",\n    limit=20,  # Increase the number of articles\n)\n\n# Add search parameters\nrecent_news = SpaceNewsKnowledgeSource(\n    api_endpoint=\"https://api.spaceflightnewsapi.net/v4/articles?search=NASA\", # Search for NASA news\n    limit=10,\n)"
    },
    {
      "content": "import os\nfrom dotenv import load_dotenv\nfrom crewai import Agent, Task, Crew\nfrom crewai.tools import BaseTool\nfrom pydantic import Field\nfrom langchain_community.utilities import GoogleSerperAPIWrapper\n\n# Set up your SERPER_API_KEY key in an .env file, eg:\n# SERPER_API_KEY=<your api key>\nload_dotenv()\n\nsearch = GoogleSerperAPIWrapper()\n\nclass SearchTool(BaseTool):\n    name: str = \"Search\"\n    description: str = \"Useful for search-based queries. Use this to find current information about markets, companies, and trends.\"\n    search: GoogleSerperAPIWrapper = Field(default_factory=GoogleSerperAPIWrapper)\n\n    def _run(self, query: str) -> str:\n        \"\"\"Execute the search query and return results\"\"\"\n        try:\n            return self.search.run(query)\n        except Exception as e:\n            return f\"Error performing search: {str(e)}\"\n\n# Create Agents\nresearcher = Agent(\n    role='Research Analyst',\n    goal='Gather current market data and trends',\n    backstory=\"\"\"You are an expert research analyst with years of experience in\n    gathering market intelligence. You're known for your ability to find\n    relevant and up-to-date market information and present it in a clear,\n    actionable format.\"\"\",\n    tools=[SearchTool()],\n    verbose=True\n)\n\n# rest of the code ...",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Using LangChain Tools",
          "level": 1
        },
        {
          "title": "Using LangChain Tools",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Using LangChain Tools",
            "level": 1
          },
          {
            "title": "Using LangChain Tools",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Using LangChain Tools > Using LangChain Tools"
      },
      "enhanced_content": "Context: Changelog > Using LangChain Tools > Using LangChain Tools\n\nimport os\nfrom dotenv import load_dotenv\nfrom crewai import Agent, Task, Crew\nfrom crewai.tools import BaseTool\nfrom pydantic import Field\nfrom langchain_community.utilities import GoogleSerperAPIWrapper\n\n# Set up your SERPER_API_KEY key in an .env file, eg:\n# SERPER_API_KEY=<your api key>\nload_dotenv()\n\nsearch = GoogleSerperAPIWrapper()\n\nclass SearchTool(BaseTool):\n    name: str = \"Search\"\n    description: str = \"Useful for search-based queries. Use this to find current information about markets, companies, and trends.\"\n    search: GoogleSerperAPIWrapper = Field(default_factory=GoogleSerperAPIWrapper)\n\n    def _run(self, query: str) -> str:\n        \"\"\"Execute the search query and return results\"\"\"\n        try:\n            return self.search.run(query)\n        except Exception as e:\n            return f\"Error performing search: {str(e)}\"\n\n# Create Agents\nresearcher = Agent(\n    role='Research Analyst',\n    goal='Gather current market data and trends',\n    backstory=\"\"\"You are an expert research analyst with years of experience in\n    gathering market intelligence. You're known for your ability to find\n    relevant and up-to-date market information and present it in a clear,\n    actionable format.\"\"\",\n    tools=[SearchTool()],\n    verbose=True\n)\n\n# rest of the code ...",
      "formatted_path": "Changelog > Using LangChain Tools > Using LangChain Tools",
      "enhanced_text": "Context: Changelog > Using LangChain Tools > Using LangChain Tools\n\nimport os\nfrom dotenv import load_dotenv\nfrom crewai import Agent, Task, Crew\nfrom crewai.tools import BaseTool\nfrom pydantic import Field\nfrom langchain_community.utilities import GoogleSerperAPIWrapper\n\n# Set up your SERPER_API_KEY key in an .env file, eg:\n# SERPER_API_KEY=<your api key>\nload_dotenv()\n\nsearch = GoogleSerperAPIWrapper()\n\nclass SearchTool(BaseTool):\n    name: str = \"Search\"\n    description: str = \"Useful for search-based queries. Use this to find current information about markets, companies, and trends.\"\n    search: GoogleSerperAPIWrapper = Field(default_factory=GoogleSerperAPIWrapper)\n\n    def _run(self, query: str) -> str:\n        \"\"\"Execute the search query and return results\"\"\"\n        try:\n            return self.search.run(query)\n        except Exception as e:\n            return f\"Error performing search: {str(e)}\"\n\n# Create Agents\nresearcher = Agent(\n    role='Research Analyst',\n    goal='Gather current market data and trends',\n    backstory=\"\"\"You are an expert research analyst with years of experience in\n    gathering market intelligence. You're known for your ability to find\n    relevant and up-to-date market information and present it in a clear,\n    actionable format.\"\"\",\n    tools=[SearchTool()],\n    verbose=True\n)\n\n# rest of the code ..."
    },
    {
      "content": "from crewai import Agent\nfrom crewai_tools import LlamaIndexTool\n\n# Example 1: Initialize from FunctionTool\nfrom llama_index.core.tools import FunctionTool\n\nyour_python_function = lambda ...: ...\nog_tool = FunctionTool.from_defaults(\n    your_python_function, \n    name=\"<name>\", \n    description='<description>'\n)\ntool = LlamaIndexTool.from_tool(og_tool)\n\n# Example 2: Initialize from LlamaHub Tools\nfrom llama_index.tools.wolfram_alpha import WolframAlphaToolSpec\nwolfram_spec = WolframAlphaToolSpec(app_id=\"<app_id>\")\nwolfram_tools = wolfram_spec.to_tool_list()\ntools = [LlamaIndexTool.from_tool(t) for t in wolfram_tools]\n\n# Example 3: Initialize Tool from a LlamaIndex Query Engine\nquery_engine = index.as_query_engine()\nquery_tool = LlamaIndexTool.from_query_engine(\n    query_engine,\n    name=\"Uber 2019 10K Query Tool\",\n    description=\"Use this tool to lookup the 2019 Uber 10K Annual Report\"\n)\n\n# Create and assign the tools to an agent\nagent = Agent(\n    role='Research Analyst',\n    goal='Provide up-to-date market analysis',\n    backstory='An expert analyst with a keen eye for market trends.',\n    tools=[tool, *tools, query_tool]\n)\n\n# rest of the code ...",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Using LlamaIndex Tools",
          "level": 1
        },
        {
          "title": "Using LlamaIndex Tools",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Using LlamaIndex Tools",
            "level": 1
          },
          {
            "title": "Using LlamaIndex Tools",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Using LlamaIndex Tools > Using LlamaIndex Tools"
      },
      "enhanced_content": "Context: Changelog > Using LlamaIndex Tools > Using LlamaIndex Tools\n\nfrom crewai import Agent\nfrom crewai_tools import LlamaIndexTool\n\n# Example 1: Initialize from FunctionTool\nfrom llama_index.core.tools import FunctionTool\n\nyour_python_function = lambda ...: ...\nog_tool = FunctionTool.from_defaults(\n    your_python_function, \n    name=\"<name>\", \n    description='<description>'\n)\ntool = LlamaIndexTool.from_tool(og_tool)\n\n# Example 2: Initialize from LlamaHub Tools\nfrom llama_index.tools.wolfram_alpha import WolframAlphaToolSpec\nwolfram_spec = WolframAlphaToolSpec(app_id=\"<app_id>\")\nwolfram_tools = wolfram_spec.to_tool_list()\ntools = [LlamaIndexTool.from_tool(t) for t in wolfram_tools]\n\n# Example 3: Initialize Tool from a LlamaIndex Query Engine\nquery_engine = index.as_query_engine()\nquery_tool = LlamaIndexTool.from_query_engine(\n    query_engine,\n    name=\"Uber 2019 10K Query Tool\",\n    description=\"Use this tool to lookup the 2019 Uber 10K Annual Report\"\n)\n\n# Create and assign the tools to an agent\nagent = Agent(\n    role='Research Analyst',\n    goal='Provide up-to-date market analysis',\n    backstory='An expert analyst with a keen eye for market trends.',\n    tools=[tool, *tools, query_tool]\n)\n\n# rest of the code ...",
      "formatted_path": "Changelog > Using LlamaIndex Tools > Using LlamaIndex Tools",
      "enhanced_text": "Context: Changelog > Using LlamaIndex Tools > Using LlamaIndex Tools\n\nfrom crewai import Agent\nfrom crewai_tools import LlamaIndexTool\n\n# Example 1: Initialize from FunctionTool\nfrom llama_index.core.tools import FunctionTool\n\nyour_python_function = lambda ...: ...\nog_tool = FunctionTool.from_defaults(\n    your_python_function, \n    name=\"<name>\", \n    description='<description>'\n)\ntool = LlamaIndexTool.from_tool(og_tool)\n\n# Example 2: Initialize from LlamaHub Tools\nfrom llama_index.tools.wolfram_alpha import WolframAlphaToolSpec\nwolfram_spec = WolframAlphaToolSpec(app_id=\"<app_id>\")\nwolfram_tools = wolfram_spec.to_tool_list()\ntools = [LlamaIndexTool.from_tool(t) for t in wolfram_tools]\n\n# Example 3: Initialize Tool from a LlamaIndex Query Engine\nquery_engine = index.as_query_engine()\nquery_tool = LlamaIndexTool.from_query_engine(\n    query_engine,\n    name=\"Uber 2019 10K Query Tool\",\n    description=\"Use this tool to lookup the 2019 Uber 10K Annual Report\"\n)\n\n# Create and assign the tools to an agent\nagent = Agent(\n    role='Research Analyst',\n    goal='Provide up-to-date market analysis',\n    backstory='An expert analyst with a keen eye for market trends.',\n    tools=[tool, *tools, query_tool]\n)\n\n# rest of the code ..."
    },
    {
      "content": "Source: https://docs.crewai.com/concepts/llms A comprehensive guide to configuring and using Large Language Models (LLMs) in your CrewAI projects",
      "title": "LLMs",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "LLMs",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "LLMs",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > LLMs"
      },
      "enhanced_content": "Context: Changelog > LLMs\n\n# LLMs\n\nSource: https://docs.crewai.com/concepts/llms A comprehensive guide to configuring and using Large Language Models (LLMs) in your CrewAI projects",
      "formatted_path": "Changelog > LLMs",
      "enhanced_text": "Context: Changelog > LLMs\n\n LLMs\n\nSource: https://docs.crewai.com/concepts/llms A comprehensive guide to configuring and using Large Language Models (LLMs) in your CrewAI projects\n\nRelated sections:\n- \n- \n- \n- \n"
    },
    {
      "content": "Large Language Models (LLMs) are the core intelligence behind CrewAI agents. They enable agents to understand context, make decisions, and generate human-like responses. Here's what you need to know:",
      "title": "What are LLMs?",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "LLMs",
          "level": 1
        },
        {
          "title": "What are LLMs?",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "LLMs",
            "level": 1
          },
          {
            "title": "What are LLMs?",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > LLMs > What are LLMs?"
      },
      "enhanced_content": "Context: Changelog > LLMs > What are LLMs?\n\n## What are LLMs?\n\nLarge Language Models (LLMs) are the core intelligence behind CrewAI agents. They enable agents to understand context, make decisions, and generate human-like responses. Here's what you need to know:",
      "formatted_path": "Changelog > LLMs > What are LLMs?",
      "enhanced_text": "Context: Changelog > LLMs > What are LLMs?\n\n What are LLMs?\n\nLarge Language Models (LLMs) are the core intelligence behind CrewAI agents. They enable agents to understand context, make decisions, and generate human-like responses. Here's what you need to know:\n\nRelated sections:\n- \n"
    },
    {
      "content": "There are three ways to configure LLMs in CrewAI. Choose the method that best fits your workflow:",
      "title": "Setting Up Your LLM",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "LLMs",
          "level": 1
        },
        {
          "title": "Setting Up Your LLM",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "LLMs",
            "level": 1
          },
          {
            "title": "Setting Up Your LLM",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > LLMs > Setting Up Your LLM"
      },
      "enhanced_content": "Context: Changelog > LLMs > Setting Up Your LLM\n\n## Setting Up Your LLM\n\nThere are three ways to configure LLMs in CrewAI. Choose the method that best fits your workflow:",
      "formatted_path": "Changelog > LLMs > Setting Up Your LLM",
      "enhanced_text": "Context: Changelog > LLMs > Setting Up Your LLM\n\n Setting Up Your LLM\n\nThere are three ways to configure LLMs in CrewAI. Choose the method that best fits your workflow:"
    },
    {
      "content": "CrewAI supports a multitude of LLM providers, each offering unique features, authentication methods, and model capabilities.\nIn this section, you'll find detailed examples that help you select, configure, and optimize the LLM that best fits your project's needs.",
      "title": "Provider Configuration Examples",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "LLMs",
          "level": 1
        },
        {
          "title": "Provider Configuration Examples",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "LLMs",
            "level": 1
          },
          {
            "title": "Provider Configuration Examples",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > LLMs > Provider Configuration Examples"
      },
      "enhanced_content": "Context: Changelog > LLMs > Provider Configuration Examples\n\n## Provider Configuration Examples\n\nCrewAI supports a multitude of LLM providers, each offering unique features, authentication methods, and model capabilities.\nIn this section, you'll find detailed examples that help you select, configure, and optimize the LLM that best fits your project's needs.",
      "formatted_path": "Changelog > LLMs > Provider Configuration Examples",
      "enhanced_text": "Context: Changelog > LLMs > Provider Configuration Examples\n\n Provider Configuration Examples\n\nCrewAI supports a multitude of LLM providers, each offering unique features, authentication methods, and model capabilities.\nIn this section, you'll find detailed examples that help you select, configure, and optimize the LLM that best fits your project's needs.\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "CrewAI supports streaming responses from LLMs, allowing your application to receive and process outputs in real-time as they're generated.",
      "title": "Streaming Responses",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "LLMs",
          "level": 1
        },
        {
          "title": "Streaming Responses",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "LLMs",
            "level": 1
          },
          {
            "title": "Streaming Responses",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > LLMs > Streaming Responses"
      },
      "enhanced_content": "Context: Changelog > LLMs > Streaming Responses\n\n## Streaming Responses\n\nCrewAI supports streaming responses from LLMs, allowing your application to receive and process outputs in real-time as they're generated.",
      "formatted_path": "Changelog > LLMs > Streaming Responses",
      "enhanced_text": "Context: Changelog > LLMs > Streaming Responses\n\n Streaming Responses\n\nCrewAI supports streaming responses from LLMs, allowing your application to receive and process outputs in real-time as they're generated."
    },
    {
      "content": "from crewai import LLM\n\nclass Dog(BaseModel):\n    name: str\n    age: int\n    breed: str\n\n\nllm = LLM(model=\"gpt-4o\", response_format=Dog)\n\nresponse = llm.call(\n    \"Analyze the following messages and return the name, age, and breed. \"\n    \"Meet Kona! She is 3 years old and is a black german shepherd.\"\n)\nprint(response)\n\n# Output:\n# Dog(name='Kona', age=3, breed='black german shepherd')",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "LLMs",
          "level": 1
        },
        {
          "title": "Structured LLM Calls",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "LLMs",
            "level": 1
          },
          {
            "title": "Structured LLM Calls",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > LLMs > Structured LLM Calls"
      },
      "enhanced_content": "Context: Changelog > LLMs > Structured LLM Calls\n\nfrom crewai import LLM\n\nclass Dog(BaseModel):\n    name: str\n    age: int\n    breed: str\n\n\nllm = LLM(model=\"gpt-4o\", response_format=Dog)\n\nresponse = llm.call(\n    \"Analyze the following messages and return the name, age, and breed. \"\n    \"Meet Kona! She is 3 years old and is a black german shepherd.\"\n)\nprint(response)\n\n# Output:\n# Dog(name='Kona', age=3, breed='black german shepherd')",
      "formatted_path": "Changelog > LLMs > Structured LLM Calls",
      "enhanced_text": "Context: Changelog > LLMs > Structured LLM Calls\n\nfrom crewai import LLM\n\nclass Dog(BaseModel):\n    name: str\n    age: int\n    breed: str\n\n\nllm = LLM(model=\"gpt-4o\", response_format=Dog)\n\nresponse = llm.call(\n    \"Analyze the following messages and return the name, age, and breed. \"\n    \"Meet Kona! She is 3 years old and is a black german shepherd.\"\n)\nprint(response)\n\n# Output:\n# Dog(name='Kona', age=3, breed='black german shepherd')"
    },
    {
      "content": "Learn how to get the most out of your LLM configuration:",
      "title": "Advanced Features and Optimization",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "LLMs",
          "level": 1
        },
        {
          "title": "Advanced Features and Optimization",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "LLMs",
            "level": 1
          },
          {
            "title": "Advanced Features and Optimization",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > LLMs > Advanced Features and Optimization"
      },
      "enhanced_content": "Context: Changelog > LLMs > Advanced Features and Optimization\n\n## Advanced Features and Optimization\n\nLearn how to get the most out of your LLM configuration:",
      "formatted_path": "Changelog > LLMs > Advanced Features and Optimization",
      "enhanced_text": "Context: Changelog > LLMs > Advanced Features and Optimization\n\n Advanced Features and Optimization\n\nLearn how to get the most out of your LLM configuration:\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "Source: https://docs.crewai.com/concepts/memory Leveraging memory systems in the CrewAI framework to enhance agent capabilities.",
      "title": "Memory",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Memory",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Memory",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Memory"
      },
      "enhanced_content": "Context: Changelog > Memory\n\n# Memory\n\nSource: https://docs.crewai.com/concepts/memory Leveraging memory systems in the CrewAI framework to enhance agent capabilities.",
      "formatted_path": "Changelog > Memory",
      "enhanced_text": "Context: Changelog > Memory\n\n Memory\n\nSource: https://docs.crewai.com/concepts/memory Leveraging memory systems in the CrewAI framework to enhance agent capabilities.\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "The crewAI framework introduces a sophisticated memory system designed to significantly enhance the capabilities of AI agents.\nThis system comprises `short-term memory`, `long-term memory`, `entity memory`, and `contextual memory`, each serving a unique purpose in aiding agents to remember,\nreason, and learn from past interactions.",
      "title": "Introduction to Memory Systems in CrewAI",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Memory",
          "level": 1
        },
        {
          "title": "Introduction to Memory Systems in CrewAI",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Memory",
            "level": 1
          },
          {
            "title": "Introduction to Memory Systems in CrewAI",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Memory > Introduction to Memory Systems in CrewAI"
      },
      "enhanced_content": "Context: Changelog > Memory > Introduction to Memory Systems in CrewAI\n\n## Introduction to Memory Systems in CrewAI\n\nThe crewAI framework introduces a sophisticated memory system designed to significantly enhance the capabilities of AI agents.\nThis system comprises `short-term memory`, `long-term memory`, `entity memory`, and `contextual memory`, each serving a unique purpose in aiding agents to remember,\nreason, and learn from past interactions.",
      "formatted_path": "Changelog > Memory > Introduction to Memory Systems in CrewAI",
      "enhanced_text": "Context: Changelog > Memory > Introduction to Memory Systems in CrewAI\n\n Introduction to Memory Systems in CrewAI\n\nThe crewAI framework introduces a sophisticated memory system designed to significantly enhance the capabilities of AI agents.\nThis system comprises `short-term memory`, `long-term memory`, `entity memory`, and `contextual memory`, each serving a unique purpose in aiding agents to remember,\nreason, and learn from past interactions.\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "| Component             | Description                                                                                                                                                                                                      |\n| :-------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Short-Term Memory** | Temporarily stores recent interactions and outcomes using `RAG`, enabling agents to recall and utilize information relevant to their current context during the current executions.                              |\n| **Long-Term Memory**  | Preserves valuable insights and learnings from past executions, allowing agents to build and refine their knowledge over time.                                                                                   |\n| **Entity Memory**     | Captures and organizes information about entities (people, places, concepts) encountered during tasks, facilitating deeper understanding and relationship mapping. Uses `RAG` for storing entity information.    |\n| **Contextual Memory** | Maintains the context of interactions by combining `ShortTermMemory`, `LongTermMemory`, and `EntityMemory`, aiding in the coherence and relevance of agent responses over a sequence of tasks or a conversation. |\n| **User Memory**       | Stores user-specific information and preferences, enhancing personalization and user experience.                                                                                                                 |",
      "title": "Memory System Components",
      "type": "descriptive_text_oversized",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Memory",
          "level": 1
        },
        {
          "title": "Memory System Components",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Memory",
            "level": 1
          },
          {
            "title": "Memory System Components",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Memory > Memory System Components"
      },
      "enhanced_content": "Context: Changelog > Memory > Memory System Components\n\n## Memory System Components\n\n| Component             | Description                                                                                                                                                                                                      |\n| :-------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Short-Term Memory** | Temporarily stores recent interactions and outcomes using `RAG`, enabling agents to recall and utilize information relevant to their current context during the current executions.                              |\n| **Long-Term Memory**  | Preserves valuable insights and learnings from past executions, allowing agents to build and refine their knowledge over time.                                                                                   |\n| **Entity Memory**     | Captures and organizes information about entities (people, places, concepts) encountered during tasks, facilitating deeper understanding and relationship mapping. Uses `RAG` for storing entity information.    |\n| **Contextual Memory** | Maintains the context of interactions by combining `ShortTermMemory`, `LongTermMemory`, and `EntityMemory`, aiding in the coherence and relevance of agent responses over a sequence of tasks or a conversation. |\n| **User Memory**       | Stores user-specific information and preferences, enhancing personalization and user experience.                                                                                                                 |",
      "formatted_path": "Changelog > Memory > Memory System Components",
      "enhanced_text": "Context: Changelog > Memory > Memory System Components\n\n Memory System Components\n\n| Component             | Description                                                                                                                                                                                                      |\n| :-------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Short-Term Memory** | Temporarily stores recent interactions and outcomes using `RAG`, enabling agents to recall and utilize information relevant to their current context during the current executions.                              |\n| **Long-Term Memory**  | Preserves valuable insights and learnings from past executions, allowing agents to build and refine their knowledge over time.                                                                                   |\n| **Entity Memory**     | Captures and organizes information about entities (people, places, concepts) encountered during tasks, facilitating deeper understanding and relationship mapping. Uses `RAG` for storing entity information.    |\n| **Contextual Memory** | Maintains the context of interactions by combining `ShortTermMemory`, `LongTermMemory`, and `EntityMemory`, aiding in the coherence and relevance of agent responses over a sequence of tasks or a conversation. |\n| **User Memory**       | Stores user-specific information and preferences, enhancing personalization and user experience.                                                                                                                 |\n\nRelated sections:\n- \n"
    },
    {
      "content": "**Contextual Awareness**: With short-term and contextual memory, agents gain the ability to maintain context over a conversation or task sequence, leading to more coherent and relevant responses. **Experience Accumulation**: Long-term memory allows agents to accumulate experiences, learning from past actions to improve future decision-making and problem-solving. **Entity Understanding**: By maintaining entity memory, agents can recognize and remember key entities, enhancing their ability to process and interact with complex information.",
      "title": "How Memory Systems Empower Agents",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Memory",
          "level": 1
        },
        {
          "title": "How Memory Systems Empower Agents",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Memory",
            "level": 1
          },
          {
            "title": "How Memory Systems Empower Agents",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Memory > How Memory Systems Empower Agents"
      },
      "enhanced_content": "Context: Changelog > Memory > How Memory Systems Empower Agents\n\n## How Memory Systems Empower Agents\n\n**Contextual Awareness**: With short-term and contextual memory, agents gain the ability to maintain context over a conversation or task sequence, leading to more coherent and relevant responses. **Experience Accumulation**: Long-term memory allows agents to accumulate experiences, learning from past actions to improve future decision-making and problem-solving. **Entity Understanding**: By maintaining entity memory, agents can recognize and remember key entities, enhancing their ability to process and interact with complex information.",
      "formatted_path": "Changelog > Memory > How Memory Systems Empower Agents",
      "enhanced_text": "Context: Changelog > Memory > How Memory Systems Empower Agents\n\n How Memory Systems Empower Agents\n\n**Contextual Awareness**: With short-term and contextual memory, agents gain the ability to maintain context over a conversation or task sequence, leading to more coherent and relevant responses. **Experience Accumulation**: Long-term memory allows agents to accumulate experiences, learning from past actions to improve future decision-making and problem-solving. **Entity Understanding**: By maintaining entity memory, agents can recognize and remember key entities, enhancing their ability to process and interact with complex information.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "When configuring a crew, you can enable and customize each memory component to suit the crew's objectives and the nature of tasks it will perform.\nBy default, the memory system is disabled, and you can ensure it is active by setting `memory=True` in the crew configuration.\nThe memory will use OpenAI embeddings by default, but you can change it by setting `embedder` to a different model.\nIt's also possible to initialize the memory instance with your own instance. The 'embedder' only applies to **Short-Term Memory** which uses Chroma for RAG.\nThe **Long-Term Memory** uses SQLite3 to store task results. Currently, there is no way to override these storage implementations.\nThe data storage files are saved into a platform-specific location found using the appdirs package,\nand the name of the project can be overridden using the **CREWAI\\_STORAGE\\_DIR** environment variable.",
      "title": "Implementing Memory in Your Crew",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Memory",
          "level": 1
        },
        {
          "title": "Implementing Memory in Your Crew",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Memory",
            "level": 1
          },
          {
            "title": "Implementing Memory in Your Crew",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Memory > Implementing Memory in Your Crew"
      },
      "enhanced_content": "Context: Changelog > Memory > Implementing Memory in Your Crew\n\n## Implementing Memory in Your Crew\n\nWhen configuring a crew, you can enable and customize each memory component to suit the crew's objectives and the nature of tasks it will perform.\nBy default, the memory system is disabled, and you can ensure it is active by setting `memory=True` in the crew configuration.\nThe memory will use OpenAI embeddings by default, but you can change it by setting `embedder` to a different model.\nIt's also possible to initialize the memory instance with your own instance. The 'embedder' only applies to **Short-Term Memory** which uses Chroma for RAG.\nThe **Long-Term Memory** uses SQLite3 to store task results. Currently, there is no way to override these storage implementations.\nThe data storage files are saved into a platform-specific location found using the appdirs package,\nand the name of the project can be overridden using the **CREWAI\\_STORAGE\\_DIR** environment variable.",
      "formatted_path": "Changelog > Memory > Implementing Memory in Your Crew",
      "enhanced_text": "Context: Changelog > Memory > Implementing Memory in Your Crew\n\n Implementing Memory in Your Crew\n\nWhen configuring a crew, you can enable and customize each memory component to suit the crew's objectives and the nature of tasks it will perform.\nBy default, the memory system is disabled, and you can ensure it is active by setting `memory=True` in the crew configuration.\nThe memory will use OpenAI embeddings by default, but you can change it by setting `embedder` to a different model.\nIt's also possible to initialize the memory instance with your own instance. The 'embedder' only applies to **Short-Term Memory** which uses Chroma for RAG.\nThe **Long-Term Memory** uses SQLite3 to store task results. Currently, there is no way to override these storage implementations.\nThe data storage files are saved into a platform-specific location found using the appdirs package,\nand the name of the project can be overridden using the **CREWAI\\_STORAGE\\_DIR** environment variable.\n\nRelated sections:\n- \n"
    },
    {
      "content": "from crewai import Crew, Agent, Task, Process\n\n# Assemble your crew with memory capabilities\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Memory",
          "level": 1
        },
        {
          "title": "Implementing Memory in Your Crew",
          "level": 2
        },
        {
          "title": "Example: Configuring Memory for a Crew",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Memory",
            "level": 1
          },
          {
            "title": "Implementing Memory in Your Crew",
            "level": 2
          },
          {
            "title": "Example: Configuring Memory for a Crew",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Memory > Implementing Memory in Your Crew > Example: Configuring Memory for a Crew"
      },
      "enhanced_content": "Context: Changelog > Memory > Implementing Memory in Your Crew > Example: Configuring Memory for a Crew\n\nfrom crewai import Crew, Agent, Task, Process\n\n# Assemble your crew with memory capabilities\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True\n)",
      "formatted_path": "Changelog > Memory > Implementing Memory in Your Crew > Example: Configuring Memory for a Crew",
      "enhanced_text": "Context: Changelog > Memory > Implementing Memory in Your Crew > Example: Configuring Memory for a Crew\n\nfrom crewai import Crew, Agent, Task, Process\n\n# Assemble your crew with memory capabilities\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True\n)"
    },
    {
      "content": "from crewai import Crew, Process\nfrom crewai.memory import LongTermMemory, ShortTermMemory, EntityMemory\nfrom crewai.memory.storage.rag_storage import RAGStorage\nfrom crewai.memory.storage.ltm_sqlite_storage import LTMSQLiteStorage\nfrom typing import List, Optional\n\n# Assemble your crew with memory capabilities\nmy_crew: Crew = Crew(\n    agents = [...],\n    tasks = [...],\n    process = Process.sequential,\n    memory = True,\n    # Long-term memory for persistent storage across sessions\n    long_term_memory = LongTermMemory(\n        storage=LTMSQLiteStorage(\n            db_path=\"/my_crew1/long_term_memory_storage.db\"\n        )\n    ),\n    # Short-term memory for current context using RAG\n    short_term_memory = ShortTermMemory(\n        storage = RAGStorage(\n                embedder_config={\n                    \"provider\": \"openai\",\n                    \"config\": {\n                        \"model\": 'text-embedding-3-small'\n                    }\n                },\n                type=\"short_term\",\n                path=\"/my_crew1/\"\n            )\n        ),\n    ),\n    # Entity memory for tracking key information about entities\n    entity_memory = EntityMemory(\n        storage=RAGStorage(\n            embedder_config={\n                \"provider\": \"openai\",\n                \"config\": {\n                    \"model\": 'text-embedding-3-small'\n                }\n            },\n            type=\"short_term\",\n            path=\"/my_crew1/\"\n        )\n    ),\n    verbose=True,\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Memory",
          "level": 1
        },
        {
          "title": "Implementing Memory in Your Crew",
          "level": 2
        },
        {
          "title": "Example: Use Custom Memory Instances e.g FAISS as the VectorDB",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Memory",
            "level": 1
          },
          {
            "title": "Implementing Memory in Your Crew",
            "level": 2
          },
          {
            "title": "Example: Use Custom Memory Instances e.g FAISS as the VectorDB",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Memory > Implementing Memory in Your Crew > Example: Use Custom Memory Instances e.g FAISS as the VectorDB"
      },
      "enhanced_content": "Context: Changelog > Memory > Implementing Memory in Your Crew > Example: Use Custom Memory Instances e.g FAISS as the VectorDB\n\nfrom crewai import Crew, Process\nfrom crewai.memory import LongTermMemory, ShortTermMemory, EntityMemory\nfrom crewai.memory.storage.rag_storage import RAGStorage\nfrom crewai.memory.storage.ltm_sqlite_storage import LTMSQLiteStorage\nfrom typing import List, Optional\n\n# Assemble your crew with memory capabilities\nmy_crew: Crew = Crew(\n    agents = [...],\n    tasks = [...],\n    process = Process.sequential,\n    memory = True,\n    # Long-term memory for persistent storage across sessions\n    long_term_memory = LongTermMemory(\n        storage=LTMSQLiteStorage(\n            db_path=\"/my_crew1/long_term_memory_storage.db\"\n        )\n    ),\n    # Short-term memory for current context using RAG\n    short_term_memory = ShortTermMemory(\n        storage = RAGStorage(\n                embedder_config={\n                    \"provider\": \"openai\",\n                    \"config\": {\n                        \"model\": 'text-embedding-3-small'\n                    }\n                },\n                type=\"short_term\",\n                path=\"/my_crew1/\"\n            )\n        ),\n    ),\n    # Entity memory for tracking key information about entities\n    entity_memory = EntityMemory(\n        storage=RAGStorage(\n            embedder_config={\n                \"provider\": \"openai\",\n                \"config\": {\n                    \"model\": 'text-embedding-3-small'\n                }\n            },\n            type=\"short_term\",\n            path=\"/my_crew1/\"\n        )\n    ),\n    verbose=True,\n)",
      "formatted_path": "Changelog > Memory > Implementing Memory in Your Crew > Example: Use Custom Memory Instances e.g FAISS as the VectorDB",
      "enhanced_text": "Context: Changelog > Memory > Implementing Memory in Your Crew > Example: Use Custom Memory Instances e.g FAISS as the VectorDB\n\nfrom crewai import Crew, Process\nfrom crewai.memory import LongTermMemory, ShortTermMemory, EntityMemory\nfrom crewai.memory.storage.rag_storage import RAGStorage\nfrom crewai.memory.storage.ltm_sqlite_storage import LTMSQLiteStorage\nfrom typing import List, Optional\n\n# Assemble your crew with memory capabilities\nmy_crew: Crew = Crew(\n    agents = [...],\n    tasks = [...],\n    process = Process.sequential,\n    memory = True,\n    # Long-term memory for persistent storage across sessions\n    long_term_memory = LongTermMemory(\n        storage=LTMSQLiteStorage(\n            db_path=\"/my_crew1/long_term_memory_storage.db\"\n        )\n    ),\n    # Short-term memory for current context using RAG\n    short_term_memory = ShortTermMemory(\n        storage = RAGStorage(\n                embedder_config={\n                    \"provider\": \"openai\",\n                    \"config\": {\n                        \"model\": 'text-embedding-3-small'\n                    }\n                },\n                type=\"short_term\",\n                path=\"/my_crew1/\"\n            )\n        ),\n    ),\n    # Entity memory for tracking key information about entities\n    entity_memory = EntityMemory(\n        storage=RAGStorage(\n            embedder_config={\n                \"provider\": \"openai\",\n                \"config\": {\n                    \"model\": 'text-embedding-3-small'\n                }\n            },\n            type=\"short_term\",\n            path=\"/my_crew1/\"\n        )\n    ),\n    verbose=True,\n)"
    },
    {
      "content": "from crewai import Crew\nfrom crewai.memory import LongTermMemory\n\n# Simple memory configuration\ncrew = Crew(memory=True)  # Uses default storage locations",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Memory",
          "level": 1
        },
        {
          "title": "Configuration Examples",
          "level": 2
        },
        {
          "title": "Basic Memory Configuration",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Memory",
            "level": 1
          },
          {
            "title": "Configuration Examples",
            "level": 2
          },
          {
            "title": "Basic Memory Configuration",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Memory > Configuration Examples > Basic Memory Configuration"
      },
      "enhanced_content": "Context: Changelog > Memory > Configuration Examples > Basic Memory Configuration\n\nfrom crewai import Crew\nfrom crewai.memory import LongTermMemory\n\n# Simple memory configuration\ncrew = Crew(memory=True)  # Uses default storage locations",
      "formatted_path": "Changelog > Memory > Configuration Examples > Basic Memory Configuration",
      "enhanced_text": "Context: Changelog > Memory > Configuration Examples > Basic Memory Configuration\n\nfrom crewai import Crew\nfrom crewai.memory import LongTermMemory\n\n# Simple memory configuration\ncrew = Crew(memory=True)  # Uses default storage locations"
    },
    {
      "content": "from crewai import Crew\nfrom crewai.memory import LongTermMemory\nfrom crewai.memory.storage.ltm_sqlite_storage import LTMSQLiteStorage\n\n# Configure custom storage paths\ncrew = Crew(\n    memory=True,\n    long_term_memory=LongTermMemory(\n        storage=LTMSQLiteStorage(db_path=\"./memory.db\")\n    )\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Memory",
          "level": 1
        },
        {
          "title": "Configuration Examples",
          "level": 2
        },
        {
          "title": "Custom Storage Configuration",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Memory",
            "level": 1
          },
          {
            "title": "Configuration Examples",
            "level": 2
          },
          {
            "title": "Custom Storage Configuration",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Memory > Configuration Examples > Custom Storage Configuration"
      },
      "enhanced_content": "Context: Changelog > Memory > Configuration Examples > Custom Storage Configuration\n\nfrom crewai import Crew\nfrom crewai.memory import LongTermMemory\nfrom crewai.memory.storage.ltm_sqlite_storage import LTMSQLiteStorage\n\n# Configure custom storage paths\ncrew = Crew(\n    memory=True,\n    long_term_memory=LongTermMemory(\n        storage=LTMSQLiteStorage(db_path=\"./memory.db\")\n    )\n)",
      "formatted_path": "Changelog > Memory > Configuration Examples > Custom Storage Configuration",
      "enhanced_text": "Context: Changelog > Memory > Configuration Examples > Custom Storage Configuration\n\nfrom crewai import Crew\nfrom crewai.memory import LongTermMemory\nfrom crewai.memory.storage.ltm_sqlite_storage import LTMSQLiteStorage\n\n# Configure custom storage paths\ncrew = Crew(\n    memory=True,\n    long_term_memory=LongTermMemory(\n        storage=LTMSQLiteStorage(db_path=\"./memory.db\")\n    )\n)"
    },
    {
      "content": "import os\nfrom crewai import Crew, Process\nfrom mem0 import MemoryClient\n\n# Set environment variables for Mem0\nos.environ[\"MEM0_API_KEY\"] = \"m0-xx\"\n\n# Step 1: Record preferences based on past conversation or user input\nclient = MemoryClient()\nmessages = [\n    {\"role\": \"user\", \"content\": \"Hi there! I'm planning a vacation and could use some advice.\"},\n    {\"role\": \"assistant\", \"content\": \"Hello! I'd be happy to help with your vacation planning. What kind of destination do you prefer?\"},\n    {\"role\": \"user\", \"content\": \"I am more of a beach person than a mountain person.\"},\n    {\"role\": \"assistant\", \"content\": \"That's interesting. Do you like hotels or Airbnb?\"},\n    {\"role\": \"user\", \"content\": \"I like Airbnb more.\"},\n]\nclient.add(messages, user_id=\"john\")\n\n# Step 2: Create a Crew with User Memory\n\ncrew = Crew(\n    agents=[...],\n    tasks=[...],\n    verbose=True,\n    process=Process.sequential,\n    memory=True,\n    memory_config={\n        \"provider\": \"mem0\",\n        \"config\": {\"user_id\": \"john\"},\n    },\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Memory",
          "level": 1
        },
        {
          "title": "Integrating Mem0 for Enhanced User Memory",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Memory",
            "level": 1
          },
          {
            "title": "Integrating Mem0 for Enhanced User Memory",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Memory > Integrating Mem0 for Enhanced User Memory"
      },
      "enhanced_content": "Context: Changelog > Memory > Integrating Mem0 for Enhanced User Memory\n\nimport os\nfrom crewai import Crew, Process\nfrom mem0 import MemoryClient\n\n# Set environment variables for Mem0\nos.environ[\"MEM0_API_KEY\"] = \"m0-xx\"\n\n# Step 1: Record preferences based on past conversation or user input\nclient = MemoryClient()\nmessages = [\n    {\"role\": \"user\", \"content\": \"Hi there! I'm planning a vacation and could use some advice.\"},\n    {\"role\": \"assistant\", \"content\": \"Hello! I'd be happy to help with your vacation planning. What kind of destination do you prefer?\"},\n    {\"role\": \"user\", \"content\": \"I am more of a beach person than a mountain person.\"},\n    {\"role\": \"assistant\", \"content\": \"That's interesting. Do you like hotels or Airbnb?\"},\n    {\"role\": \"user\", \"content\": \"I like Airbnb more.\"},\n]\nclient.add(messages, user_id=\"john\")\n\n# Step 2: Create a Crew with User Memory\n\ncrew = Crew(\n    agents=[...],\n    tasks=[...],\n    verbose=True,\n    process=Process.sequential,\n    memory=True,\n    memory_config={\n        \"provider\": \"mem0\",\n        \"config\": {\"user_id\": \"john\"},\n    },\n)",
      "formatted_path": "Changelog > Memory > Integrating Mem0 for Enhanced User Memory",
      "enhanced_text": "Context: Changelog > Memory > Integrating Mem0 for Enhanced User Memory\n\nimport os\nfrom crewai import Crew, Process\nfrom mem0 import MemoryClient\n\n# Set environment variables for Mem0\nos.environ[\"MEM0_API_KEY\"] = \"m0-xx\"\n\n# Step 1: Record preferences based on past conversation or user input\nclient = MemoryClient()\nmessages = [\n    {\"role\": \"user\", \"content\": \"Hi there! I'm planning a vacation and could use some advice.\"},\n    {\"role\": \"assistant\", \"content\": \"Hello! I'd be happy to help with your vacation planning. What kind of destination do you prefer?\"},\n    {\"role\": \"user\", \"content\": \"I am more of a beach person than a mountain person.\"},\n    {\"role\": \"assistant\", \"content\": \"That's interesting. Do you like hotels or Airbnb?\"},\n    {\"role\": \"user\", \"content\": \"I like Airbnb more.\"},\n]\nclient.add(messages, user_id=\"john\")\n\n# Step 2: Create a Crew with User Memory\n\ncrew = Crew(\n    agents=[...],\n    tasks=[...],\n    verbose=True,\n    process=Process.sequential,\n    memory=True,\n    memory_config={\n        \"provider\": \"mem0\",\n        \"config\": {\"user_id\": \"john\"},\n    },\n)"
    },
    {
      "content": "from crewai import Crew\n\ncrew = Crew(\n    agents=[...],\n    tasks=[...],\n    verbose=True,\n    memory=True,\n    memory_config={\n        \"provider\": \"mem0\",\n        \"config\": {\"user_id\": \"john\", \"org_id\": \"my_org_id\", \"project_id\": \"my_project_id\"},\n    },\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Memory",
          "level": 1
        },
        {
          "title": "Memory Configuration Options",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Memory",
            "level": 1
          },
          {
            "title": "Memory Configuration Options",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Memory > Memory Configuration Options"
      },
      "enhanced_content": "Context: Changelog > Memory > Memory Configuration Options\n\nfrom crewai import Crew\n\ncrew = Crew(\n    agents=[...],\n    tasks=[...],\n    verbose=True,\n    memory=True,\n    memory_config={\n        \"provider\": \"mem0\",\n        \"config\": {\"user_id\": \"john\", \"org_id\": \"my_org_id\", \"project_id\": \"my_project_id\"},\n    },\n)",
      "formatted_path": "Changelog > Memory > Memory Configuration Options",
      "enhanced_text": "Context: Changelog > Memory > Memory Configuration Options\n\nfrom crewai import Crew\n\ncrew = Crew(\n    agents=[...],\n    tasks=[...],\n    verbose=True,\n    memory=True,\n    memory_config={\n        \"provider\": \"mem0\",\n        \"config\": {\"user_id\": \"john\", \"org_id\": \"my_org_id\", \"project_id\": \"my_project_id\"},\n    },\n)"
    },
    {
      "content": "from crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"openai\",\n        \"config\": {\n            \"model\": 'text-embedding-3-small'\n        }\n    }\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Memory",
          "level": 1
        },
        {
          "title": "Additional Embedding Providers",
          "level": 2
        },
        {
          "title": "Using OpenAI embeddings (already default)",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Memory",
            "level": 1
          },
          {
            "title": "Additional Embedding Providers",
            "level": 2
          },
          {
            "title": "Using OpenAI embeddings (already default)",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Memory > Additional Embedding Providers > Using OpenAI embeddings (already default)"
      },
      "enhanced_content": "Context: Changelog > Memory > Additional Embedding Providers > Using OpenAI embeddings (already default)\n\nfrom crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"openai\",\n        \"config\": {\n            \"model\": 'text-embedding-3-small'\n        }\n    }\n)",
      "formatted_path": "Changelog > Memory > Additional Embedding Providers > Using OpenAI embeddings (already default)",
      "enhanced_text": "Context: Changelog > Memory > Additional Embedding Providers > Using OpenAI embeddings (already default)\n\nfrom crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"openai\",\n        \"config\": {\n            \"model\": 'text-embedding-3-small'\n        }\n    }\n)"
    },
    {
      "content": "from crewai import Crew, Agent, Task, Process\nfrom chromadb.utils.embedding_functions import OpenAIEmbeddingFunction\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"openai\",\n        \"config\": {\n            \"model\": 'text-embedding-3-small'\n        }\n    }\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Memory",
          "level": 1
        },
        {
          "title": "Additional Embedding Providers",
          "level": 2
        },
        {
          "title": "Using OpenAI embeddings (already default)",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Memory",
            "level": 1
          },
          {
            "title": "Additional Embedding Providers",
            "level": 2
          },
          {
            "title": "Using OpenAI embeddings (already default)",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Memory > Additional Embedding Providers > Using OpenAI embeddings (already default)"
      },
      "enhanced_content": "Context: Changelog > Memory > Additional Embedding Providers > Using OpenAI embeddings (already default)\n\nfrom crewai import Crew, Agent, Task, Process\nfrom chromadb.utils.embedding_functions import OpenAIEmbeddingFunction\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"openai\",\n        \"config\": {\n            \"model\": 'text-embedding-3-small'\n        }\n    }\n)",
      "formatted_path": "Changelog > Memory > Additional Embedding Providers > Using OpenAI embeddings (already default)",
      "enhanced_text": "Context: Changelog > Memory > Additional Embedding Providers > Using OpenAI embeddings (already default)\n\nfrom crewai import Crew, Agent, Task, Process\nfrom chromadb.utils.embedding_functions import OpenAIEmbeddingFunction\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"openai\",\n        \"config\": {\n            \"model\": 'text-embedding-3-small'\n        }\n    }\n)"
    },
    {
      "content": "from crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"ollama\",\n        \"config\": {\n            \"model\": \"mxbai-embed-large\"\n        }\n    }\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Memory",
          "level": 1
        },
        {
          "title": "Additional Embedding Providers",
          "level": 2
        },
        {
          "title": "Using Ollama embeddings",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Memory",
            "level": 1
          },
          {
            "title": "Additional Embedding Providers",
            "level": 2
          },
          {
            "title": "Using Ollama embeddings",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Memory > Additional Embedding Providers > Using Ollama embeddings"
      },
      "enhanced_content": "Context: Changelog > Memory > Additional Embedding Providers > Using Ollama embeddings\n\nfrom crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"ollama\",\n        \"config\": {\n            \"model\": \"mxbai-embed-large\"\n        }\n    }\n)",
      "formatted_path": "Changelog > Memory > Additional Embedding Providers > Using Ollama embeddings",
      "enhanced_text": "Context: Changelog > Memory > Additional Embedding Providers > Using Ollama embeddings\n\nfrom crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"ollama\",\n        \"config\": {\n            \"model\": \"mxbai-embed-large\"\n        }\n    }\n)"
    },
    {
      "content": "from chromadb.utils.embedding_functions import OpenAIEmbeddingFunction\nfrom crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"openai\",\n        \"config\": {\n            \"api_key\": \"YOUR_API_KEY\",\n            \"api_base\": \"YOUR_API_BASE_PATH\",\n            \"api_version\": \"YOUR_API_VERSION\",\n            \"model_name\": 'text-embedding-3-small'\n        }\n    }\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Memory",
          "level": 1
        },
        {
          "title": "Additional Embedding Providers",
          "level": 2
        },
        {
          "title": "Using Azure OpenAI embeddings",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Memory",
            "level": 1
          },
          {
            "title": "Additional Embedding Providers",
            "level": 2
          },
          {
            "title": "Using Azure OpenAI embeddings",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Memory > Additional Embedding Providers > Using Azure OpenAI embeddings"
      },
      "enhanced_content": "Context: Changelog > Memory > Additional Embedding Providers > Using Azure OpenAI embeddings\n\nfrom chromadb.utils.embedding_functions import OpenAIEmbeddingFunction\nfrom crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"openai\",\n        \"config\": {\n            \"api_key\": \"YOUR_API_KEY\",\n            \"api_base\": \"YOUR_API_BASE_PATH\",\n            \"api_version\": \"YOUR_API_VERSION\",\n            \"model_name\": 'text-embedding-3-small'\n        }\n    }\n)",
      "formatted_path": "Changelog > Memory > Additional Embedding Providers > Using Azure OpenAI embeddings",
      "enhanced_text": "Context: Changelog > Memory > Additional Embedding Providers > Using Azure OpenAI embeddings\n\nfrom chromadb.utils.embedding_functions import OpenAIEmbeddingFunction\nfrom crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"openai\",\n        \"config\": {\n            \"api_key\": \"YOUR_API_KEY\",\n            \"api_base\": \"YOUR_API_BASE_PATH\",\n            \"api_version\": \"YOUR_API_VERSION\",\n            \"model_name\": 'text-embedding-3-small'\n        }\n    }\n)"
    },
    {
      "content": "from chromadb.utils.embedding_functions import GoogleVertexEmbeddingFunction\nfrom crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"vertexai\",\n        \"config\": {\n            \"project_id\"=\"YOUR_PROJECT_ID\",\n            \"region\"=\"YOUR_REGION\",\n            \"api_key\"=\"YOUR_API_KEY\",\n            \"model_name\"=\"textembedding-gecko\"\n        }\n    }\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Memory",
          "level": 1
        },
        {
          "title": "Additional Embedding Providers",
          "level": 2
        },
        {
          "title": "Using Vertex AI embeddings",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Memory",
            "level": 1
          },
          {
            "title": "Additional Embedding Providers",
            "level": 2
          },
          {
            "title": "Using Vertex AI embeddings",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Memory > Additional Embedding Providers > Using Vertex AI embeddings"
      },
      "enhanced_content": "Context: Changelog > Memory > Additional Embedding Providers > Using Vertex AI embeddings\n\nfrom chromadb.utils.embedding_functions import GoogleVertexEmbeddingFunction\nfrom crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"vertexai\",\n        \"config\": {\n            \"project_id\"=\"YOUR_PROJECT_ID\",\n            \"region\"=\"YOUR_REGION\",\n            \"api_key\"=\"YOUR_API_KEY\",\n            \"model_name\"=\"textembedding-gecko\"\n        }\n    }\n)",
      "formatted_path": "Changelog > Memory > Additional Embedding Providers > Using Vertex AI embeddings",
      "enhanced_text": "Context: Changelog > Memory > Additional Embedding Providers > Using Vertex AI embeddings\n\nfrom chromadb.utils.embedding_functions import GoogleVertexEmbeddingFunction\nfrom crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"vertexai\",\n        \"config\": {\n            \"project_id\"=\"YOUR_PROJECT_ID\",\n            \"region\"=\"YOUR_REGION\",\n            \"api_key\"=\"YOUR_API_KEY\",\n            \"model_name\"=\"textembedding-gecko\"\n        }\n    }\n)"
    },
    {
      "content": "from crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"cohere\",\n        \"config\": {\n            \"api_key\": \"YOUR_API_KEY\",\n            \"model\": \"<model_name>\"\n        }\n    }\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Memory",
          "level": 1
        },
        {
          "title": "Additional Embedding Providers",
          "level": 2
        },
        {
          "title": "Using Cohere embeddings",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Memory",
            "level": 1
          },
          {
            "title": "Additional Embedding Providers",
            "level": 2
          },
          {
            "title": "Using Cohere embeddings",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Memory > Additional Embedding Providers > Using Cohere embeddings"
      },
      "enhanced_content": "Context: Changelog > Memory > Additional Embedding Providers > Using Cohere embeddings\n\nfrom crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"cohere\",\n        \"config\": {\n            \"api_key\": \"YOUR_API_KEY\",\n            \"model\": \"<model_name>\"\n        }\n    }\n)",
      "formatted_path": "Changelog > Memory > Additional Embedding Providers > Using Cohere embeddings",
      "enhanced_text": "Context: Changelog > Memory > Additional Embedding Providers > Using Cohere embeddings\n\nfrom crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"cohere\",\n        \"config\": {\n            \"api_key\": \"YOUR_API_KEY\",\n            \"model\": \"<model_name>\"\n        }\n    }\n)"
    },
    {
      "content": "from crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"voyageai\",\n        \"config\": {\n            \"api_key\": \"YOUR_API_KEY\",\n            \"model\": \"<model_name>\"\n        }\n    }\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Memory",
          "level": 1
        },
        {
          "title": "Additional Embedding Providers",
          "level": 2
        },
        {
          "title": "Using VoyageAI embeddings",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Memory",
            "level": 1
          },
          {
            "title": "Additional Embedding Providers",
            "level": 2
          },
          {
            "title": "Using VoyageAI embeddings",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Memory > Additional Embedding Providers > Using VoyageAI embeddings"
      },
      "enhanced_content": "Context: Changelog > Memory > Additional Embedding Providers > Using VoyageAI embeddings\n\nfrom crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"voyageai\",\n        \"config\": {\n            \"api_key\": \"YOUR_API_KEY\",\n            \"model\": \"<model_name>\"\n        }\n    }\n)",
      "formatted_path": "Changelog > Memory > Additional Embedding Providers > Using VoyageAI embeddings",
      "enhanced_text": "Context: Changelog > Memory > Additional Embedding Providers > Using VoyageAI embeddings\n\nfrom crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"voyageai\",\n        \"config\": {\n            \"api_key\": \"YOUR_API_KEY\",\n            \"model\": \"<model_name>\"\n        }\n    }\n)"
    },
    {
      "content": "from crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"huggingface\",\n        \"config\": {\n            \"api_url\": \"<api_url>\",\n        }\n    }\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Memory",
          "level": 1
        },
        {
          "title": "Additional Embedding Providers",
          "level": 2
        },
        {
          "title": "Using HuggingFace embeddings",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Memory",
            "level": 1
          },
          {
            "title": "Additional Embedding Providers",
            "level": 2
          },
          {
            "title": "Using HuggingFace embeddings",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Memory > Additional Embedding Providers > Using HuggingFace embeddings"
      },
      "enhanced_content": "Context: Changelog > Memory > Additional Embedding Providers > Using HuggingFace embeddings\n\nfrom crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"huggingface\",\n        \"config\": {\n            \"api_url\": \"<api_url>\",\n        }\n    }\n)",
      "formatted_path": "Changelog > Memory > Additional Embedding Providers > Using HuggingFace embeddings",
      "enhanced_text": "Context: Changelog > Memory > Additional Embedding Providers > Using HuggingFace embeddings\n\nfrom crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"huggingface\",\n        \"config\": {\n            \"api_url\": \"<api_url>\",\n        }\n    }\n)"
    },
    {
      "content": "from crewai import Crew, Agent, Task, Process\n\n# Note: Ensure you have installed and imported `ibm_watsonx_ai` for Watson embeddings to work.\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"watson\",\n        \"config\": {\n            \"model\": \"<model_name>\",\n            \"api_url\": \"<api_url>\",\n            \"api_key\": \"<YOUR_API_KEY>\",\n            \"project_id\": \"<YOUR_PROJECT_ID>\",\n        }\n    }\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Memory",
          "level": 1
        },
        {
          "title": "Additional Embedding Providers",
          "level": 2
        },
        {
          "title": "Using Watson embeddings",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Memory",
            "level": 1
          },
          {
            "title": "Additional Embedding Providers",
            "level": 2
          },
          {
            "title": "Using Watson embeddings",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Memory > Additional Embedding Providers > Using Watson embeddings"
      },
      "enhanced_content": "Context: Changelog > Memory > Additional Embedding Providers > Using Watson embeddings\n\nfrom crewai import Crew, Agent, Task, Process\n\n# Note: Ensure you have installed and imported `ibm_watsonx_ai` for Watson embeddings to work.\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"watson\",\n        \"config\": {\n            \"model\": \"<model_name>\",\n            \"api_url\": \"<api_url>\",\n            \"api_key\": \"<YOUR_API_KEY>\",\n            \"project_id\": \"<YOUR_PROJECT_ID>\",\n        }\n    }\n)",
      "formatted_path": "Changelog > Memory > Additional Embedding Providers > Using Watson embeddings",
      "enhanced_text": "Context: Changelog > Memory > Additional Embedding Providers > Using Watson embeddings\n\nfrom crewai import Crew, Agent, Task, Process\n\n# Note: Ensure you have installed and imported `ibm_watsonx_ai` for Watson embeddings to work.\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"watson\",\n        \"config\": {\n            \"model\": \"<model_name>\",\n            \"api_url\": \"<api_url>\",\n            \"api_key\": \"<YOUR_API_KEY>\",\n            \"project_id\": \"<YOUR_PROJECT_ID>\",\n        }\n    }\n)"
    },
    {
      "content": "# Note: Ensure you have installed `boto3` for Bedrock embeddings to work.\n\nimport os\nimport boto3\nfrom crewai import Crew, Agent, Task, Process\n\nboto3_session = boto3.Session(\n    region_name=os.environ.get(\"AWS_REGION_NAME\"),\n    aws_access_key_id=os.environ.get(\"AWS_ACCESS_KEY_ID\"),\n    aws_secret_access_key=os.environ.get(\"AWS_SECRET_ACCESS_KEY\")\n)\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    embedder={\n    \"provider\": \"bedrock\",\n        \"config\":{\n            \"session\": boto3_session,\n            \"model\": \"amazon.titan-embed-text-v2:0\",\n            \"vector_dimension\": 1024\n        }\n    }\n    verbose=True\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Memory",
          "level": 1
        },
        {
          "title": "Additional Embedding Providers",
          "level": 2
        },
        {
          "title": "Using Amazon Bedrock embeddings",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Memory",
            "level": 1
          },
          {
            "title": "Additional Embedding Providers",
            "level": 2
          },
          {
            "title": "Using Amazon Bedrock embeddings",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Memory > Additional Embedding Providers > Using Amazon Bedrock embeddings"
      },
      "enhanced_content": "Context: Changelog > Memory > Additional Embedding Providers > Using Amazon Bedrock embeddings\n\n# Note: Ensure you have installed `boto3` for Bedrock embeddings to work.\n\nimport os\nimport boto3\nfrom crewai import Crew, Agent, Task, Process\n\nboto3_session = boto3.Session(\n    region_name=os.environ.get(\"AWS_REGION_NAME\"),\n    aws_access_key_id=os.environ.get(\"AWS_ACCESS_KEY_ID\"),\n    aws_secret_access_key=os.environ.get(\"AWS_SECRET_ACCESS_KEY\")\n)\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    embedder={\n    \"provider\": \"bedrock\",\n        \"config\":{\n            \"session\": boto3_session,\n            \"model\": \"amazon.titan-embed-text-v2:0\",\n            \"vector_dimension\": 1024\n        }\n    }\n    verbose=True\n)",
      "formatted_path": "Changelog > Memory > Additional Embedding Providers > Using Amazon Bedrock embeddings",
      "enhanced_text": "Context: Changelog > Memory > Additional Embedding Providers > Using Amazon Bedrock embeddings\n\n# Note: Ensure you have installed `boto3` for Bedrock embeddings to work.\n\nimport os\nimport boto3\nfrom crewai import Crew, Agent, Task, Process\n\nboto3_session = boto3.Session(\n    region_name=os.environ.get(\"AWS_REGION_NAME\"),\n    aws_access_key_id=os.environ.get(\"AWS_ACCESS_KEY_ID\"),\n    aws_secret_access_key=os.environ.get(\"AWS_SECRET_ACCESS_KEY\")\n)\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    embedder={\n    \"provider\": \"bedrock\",\n        \"config\":{\n            \"session\": boto3_session,\n            \"model\": \"amazon.titan-embed-text-v2:0\",\n            \"vector_dimension\": 1024\n        }\n    }\n    verbose=True\n)"
    },
    {
      "content": "from crewai import Crew, Agent, Task, Process\nfrom chromadb import Documents, EmbeddingFunction, Embeddings\n\n# Create a custom embedding function\nclass CustomEmbedder(EmbeddingFunction):\n    def __call__(self, input: Documents) -> Embeddings:\n        # generate embeddings\n        return [1, 2, 3] # this is a dummy embedding\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"custom\",\n        \"config\": {\n            \"embedder\": CustomEmbedder()\n        }\n    }\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Memory",
          "level": 1
        },
        {
          "title": "Additional Embedding Providers",
          "level": 2
        },
        {
          "title": "Adding Custom Embedding Function",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Memory",
            "level": 1
          },
          {
            "title": "Additional Embedding Providers",
            "level": 2
          },
          {
            "title": "Adding Custom Embedding Function",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Memory > Additional Embedding Providers > Adding Custom Embedding Function"
      },
      "enhanced_content": "Context: Changelog > Memory > Additional Embedding Providers > Adding Custom Embedding Function\n\nfrom crewai import Crew, Agent, Task, Process\nfrom chromadb import Documents, EmbeddingFunction, Embeddings\n\n# Create a custom embedding function\nclass CustomEmbedder(EmbeddingFunction):\n    def __call__(self, input: Documents) -> Embeddings:\n        # generate embeddings\n        return [1, 2, 3] # this is a dummy embedding\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"custom\",\n        \"config\": {\n            \"embedder\": CustomEmbedder()\n        }\n    }\n)",
      "formatted_path": "Changelog > Memory > Additional Embedding Providers > Adding Custom Embedding Function",
      "enhanced_text": "Context: Changelog > Memory > Additional Embedding Providers > Adding Custom Embedding Function\n\nfrom crewai import Crew, Agent, Task, Process\nfrom chromadb import Documents, EmbeddingFunction, Embeddings\n\n# Create a custom embedding function\nclass CustomEmbedder(EmbeddingFunction):\n    def __call__(self, input: Documents) -> Embeddings:\n        # generate embeddings\n        return [1, 2, 3] # this is a dummy embedding\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"custom\",\n        \"config\": {\n            \"embedder\": CustomEmbedder()\n        }\n    }\n)"
    },
    {
      "content": "crewai reset-memories [OPTIONS]",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Memory",
          "level": 1
        },
        {
          "title": "Additional Embedding Providers",
          "level": 2
        },
        {
          "title": "Resetting Memory via cli",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Memory",
            "level": 1
          },
          {
            "title": "Additional Embedding Providers",
            "level": 2
          },
          {
            "title": "Resetting Memory via cli",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Memory > Additional Embedding Providers > Resetting Memory via cli"
      },
      "enhanced_content": "Context: Changelog > Memory > Additional Embedding Providers > Resetting Memory via cli\n\ncrewai reset-memories [OPTIONS]",
      "formatted_path": "Changelog > Memory > Additional Embedding Providers > Resetting Memory via cli",
      "enhanced_text": "Context: Changelog > Memory > Additional Embedding Providers > Resetting Memory via cli\n\ncrewai reset-memories [OPTIONS]"
    },
    {
      "content": "my_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"custom\",\n        \"config\": {\n            \"embedder\": CustomEmbedder()\n        }\n    }\n)\n\nmy_crew.reset_memories(command_type = 'all') # Resets all the memory",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Memory",
          "level": 1
        },
        {
          "title": "Additional Embedding Providers",
          "level": 2
        },
        {
          "title": "Resetting Memory via crew object",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Memory",
            "level": 1
          },
          {
            "title": "Additional Embedding Providers",
            "level": 2
          },
          {
            "title": "Resetting Memory via crew object",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Memory > Additional Embedding Providers > Resetting Memory via crew object"
      },
      "enhanced_content": "Context: Changelog > Memory > Additional Embedding Providers > Resetting Memory via crew object\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"custom\",\n        \"config\": {\n            \"embedder\": CustomEmbedder()\n        }\n    }\n)\n\nmy_crew.reset_memories(command_type = 'all') # Resets all the memory",
      "formatted_path": "Changelog > Memory > Additional Embedding Providers > Resetting Memory via crew object",
      "enhanced_text": "Context: Changelog > Memory > Additional Embedding Providers > Resetting Memory via crew object\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"custom\",\n        \"config\": {\n            \"embedder\": CustomEmbedder()\n        }\n    }\n)\n\nmy_crew.reset_memories(command_type = 'all') # Resets all the memory"
    },
    {
      "content": "| Option                    | Description                        | Type           | Default |\n| :------------------------ | :--------------------------------- | :------------- | :------ |\n| `-l`, `--long`            | Reset LONG TERM memory.            | Flag (boolean) | False   |\n| `-s`, `--short`           | Reset SHORT TERM memory.           | Flag (boolean) | False   |\n| `-e`, `--entities`        | Reset ENTITIES memory.             | Flag (boolean) | False   |\n| `-k`, `--kickoff-outputs` | Reset LATEST KICKOFF TASK OUTPUTS. | Flag (boolean) | False   |\n| `-kn`, `--knowledge`      | Reset KNOWLEDEGE storage           | Flag (boolean) | False   |\n| `-a`, `--all`             | Reset ALL memories.                | Flag (boolean) | False   | Note: To use the cli command you need to have your crew in a file called crew\\.py in the same directory.\n\n| Command Type      | Description                        |\n| :---------------- | :--------------------------------- |\n| `long`            | Reset LONG TERM memory.            |\n| `short`           | Reset SHORT TERM memory.           |\n| `entities`        | Reset ENTITIES memory.             |\n| `kickoff_outputs` | Reset LATEST KICKOFF TASK OUTPUTS. |\n| `knowledge`       | Reset KNOWLEDGE memory.            |\n| `all`             | Reset ALL memories.                |",
      "title": "Resetting Memory Options",
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Memory",
          "level": 1
        },
        {
          "title": "Additional Embedding Providers",
          "level": 2
        },
        {
          "title": "Resetting Memory via crew object",
          "level": 3
        },
        {
          "title": "Resetting Memory Options",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Memory",
            "level": 1
          },
          {
            "title": "Additional Embedding Providers",
            "level": 2
          },
          {
            "title": "Resetting Memory via crew object",
            "level": 3
          },
          {
            "title": "Resetting Memory Options",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Memory > Additional Embedding Providers > Resetting Memory via crew object > Resetting Memory Options"
      },
      "enhanced_content": "Context: Changelog > Memory > Additional Embedding Providers > Resetting Memory via crew object > Resetting Memory Options\n\n#### Resetting Memory Options\n\n| Option                    | Description                        | Type           | Default |\n| :------------------------ | :--------------------------------- | :------------- | :------ |\n| `-l`, `--long`            | Reset LONG TERM memory.            | Flag (boolean) | False   |\n| `-s`, `--short`           | Reset SHORT TERM memory.           | Flag (boolean) | False   |\n| `-e`, `--entities`        | Reset ENTITIES memory.             | Flag (boolean) | False   |\n| `-k`, `--kickoff-outputs` | Reset LATEST KICKOFF TASK OUTPUTS. | Flag (boolean) | False   |\n| `-kn`, `--knowledge`      | Reset KNOWLEDEGE storage           | Flag (boolean) | False   |\n| `-a`, `--all`             | Reset ALL memories.                | Flag (boolean) | False   | Note: To use the cli command you need to have your crew in a file called crew\\.py in the same directory.\n\n| Command Type      | Description                        |\n| :---------------- | :--------------------------------- |\n| `long`            | Reset LONG TERM memory.            |\n| `short`           | Reset SHORT TERM memory.           |\n| `entities`        | Reset ENTITIES memory.             |\n| `kickoff_outputs` | Reset LATEST KICKOFF TASK OUTPUTS. |\n| `knowledge`       | Reset KNOWLEDGE memory.            |\n| `all`             | Reset ALL memories.                |",
      "formatted_path": "Changelog > Memory > Additional Embedding Providers > Resetting Memory via crew object > Resetting Memory Options",
      "enhanced_text": "Context: Changelog > Memory > Additional Embedding Providers > Resetting Memory via crew object > Resetting Memory Options\n\n Resetting Memory Options\n\n| Option                    | Description                        | Type           | Default |\n| :------------------------ | :--------------------------------- | :------------- | :------ |\n| `-l`, `--long`            | Reset LONG TERM memory.            | Flag (boolean) | False   |\n| `-s`, `--short`           | Reset SHORT TERM memory.           | Flag (boolean) | False   |\n| `-e`, `--entities`        | Reset ENTITIES memory.             | Flag (boolean) | False   |\n| `-k`, `--kickoff-outputs` | Reset LATEST KICKOFF TASK OUTPUTS. | Flag (boolean) | False   |\n| `-kn`, `--knowledge`      | Reset KNOWLEDEGE storage           | Flag (boolean) | False   |\n| `-a`, `--all`             | Reset ALL memories.                | Flag (boolean) | False   | Note: To use the cli command you need to have your crew in a file called crew\\.py in the same directory.\n\n| Command Type      | Description                        |\n| :---------------- | :--------------------------------- |\n| `long`            | Reset LONG TERM memory.            |\n| `short`           | Reset SHORT TERM memory.           |\n| `entities`        | Reset ENTITIES memory.             |\n| `kickoff_outputs` | Reset LATEST KICKOFF TASK OUTPUTS. |\n| `knowledge`       | Reset KNOWLEDGE memory.            |\n| `all`             | Reset ALL memories.                |\n\nRelated sections:\n- \n"
    },
    {
      "content": "\ud83e\uddbe **Adaptive Learning:** Crews become more efficient over time, adapting to new information and refining their approach to tasks. \ud83e\udee1 **Enhanced Personalization:** Memory enables agents to remember user preferences and historical interactions, leading to personalized experiences. \ud83e\udde0 **Improved Problem Solving:** Access to a rich memory store aids agents in making more informed decisions, drawing on past learnings and contextual insights.",
      "title": "Benefits of Using CrewAI's Memory System",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Memory",
          "level": 1
        },
        {
          "title": "Benefits of Using CrewAI's Memory System",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Memory",
            "level": 1
          },
          {
            "title": "Benefits of Using CrewAI's Memory System",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Memory > Benefits of Using CrewAI's Memory System"
      },
      "enhanced_content": "Context: Changelog > Memory > Benefits of Using CrewAI's Memory System\n\n## Benefits of Using CrewAI's Memory System\n\n\ud83e\uddbe **Adaptive Learning:** Crews become more efficient over time, adapting to new information and refining their approach to tasks. \ud83e\udee1 **Enhanced Personalization:** Memory enables agents to remember user preferences and historical interactions, leading to personalized experiences. \ud83e\udde0 **Improved Problem Solving:** Access to a rich memory store aids agents in making more informed decisions, drawing on past learnings and contextual insights.",
      "formatted_path": "Changelog > Memory > Benefits of Using CrewAI's Memory System",
      "enhanced_text": "Context: Changelog > Memory > Benefits of Using CrewAI's Memory System\n\n Benefits of Using CrewAI's Memory System\n\n\ud83e\uddbe **Adaptive Learning:** Crews become more efficient over time, adapting to new information and refining their approach to tasks. \ud83e\udee1 **Enhanced Personalization:** Memory enables agents to remember user preferences and historical interactions, leading to personalized experiences. \ud83e\udde0 **Improved Problem Solving:** Access to a rich memory store aids agents in making more informed decisions, drawing on past learnings and contextual insights.\n\nRelated sections:\n- \n"
    },
    {
      "content": "Source: https://docs.crewai.com/concepts/planning Learn how to add planning to your CrewAI Crew and improve their performance.",
      "title": "Planning",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Planning",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Planning",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Planning"
      },
      "enhanced_content": "Context: Changelog > Planning\n\n# Planning\n\nSource: https://docs.crewai.com/concepts/planning Learn how to add planning to your CrewAI Crew and improve their performance.",
      "formatted_path": "Changelog > Planning",
      "enhanced_text": "Context: Changelog > Planning\n\n Planning\n\nSource: https://docs.crewai.com/concepts/planning Learn how to add planning to your CrewAI Crew and improve their performance.\n\nRelated sections:\n- \n"
    },
    {
      "content": "Getting started with the planning feature is very easy, the only step required is to add `planning=True` to your Crew:",
      "title": "Using the Planning Feature",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Planning",
          "level": 1
        },
        {
          "title": "Introduction",
          "level": 2
        },
        {
          "title": "Using the Planning Feature",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Planning",
            "level": 1
          },
          {
            "title": "Introduction",
            "level": 2
          },
          {
            "title": "Using the Planning Feature",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Planning > Introduction > Using the Planning Feature"
      },
      "enhanced_content": "Context: Changelog > Planning > Introduction > Using the Planning Feature\n\n### Using the Planning Feature\n\nGetting started with the planning feature is very easy, the only step required is to add `planning=True` to your Crew:",
      "formatted_path": "Changelog > Planning > Introduction > Using the Planning Feature",
      "enhanced_text": "Context: Changelog > Planning > Introduction > Using the Planning Feature\n\n Using the Planning Feature\n\nGetting started with the planning feature is very easy, the only step required is to add `planning=True` to your Crew:\n\nRelated sections:\n- \n"
    },
    {
      "content": "</CodeGroup>\n\nFrom this point on, your crew will have planning enabled, and the tasks will be planned before each iteration.\n\n#### Planning LLM\n\nNow you can define the LLM that will be used to plan the tasks.\n\nWhen running the base case example, you will see something like the output below, which represents the output of the `AgentPlanner`\nresponsible for creating the step-by-step logic to add to the Agents' tasks.\n\n<CodeGroup>\n```python Code\nfrom crewai import Crew, Agent, Task, Process\n\n# Assemble your crew with planning capabilities and custom LLM\nmy_crew = Crew(\n    agents=self.agents,\n    tasks=self.tasks,\n    process=Process.sequential,\n    planning=True,\n    planning_llm=\"gpt-4o\"\n)\n\n# Run the crew\nmy_crew.kickoff()",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Assemble your crew with planning capabilities",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Assemble your crew with planning capabilities",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Assemble your crew with planning capabilities"
      },
      "enhanced_content": "Context: Changelog > Assemble your crew with planning capabilities\n\n</CodeGroup>\n\nFrom this point on, your crew will have planning enabled, and the tasks will be planned before each iteration.\n\n#### Planning LLM\n\nNow you can define the LLM that will be used to plan the tasks.\n\nWhen running the base case example, you will see something like the output below, which represents the output of the `AgentPlanner`\nresponsible for creating the step-by-step logic to add to the Agents' tasks.\n\n<CodeGroup>\n```python Code\nfrom crewai import Crew, Agent, Task, Process\n\n# Assemble your crew with planning capabilities and custom LLM\nmy_crew = Crew(\n    agents=self.agents,\n    tasks=self.tasks,\n    process=Process.sequential,\n    planning=True,\n    planning_llm=\"gpt-4o\"\n)\n\n# Run the crew\nmy_crew.kickoff()",
      "formatted_path": "Changelog > Assemble your crew with planning capabilities",
      "enhanced_text": "Context: Changelog > Assemble your crew with planning capabilities\n\n</CodeGroup>\n\nFrom this point on, your crew will have planning enabled, and the tasks will be planned before each iteration.\n\n#### Planning LLM\n\nNow you can define the LLM that will be used to plan the tasks.\n\nWhen running the base case example, you will see something like the output below, which represents the output of the `AgentPlanner`\nresponsible for creating the step-by-step logic to add to the Agents' tasks.\n\n<CodeGroup>\n```python Code\nfrom crewai import Crew, Agent, Task, Process\n\n# Assemble your crew with planning capabilities and custom LLM\nmy_crew = Crew(\n    agents=self.agents,\n    tasks=self.tasks,\n    process=Process.sequential,\n    planning=True,\n    planning_llm=\"gpt-4o\"\n)\n\n# Run the crew\nmy_crew.kickoff()"
    },
    {
      "content": "[2024-07-15 16:49:11][INFO]: Planning the crew execution\n**Step-by-Step Plan for Task Execution**\n\n**Task Number 1: Conduct a thorough research about AI LLMs**\n\n**Agent:** AI LLMs Senior Data Researcher\n\n**Agent Goal:** Uncover cutting-edge developments in AI LLMs\n\n**Task Expected Output:** A list with 10 bullet points of the most relevant information about AI LLMs\n\n**Task Tools:** None specified\n\n**Agent Tools:** None specified\n\n**Step-by-Step Plan:**\n\n1. **Define Research Scope:**\n\n   - Determine the specific areas of AI LLMs to focus on, such as advancements in architecture, use cases, ethical considerations, and performance metrics.\n\n2. **Identify Reliable Sources:**\n\n   - List reputable sources for AI research, including academic journals, industry reports, conferences (e.g., NeurIPS, ACL), AI research labs (e.g., OpenAI, Google AI), and online databases (e.g., IEEE Xplore, arXiv).\n\n3. **Collect Data:**\n\n   - Search for the latest papers, articles, and reports published in 2024 and early 2025.\n   - Use keywords like \"Large Language Models 2025\", \"AI LLM advancements\", \"AI ethics 2025\", etc.\n\n4. **Analyze Findings:**\n\n   - Read and summarize the key points from each source.\n   - Highlight new techniques, models, and applications introduced in the past year.\n\n5. **Organize Information:**\n\n   - Categorize the information into relevant topics (e.g., new architectures, ethical implications, real-world applications).\n   - Ensure each bullet point is concise but informative.\n\n6. **Create the List:**\n\n   - Compile the 10 most relevant pieces of information into a bullet point list.\n   - Review the list to ensure clarity and relevance.\n\n**Expected Output:**\n\nA list with 10 bullet points of the most relevant information about AI LLMs.\n\n---\n\n**Task Number 2: Review the context you got and expand each topic into a full section for a report**\n\n**Agent:** AI LLMs Reporting Analyst\n\n**Agent Goal:** Create detailed reports based on AI LLMs data analysis and research findings\n\n**Task Expected Output:** A fully fledged report with the main topics, each with a full section of information. Formatted as markdown without '```'\n\n**Task Tools:** None specified\n\n**Agent Tools:** None specified\n\n**Step-by-Step Plan:**\n\n1. **Review the Bullet Points:**\n   - Carefully read through the list of 10 bullet points provided by the AI LLMs Senior Data Researcher.\n\n2. **Outline the Report:**\n   - Create an outline with each bullet point as a main section heading.\n   - Plan sub-sections under each main heading to cover different aspects of the topic.\n\n3. **Research Further Details:**\n   - For each bullet point, conduct additional research if necessary to gather more detailed information.\n   - Look for case studies, examples, and statistical data to support each section.\n\n4. **Write Detailed Sections:**\n   - Expand each bullet point into a comprehensive section.\n   - Ensure each section includes an introduction, detailed explanation, examples, and a conclusion.\n   - Use markdown formatting for headings, subheadings, lists, and emphasis.\n\n5. **Review and Edit:**\n   - Proofread the report for clarity, coherence, and correctness.\n   - Make sure the report flows logically from one section to the next.\n   - Format the report according to markdown standards.\n\n6. **Finalize the Report:**\n   - Ensure the report is complete with all sections expanded and detailed.\n   - Double-check formatting and make any necessary adjustments.\n\n**Expected Output:**\nA fully fledged report with the main topics, each with a full section of information. Formatted as markdown without '```'.",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Assemble your crew with planning capabilities",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Assemble your crew with planning capabilities",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Assemble your crew with planning capabilities"
      },
      "enhanced_content": "Context: Changelog > Assemble your crew with planning capabilities\n\n[2024-07-15 16:49:11][INFO]: Planning the crew execution\n**Step-by-Step Plan for Task Execution**\n\n**Task Number 1: Conduct a thorough research about AI LLMs**\n\n**Agent:** AI LLMs Senior Data Researcher\n\n**Agent Goal:** Uncover cutting-edge developments in AI LLMs\n\n**Task Expected Output:** A list with 10 bullet points of the most relevant information about AI LLMs\n\n**Task Tools:** None specified\n\n**Agent Tools:** None specified\n\n**Step-by-Step Plan:**\n\n1. **Define Research Scope:**\n\n   - Determine the specific areas of AI LLMs to focus on, such as advancements in architecture, use cases, ethical considerations, and performance metrics.\n\n2. **Identify Reliable Sources:**\n\n   - List reputable sources for AI research, including academic journals, industry reports, conferences (e.g., NeurIPS, ACL), AI research labs (e.g., OpenAI, Google AI), and online databases (e.g., IEEE Xplore, arXiv).\n\n3. **Collect Data:**\n\n   - Search for the latest papers, articles, and reports published in 2024 and early 2025.\n   - Use keywords like \"Large Language Models 2025\", \"AI LLM advancements\", \"AI ethics 2025\", etc.\n\n4. **Analyze Findings:**\n\n   - Read and summarize the key points from each source.\n   - Highlight new techniques, models, and applications introduced in the past year.\n\n5. **Organize Information:**\n\n   - Categorize the information into relevant topics (e.g., new architectures, ethical implications, real-world applications).\n   - Ensure each bullet point is concise but informative.\n\n6. **Create the List:**\n\n   - Compile the 10 most relevant pieces of information into a bullet point list.\n   - Review the list to ensure clarity and relevance.\n\n**Expected Output:**\n\nA list with 10 bullet points of the most relevant information about AI LLMs.\n\n---\n\n**Task Number 2: Review the context you got and expand each topic into a full section for a report**\n\n**Agent:** AI LLMs Reporting Analyst\n\n**Agent Goal:** Create detailed reports based on AI LLMs data analysis and research findings\n\n**Task Expected Output:** A fully fledged report with the main topics, each with a full section of information. Formatted as markdown without '```'\n\n**Task Tools:** None specified\n\n**Agent Tools:** None specified\n\n**Step-by-Step Plan:**\n\n1. **Review the Bullet Points:**\n   - Carefully read through the list of 10 bullet points provided by the AI LLMs Senior Data Researcher.\n\n2. **Outline the Report:**\n   - Create an outline with each bullet point as a main section heading.\n   - Plan sub-sections under each main heading to cover different aspects of the topic.\n\n3. **Research Further Details:**\n   - For each bullet point, conduct additional research if necessary to gather more detailed information.\n   - Look for case studies, examples, and statistical data to support each section.\n\n4. **Write Detailed Sections:**\n   - Expand each bullet point into a comprehensive section.\n   - Ensure each section includes an introduction, detailed explanation, examples, and a conclusion.\n   - Use markdown formatting for headings, subheadings, lists, and emphasis.\n\n5. **Review and Edit:**\n   - Proofread the report for clarity, coherence, and correctness.\n   - Make sure the report flows logically from one section to the next.\n   - Format the report according to markdown standards.\n\n6. **Finalize the Report:**\n   - Ensure the report is complete with all sections expanded and detailed.\n   - Double-check formatting and make any necessary adjustments.\n\n**Expected Output:**\nA fully fledged report with the main topics, each with a full section of information. Formatted as markdown without '```'.",
      "formatted_path": "Changelog > Assemble your crew with planning capabilities",
      "enhanced_text": "Context: Changelog > Assemble your crew with planning capabilities\n\n[2024-07-15 16:49:11][INFO]: Planning the crew execution\n**Step-by-Step Plan for Task Execution**\n\n**Task Number 1: Conduct a thorough research about AI LLMs**\n\n**Agent:** AI LLMs Senior Data Researcher\n\n**Agent Goal:** Uncover cutting-edge developments in AI LLMs\n\n**Task Expected Output:** A list with 10 bullet points of the most relevant information about AI LLMs\n\n**Task Tools:** None specified\n\n**Agent Tools:** None specified\n\n**Step-by-Step Plan:**\n\n1. **Define Research Scope:**\n\n   - Determine the specific areas of AI LLMs to focus on, such as advancements in architecture, use cases, ethical considerations, and performance metrics.\n\n2. **Identify Reliable Sources:**\n\n   - List reputable sources for AI research, including academic journals, industry reports, conferences (e.g., NeurIPS, ACL), AI research labs (e.g., OpenAI, Google AI), and online databases (e.g., IEEE Xplore, arXiv).\n\n3. **Collect Data:**\n\n   - Search for the latest papers, articles, and reports published in 2024 and early 2025.\n   - Use keywords like \"Large Language Models 2025\", \"AI LLM advancements\", \"AI ethics 2025\", etc.\n\n4. **Analyze Findings:**\n\n   - Read and summarize the key points from each source.\n   - Highlight new techniques, models, and applications introduced in the past year.\n\n5. **Organize Information:**\n\n   - Categorize the information into relevant topics (e.g., new architectures, ethical implications, real-world applications).\n   - Ensure each bullet point is concise but informative.\n\n6. **Create the List:**\n\n   - Compile the 10 most relevant pieces of information into a bullet point list.\n   - Review the list to ensure clarity and relevance.\n\n**Expected Output:**\n\nA list with 10 bullet points of the most relevant information about AI LLMs.\n\n---\n\n**Task Number 2: Review the context you got and expand each topic into a full section for a report**\n\n**Agent:** AI LLMs Reporting Analyst\n\n**Agent Goal:** Create detailed reports based on AI LLMs data analysis and research findings\n\n**Task Expected Output:** A fully fledged report with the main topics, each with a full section of information. Formatted as markdown without '```'\n\n**Task Tools:** None specified\n\n**Agent Tools:** None specified\n\n**Step-by-Step Plan:**\n\n1. **Review the Bullet Points:**\n   - Carefully read through the list of 10 bullet points provided by the AI LLMs Senior Data Researcher.\n\n2. **Outline the Report:**\n   - Create an outline with each bullet point as a main section heading.\n   - Plan sub-sections under each main heading to cover different aspects of the topic.\n\n3. **Research Further Details:**\n   - For each bullet point, conduct additional research if necessary to gather more detailed information.\n   - Look for case studies, examples, and statistical data to support each section.\n\n4. **Write Detailed Sections:**\n   - Expand each bullet point into a comprehensive section.\n   - Ensure each section includes an introduction, detailed explanation, examples, and a conclusion.\n   - Use markdown formatting for headings, subheadings, lists, and emphasis.\n\n5. **Review and Edit:**\n   - Proofread the report for clarity, coherence, and correctness.\n   - Make sure the report flows logically from one section to the next.\n   - Format the report according to markdown standards.\n\n6. **Finalize the Report:**\n   - Ensure the report is complete with all sections expanded and detailed.\n   - Double-check formatting and make any necessary adjustments.\n\n**Expected Output:**\nA fully fledged report with the main topics, each with a full section of information. Formatted as markdown without '```'."
    },
    {
      "content": "Source: https://docs.crewai.com/concepts/processes Detailed guide on workflow management through processes in CrewAI, with updated implementation details.",
      "title": "Processes",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Processes",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Processes",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Processes"
      },
      "enhanced_content": "Context: Changelog > Processes\n\n# Processes\n\nSource: https://docs.crewai.com/concepts/processes Detailed guide on workflow management through processes in CrewAI, with updated implementation details.",
      "formatted_path": "Changelog > Processes",
      "enhanced_text": "Context: Changelog > Processes\n\n Processes\n\nSource: https://docs.crewai.com/concepts/processes Detailed guide on workflow management through processes in CrewAI, with updated implementation details.\n\nRelated sections:\n- \n- \n- \n- \n- \n"
    },
    {
      "content": "**Sequential**: Executes tasks sequentially, ensuring tasks are completed in an orderly progression. **Hierarchical**: Organizes tasks in a managerial hierarchy, where tasks are delegated and executed based on a structured chain of command. A manager language model (`manager_llm`) or a custom manager agent (`manager_agent`) must be specified in the crew to enable the hierarchical process, facilitating the creation and management of tasks by the manager. **Consensual Process (Planned)**: Aiming for collaborative decision-making among agents on task execution, this process type introduces a democratic approach to task management within CrewAI. It is planned for future development and is not currently implemented in the codebase.",
      "title": "Process Implementations",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Processes",
          "level": 1
        },
        {
          "title": "Process Implementations",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Processes",
            "level": 1
          },
          {
            "title": "Process Implementations",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Processes > Process Implementations"
      },
      "enhanced_content": "Context: Changelog > Processes > Process Implementations\n\n## Process Implementations\n\n**Sequential**: Executes tasks sequentially, ensuring tasks are completed in an orderly progression. **Hierarchical**: Organizes tasks in a managerial hierarchy, where tasks are delegated and executed based on a structured chain of command. A manager language model (`manager_llm`) or a custom manager agent (`manager_agent`) must be specified in the crew to enable the hierarchical process, facilitating the creation and management of tasks by the manager. **Consensual Process (Planned)**: Aiming for collaborative decision-making among agents on task execution, this process type introduces a democratic approach to task management within CrewAI. It is planned for future development and is not currently implemented in the codebase.",
      "formatted_path": "Changelog > Processes > Process Implementations",
      "enhanced_text": "Context: Changelog > Processes > Process Implementations\n\n Process Implementations\n\n**Sequential**: Executes tasks sequentially, ensuring tasks are completed in an orderly progression. **Hierarchical**: Organizes tasks in a managerial hierarchy, where tasks are delegated and executed based on a structured chain of command. A manager language model (`manager_llm`) or a custom manager agent (`manager_agent`) must be specified in the crew to enable the hierarchical process, facilitating the creation and management of tasks by the manager. **Consensual Process (Planned)**: Aiming for collaborative decision-making among agents on task execution, this process type introduces a democratic approach to task management within CrewAI. It is planned for future development and is not currently implemented in the codebase."
    },
    {
      "content": "Processes enable individual agents to operate as a cohesive unit, streamlining their efforts to achieve common objectives with efficiency and coherence.",
      "title": "The Role of Processes in Teamwork",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Processes",
          "level": 1
        },
        {
          "title": "The Role of Processes in Teamwork",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Processes",
            "level": 1
          },
          {
            "title": "The Role of Processes in Teamwork",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Processes > The Role of Processes in Teamwork"
      },
      "enhanced_content": "Context: Changelog > Processes > The Role of Processes in Teamwork\n\n## The Role of Processes in Teamwork\n\nProcesses enable individual agents to operate as a cohesive unit, streamlining their efforts to achieve common objectives with efficiency and coherence.",
      "formatted_path": "Changelog > Processes > The Role of Processes in Teamwork",
      "enhanced_text": "Context: Changelog > Processes > The Role of Processes in Teamwork\n\n The Role of Processes in Teamwork\n\nProcesses enable individual agents to operate as a cohesive unit, streamlining their efforts to achieve common objectives with efficiency and coherence.\n\nRelated sections:\n- \n"
    },
    {
      "content": "from crewai import Crew, Process\n\n# Example: Creating a crew with a sequential process\ncrew = Crew(\n    agents=my_agents,\n    tasks=my_tasks,\n    process=Process.sequential\n)\n\n# Example: Creating a crew with a hierarchical process\n# Ensure to provide a manager_llm or manager_agent\ncrew = Crew(\n    agents=my_agents,\n    tasks=my_tasks,\n    process=Process.hierarchical,\n    manager_llm=\"gpt-4o\"\n    # or\n    # manager_agent=my_manager_agent\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Processes",
          "level": 1
        },
        {
          "title": "Assigning Processes to a Crew",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Processes",
            "level": 1
          },
          {
            "title": "Assigning Processes to a Crew",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Processes > Assigning Processes to a Crew"
      },
      "enhanced_content": "Context: Changelog > Processes > Assigning Processes to a Crew\n\nfrom crewai import Crew, Process\n\n# Example: Creating a crew with a sequential process\ncrew = Crew(\n    agents=my_agents,\n    tasks=my_tasks,\n    process=Process.sequential\n)\n\n# Example: Creating a crew with a hierarchical process\n# Ensure to provide a manager_llm or manager_agent\ncrew = Crew(\n    agents=my_agents,\n    tasks=my_tasks,\n    process=Process.hierarchical,\n    manager_llm=\"gpt-4o\"\n    # or\n    # manager_agent=my_manager_agent\n)",
      "formatted_path": "Changelog > Processes > Assigning Processes to a Crew",
      "enhanced_text": "Context: Changelog > Processes > Assigning Processes to a Crew\n\nfrom crewai import Crew, Process\n\n# Example: Creating a crew with a sequential process\ncrew = Crew(\n    agents=my_agents,\n    tasks=my_tasks,\n    process=Process.sequential\n)\n\n# Example: Creating a crew with a hierarchical process\n# Ensure to provide a manager_llm or manager_agent\ncrew = Crew(\n    agents=my_agents,\n    tasks=my_tasks,\n    process=Process.hierarchical,\n    manager_llm=\"gpt-4o\"\n    # or\n    # manager_agent=my_manager_agent\n)"
    },
    {
      "content": "This method mirrors dynamic team workflows, progressing through tasks in a thoughtful and systematic manner. Task execution follows the predefined order in the task list, with the output of one task serving as context for the next. To customize task context, utilize the `context` parameter in the `Task` class to specify outputs that should be used as context for subsequent tasks.",
      "title": "Sequential Process",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Processes",
          "level": 1
        },
        {
          "title": "Sequential Process",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Processes",
            "level": 1
          },
          {
            "title": "Sequential Process",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Processes > Sequential Process"
      },
      "enhanced_content": "Context: Changelog > Processes > Sequential Process\n\n## Sequential Process\n\nThis method mirrors dynamic team workflows, progressing through tasks in a thoughtful and systematic manner. Task execution follows the predefined order in the task list, with the output of one task serving as context for the next. To customize task context, utilize the `context` parameter in the `Task` class to specify outputs that should be used as context for subsequent tasks.",
      "formatted_path": "Changelog > Processes > Sequential Process",
      "enhanced_text": "Context: Changelog > Processes > Sequential Process\n\n Sequential Process\n\nThis method mirrors dynamic team workflows, progressing through tasks in a thoughtful and systematic manner. Task execution follows the predefined order in the task list, with the output of one task serving as context for the next. To customize task context, utilize the `context` parameter in the `Task` class to specify outputs that should be used as context for subsequent tasks.\n\nRelated sections:\n- \n- \n- \n- \n"
    },
    {
      "content": "The `Process` class is implemented as an enumeration (`Enum`), ensuring type safety and restricting process values to the defined types (`sequential`, `hierarchical`). The consensual process is planned for future inclusion, emphasizing our commitment to continuous development and innovation.",
      "title": "Process Class: Detailed Overview",
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Processes",
          "level": 1
        },
        {
          "title": "Process Class: Detailed Overview",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Processes",
            "level": 1
          },
          {
            "title": "Process Class: Detailed Overview",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Processes > Process Class: Detailed Overview"
      },
      "enhanced_content": "Context: Changelog > Processes > Process Class: Detailed Overview\n\n## Process Class: Detailed Overview\n\nThe `Process` class is implemented as an enumeration (`Enum`), ensuring type safety and restricting process values to the defined types (`sequential`, `hierarchical`). The consensual process is planned for future inclusion, emphasizing our commitment to continuous development and innovation.",
      "formatted_path": "Changelog > Processes > Process Class: Detailed Overview",
      "enhanced_text": "Context: Changelog > Processes > Process Class: Detailed Overview\n\n Process Class: Detailed Overview\n\nThe `Process` class is implemented as an enumeration (`Enum`), ensuring type safety and restricting process values to the defined types (`sequential`, `hierarchical`). The consensual process is planned for future inclusion, emphasizing our commitment to continuous development and innovation.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "Source: https://docs.crewai.com/concepts/tasks Detailed guide on managing and creating tasks within the CrewAI framework.",
      "title": "Tasks",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tasks",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tasks",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tasks"
      },
      "enhanced_content": "Context: Changelog > Tasks\n\n# Tasks\n\nSource: https://docs.crewai.com/concepts/tasks Detailed guide on managing and creating tasks within the CrewAI framework.",
      "formatted_path": "Changelog > Tasks",
      "enhanced_text": "Context: Changelog > Tasks\n\n Tasks\n\nSource: https://docs.crewai.com/concepts/tasks Detailed guide on managing and creating tasks within the CrewAI framework.\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "In the CrewAI framework, a `Task` is a specific assignment completed by an `Agent`. Tasks provide all necessary details for execution, such as a description, the agent responsible, required tools, and more, facilitating a wide range of action complexities. Tasks within CrewAI can be collaborative, requiring multiple agents to work together. This is managed through the task properties and orchestrated by the Crew's process, enhancing teamwork and efficiency.",
      "title": "Overview of a Task",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tasks",
          "level": 1
        },
        {
          "title": "Overview of a Task",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tasks",
            "level": 1
          },
          {
            "title": "Overview of a Task",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tasks > Overview of a Task"
      },
      "enhanced_content": "Context: Changelog > Tasks > Overview of a Task\n\n## Overview of a Task\n\nIn the CrewAI framework, a `Task` is a specific assignment completed by an `Agent`. Tasks provide all necessary details for execution, such as a description, the agent responsible, required tools, and more, facilitating a wide range of action complexities. Tasks within CrewAI can be collaborative, requiring multiple agents to work together. This is managed through the task properties and orchestrated by the Crew's process, enhancing teamwork and efficiency.",
      "formatted_path": "Changelog > Tasks > Overview of a Task",
      "enhanced_text": "Context: Changelog > Tasks > Overview of a Task\n\n Overview of a Task\n\nIn the CrewAI framework, a `Task` is a specific assignment completed by an `Agent`. Tasks provide all necessary details for execution, such as a description, the agent responsible, required tools, and more, facilitating a wide range of action complexities. Tasks within CrewAI can be collaborative, requiring multiple agents to work together. This is managed through the task properties and orchestrated by the Crew's process, enhancing teamwork and efficiency.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "crew = Crew(\n    agents=[agent1, agent2],\n    tasks=[task1, task2],\n    process=Process.sequential  # or Process.hierarchical\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tasks",
          "level": 1
        },
        {
          "title": "Overview of a Task",
          "level": 2
        },
        {
          "title": "Task Execution Flow",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tasks",
            "level": 1
          },
          {
            "title": "Overview of a Task",
            "level": 2
          },
          {
            "title": "Task Execution Flow",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tasks > Overview of a Task > Task Execution Flow"
      },
      "enhanced_content": "Context: Changelog > Tasks > Overview of a Task > Task Execution Flow\n\ncrew = Crew(\n    agents=[agent1, agent2],\n    tasks=[task1, task2],\n    process=Process.sequential  # or Process.hierarchical\n)",
      "formatted_path": "Changelog > Tasks > Overview of a Task > Task Execution Flow",
      "enhanced_text": "Context: Changelog > Tasks > Overview of a Task > Task Execution Flow\n\ncrew = Crew(\n    agents=[agent1, agent2],\n    tasks=[task1, task2],\n    process=Process.sequential  # or Process.hierarchical\n)"
    },
    {
      "content": "| Attribute                        | Parameters        | Type                        | Description                                                                                   |\n| :------------------------------- | :---------------- | :-------------------------- | :-------------------------------------------------------------------------------------------- |\n| **Description**                  | `description`     | `str`                       | A clear, concise statement of what the task entails.                                          |\n| **Expected Output**              | `expected_output` | `str`                       | A detailed description of what the task's completion looks like.                              |\n| **Name** *(optional)*            | `name`            | `Optional[str]`             | A name identifier for the task.                                                               |\n| **Agent** *(optional)*           | `agent`           | `Optional[BaseAgent]`       | The agent responsible for executing the task.                                                 |\n| **Tools** *(optional)*           | `tools`           | `List[BaseTool]`            | The tools/resources the agent is limited to use for this task.                                |\n| **Context** *(optional)*         | `context`         | `Optional[List[\"Task\"]]`    | Other tasks whose outputs will be used as context for this task.                              |\n| **Async Execution** *(optional)* | `async_execution` | `Optional[bool]`            | Whether the task should be executed asynchronously. Defaults to False.                        |\n| **Human Input** *(optional)*     | `human_input`     | `Optional[bool]`            | Whether the task should have a human review the final answer of the agent. Defaults to False. |\n| **Config** *(optional)*          | `config`          | `Optional[Dict[str, Any]]`  | Task-specific configuration parameters.                                                       |\n| **Output File** *(optional)*     | `output_file`     | `Optional[str]`             | File path for storing the task output.                                                        |\n| **Output JSON** *(optional)*     | `output_json`     | `Optional[Type[BaseModel]]` | A Pydantic model to structure the JSON output.                                                |\n| **Output Pydantic** *(optional)* | `output_pydantic` | `Optional[Type[BaseModel]]` | A Pydantic model for task output.                                                             |\n| **Callback** *(optional)*        | `callback`        | `Optional[Any]`             | Function/object to be executed after task completion.                                         |",
      "title": "Task Attributes",
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tasks",
          "level": 1
        },
        {
          "title": "Task Attributes",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tasks",
            "level": 1
          },
          {
            "title": "Task Attributes",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tasks > Task Attributes"
      },
      "enhanced_content": "Context: Changelog > Tasks > Task Attributes\n\n## Task Attributes\n\n| Attribute                        | Parameters        | Type                        | Description                                                                                   |\n| :------------------------------- | :---------------- | :-------------------------- | :-------------------------------------------------------------------------------------------- |\n| **Description**                  | `description`     | `str`                       | A clear, concise statement of what the task entails.                                          |\n| **Expected Output**              | `expected_output` | `str`                       | A detailed description of what the task's completion looks like.                              |\n| **Name** *(optional)*            | `name`            | `Optional[str]`             | A name identifier for the task.                                                               |\n| **Agent** *(optional)*           | `agent`           | `Optional[BaseAgent]`       | The agent responsible for executing the task.                                                 |\n| **Tools** *(optional)*           | `tools`           | `List[BaseTool]`            | The tools/resources the agent is limited to use for this task.                                |\n| **Context** *(optional)*         | `context`         | `Optional[List[\"Task\"]]`    | Other tasks whose outputs will be used as context for this task.                              |\n| **Async Execution** *(optional)* | `async_execution` | `Optional[bool]`            | Whether the task should be executed asynchronously. Defaults to False.                        |\n| **Human Input** *(optional)*     | `human_input`     | `Optional[bool]`            | Whether the task should have a human review the final answer of the agent. Defaults to False. |\n| **Config** *(optional)*          | `config`          | `Optional[Dict[str, Any]]`  | Task-specific configuration parameters.                                                       |\n| **Output File** *(optional)*     | `output_file`     | `Optional[str]`             | File path for storing the task output.                                                        |\n| **Output JSON** *(optional)*     | `output_json`     | `Optional[Type[BaseModel]]` | A Pydantic model to structure the JSON output.                                                |\n| **Output Pydantic** *(optional)* | `output_pydantic` | `Optional[Type[BaseModel]]` | A Pydantic model for task output.                                                             |\n| **Callback** *(optional)*        | `callback`        | `Optional[Any]`             | Function/object to be executed after task completion.                                         |",
      "formatted_path": "Changelog > Tasks > Task Attributes",
      "enhanced_text": "Context: Changelog > Tasks > Task Attributes\n\n Task Attributes\n\n| Attribute                        | Parameters        | Type                        | Description                                                                                   |\n| :------------------------------- | :---------------- | :-------------------------- | :-------------------------------------------------------------------------------------------- |\n| **Description**                  | `description`     | `str`                       | A clear, concise statement of what the task entails.                                          |\n| **Expected Output**              | `expected_output` | `str`                       | A detailed description of what the task's completion looks like.                              |\n| **Name** *(optional)*            | `name`            | `Optional[str]`             | A name identifier for the task.                                                               |\n| **Agent** *(optional)*           | `agent`           | `Optional[BaseAgent]`       | The agent responsible for executing the task.                                                 |\n| **Tools** *(optional)*           | `tools`           | `List[BaseTool]`            | The tools/resources the agent is limited to use for this task.                                |\n| **Context** *(optional)*         | `context`         | `Optional[List[\"Task\"]]`    | Other tasks whose outputs will be used as context for this task.                              |\n| **Async Execution** *(optional)* | `async_execution` | `Optional[bool]`            | Whether the task should be executed asynchronously. Defaults to False.                        |\n| **Human Input** *(optional)*     | `human_input`     | `Optional[bool]`            | Whether the task should have a human review the final answer of the agent. Defaults to False. |\n| **Config** *(optional)*          | `config`          | `Optional[Dict[str, Any]]`  | Task-specific configuration parameters.                                                       |\n| **Output File** *(optional)*     | `output_file`     | `Optional[str]`             | File path for storing the task output.                                                        |\n| **Output JSON** *(optional)*     | `output_json`     | `Optional[Type[BaseModel]]` | A Pydantic model to structure the JSON output.                                                |\n| **Output Pydantic** *(optional)* | `output_pydantic` | `Optional[Type[BaseModel]]` | A Pydantic model for task output.                                                             |\n| **Callback** *(optional)*        | `callback`        | `Optional[Any]`             | Function/object to be executed after task completion.                                         |"
    },
    {
      "content": "There are two ways to create tasks in CrewAI: using **YAML configuration (recommended)** or defining them **directly in code**.",
      "title": "Creating Tasks",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tasks",
          "level": 1
        },
        {
          "title": "Creating Tasks",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tasks",
            "level": 1
          },
          {
            "title": "Creating Tasks",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tasks > Creating Tasks"
      },
      "enhanced_content": "Context: Changelog > Tasks > Creating Tasks\n\n## Creating Tasks\n\nThere are two ways to create tasks in CrewAI: using **YAML configuration (recommended)** or defining them **directly in code**.",
      "formatted_path": "Changelog > Tasks > Creating Tasks",
      "enhanced_text": "Context: Changelog > Tasks > Creating Tasks\n\n Creating Tasks\n\nThere are two ways to create tasks in CrewAI: using **YAML configuration (recommended)** or defining them **directly in code**.\n\nRelated sections:\n- \n"
    },
    {
      "content": "crew.kickoff(inputs={'topic': 'AI Agents'})",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tasks",
          "level": 1
        },
        {
          "title": "Creating Tasks",
          "level": 2
        },
        {
          "title": "YAML Configuration (Recommended)",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tasks",
            "level": 1
          },
          {
            "title": "Creating Tasks",
            "level": 2
          },
          {
            "title": "YAML Configuration (Recommended)",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tasks > Creating Tasks > YAML Configuration (Recommended)"
      },
      "enhanced_content": "Context: Changelog > Tasks > Creating Tasks > YAML Configuration (Recommended)\n\ncrew.kickoff(inputs={'topic': 'AI Agents'})",
      "formatted_path": "Changelog > Tasks > Creating Tasks > YAML Configuration (Recommended)",
      "enhanced_text": "Context: Changelog > Tasks > Creating Tasks > YAML Configuration (Recommended)\n\ncrew.kickoff(inputs={'topic': 'AI Agents'})"
    },
    {
      "content": "# src/latest_ai_development/config/agents.yaml\nresearcher:\n  role: >\n    {topic} Senior Data Researcher\n  goal: >\n    Uncover cutting-edge developments in {topic}\n  backstory: >\n    You're a seasoned researcher with a knack for uncovering the latest\n    developments in {topic}. Known for your ability to find the most relevant\n    information and present it in a clear and concise manner.\n\nreporting_analyst:\n  role: >\n    {topic} Reporting Analyst\n  goal: >\n    Create detailed reports based on {topic} data analysis and research findings\n  backstory: >\n    You're a meticulous analyst with a keen eye for detail. You're known for\n    your ability to turn complex data into clear and concise reports, making\n    it easy for others to understand and act on the information you provide.",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tasks",
          "level": 1
        },
        {
          "title": "Creating Tasks",
          "level": 2
        },
        {
          "title": "YAML Configuration (Recommended)",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tasks",
            "level": 1
          },
          {
            "title": "Creating Tasks",
            "level": 2
          },
          {
            "title": "YAML Configuration (Recommended)",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tasks > Creating Tasks > YAML Configuration (Recommended)"
      },
      "enhanced_content": "Context: Changelog > Tasks > Creating Tasks > YAML Configuration (Recommended)\n\n# src/latest_ai_development/config/agents.yaml\nresearcher:\n  role: >\n    {topic} Senior Data Researcher\n  goal: >\n    Uncover cutting-edge developments in {topic}\n  backstory: >\n    You're a seasoned researcher with a knack for uncovering the latest\n    developments in {topic}. Known for your ability to find the most relevant\n    information and present it in a clear and concise manner.\n\nreporting_analyst:\n  role: >\n    {topic} Reporting Analyst\n  goal: >\n    Create detailed reports based on {topic} data analysis and research findings\n  backstory: >\n    You're a meticulous analyst with a keen eye for detail. You're known for\n    your ability to turn complex data into clear and concise reports, making\n    it easy for others to understand and act on the information you provide.",
      "formatted_path": "Changelog > Tasks > Creating Tasks > YAML Configuration (Recommended)",
      "enhanced_text": "Context: Changelog > Tasks > Creating Tasks > YAML Configuration (Recommended)\n\n# src/latest_ai_development/config/agents.yaml\nresearcher:\n  role: >\n    {topic} Senior Data Researcher\n  goal: >\n    Uncover cutting-edge developments in {topic}\n  backstory: >\n    You're a seasoned researcher with a knack for uncovering the latest\n    developments in {topic}. Known for your ability to find the most relevant\n    information and present it in a clear and concise manner.\n\nreporting_analyst:\n  role: >\n    {topic} Reporting Analyst\n  goal: >\n    Create detailed reports based on {topic} data analysis and research findings\n  backstory: >\n    You're a meticulous analyst with a keen eye for detail. You're known for\n    your ability to turn complex data into clear and concise reports, making\n    it easy for others to understand and act on the information you provide."
    },
    {
      "content": "# src/latest_ai_development/crew.py\nfrom crewai import Agent, Crew, Process\nfrom crewai.project import CrewBase, agent, crew\nfrom crewai_tools import SerperDevTool\n\n@CrewBase\nclass LatestAiDevelopmentCrew():\n  \"\"\"LatestAiDevelopment crew\"\"\"\n\n  agents_config = \"config/agents.yaml\"\n\n  @agent\n  def researcher(self) -> Agent:\n    return Agent(\n      config=self.agents_config['researcher'],\n      verbose=True,\n      tools=[SerperDevTool()]\n    )\n\n  @agent\n  def reporting_analyst(self) -> Agent:\n    return Agent(\n      config=self.agents_config['reporting_analyst'],\n      verbose=True\n    )",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tasks",
          "level": 1
        },
        {
          "title": "Creating Tasks",
          "level": 2
        },
        {
          "title": "YAML Configuration (Recommended)",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tasks",
            "level": 1
          },
          {
            "title": "Creating Tasks",
            "level": 2
          },
          {
            "title": "YAML Configuration (Recommended)",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tasks > Creating Tasks > YAML Configuration (Recommended)"
      },
      "enhanced_content": "Context: Changelog > Tasks > Creating Tasks > YAML Configuration (Recommended)\n\n# src/latest_ai_development/crew.py\nfrom crewai import Agent, Crew, Process\nfrom crewai.project import CrewBase, agent, crew\nfrom crewai_tools import SerperDevTool\n\n@CrewBase\nclass LatestAiDevelopmentCrew():\n  \"\"\"LatestAiDevelopment crew\"\"\"\n\n  agents_config = \"config/agents.yaml\"\n\n  @agent\n  def researcher(self) -> Agent:\n    return Agent(\n      config=self.agents_config['researcher'],\n      verbose=True,\n      tools=[SerperDevTool()]\n    )\n\n  @agent\n  def reporting_analyst(self) -> Agent:\n    return Agent(\n      config=self.agents_config['reporting_analyst'],\n      verbose=True\n    )",
      "formatted_path": "Changelog > Tasks > Creating Tasks > YAML Configuration (Recommended)",
      "enhanced_text": "Context: Changelog > Tasks > Creating Tasks > YAML Configuration (Recommended)\n\n# src/latest_ai_development/crew.py\nfrom crewai import Agent, Crew, Process\nfrom crewai.project import CrewBase, agent, crew\nfrom crewai_tools import SerperDevTool\n\n@CrewBase\nclass LatestAiDevelopmentCrew():\n  \"\"\"LatestAiDevelopment crew\"\"\"\n\n  agents_config = \"config/agents.yaml\"\n\n  @agent\n  def researcher(self) -> Agent:\n    return Agent(\n      config=self.agents_config['researcher'],\n      verbose=True,\n      tools=[SerperDevTool()]\n    )\n\n  @agent\n  def reporting_analyst(self) -> Agent:\n    return Agent(\n      config=self.agents_config['reporting_analyst'],\n      verbose=True\n    )"
    },
    {
      "content": "crew.kickoff(inputs={'topic': 'AI Agents'})",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tasks",
          "level": 1
        },
        {
          "title": "Creating Tasks",
          "level": 2
        },
        {
          "title": "YAML Configuration (Recommended)",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tasks",
            "level": 1
          },
          {
            "title": "Creating Tasks",
            "level": 2
          },
          {
            "title": "YAML Configuration (Recommended)",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tasks > Creating Tasks > YAML Configuration (Recommended)"
      },
      "enhanced_content": "Context: Changelog > Tasks > Creating Tasks > YAML Configuration (Recommended)\n\ncrew.kickoff(inputs={'topic': 'AI Agents'})",
      "formatted_path": "Changelog > Tasks > Creating Tasks > YAML Configuration (Recommended)",
      "enhanced_text": "Context: Changelog > Tasks > Creating Tasks > YAML Configuration (Recommended)\n\ncrew.kickoff(inputs={'topic': 'AI Agents'})"
    },
    {
      "content": "research_task:\n  description: >\n    Conduct a thorough research about {topic}\n    Make sure you find any interesting and relevant information given\n    the current year is 2025.\n  expected_output: >\n    A list with 10 bullet points of the most relevant information about {topic}\n  agent: researcher\n\nreporting_task:\n  description: >\n    Review the context you got and expand each topic into a full section for a report.\n    Make sure the report is detailed and contains any and all relevant information.\n  expected_output: >\n    A fully fledge reports with the mains topics, each with a full section of information.\n    Formatted as markdown without '```'\n  agent: reporting_analyst\n  output_file: report.md",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tasks",
          "level": 1
        },
        {
          "title": "Creating Tasks",
          "level": 2
        },
        {
          "title": "YAML Configuration (Recommended)",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tasks",
            "level": 1
          },
          {
            "title": "Creating Tasks",
            "level": 2
          },
          {
            "title": "YAML Configuration (Recommended)",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tasks > Creating Tasks > YAML Configuration (Recommended)"
      },
      "enhanced_content": "Context: Changelog > Tasks > Creating Tasks > YAML Configuration (Recommended)\n\nresearch_task:\n  description: >\n    Conduct a thorough research about {topic}\n    Make sure you find any interesting and relevant information given\n    the current year is 2025.\n  expected_output: >\n    A list with 10 bullet points of the most relevant information about {topic}\n  agent: researcher\n\nreporting_task:\n  description: >\n    Review the context you got and expand each topic into a full section for a report.\n    Make sure the report is detailed and contains any and all relevant information.\n  expected_output: >\n    A fully fledge reports with the mains topics, each with a full section of information.\n    Formatted as markdown without '```'\n  agent: reporting_analyst\n  output_file: report.md",
      "formatted_path": "Changelog > Tasks > Creating Tasks > YAML Configuration (Recommended)",
      "enhanced_text": "Context: Changelog > Tasks > Creating Tasks > YAML Configuration (Recommended)\n\nresearch_task:\n  description: >\n    Conduct a thorough research about {topic}\n    Make sure you find any interesting and relevant information given\n    the current year is 2025.\n  expected_output: >\n    A list with 10 bullet points of the most relevant information about {topic}\n  agent: researcher\n\nreporting_task:\n  description: >\n    Review the context you got and expand each topic into a full section for a report.\n    Make sure the report is detailed and contains any and all relevant information.\n  expected_output: >\n    A fully fledge reports with the mains topics, each with a full section of information.\n    Formatted as markdown without '```'\n  agent: reporting_analyst\n  output_file: report.md"
    },
    {
      "content": "# src/latest_ai_development/crew.py\n\nfrom crewai import Agent, Crew, Process, Task\nfrom crewai.project import CrewBase, agent, crew, task\nfrom crewai_tools import SerperDevTool\n\n@CrewBase\nclass LatestAiDevelopmentCrew():\n  \"\"\"LatestAiDevelopment crew\"\"\"\n\n  @agent\n  def researcher(self) -> Agent:\n    return Agent(\n      config=self.agents_config['researcher'],\n      verbose=True,\n      tools=[SerperDevTool()]\n    )\n\n  @agent\n  def reporting_analyst(self) -> Agent:\n    return Agent(\n      config=self.agents_config['reporting_analyst'],\n      verbose=True\n    )\n\n  @task\n  def research_task(self) -> Task:\n    return Task(\n      config=self.tasks_config['research_task']\n    )\n\n  @task\n  def reporting_task(self) -> Task:\n    return Task(\n      config=self.tasks_config['reporting_task']\n    )\n\n  @crew\n  def crew(self) -> Crew:\n    return Crew(\n      agents=[\n        self.researcher(),\n        self.reporting_analyst()\n      ],\n      tasks=[\n        self.research_task(),\n        self.reporting_task()\n      ],\n      process=Process.sequential\n    )",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tasks",
          "level": 1
        },
        {
          "title": "Creating Tasks",
          "level": 2
        },
        {
          "title": "YAML Configuration (Recommended)",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tasks",
            "level": 1
          },
          {
            "title": "Creating Tasks",
            "level": 2
          },
          {
            "title": "YAML Configuration (Recommended)",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tasks > Creating Tasks > YAML Configuration (Recommended)"
      },
      "enhanced_content": "Context: Changelog > Tasks > Creating Tasks > YAML Configuration (Recommended)\n\n# src/latest_ai_development/crew.py\n\nfrom crewai import Agent, Crew, Process, Task\nfrom crewai.project import CrewBase, agent, crew, task\nfrom crewai_tools import SerperDevTool\n\n@CrewBase\nclass LatestAiDevelopmentCrew():\n  \"\"\"LatestAiDevelopment crew\"\"\"\n\n  @agent\n  def researcher(self) -> Agent:\n    return Agent(\n      config=self.agents_config['researcher'],\n      verbose=True,\n      tools=[SerperDevTool()]\n    )\n\n  @agent\n  def reporting_analyst(self) -> Agent:\n    return Agent(\n      config=self.agents_config['reporting_analyst'],\n      verbose=True\n    )\n\n  @task\n  def research_task(self) -> Task:\n    return Task(\n      config=self.tasks_config['research_task']\n    )\n\n  @task\n  def reporting_task(self) -> Task:\n    return Task(\n      config=self.tasks_config['reporting_task']\n    )\n\n  @crew\n  def crew(self) -> Crew:\n    return Crew(\n      agents=[\n        self.researcher(),\n        self.reporting_analyst()\n      ],\n      tasks=[\n        self.research_task(),\n        self.reporting_task()\n      ],\n      process=Process.sequential\n    )",
      "formatted_path": "Changelog > Tasks > Creating Tasks > YAML Configuration (Recommended)",
      "enhanced_text": "Context: Changelog > Tasks > Creating Tasks > YAML Configuration (Recommended)\n\n# src/latest_ai_development/crew.py\n\nfrom crewai import Agent, Crew, Process, Task\nfrom crewai.project import CrewBase, agent, crew, task\nfrom crewai_tools import SerperDevTool\n\n@CrewBase\nclass LatestAiDevelopmentCrew():\n  \"\"\"LatestAiDevelopment crew\"\"\"\n\n  @agent\n  def researcher(self) -> Agent:\n    return Agent(\n      config=self.agents_config['researcher'],\n      verbose=True,\n      tools=[SerperDevTool()]\n    )\n\n  @agent\n  def reporting_analyst(self) -> Agent:\n    return Agent(\n      config=self.agents_config['reporting_analyst'],\n      verbose=True\n    )\n\n  @task\n  def research_task(self) -> Task:\n    return Task(\n      config=self.tasks_config['research_task']\n    )\n\n  @task\n  def reporting_task(self) -> Task:\n    return Task(\n      config=self.tasks_config['reporting_task']\n    )\n\n  @crew\n  def crew(self) -> Crew:\n    return Crew(\n      agents=[\n        self.researcher(),\n        self.reporting_analyst()\n      ],\n      tasks=[\n        self.research_task(),\n        self.reporting_task()\n      ],\n      process=Process.sequential\n    )"
    },
    {
      "content": "from crewai import Agent, Crew, Task, Process\nfrom crewai_tools import YourCustomTool\n\nclass YourCrewName:\n    def agent_one(self) -> Agent:\n        return Agent(\n            role=\"Data Analyst\",\n            goal=\"Analyze data trends in the market\",\n            backstory=\"An experienced data analyst with a background in economics\",\n            verbose=True,\n            tools=[YourCustomTool()]\n        )\n\n    def agent_two(self) -> Agent:\n        return Agent(\n            role=\"Market Researcher\",\n            goal=\"Gather information on market dynamics\",\n            backstory=\"A diligent researcher with a keen eye for detail\",\n            verbose=True\n        )\n\n    def task_one(self) -> Task:\n        return Task(\n            description=\"Collect recent market data and identify trends.\",\n            expected_output=\"A report summarizing key trends in the market.\",\n            agent=self.agent_one()\n        )\n\n    def task_two(self) -> Task:\n        return Task(\n            description=\"Research factors affecting market dynamics.\",\n            expected_output=\"An analysis of factors influencing the market.\",\n            agent=self.agent_two()\n        )\n\n    def crew(self) -> Crew:\n        return Crew(\n            agents=[self.agent_one(), self.agent_two()],\n            tasks=[self.task_one(), self.task_two()],\n            process=Process.sequential,\n            verbose=True\n        )",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tasks",
          "level": 1
        },
        {
          "title": "Creating Tasks",
          "level": 2
        },
        {
          "title": "Direct Code Definition (Alternative)",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tasks",
            "level": 1
          },
          {
            "title": "Creating Tasks",
            "level": 2
          },
          {
            "title": "Direct Code Definition (Alternative)",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tasks > Creating Tasks > Direct Code Definition (Alternative)"
      },
      "enhanced_content": "Context: Changelog > Tasks > Creating Tasks > Direct Code Definition (Alternative)\n\nfrom crewai import Agent, Crew, Task, Process\nfrom crewai_tools import YourCustomTool\n\nclass YourCrewName:\n    def agent_one(self) -> Agent:\n        return Agent(\n            role=\"Data Analyst\",\n            goal=\"Analyze data trends in the market\",\n            backstory=\"An experienced data analyst with a background in economics\",\n            verbose=True,\n            tools=[YourCustomTool()]\n        )\n\n    def agent_two(self) -> Agent:\n        return Agent(\n            role=\"Market Researcher\",\n            goal=\"Gather information on market dynamics\",\n            backstory=\"A diligent researcher with a keen eye for detail\",\n            verbose=True\n        )\n\n    def task_one(self) -> Task:\n        return Task(\n            description=\"Collect recent market data and identify trends.\",\n            expected_output=\"A report summarizing key trends in the market.\",\n            agent=self.agent_one()\n        )\n\n    def task_two(self) -> Task:\n        return Task(\n            description=\"Research factors affecting market dynamics.\",\n            expected_output=\"An analysis of factors influencing the market.\",\n            agent=self.agent_two()\n        )\n\n    def crew(self) -> Crew:\n        return Crew(\n            agents=[self.agent_one(), self.agent_two()],\n            tasks=[self.task_one(), self.task_two()],\n            process=Process.sequential,\n            verbose=True\n        )",
      "formatted_path": "Changelog > Tasks > Creating Tasks > Direct Code Definition (Alternative)",
      "enhanced_text": "Context: Changelog > Tasks > Creating Tasks > Direct Code Definition (Alternative)\n\nfrom crewai import Agent, Crew, Task, Process\nfrom crewai_tools import YourCustomTool\n\nclass YourCrewName:\n    def agent_one(self) -> Agent:\n        return Agent(\n            role=\"Data Analyst\",\n            goal=\"Analyze data trends in the market\",\n            backstory=\"An experienced data analyst with a background in economics\",\n            verbose=True,\n            tools=[YourCustomTool()]\n        )\n\n    def agent_two(self) -> Agent:\n        return Agent(\n            role=\"Market Researcher\",\n            goal=\"Gather information on market dynamics\",\n            backstory=\"A diligent researcher with a keen eye for detail\",\n            verbose=True\n        )\n\n    def task_one(self) -> Task:\n        return Task(\n            description=\"Collect recent market data and identify trends.\",\n            expected_output=\"A report summarizing key trends in the market.\",\n            agent=self.agent_one()\n        )\n\n    def task_two(self) -> Task:\n        return Task(\n            description=\"Research factors affecting market dynamics.\",\n            expected_output=\"An analysis of factors influencing the market.\",\n            agent=self.agent_two()\n        )\n\n    def crew(self) -> Crew:\n        return Crew(\n            agents=[self.agent_one(), self.agent_two()],\n            tasks=[self.task_one(), self.task_two()],\n            process=Process.sequential,\n            verbose=True\n        )"
    },
    {
      "content": "from crewai import Task\n\nresearch_task = Task(\n    description=\"\"\"\n        Conduct a thorough research about AI Agents.\n        Make sure you find any interesting and relevant information given\n        the current year is 2025.\n    \"\"\",\n    expected_output=\"\"\"\n        A list with 10 bullet points of the most relevant information about AI Agents\n    \"\"\",\n    agent=researcher\n)\n\nreporting_task = Task(\n    description=\"\"\"\n        Review the context you got and expand each topic into a full section for a report.\n        Make sure the report is detailed and contains any and all relevant information.\n    \"\"\",\n    expected_output=\"\"\"\n        A fully fledge reports with the mains topics, each with a full section of information.\n        Formatted as markdown without '```'\n    \"\"\",\n    agent=reporting_analyst,\n    output_file=\"report.md\"\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tasks",
          "level": 1
        },
        {
          "title": "Creating Tasks",
          "level": 2
        },
        {
          "title": "Direct Code Definition (Alternative)",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tasks",
            "level": 1
          },
          {
            "title": "Creating Tasks",
            "level": 2
          },
          {
            "title": "Direct Code Definition (Alternative)",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tasks > Creating Tasks > Direct Code Definition (Alternative)"
      },
      "enhanced_content": "Context: Changelog > Tasks > Creating Tasks > Direct Code Definition (Alternative)\n\nfrom crewai import Task\n\nresearch_task = Task(\n    description=\"\"\"\n        Conduct a thorough research about AI Agents.\n        Make sure you find any interesting and relevant information given\n        the current year is 2025.\n    \"\"\",\n    expected_output=\"\"\"\n        A list with 10 bullet points of the most relevant information about AI Agents\n    \"\"\",\n    agent=researcher\n)\n\nreporting_task = Task(\n    description=\"\"\"\n        Review the context you got and expand each topic into a full section for a report.\n        Make sure the report is detailed and contains any and all relevant information.\n    \"\"\",\n    expected_output=\"\"\"\n        A fully fledge reports with the mains topics, each with a full section of information.\n        Formatted as markdown without '```'\n    \"\"\",\n    agent=reporting_analyst,\n    output_file=\"report.md\"\n)",
      "formatted_path": "Changelog > Tasks > Creating Tasks > Direct Code Definition (Alternative)",
      "enhanced_text": "Context: Changelog > Tasks > Creating Tasks > Direct Code Definition (Alternative)\n\nfrom crewai import Task\n\nresearch_task = Task(\n    description=\"\"\"\n        Conduct a thorough research about AI Agents.\n        Make sure you find any interesting and relevant information given\n        the current year is 2025.\n    \"\"\",\n    expected_output=\"\"\"\n        A list with 10 bullet points of the most relevant information about AI Agents\n    \"\"\",\n    agent=researcher\n)\n\nreporting_task = Task(\n    description=\"\"\"\n        Review the context you got and expand each topic into a full section for a report.\n        Make sure the report is detailed and contains any and all relevant information.\n    \"\"\",\n    expected_output=\"\"\"\n        A fully fledge reports with the mains topics, each with a full section of information.\n        Formatted as markdown without '```'\n    \"\"\",\n    agent=reporting_analyst,\n    output_file=\"report.md\"\n)"
    },
    {
      "content": "Understanding task outputs is crucial for building effective AI workflows. CrewAI provides a structured way to handle task results through the `TaskOutput` class, which supports multiple output formats and can be easily passed between tasks. The output of a task in CrewAI framework is encapsulated within the `TaskOutput` class. This class provides a structured way to access results of a task, including various formats such as raw output, JSON, and Pydantic models. By default, the `TaskOutput` will only include the `raw` output. A `TaskOutput` will only include the `pydantic` or `json_dict` output if the original `Task` object was configured with `output_pydantic` or `output_json`, respectively.",
      "title": "Task Output",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tasks",
          "level": 1
        },
        {
          "title": "Task Output",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tasks",
            "level": 1
          },
          {
            "title": "Task Output",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tasks > Task Output"
      },
      "enhanced_content": "Context: Changelog > Tasks > Task Output\n\n## Task Output\n\nUnderstanding task outputs is crucial for building effective AI workflows. CrewAI provides a structured way to handle task results through the `TaskOutput` class, which supports multiple output formats and can be easily passed between tasks. The output of a task in CrewAI framework is encapsulated within the `TaskOutput` class. This class provides a structured way to access results of a task, including various formats such as raw output, JSON, and Pydantic models. By default, the `TaskOutput` will only include the `raw` output. A `TaskOutput` will only include the `pydantic` or `json_dict` output if the original `Task` object was configured with `output_pydantic` or `output_json`, respectively.",
      "formatted_path": "Changelog > Tasks > Task Output",
      "enhanced_text": "Context: Changelog > Tasks > Task Output\n\n Task Output\n\nUnderstanding task outputs is crucial for building effective AI workflows. CrewAI provides a structured way to handle task results through the `TaskOutput` class, which supports multiple output formats and can be easily passed between tasks. The output of a task in CrewAI framework is encapsulated within the `TaskOutput` class. This class provides a structured way to access results of a task, including various formats such as raw output, JSON, and Pydantic models. By default, the `TaskOutput` will only include the `raw` output. A `TaskOutput` will only include the `pydantic` or `json_dict` output if the original `Task` object was configured with `output_pydantic` or `output_json`, respectively.\n\nRelated sections:\n- \n- \n- \n"
    },
    {
      "content": "| Attribute         | Parameters      | Type                       | Description                                                                                        |\n| :---------------- | :-------------- | :------------------------- | :------------------------------------------------------------------------------------------------- |\n| **Description**   | `description`   | `str`                      | Description of the task.                                                                           |\n| **Summary**       | `summary`       | `Optional[str]`            | Summary of the task, auto-generated from the first 10 words of the description.                    |\n| **Raw**           | `raw`           | `str`                      | The raw output of the task. This is the default format for the output.                             |\n| **Pydantic**      | `pydantic`      | `Optional[BaseModel]`      | A Pydantic model object representing the structured output of the task.                            |\n| **JSON Dict**     | `json_dict`     | `Optional[Dict[str, Any]]` | A dictionary representing the JSON output of the task.                                             |\n| **Agent**         | `agent`         | `str`                      | The agent that executed the task.                                                                  |\n| **Output Format** | `output_format` | `OutputFormat`             | The format of the task output, with options including RAW, JSON, and Pydantic. The default is RAW. |",
      "title": "Task Output Attributes",
      "type": "descriptive_text_oversized",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tasks",
          "level": 1
        },
        {
          "title": "Task Output",
          "level": 2
        },
        {
          "title": "Task Output Attributes",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tasks",
            "level": 1
          },
          {
            "title": "Task Output",
            "level": 2
          },
          {
            "title": "Task Output Attributes",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tasks > Task Output > Task Output Attributes"
      },
      "enhanced_content": "Context: Changelog > Tasks > Task Output > Task Output Attributes\n\n### Task Output Attributes\n\n| Attribute         | Parameters      | Type                       | Description                                                                                        |\n| :---------------- | :-------------- | :------------------------- | :------------------------------------------------------------------------------------------------- |\n| **Description**   | `description`   | `str`                      | Description of the task.                                                                           |\n| **Summary**       | `summary`       | `Optional[str]`            | Summary of the task, auto-generated from the first 10 words of the description.                    |\n| **Raw**           | `raw`           | `str`                      | The raw output of the task. This is the default format for the output.                             |\n| **Pydantic**      | `pydantic`      | `Optional[BaseModel]`      | A Pydantic model object representing the structured output of the task.                            |\n| **JSON Dict**     | `json_dict`     | `Optional[Dict[str, Any]]` | A dictionary representing the JSON output of the task.                                             |\n| **Agent**         | `agent`         | `str`                      | The agent that executed the task.                                                                  |\n| **Output Format** | `output_format` | `OutputFormat`             | The format of the task output, with options including RAW, JSON, and Pydantic. The default is RAW. |",
      "formatted_path": "Changelog > Tasks > Task Output > Task Output Attributes",
      "enhanced_text": "Context: Changelog > Tasks > Task Output > Task Output Attributes\n\n Task Output Attributes\n\n| Attribute         | Parameters      | Type                       | Description                                                                                        |\n| :---------------- | :-------------- | :------------------------- | :------------------------------------------------------------------------------------------------- |\n| **Description**   | `description`   | `str`                      | Description of the task.                                                                           |\n| **Summary**       | `summary`       | `Optional[str]`            | Summary of the task, auto-generated from the first 10 words of the description.                    |\n| **Raw**           | `raw`           | `str`                      | The raw output of the task. This is the default format for the output.                             |\n| **Pydantic**      | `pydantic`      | `Optional[BaseModel]`      | A Pydantic model object representing the structured output of the task.                            |\n| **JSON Dict**     | `json_dict`     | `Optional[Dict[str, Any]]` | A dictionary representing the JSON output of the task.                                             |\n| **Agent**         | `agent`         | `str`                      | The agent that executed the task.                                                                  |\n| **Output Format** | `output_format` | `OutputFormat`             | The format of the task output, with options including RAW, JSON, and Pydantic. The default is RAW. |\n\nRelated sections:\n- \n"
    },
    {
      "content": "| Method/Property | Description                                                                                       |\n| :-------------- | :------------------------------------------------------------------------------------------------ |\n| **json**        | Returns the JSON string representation of the task output if the output format is JSON.           |\n| **to\\_dict**    | Converts the JSON and Pydantic outputs to a dictionary.                                           |\n| **str**         | Returns the string representation of the task output, prioritizing Pydantic, then JSON, then raw. |",
      "title": "Task Methods and Properties",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tasks",
          "level": 1
        },
        {
          "title": "Task Output",
          "level": 2
        },
        {
          "title": "Task Methods and Properties",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tasks",
            "level": 1
          },
          {
            "title": "Task Output",
            "level": 2
          },
          {
            "title": "Task Methods and Properties",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tasks > Task Output > Task Methods and Properties"
      },
      "enhanced_content": "Context: Changelog > Tasks > Task Output > Task Methods and Properties\n\n### Task Methods and Properties\n\n| Method/Property | Description                                                                                       |\n| :-------------- | :------------------------------------------------------------------------------------------------ |\n| **json**        | Returns the JSON string representation of the task output if the output format is JSON.           |\n| **to\\_dict**    | Converts the JSON and Pydantic outputs to a dictionary.                                           |\n| **str**         | Returns the string representation of the task output, prioritizing Pydantic, then JSON, then raw. |",
      "formatted_path": "Changelog > Tasks > Task Output > Task Methods and Properties",
      "enhanced_text": "Context: Changelog > Tasks > Task Output > Task Methods and Properties\n\n Task Methods and Properties\n\n| Method/Property | Description                                                                                       |\n| :-------------- | :------------------------------------------------------------------------------------------------ |\n| **json**        | Returns the JSON string representation of the task output if the output format is JSON.           |\n| **to\\_dict**    | Converts the JSON and Pydantic outputs to a dictionary.                                           |\n| **str**         | Returns the string representation of the task output, prioritizing Pydantic, then JSON, then raw. |"
    },
    {
      "content": "Once a task has been executed, its output can be accessed through the `output` attribute of the `Task` object. The `TaskOutput` class provides various ways to interact with and present this output.",
      "title": "Accessing Task Outputs",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tasks",
          "level": 1
        },
        {
          "title": "Task Output",
          "level": 2
        },
        {
          "title": "Accessing Task Outputs",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tasks",
            "level": 1
          },
          {
            "title": "Task Output",
            "level": 2
          },
          {
            "title": "Accessing Task Outputs",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tasks > Task Output > Accessing Task Outputs"
      },
      "enhanced_content": "Context: Changelog > Tasks > Task Output > Accessing Task Outputs\n\n### Accessing Task Outputs\n\nOnce a task has been executed, its output can be accessed through the `output` attribute of the `Task` object. The `TaskOutput` class provides various ways to interact with and present this output.",
      "formatted_path": "Changelog > Tasks > Task Output > Accessing Task Outputs",
      "enhanced_text": "Context: Changelog > Tasks > Task Output > Accessing Task Outputs\n\n Accessing Task Outputs\n\nOnce a task has been executed, its output can be accessed through the `output` attribute of the `Task` object. The `TaskOutput` class provides various ways to interact with and present this output.\n\nRelated sections:\n- \n"
    },
    {
      "content": "research_task = Task(\n    description=\"Research the latest developments in AI\",\n    expected_output=\"A list of recent AI developments\",\n    agent=researcher\n)\n\nanalysis_task = Task(\n    description=\"Analyze the research findings and identify key trends\",\n    expected_output=\"Analysis report of AI trends\",\n    agent=analyst,\n    context=[research_task]  # This task will wait for research_task to complete\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tasks",
          "level": 1
        },
        {
          "title": "Task Dependencies and Context",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tasks",
            "level": 1
          },
          {
            "title": "Task Dependencies and Context",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tasks > Task Dependencies and Context"
      },
      "enhanced_content": "Context: Changelog > Tasks > Task Dependencies and Context\n\nresearch_task = Task(\n    description=\"Research the latest developments in AI\",\n    expected_output=\"A list of recent AI developments\",\n    agent=researcher\n)\n\nanalysis_task = Task(\n    description=\"Analyze the research findings and identify key trends\",\n    expected_output=\"Analysis report of AI trends\",\n    agent=analyst,\n    context=[research_task]  # This task will wait for research_task to complete\n)",
      "formatted_path": "Changelog > Tasks > Task Dependencies and Context",
      "enhanced_text": "Context: Changelog > Tasks > Task Dependencies and Context\n\nresearch_task = Task(\n    description=\"Research the latest developments in AI\",\n    expected_output=\"A list of recent AI developments\",\n    agent=researcher\n)\n\nanalysis_task = Task(\n    description=\"Analyze the research findings and identify key trends\",\n    expected_output=\"Analysis report of AI trends\",\n    agent=analyst,\n    context=[research_task]  # This task will wait for research_task to complete\n)"
    },
    {
      "content": "from typing import Tuple, Union, Dict, Any\n\ndef validate_blog_content(result: str) -> Tuple[bool, Union[Dict[str, Any], str]]:\n    \"\"\"Validate blog content meets requirements.\"\"\"\n    try:\n        # Check word count\n        word_count = len(result.split())\n        if word_count > 200:\n            return (False, {\n                \"error\": \"Blog content exceeds 200 words\",\n                \"code\": \"WORD_COUNT_ERROR\",\n                \"context\": {\"word_count\": word_count}\n            })\n\n        # Additional validation logic here\n        return (True, result.strip())\n    except Exception as e:\n        return (False, {\n            \"error\": \"Unexpected error during validation\",\n            \"code\": \"SYSTEM_ERROR\"\n        })\n\nblog_task = Task(\n    description=\"Write a blog post about AI\",\n    expected_output=\"A blog post under 200 words\",\n    agent=blog_agent,\n    guardrail=validate_blog_content  # Add the guardrail function\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tasks",
          "level": 1
        },
        {
          "title": "Task Guardrails",
          "level": 2
        },
        {
          "title": "Using Task Guardrails",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tasks",
            "level": 1
          },
          {
            "title": "Task Guardrails",
            "level": 2
          },
          {
            "title": "Using Task Guardrails",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tasks > Task Guardrails > Using Task Guardrails"
      },
      "enhanced_content": "Context: Changelog > Tasks > Task Guardrails > Using Task Guardrails\n\nfrom typing import Tuple, Union, Dict, Any\n\ndef validate_blog_content(result: str) -> Tuple[bool, Union[Dict[str, Any], str]]:\n    \"\"\"Validate blog content meets requirements.\"\"\"\n    try:\n        # Check word count\n        word_count = len(result.split())\n        if word_count > 200:\n            return (False, {\n                \"error\": \"Blog content exceeds 200 words\",\n                \"code\": \"WORD_COUNT_ERROR\",\n                \"context\": {\"word_count\": word_count}\n            })\n\n        # Additional validation logic here\n        return (True, result.strip())\n    except Exception as e:\n        return (False, {\n            \"error\": \"Unexpected error during validation\",\n            \"code\": \"SYSTEM_ERROR\"\n        })\n\nblog_task = Task(\n    description=\"Write a blog post about AI\",\n    expected_output=\"A blog post under 200 words\",\n    agent=blog_agent,\n    guardrail=validate_blog_content  # Add the guardrail function\n)",
      "formatted_path": "Changelog > Tasks > Task Guardrails > Using Task Guardrails",
      "enhanced_text": "Context: Changelog > Tasks > Task Guardrails > Using Task Guardrails\n\nfrom typing import Tuple, Union, Dict, Any\n\ndef validate_blog_content(result: str) -> Tuple[bool, Union[Dict[str, Any], str]]:\n    \"\"\"Validate blog content meets requirements.\"\"\"\n    try:\n        # Check word count\n        word_count = len(result.split())\n        if word_count > 200:\n            return (False, {\n                \"error\": \"Blog content exceeds 200 words\",\n                \"code\": \"WORD_COUNT_ERROR\",\n                \"context\": {\"word_count\": word_count}\n            })\n\n        # Additional validation logic here\n        return (True, result.strip())\n    except Exception as e:\n        return (False, {\n            \"error\": \"Unexpected error during validation\",\n            \"code\": \"SYSTEM_ERROR\"\n        })\n\nblog_task = Task(\n    description=\"Write a blog post about AI\",\n    expected_output=\"A blog post under 200 words\",\n    agent=blog_agent,\n    guardrail=validate_blog_content  # Add the guardrail function\n)"
    },
    {
      "content": "**Function Signature**: Must accept exactly one parameter (the task output) Should return a tuple of `(bool, Any)` Type hints are recommended but optional **Return Values**: Success: Return `(True, validated_result)` Failure: Return `(False, error_details)`",
      "title": "Guardrail Function Requirements",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tasks",
          "level": 1
        },
        {
          "title": "Task Guardrails",
          "level": 2
        },
        {
          "title": "Guardrail Function Requirements",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tasks",
            "level": 1
          },
          {
            "title": "Task Guardrails",
            "level": 2
          },
          {
            "title": "Guardrail Function Requirements",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tasks > Task Guardrails > Guardrail Function Requirements"
      },
      "enhanced_content": "Context: Changelog > Tasks > Task Guardrails > Guardrail Function Requirements\n\n### Guardrail Function Requirements\n\n**Function Signature**: Must accept exactly one parameter (the task output) Should return a tuple of `(bool, Any)` Type hints are recommended but optional **Return Values**: Success: Return `(True, validated_result)` Failure: Return `(False, error_details)`",
      "formatted_path": "Changelog > Tasks > Task Guardrails > Guardrail Function Requirements",
      "enhanced_text": "Context: Changelog > Tasks > Task Guardrails > Guardrail Function Requirements\n\n Guardrail Function Requirements\n\n**Function Signature**: Must accept exactly one parameter (the task output) Should return a tuple of `(bool, Any)` Type hints are recommended but optional **Return Values**: Success: Return `(True, validated_result)` Failure: Return `(False, error_details)`\n\nRelated sections:\n- \n- \n- \n- \n"
    },
    {
      "content": "def validate_with_context(result: str) -> Tuple[bool, Union[Dict[str, Any], str]]:\n    try:\n        # Main validation logic\n        validated_data = perform_validation(result)\n        return (True, validated_data)\n    except ValidationError as e:\n        return (False, {\n            \"error\": str(e),\n            \"code\": \"VALIDATION_ERROR\",\n            \"context\": {\"input\": result}\n        })\n    except Exception as e:\n        return (False, {\n            \"error\": \"Unexpected error\",\n            \"code\": \"SYSTEM_ERROR\"\n        })",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tasks",
          "level": 1
        },
        {
          "title": "Task Guardrails",
          "level": 2
        },
        {
          "title": "Error Handling Best Practices",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tasks",
            "level": 1
          },
          {
            "title": "Task Guardrails",
            "level": 2
          },
          {
            "title": "Error Handling Best Practices",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tasks > Task Guardrails > Error Handling Best Practices"
      },
      "enhanced_content": "Context: Changelog > Tasks > Task Guardrails > Error Handling Best Practices\n\ndef validate_with_context(result: str) -> Tuple[bool, Union[Dict[str, Any], str]]:\n    try:\n        # Main validation logic\n        validated_data = perform_validation(result)\n        return (True, validated_data)\n    except ValidationError as e:\n        return (False, {\n            \"error\": str(e),\n            \"code\": \"VALIDATION_ERROR\",\n            \"context\": {\"input\": result}\n        })\n    except Exception as e:\n        return (False, {\n            \"error\": \"Unexpected error\",\n            \"code\": \"SYSTEM_ERROR\"\n        })",
      "formatted_path": "Changelog > Tasks > Task Guardrails > Error Handling Best Practices",
      "enhanced_text": "Context: Changelog > Tasks > Task Guardrails > Error Handling Best Practices\n\ndef validate_with_context(result: str) -> Tuple[bool, Union[Dict[str, Any], str]]:\n    try:\n        # Main validation logic\n        validated_data = perform_validation(result)\n        return (True, validated_data)\n    except ValidationError as e:\n        return (False, {\n            \"error\": str(e),\n            \"code\": \"VALIDATION_ERROR\",\n            \"context\": {\"input\": result}\n        })\n    except Exception as e:\n        return (False, {\n            \"error\": \"Unexpected error\",\n            \"code\": \"SYSTEM_ERROR\"\n        })"
    },
    {
      "content": "from typing import Any, Dict, List, Tuple, Union\n\ndef complex_validation(result: str) -> Tuple[bool, Union[str, Dict[str, Any]]]:\n    \"\"\"Chain multiple validation steps.\"\"\"\n    # Step 1: Basic validation\n    if not result:\n        return (False, {\"error\": \"Empty result\", \"code\": \"EMPTY_INPUT\"})\n\n    # Step 2: Content validation\n    try:\n        validated = validate_content(result)\n        if not validated:\n            return (False, {\"error\": \"Invalid content\", \"code\": \"CONTENT_ERROR\"})\n\n        # Step 3: Format validation\n        formatted = format_output(validated)\n        return (True, formatted)\n    except Exception as e:\n        return (False, {\n            \"error\": str(e),\n            \"code\": \"VALIDATION_ERROR\",\n            \"context\": {\"step\": \"content_validation\"}\n        })",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tasks",
          "level": 1
        },
        {
          "title": "Task Guardrails",
          "level": 2
        },
        {
          "title": "Error Handling Best Practices",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tasks",
            "level": 1
          },
          {
            "title": "Task Guardrails",
            "level": 2
          },
          {
            "title": "Error Handling Best Practices",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tasks > Task Guardrails > Error Handling Best Practices"
      },
      "enhanced_content": "Context: Changelog > Tasks > Task Guardrails > Error Handling Best Practices\n\nfrom typing import Any, Dict, List, Tuple, Union\n\ndef complex_validation(result: str) -> Tuple[bool, Union[str, Dict[str, Any]]]:\n    \"\"\"Chain multiple validation steps.\"\"\"\n    # Step 1: Basic validation\n    if not result:\n        return (False, {\"error\": \"Empty result\", \"code\": \"EMPTY_INPUT\"})\n\n    # Step 2: Content validation\n    try:\n        validated = validate_content(result)\n        if not validated:\n            return (False, {\"error\": \"Invalid content\", \"code\": \"CONTENT_ERROR\"})\n\n        # Step 3: Format validation\n        formatted = format_output(validated)\n        return (True, formatted)\n    except Exception as e:\n        return (False, {\n            \"error\": str(e),\n            \"code\": \"VALIDATION_ERROR\",\n            \"context\": {\"step\": \"content_validation\"}\n        })",
      "formatted_path": "Changelog > Tasks > Task Guardrails > Error Handling Best Practices",
      "enhanced_text": "Context: Changelog > Tasks > Task Guardrails > Error Handling Best Practices\n\nfrom typing import Any, Dict, List, Tuple, Union\n\ndef complex_validation(result: str) -> Tuple[bool, Union[str, Dict[str, Any]]]:\n    \"\"\"Chain multiple validation steps.\"\"\"\n    # Step 1: Basic validation\n    if not result:\n        return (False, {\"error\": \"Empty result\", \"code\": \"EMPTY_INPUT\"})\n\n    # Step 2: Content validation\n    try:\n        validated = validate_content(result)\n        if not validated:\n            return (False, {\"error\": \"Invalid content\", \"code\": \"CONTENT_ERROR\"})\n\n        # Step 3: Format validation\n        formatted = format_output(validated)\n        return (True, formatted)\n    except Exception as e:\n        return (False, {\n            \"error\": str(e),\n            \"code\": \"VALIDATION_ERROR\",\n            \"context\": {\"step\": \"content_validation\"}\n        })"
    },
    {
      "content": "from typing import Optional, Tuple, Union\n\ndef validate_json_output(result: str) -> Tuple[bool, Union[Dict[str, Any], str]]:\n    \"\"\"Validate and parse JSON output.\"\"\"\n    try:\n        # Try to parse as JSON\n        data = json.loads(result)\n        return (True, data)\n    except json.JSONDecodeError as e:\n        return (False, {\n            \"error\": \"Invalid JSON format\",\n            \"code\": \"JSON_ERROR\",\n            \"context\": {\"line\": e.lineno, \"column\": e.colno}\n        })\n\ntask = Task(\n    description=\"Generate a JSON report\",\n    expected_output=\"A valid JSON object\",\n    agent=analyst,\n    guardrail=validate_json_output,\n    max_retries=3  # Limit retry attempts\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tasks",
          "level": 1
        },
        {
          "title": "Task Guardrails",
          "level": 2
        },
        {
          "title": "Handling Guardrail Results",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tasks",
            "level": 1
          },
          {
            "title": "Task Guardrails",
            "level": 2
          },
          {
            "title": "Handling Guardrail Results",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tasks > Task Guardrails > Handling Guardrail Results"
      },
      "enhanced_content": "Context: Changelog > Tasks > Task Guardrails > Handling Guardrail Results\n\nfrom typing import Optional, Tuple, Union\n\ndef validate_json_output(result: str) -> Tuple[bool, Union[Dict[str, Any], str]]:\n    \"\"\"Validate and parse JSON output.\"\"\"\n    try:\n        # Try to parse as JSON\n        data = json.loads(result)\n        return (True, data)\n    except json.JSONDecodeError as e:\n        return (False, {\n            \"error\": \"Invalid JSON format\",\n            \"code\": \"JSON_ERROR\",\n            \"context\": {\"line\": e.lineno, \"column\": e.colno}\n        })\n\ntask = Task(\n    description=\"Generate a JSON report\",\n    expected_output=\"A valid JSON object\",\n    agent=analyst,\n    guardrail=validate_json_output,\n    max_retries=3  # Limit retry attempts\n)",
      "formatted_path": "Changelog > Tasks > Task Guardrails > Handling Guardrail Results",
      "enhanced_text": "Context: Changelog > Tasks > Task Guardrails > Handling Guardrail Results\n\nfrom typing import Optional, Tuple, Union\n\ndef validate_json_output(result: str) -> Tuple[bool, Union[Dict[str, Any], str]]:\n    \"\"\"Validate and parse JSON output.\"\"\"\n    try:\n        # Try to parse as JSON\n        data = json.loads(result)\n        return (True, data)\n    except json.JSONDecodeError as e:\n        return (False, {\n            \"error\": \"Invalid JSON format\",\n            \"code\": \"JSON_ERROR\",\n            \"context\": {\"line\": e.lineno, \"column\": e.colno}\n        })\n\ntask = Task(\n    description=\"Generate a JSON report\",\n    expected_output=\"A valid JSON object\",\n    agent=analyst,\n    guardrail=validate_json_output,\n    max_retries=3  # Limit retry attempts\n)"
    },
    {
      "content": "import json\n\nfrom crewai import Agent, Crew, Process, Task\nfrom pydantic import BaseModel\n\n\nclass Blog(BaseModel):\n    title: str\n    content: str\n\n\nblog_agent = Agent(\n    role=\"Blog Content Generator Agent\",\n    goal=\"Generate a blog title and content\",\n    backstory=\"\"\"You are an expert content creator, skilled in crafting engaging and informative blog posts.\"\"\",\n    verbose=False,\n    allow_delegation=False,\n    llm=\"gpt-4o\",\n)\n\ntask1 = Task(\n    description=\"\"\"Create a blog title and content on a given topic. Make sure the content is under 200 words.\"\"\",\n    expected_output=\"A compelling blog title and well-written content.\",\n    agent=blog_agent,\n    output_pydantic=Blog,\n)\n\n# Instantiate your crew with a sequential process\ncrew = Crew(\n    agents=[blog_agent],\n    tasks=[task1],\n    verbose=True,\n    process=Process.sequential,\n)\n\nresult = crew.kickoff()\n\n# Option 1: Accessing Properties Using Dictionary-Style Indexing\nprint(\"Accessing Properties - Option 1\")\ntitle = result[\"title\"]\ncontent = result[\"content\"]\nprint(\"Title:\", title)\nprint(\"Content:\", content)\n\n# Option 2: Accessing Properties Directly from the Pydantic Model\nprint(\"Accessing Properties - Option 2\")\ntitle = result.pydantic.title\ncontent = result.pydantic.content\nprint(\"Title:\", title)\nprint(\"Content:\", content)\n\n# Option 3: Accessing Properties Using the to_dict() Method\nprint(\"Accessing Properties - Option 3\")\noutput_dict = result.to_dict()\ntitle = output_dict[\"title\"]\ncontent = output_dict[\"content\"]\nprint(\"Title:\", title)\nprint(\"Content:\", content)\n\n# Option 4: Printing the Entire Blog Object\nprint(\"Accessing Properties - Option 5\")\nprint(\"Blog:\", result)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tasks",
          "level": 1
        },
        {
          "title": "Getting Structured Consistent Outputs from Tasks",
          "level": 2
        },
        {
          "title": "Using `output_pydantic`",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tasks",
            "level": 1
          },
          {
            "title": "Getting Structured Consistent Outputs from Tasks",
            "level": 2
          },
          {
            "title": "Using `output_pydantic`",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tasks > Getting Structured Consistent Outputs from Tasks > Using `output_pydantic`"
      },
      "enhanced_content": "Context: Changelog > Tasks > Getting Structured Consistent Outputs from Tasks > Using `output_pydantic`\n\nimport json\n\nfrom crewai import Agent, Crew, Process, Task\nfrom pydantic import BaseModel\n\n\nclass Blog(BaseModel):\n    title: str\n    content: str\n\n\nblog_agent = Agent(\n    role=\"Blog Content Generator Agent\",\n    goal=\"Generate a blog title and content\",\n    backstory=\"\"\"You are an expert content creator, skilled in crafting engaging and informative blog posts.\"\"\",\n    verbose=False,\n    allow_delegation=False,\n    llm=\"gpt-4o\",\n)\n\ntask1 = Task(\n    description=\"\"\"Create a blog title and content on a given topic. Make sure the content is under 200 words.\"\"\",\n    expected_output=\"A compelling blog title and well-written content.\",\n    agent=blog_agent,\n    output_pydantic=Blog,\n)\n\n# Instantiate your crew with a sequential process\ncrew = Crew(\n    agents=[blog_agent],\n    tasks=[task1],\n    verbose=True,\n    process=Process.sequential,\n)\n\nresult = crew.kickoff()\n\n# Option 1: Accessing Properties Using Dictionary-Style Indexing\nprint(\"Accessing Properties - Option 1\")\ntitle = result[\"title\"]\ncontent = result[\"content\"]\nprint(\"Title:\", title)\nprint(\"Content:\", content)\n\n# Option 2: Accessing Properties Directly from the Pydantic Model\nprint(\"Accessing Properties - Option 2\")\ntitle = result.pydantic.title\ncontent = result.pydantic.content\nprint(\"Title:\", title)\nprint(\"Content:\", content)\n\n# Option 3: Accessing Properties Using the to_dict() Method\nprint(\"Accessing Properties - Option 3\")\noutput_dict = result.to_dict()\ntitle = output_dict[\"title\"]\ncontent = output_dict[\"content\"]\nprint(\"Title:\", title)\nprint(\"Content:\", content)\n\n# Option 4: Printing the Entire Blog Object\nprint(\"Accessing Properties - Option 5\")\nprint(\"Blog:\", result)",
      "formatted_path": "Changelog > Tasks > Getting Structured Consistent Outputs from Tasks > Using `output_pydantic`",
      "enhanced_text": "Context: Changelog > Tasks > Getting Structured Consistent Outputs from Tasks > Using `output_pydantic`\n\nimport json\n\nfrom crewai import Agent, Crew, Process, Task\nfrom pydantic import BaseModel\n\n\nclass Blog(BaseModel):\n    title: str\n    content: str\n\n\nblog_agent = Agent(\n    role=\"Blog Content Generator Agent\",\n    goal=\"Generate a blog title and content\",\n    backstory=\"\"\"You are an expert content creator, skilled in crafting engaging and informative blog posts.\"\"\",\n    verbose=False,\n    allow_delegation=False,\n    llm=\"gpt-4o\",\n)\n\ntask1 = Task(\n    description=\"\"\"Create a blog title and content on a given topic. Make sure the content is under 200 words.\"\"\",\n    expected_output=\"A compelling blog title and well-written content.\",\n    agent=blog_agent,\n    output_pydantic=Blog,\n)\n\n# Instantiate your crew with a sequential process\ncrew = Crew(\n    agents=[blog_agent],\n    tasks=[task1],\n    verbose=True,\n    process=Process.sequential,\n)\n\nresult = crew.kickoff()\n\n# Option 1: Accessing Properties Using Dictionary-Style Indexing\nprint(\"Accessing Properties - Option 1\")\ntitle = result[\"title\"]\ncontent = result[\"content\"]\nprint(\"Title:\", title)\nprint(\"Content:\", content)\n\n# Option 2: Accessing Properties Directly from the Pydantic Model\nprint(\"Accessing Properties - Option 2\")\ntitle = result.pydantic.title\ncontent = result.pydantic.content\nprint(\"Title:\", title)\nprint(\"Content:\", content)\n\n# Option 3: Accessing Properties Using the to_dict() Method\nprint(\"Accessing Properties - Option 3\")\noutput_dict = result.to_dict()\ntitle = output_dict[\"title\"]\ncontent = output_dict[\"content\"]\nprint(\"Title:\", title)\nprint(\"Content:\", content)\n\n# Option 4: Printing the Entire Blog Object\nprint(\"Accessing Properties - Option 5\")\nprint(\"Blog:\", result)"
    },
    {
      "content": "import json\n\nfrom crewai import Agent, Crew, Process, Task\nfrom pydantic import BaseModel\n\n\n# Define the Pydantic model for the blog\nclass Blog(BaseModel):\n    title: str\n    content: str\n\n\n# Define the agent\nblog_agent = Agent(\n    role=\"Blog Content Generator Agent\",\n    goal=\"Generate a blog title and content\",\n    backstory=\"\"\"You are an expert content creator, skilled in crafting engaging and informative blog posts.\"\"\",\n    verbose=False,\n    allow_delegation=False,\n    llm=\"gpt-4o\",\n)\n\n# Define the task with output_json set to the Blog model\ntask1 = Task(\n    description=\"\"\"Create a blog title and content on a given topic. Make sure the content is under 200 words.\"\"\",\n    expected_output=\"A JSON object with 'title' and 'content' fields.\",\n    agent=blog_agent,\n    output_json=Blog,\n)\n\n# Instantiate the crew with a sequential process\ncrew = Crew(\n    agents=[blog_agent],\n    tasks=[task1],\n    verbose=True,\n    process=Process.sequential,\n)\n\n# Kickoff the crew to execute the task\nresult = crew.kickoff()\n\n# Option 1: Accessing Properties Using Dictionary-Style Indexing\nprint(\"Accessing Properties - Option 1\")\ntitle = result[\"title\"]\ncontent = result[\"content\"]\nprint(\"Title:\", title)\nprint(\"Content:\", content)\n\n# Option 2: Printing the Entire Blog Object\nprint(\"Accessing Properties - Option 2\")\nprint(\"Blog:\", result)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tasks",
          "level": 1
        },
        {
          "title": "Getting Structured Consistent Outputs from Tasks",
          "level": 2
        },
        {
          "title": "Using `output_json`",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tasks",
            "level": 1
          },
          {
            "title": "Getting Structured Consistent Outputs from Tasks",
            "level": 2
          },
          {
            "title": "Using `output_json`",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tasks > Getting Structured Consistent Outputs from Tasks > Using `output_json`"
      },
      "enhanced_content": "Context: Changelog > Tasks > Getting Structured Consistent Outputs from Tasks > Using `output_json`\n\nimport json\n\nfrom crewai import Agent, Crew, Process, Task\nfrom pydantic import BaseModel\n\n\n# Define the Pydantic model for the blog\nclass Blog(BaseModel):\n    title: str\n    content: str\n\n\n# Define the agent\nblog_agent = Agent(\n    role=\"Blog Content Generator Agent\",\n    goal=\"Generate a blog title and content\",\n    backstory=\"\"\"You are an expert content creator, skilled in crafting engaging and informative blog posts.\"\"\",\n    verbose=False,\n    allow_delegation=False,\n    llm=\"gpt-4o\",\n)\n\n# Define the task with output_json set to the Blog model\ntask1 = Task(\n    description=\"\"\"Create a blog title and content on a given topic. Make sure the content is under 200 words.\"\"\",\n    expected_output=\"A JSON object with 'title' and 'content' fields.\",\n    agent=blog_agent,\n    output_json=Blog,\n)\n\n# Instantiate the crew with a sequential process\ncrew = Crew(\n    agents=[blog_agent],\n    tasks=[task1],\n    verbose=True,\n    process=Process.sequential,\n)\n\n# Kickoff the crew to execute the task\nresult = crew.kickoff()\n\n# Option 1: Accessing Properties Using Dictionary-Style Indexing\nprint(\"Accessing Properties - Option 1\")\ntitle = result[\"title\"]\ncontent = result[\"content\"]\nprint(\"Title:\", title)\nprint(\"Content:\", content)\n\n# Option 2: Printing the Entire Blog Object\nprint(\"Accessing Properties - Option 2\")\nprint(\"Blog:\", result)",
      "formatted_path": "Changelog > Tasks > Getting Structured Consistent Outputs from Tasks > Using `output_json`",
      "enhanced_text": "Context: Changelog > Tasks > Getting Structured Consistent Outputs from Tasks > Using `output_json`\n\nimport json\n\nfrom crewai import Agent, Crew, Process, Task\nfrom pydantic import BaseModel\n\n\n# Define the Pydantic model for the blog\nclass Blog(BaseModel):\n    title: str\n    content: str\n\n\n# Define the agent\nblog_agent = Agent(\n    role=\"Blog Content Generator Agent\",\n    goal=\"Generate a blog title and content\",\n    backstory=\"\"\"You are an expert content creator, skilled in crafting engaging and informative blog posts.\"\"\",\n    verbose=False,\n    allow_delegation=False,\n    llm=\"gpt-4o\",\n)\n\n# Define the task with output_json set to the Blog model\ntask1 = Task(\n    description=\"\"\"Create a blog title and content on a given topic. Make sure the content is under 200 words.\"\"\",\n    expected_output=\"A JSON object with 'title' and 'content' fields.\",\n    agent=blog_agent,\n    output_json=Blog,\n)\n\n# Instantiate the crew with a sequential process\ncrew = Crew(\n    agents=[blog_agent],\n    tasks=[task1],\n    verbose=True,\n    process=Process.sequential,\n)\n\n# Kickoff the crew to execute the task\nresult = crew.kickoff()\n\n# Option 1: Accessing Properties Using Dictionary-Style Indexing\nprint(\"Accessing Properties - Option 1\")\ntitle = result[\"title\"]\ncontent = result[\"content\"]\nprint(\"Title:\", title)\nprint(\"Content:\", content)\n\n# Option 2: Printing the Entire Blog Object\nprint(\"Accessing Properties - Option 2\")\nprint(\"Blog:\", result)"
    },
    {
      "content": "Dictionary-Style Indexing: You can directly access the fields using result\\[\"field\\_name\"]. This works because the CrewOutput class implements the **getitem** method. Directly from Pydantic Model: Access the attributes directly from the result.pydantic object. Using to\\_dict() Method: Convert the output to a dictionary and access the fields. Printing the Entire Object: Simply print the result object to see the structured output.",
      "title": "Explanation of Accessing the Output",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tasks",
          "level": 1
        },
        {
          "title": "Getting Structured Consistent Outputs from Tasks",
          "level": 2
        },
        {
          "title": "Using `output_json`",
          "level": 3
        },
        {
          "title": "Explanation of Accessing the Output",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tasks",
            "level": 1
          },
          {
            "title": "Getting Structured Consistent Outputs from Tasks",
            "level": 2
          },
          {
            "title": "Using `output_json`",
            "level": 3
          },
          {
            "title": "Explanation of Accessing the Output",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tasks > Getting Structured Consistent Outputs from Tasks > Using `output_json` > Explanation of Accessing the Output"
      },
      "enhanced_content": "Context: Changelog > Tasks > Getting Structured Consistent Outputs from Tasks > Using `output_json` > Explanation of Accessing the Output\n\n#### Explanation of Accessing the Output\n\nDictionary-Style Indexing: You can directly access the fields using result\\[\"field\\_name\"]. This works because the CrewOutput class implements the **getitem** method. Directly from Pydantic Model: Access the attributes directly from the result.pydantic object. Using to\\_dict() Method: Convert the output to a dictionary and access the fields. Printing the Entire Object: Simply print the result object to see the structured output.",
      "formatted_path": "Changelog > Tasks > Getting Structured Consistent Outputs from Tasks > Using `output_json` > Explanation of Accessing the Output",
      "enhanced_text": "Context: Changelog > Tasks > Getting Structured Consistent Outputs from Tasks > Using `output_json` > Explanation of Accessing the Output\n\n Explanation of Accessing the Output\n\nDictionary-Style Indexing: You can directly access the fields using result\\[\"field\\_name\"]. This works because the CrewOutput class implements the **getitem** method. Directly from Pydantic Model: Access the attributes directly from the result.pydantic object. Using to\\_dict() Method: Convert the output to a dictionary and access the fields. Printing the Entire Object: Simply print the result object to see the structured output."
    },
    {
      "content": "Accessing Properties Using Dictionary-Style Indexing: You can access the fields directly using result\\[\"field\\_name\"]. This is possible because the CrewOutput class implements the **getitem** method, allowing you to treat the output like a dictionary. In this option, we're retrieving the title and content from the result. Printing the Entire Blog Object: By printing result, you get the string representation of the CrewOutput object. Since the **str** method is implemented to return the JSON output, this will display the entire output as a formatted string representing the Blog object. By using output\\_pydantic or output\\_json, you ensure that your tasks produce outputs in a consistent and structured format, making it easier to process and utilize the data within your application or across multiple tasks.",
      "title": "Explanation of Accessing the Output",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tasks",
          "level": 1
        },
        {
          "title": "Getting Structured Consistent Outputs from Tasks",
          "level": 2
        },
        {
          "title": "Using `output_json`",
          "level": 3
        },
        {
          "title": "Explanation of Accessing the Output",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tasks",
            "level": 1
          },
          {
            "title": "Getting Structured Consistent Outputs from Tasks",
            "level": 2
          },
          {
            "title": "Using `output_json`",
            "level": 3
          },
          {
            "title": "Explanation of Accessing the Output",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tasks > Getting Structured Consistent Outputs from Tasks > Using `output_json` > Explanation of Accessing the Output"
      },
      "enhanced_content": "Context: Changelog > Tasks > Getting Structured Consistent Outputs from Tasks > Using `output_json` > Explanation of Accessing the Output\n\n#### Explanation of Accessing the Output\n\nAccessing Properties Using Dictionary-Style Indexing: You can access the fields directly using result\\[\"field\\_name\"]. This is possible because the CrewOutput class implements the **getitem** method, allowing you to treat the output like a dictionary. In this option, we're retrieving the title and content from the result. Printing the Entire Blog Object: By printing result, you get the string representation of the CrewOutput object. Since the **str** method is implemented to return the JSON output, this will display the entire output as a formatted string representing the Blog object. By using output\\_pydantic or output\\_json, you ensure that your tasks produce outputs in a consistent and structured format, making it easier to process and utilize the data within your application or across multiple tasks.",
      "formatted_path": "Changelog > Tasks > Getting Structured Consistent Outputs from Tasks > Using `output_json` > Explanation of Accessing the Output",
      "enhanced_text": "Context: Changelog > Tasks > Getting Structured Consistent Outputs from Tasks > Using `output_json` > Explanation of Accessing the Output\n\n Explanation of Accessing the Output\n\nAccessing Properties Using Dictionary-Style Indexing: You can access the fields directly using result\\[\"field\\_name\"]. This is possible because the CrewOutput class implements the **getitem** method, allowing you to treat the output like a dictionary. In this option, we're retrieving the title and content from the result. Printing the Entire Blog Object: By printing result, you get the string representation of the CrewOutput object. Since the **str** method is implemented to return the JSON output, this will display the entire output as a formatted string representing the Blog object. By using output\\_pydantic or output\\_json, you ensure that your tasks produce outputs in a consistent and structured format, making it easier to process and utilize the data within your application or across multiple tasks."
    },
    {
      "content": "Leverage tools from the [CrewAI Toolkit](https://github.com/joaomdmoura/crewai-tools) and [LangChain Tools](https://python.langchain.com/docs/integrations/tools) for enhanced task performance and agent interaction.",
      "title": "Integrating Tools with Tasks",
      "type": "link_list",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tasks",
          "level": 1
        },
        {
          "title": "Integrating Tools with Tasks",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tasks",
            "level": 1
          },
          {
            "title": "Integrating Tools with Tasks",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 2,
        "formatted_path": "Changelog > Tasks > Integrating Tools with Tasks"
      },
      "enhanced_content": "Context: Changelog > Tasks > Integrating Tools with Tasks\n\n## Integrating Tools with Tasks\n\nLeverage tools from the [CrewAI Toolkit](https://github.com/joaomdmoura/crewai-tools) and [LangChain Tools](https://python.langchain.com/docs/integrations/tools) for enhanced task performance and agent interaction.",
      "formatted_path": "Changelog > Tasks > Integrating Tools with Tasks",
      "enhanced_text": "Context: Changelog > Tasks > Integrating Tools with Tasks\n\n Integrating Tools with Tasks\n\nLeverage tools from the [CrewAI Toolkit](https://github.com/joaomdmoura/crewai-tools) and [LangChain Tools](https://python.langchain.com/docs/integrations/tools) for enhanced task performance and agent interaction.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "import os\nos.environ[\"OPENAI_API_KEY\"] = \"Your Key\"\nos.environ[\"SERPER_API_KEY\"] = \"Your Key\" # serper.dev API key\n\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import SerperDevTool\n\nresearch_agent = Agent(\n  role='Researcher',\n  goal='Find and summarize the latest AI news',\n  backstory=\"\"\"You're a researcher at a large company.\n  You're responsible for analyzing data and providing insights\n  to the business.\"\"\",\n  verbose=True\n)\n\n# to perform a semantic search for a specified query from a text's content across the internet\nsearch_tool = SerperDevTool()\n\ntask = Task(\n  description='Find and summarize the latest AI news',\n  expected_output='A bullet list summary of the top 5 most important AI news',\n  agent=research_agent,\n  tools=[search_tool]\n)\n\ncrew = Crew(\n    agents=[research_agent],\n    tasks=[task],\n    verbose=True\n)\n\nresult = crew.kickoff()\nprint(result)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tasks",
          "level": 1
        },
        {
          "title": "Creating a Task with Tools",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tasks",
            "level": 1
          },
          {
            "title": "Creating a Task with Tools",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tasks > Creating a Task with Tools"
      },
      "enhanced_content": "Context: Changelog > Tasks > Creating a Task with Tools\n\nimport os\nos.environ[\"OPENAI_API_KEY\"] = \"Your Key\"\nos.environ[\"SERPER_API_KEY\"] = \"Your Key\" # serper.dev API key\n\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import SerperDevTool\n\nresearch_agent = Agent(\n  role='Researcher',\n  goal='Find and summarize the latest AI news',\n  backstory=\"\"\"You're a researcher at a large company.\n  You're responsible for analyzing data and providing insights\n  to the business.\"\"\",\n  verbose=True\n)\n\n# to perform a semantic search for a specified query from a text's content across the internet\nsearch_tool = SerperDevTool()\n\ntask = Task(\n  description='Find and summarize the latest AI news',\n  expected_output='A bullet list summary of the top 5 most important AI news',\n  agent=research_agent,\n  tools=[search_tool]\n)\n\ncrew = Crew(\n    agents=[research_agent],\n    tasks=[task],\n    verbose=True\n)\n\nresult = crew.kickoff()\nprint(result)",
      "formatted_path": "Changelog > Tasks > Creating a Task with Tools",
      "enhanced_text": "Context: Changelog > Tasks > Creating a Task with Tools\n\nimport os\nos.environ[\"OPENAI_API_KEY\"] = \"Your Key\"\nos.environ[\"SERPER_API_KEY\"] = \"Your Key\" # serper.dev API key\n\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import SerperDevTool\n\nresearch_agent = Agent(\n  role='Researcher',\n  goal='Find and summarize the latest AI news',\n  backstory=\"\"\"You're a researcher at a large company.\n  You're responsible for analyzing data and providing insights\n  to the business.\"\"\",\n  verbose=True\n)\n\n# to perform a semantic search for a specified query from a text's content across the internet\nsearch_tool = SerperDevTool()\n\ntask = Task(\n  description='Find and summarize the latest AI news',\n  expected_output='A bullet list summary of the top 5 most important AI news',\n  agent=research_agent,\n  tools=[search_tool]\n)\n\ncrew = Crew(\n    agents=[research_agent],\n    tasks=[task],\n    verbose=True\n)\n\nresult = crew.kickoff()\nprint(result)"
    },
    {
      "content": "# ...\n\nresearch_ai_task = Task(\n    description=\"Research the latest developments in AI\",\n    expected_output=\"A list of recent AI developments\",\n    async_execution=True,\n    agent=research_agent,\n    tools=[search_tool]\n)\n\nresearch_ops_task = Task(\n    description=\"Research the latest developments in AI Ops\",\n    expected_output=\"A list of recent AI Ops developments\",\n    async_execution=True,\n    agent=research_agent,\n    tools=[search_tool]\n)\n\nwrite_blog_task = Task(\n    description=\"Write a full blog post about the importance of AI and its latest news\",\n    expected_output=\"Full blog post that is 4 paragraphs long\",\n    agent=writer_agent,\n    context=[research_ai_task, research_ops_task]\n)\n\n#...",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tasks",
          "level": 1
        },
        {
          "title": "Referring to Other Tasks",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tasks",
            "level": 1
          },
          {
            "title": "Referring to Other Tasks",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tasks > Referring to Other Tasks"
      },
      "enhanced_content": "Context: Changelog > Tasks > Referring to Other Tasks\n\n# ...\n\nresearch_ai_task = Task(\n    description=\"Research the latest developments in AI\",\n    expected_output=\"A list of recent AI developments\",\n    async_execution=True,\n    agent=research_agent,\n    tools=[search_tool]\n)\n\nresearch_ops_task = Task(\n    description=\"Research the latest developments in AI Ops\",\n    expected_output=\"A list of recent AI Ops developments\",\n    async_execution=True,\n    agent=research_agent,\n    tools=[search_tool]\n)\n\nwrite_blog_task = Task(\n    description=\"Write a full blog post about the importance of AI and its latest news\",\n    expected_output=\"Full blog post that is 4 paragraphs long\",\n    agent=writer_agent,\n    context=[research_ai_task, research_ops_task]\n)\n\n#...",
      "formatted_path": "Changelog > Tasks > Referring to Other Tasks",
      "enhanced_text": "Context: Changelog > Tasks > Referring to Other Tasks\n\n# ...\n\nresearch_ai_task = Task(\n    description=\"Research the latest developments in AI\",\n    expected_output=\"A list of recent AI developments\",\n    async_execution=True,\n    agent=research_agent,\n    tools=[search_tool]\n)\n\nresearch_ops_task = Task(\n    description=\"Research the latest developments in AI Ops\",\n    expected_output=\"A list of recent AI Ops developments\",\n    async_execution=True,\n    agent=research_agent,\n    tools=[search_tool]\n)\n\nwrite_blog_task = Task(\n    description=\"Write a full blog post about the importance of AI and its latest news\",\n    expected_output=\"Full blog post that is 4 paragraphs long\",\n    agent=writer_agent,\n    context=[research_ai_task, research_ops_task]\n)\n\n#..."
    },
    {
      "content": "# ...\n\ndef callback_function(output: TaskOutput):\n    # Do something after the task is completed\n    # Example: Send an email to the manager\n    print(f\"\"\"\n        Task completed!\n        Task: {output.description}\n        Output: {output.raw}\n    \"\"\")\n\nresearch_task = Task(\n    description='Find and summarize the latest AI news',\n    expected_output='A bullet list summary of the top 5 most important AI news',\n    agent=research_agent,\n    tools=[search_tool],\n    callback=callback_function\n)\n\n#...",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tasks",
          "level": 1
        },
        {
          "title": "Callback Mechanism",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tasks",
            "level": 1
          },
          {
            "title": "Callback Mechanism",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tasks > Callback Mechanism"
      },
      "enhanced_content": "Context: Changelog > Tasks > Callback Mechanism\n\n# ...\n\ndef callback_function(output: TaskOutput):\n    # Do something after the task is completed\n    # Example: Send an email to the manager\n    print(f\"\"\"\n        Task completed!\n        Task: {output.description}\n        Output: {output.raw}\n    \"\"\")\n\nresearch_task = Task(\n    description='Find and summarize the latest AI news',\n    expected_output='A bullet list summary of the top 5 most important AI news',\n    agent=research_agent,\n    tools=[search_tool],\n    callback=callback_function\n)\n\n#...",
      "formatted_path": "Changelog > Tasks > Callback Mechanism",
      "enhanced_text": "Context: Changelog > Tasks > Callback Mechanism\n\n# ...\n\ndef callback_function(output: TaskOutput):\n    # Do something after the task is completed\n    # Example: Send an email to the manager\n    print(f\"\"\"\n        Task completed!\n        Task: {output.description}\n        Output: {output.raw}\n    \"\"\")\n\nresearch_task = Task(\n    description='Find and summarize the latest AI news',\n    expected_output='A bullet list summary of the top 5 most important AI news',\n    agent=research_agent,\n    tools=[search_tool],\n    callback=callback_function\n)\n\n#..."
    },
    {
      "content": "# ...\ntask1 = Task(\n    description='Find and summarize the latest AI news',\n    expected_output='A bullet list summary of the top 5 most important AI news',\n    agent=research_agent,\n    tools=[search_tool]\n)\n\n#...\n\ncrew = Crew(\n    agents=[research_agent],\n    tasks=[task1, task2, task3],\n    verbose=True\n)\n\nresult = crew.kickoff()\n\n# Returns a TaskOutput object with the description and results of the task\nprint(f\"\"\"\n    Task completed!\n    Task: {task1.output.description}\n    Output: {task1.output.raw}\n\"\"\")",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tasks",
          "level": 1
        },
        {
          "title": "Accessing a Specific Task Output",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tasks",
            "level": 1
          },
          {
            "title": "Accessing a Specific Task Output",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tasks > Accessing a Specific Task Output"
      },
      "enhanced_content": "Context: Changelog > Tasks > Accessing a Specific Task Output\n\n# ...\ntask1 = Task(\n    description='Find and summarize the latest AI news',\n    expected_output='A bullet list summary of the top 5 most important AI news',\n    agent=research_agent,\n    tools=[search_tool]\n)\n\n#...\n\ncrew = Crew(\n    agents=[research_agent],\n    tasks=[task1, task2, task3],\n    verbose=True\n)\n\nresult = crew.kickoff()\n\n# Returns a TaskOutput object with the description and results of the task\nprint(f\"\"\"\n    Task completed!\n    Task: {task1.output.description}\n    Output: {task1.output.raw}\n\"\"\")",
      "formatted_path": "Changelog > Tasks > Accessing a Specific Task Output",
      "enhanced_text": "Context: Changelog > Tasks > Accessing a Specific Task Output\n\n# ...\ntask1 = Task(\n    description='Find and summarize the latest AI news',\n    expected_output='A bullet list summary of the top 5 most important AI news',\n    agent=research_agent,\n    tools=[search_tool]\n)\n\n#...\n\ncrew = Crew(\n    agents=[research_agent],\n    tasks=[task1, task2, task3],\n    verbose=True\n)\n\nresult = crew.kickoff()\n\n# Returns a TaskOutput object with the description and results of the task\nprint(f\"\"\"\n    Task completed!\n    Task: {task1.output.description}\n    Output: {task1.output.raw}\n\"\"\")"
    },
    {
      "content": "Specifying tools in a task allows for dynamic adaptation of agent capabilities, emphasizing CrewAI's flexibility.",
      "title": "Tool Override Mechanism",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tasks",
          "level": 1
        },
        {
          "title": "Tool Override Mechanism",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tasks",
            "level": 1
          },
          {
            "title": "Tool Override Mechanism",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tasks > Tool Override Mechanism"
      },
      "enhanced_content": "Context: Changelog > Tasks > Tool Override Mechanism\n\n## Tool Override Mechanism\n\nSpecifying tools in a task allows for dynamic adaptation of agent capabilities, emphasizing CrewAI's flexibility.",
      "formatted_path": "Changelog > Tasks > Tool Override Mechanism",
      "enhanced_text": "Context: Changelog > Tasks > Tool Override Mechanism\n\n Tool Override Mechanism\n\nSpecifying tools in a task allows for dynamic adaptation of agent capabilities, emphasizing CrewAI's flexibility."
    },
    {
      "content": "While creating and executing tasks, certain validation mechanisms are in place to ensure the robustness and reliability of task attributes. These include but are not limited to: Ensuring only one output type is set per task to maintain clear output expectations. Preventing the manual assignment of the `id` attribute to uphold the integrity of the unique identifier system. These validations help in maintaining the consistency and reliability of task executions within the crewAI framework.",
      "title": "Error Handling and Validation Mechanisms",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tasks",
          "level": 1
        },
        {
          "title": "Error Handling and Validation Mechanisms",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tasks",
            "level": 1
          },
          {
            "title": "Error Handling and Validation Mechanisms",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tasks > Error Handling and Validation Mechanisms"
      },
      "enhanced_content": "Context: Changelog > Tasks > Error Handling and Validation Mechanisms\n\n## Error Handling and Validation Mechanisms\n\nWhile creating and executing tasks, certain validation mechanisms are in place to ensure the robustness and reliability of task attributes. These include but are not limited to: Ensuring only one output type is set per task to maintain clear output expectations. Preventing the manual assignment of the `id` attribute to uphold the integrity of the unique identifier system. These validations help in maintaining the consistency and reliability of task executions within the crewAI framework.",
      "formatted_path": "Changelog > Tasks > Error Handling and Validation Mechanisms",
      "enhanced_text": "Context: Changelog > Tasks > Error Handling and Validation Mechanisms\n\n Error Handling and Validation Mechanisms\n\nWhile creating and executing tasks, certain validation mechanisms are in place to ensure the robustness and reliability of task attributes. These include but are not limited to: Ensuring only one output type is set per task to maintain clear output expectations. Preventing the manual assignment of the `id` attribute to uphold the integrity of the unique identifier system. These validations help in maintaining the consistency and reliability of task executions within the crewAI framework.\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "Task guardrails provide a way to validate and transform task outputs before they\nare passed to the next task. This feature helps ensure data quality and provides\nfeedback to agents when their output doesn't meet specific criteria.\n\nTask guardrails provide a powerful way to validate, transform, or filter task outputs before they are passed to the next task. Guardrails are optional functions that execute before the next task starts, allowing you to ensure that task outputs meet specific requirements or formats.",
      "title": "Task Guardrails",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tasks",
          "level": 1
        },
        {
          "title": "Task Guardrails",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tasks",
            "level": 1
          },
          {
            "title": "Task Guardrails",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tasks > Task Guardrails"
      },
      "enhanced_content": "Context: Changelog > Tasks > Task Guardrails\n\n## Task Guardrails\n\nTask guardrails provide a way to validate and transform task outputs before they\nare passed to the next task. This feature helps ensure data quality and provides\nfeedback to agents when their output doesn't meet specific criteria.\n\nTask guardrails provide a powerful way to validate, transform, or filter task outputs before they are passed to the next task. Guardrails are optional functions that execute before the next task starts, allowing you to ensure that task outputs meet specific requirements or formats.",
      "formatted_path": "Changelog > Tasks > Task Guardrails",
      "enhanced_text": "Context: Changelog > Tasks > Task Guardrails\n\n Task Guardrails\n\nTask guardrails provide a way to validate and transform task outputs before they\nare passed to the next task. This feature helps ensure data quality and provides\nfeedback to agents when their output doesn't meet specific criteria.\n\nTask guardrails provide a powerful way to validate, transform, or filter task outputs before they are passed to the next task. Guardrails are optional functions that execute before the next task starts, allowing you to ensure that task outputs meet specific requirements or formats.\n\nRelated sections:\n- \n"
    },
    {
      "content": "**Optional Attribute**: Guardrails are an optional attribute at the task level, allowing you to add validation only where needed. **Execution Timing**: The guardrail function is executed before the next task starts, ensuring valid data flow between tasks. **Return Format**: Guardrails must return a tuple of `(success, data)`: If `success` is `True`, `data` is the validated/transformed result If `success` is `False`, `data` is the error message **Result Routing**: On success (`True`), the result is automatically passed to the next task On failure (`False`), the error is sent back to the agent to generate a new answer",
      "title": "How Guardrails Work",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tasks",
          "level": 1
        },
        {
          "title": "Task Guardrails",
          "level": 2
        },
        {
          "title": "How Guardrails Work",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tasks",
            "level": 1
          },
          {
            "title": "Task Guardrails",
            "level": 2
          },
          {
            "title": "How Guardrails Work",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tasks > Task Guardrails > How Guardrails Work"
      },
      "enhanced_content": "Context: Changelog > Tasks > Task Guardrails > How Guardrails Work\n\n### How Guardrails Work\n\n**Optional Attribute**: Guardrails are an optional attribute at the task level, allowing you to add validation only where needed. **Execution Timing**: The guardrail function is executed before the next task starts, ensuring valid data flow between tasks. **Return Format**: Guardrails must return a tuple of `(success, data)`: If `success` is `True`, `data` is the validated/transformed result If `success` is `False`, `data` is the error message **Result Routing**: On success (`True`), the result is automatically passed to the next task On failure (`False`), the error is sent back to the agent to generate a new answer",
      "formatted_path": "Changelog > Tasks > Task Guardrails > How Guardrails Work",
      "enhanced_text": "Context: Changelog > Tasks > Task Guardrails > How Guardrails Work\n\n How Guardrails Work\n\n**Optional Attribute**: Guardrails are an optional attribute at the task level, allowing you to add validation only where needed. **Execution Timing**: The guardrail function is executed before the next task starts, ensuring valid data flow between tasks. **Return Format**: Guardrails must return a tuple of `(success, data)`: If `success` is `True`, `data` is the validated/transformed result If `success` is `False`, `data` is the error message **Result Routing**: On success (`True`), the result is automatically passed to the next task On failure (`False`), the error is sent back to the agent to generate a new answer"
    },
    {
      "content": "def validate_email_format(result: str) -> Tuple[bool, Union[str, str]]:\n    \"\"\"Ensure the output contains a valid email address.\"\"\"\n    import re\n    email_pattern = r'^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$'\n    if re.match(email_pattern, result.strip()):\n        return (True, result.strip())\n    return (False, \"Output must be a valid email address\")",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tasks",
          "level": 1
        },
        {
          "title": "Task Guardrails",
          "level": 2
        },
        {
          "title": "Common Use Cases",
          "level": 3
        },
        {
          "title": "Data Format Validation",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tasks",
            "level": 1
          },
          {
            "title": "Task Guardrails",
            "level": 2
          },
          {
            "title": "Common Use Cases",
            "level": 3
          },
          {
            "title": "Data Format Validation",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tasks > Task Guardrails > Common Use Cases > Data Format Validation"
      },
      "enhanced_content": "Context: Changelog > Tasks > Task Guardrails > Common Use Cases > Data Format Validation\n\ndef validate_email_format(result: str) -> Tuple[bool, Union[str, str]]:\n    \"\"\"Ensure the output contains a valid email address.\"\"\"\n    import re\n    email_pattern = r'^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$'\n    if re.match(email_pattern, result.strip()):\n        return (True, result.strip())\n    return (False, \"Output must be a valid email address\")",
      "formatted_path": "Changelog > Tasks > Task Guardrails > Common Use Cases > Data Format Validation",
      "enhanced_text": "Context: Changelog > Tasks > Task Guardrails > Common Use Cases > Data Format Validation\n\ndef validate_email_format(result: str) -> Tuple[bool, Union[str, str]]:\n    \"\"\"Ensure the output contains a valid email address.\"\"\"\n    import re\n    email_pattern = r'^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$'\n    if re.match(email_pattern, result.strip()):\n        return (True, result.strip())\n    return (False, \"Output must be a valid email address\")"
    },
    {
      "content": "def filter_sensitive_info(result: str) -> Tuple[bool, Union[str, str]]:\n    \"\"\"Remove or validate sensitive information.\"\"\"\n    sensitive_patterns = ['SSN:', 'password:', 'secret:']\n    for pattern in sensitive_patterns:\n        if pattern.lower() in result.lower():\n            return (False, f\"Output contains sensitive information ({pattern})\")\n    return (True, result)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tasks",
          "level": 1
        },
        {
          "title": "Task Guardrails",
          "level": 2
        },
        {
          "title": "Common Use Cases",
          "level": 3
        },
        {
          "title": "Content Filtering",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tasks",
            "level": 1
          },
          {
            "title": "Task Guardrails",
            "level": 2
          },
          {
            "title": "Common Use Cases",
            "level": 3
          },
          {
            "title": "Content Filtering",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tasks > Task Guardrails > Common Use Cases > Content Filtering"
      },
      "enhanced_content": "Context: Changelog > Tasks > Task Guardrails > Common Use Cases > Content Filtering\n\ndef filter_sensitive_info(result: str) -> Tuple[bool, Union[str, str]]:\n    \"\"\"Remove or validate sensitive information.\"\"\"\n    sensitive_patterns = ['SSN:', 'password:', 'secret:']\n    for pattern in sensitive_patterns:\n        if pattern.lower() in result.lower():\n            return (False, f\"Output contains sensitive information ({pattern})\")\n    return (True, result)",
      "formatted_path": "Changelog > Tasks > Task Guardrails > Common Use Cases > Content Filtering",
      "enhanced_text": "Context: Changelog > Tasks > Task Guardrails > Common Use Cases > Content Filtering\n\ndef filter_sensitive_info(result: str) -> Tuple[bool, Union[str, str]]:\n    \"\"\"Remove or validate sensitive information.\"\"\"\n    sensitive_patterns = ['SSN:', 'password:', 'secret:']\n    for pattern in sensitive_patterns:\n        if pattern.lower() in result.lower():\n            return (False, f\"Output contains sensitive information ({pattern})\")\n    return (True, result)"
    },
    {
      "content": "def normalize_phone_number(result: str) -> Tuple[bool, Union[str, str]]:\n    \"\"\"Ensure phone numbers are in a consistent format.\"\"\"\n    import re\n    digits = re.sub(r'\\D', '', result)\n    if len(digits) == 10:\n        formatted = f\"({digits[:3]}) {digits[3:6]}-{digits[6:]}\"\n        return (True, formatted)\n    return (False, \"Output must be a 10-digit phone number\")",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tasks",
          "level": 1
        },
        {
          "title": "Task Guardrails",
          "level": 2
        },
        {
          "title": "Common Use Cases",
          "level": 3
        },
        {
          "title": "Data Transformation",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tasks",
            "level": 1
          },
          {
            "title": "Task Guardrails",
            "level": 2
          },
          {
            "title": "Common Use Cases",
            "level": 3
          },
          {
            "title": "Data Transformation",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tasks > Task Guardrails > Common Use Cases > Data Transformation"
      },
      "enhanced_content": "Context: Changelog > Tasks > Task Guardrails > Common Use Cases > Data Transformation\n\ndef normalize_phone_number(result: str) -> Tuple[bool, Union[str, str]]:\n    \"\"\"Ensure phone numbers are in a consistent format.\"\"\"\n    import re\n    digits = re.sub(r'\\D', '', result)\n    if len(digits) == 10:\n        formatted = f\"({digits[:3]}) {digits[3:6]}-{digits[6:]}\"\n        return (True, formatted)\n    return (False, \"Output must be a 10-digit phone number\")",
      "formatted_path": "Changelog > Tasks > Task Guardrails > Common Use Cases > Data Transformation",
      "enhanced_text": "Context: Changelog > Tasks > Task Guardrails > Common Use Cases > Data Transformation\n\ndef normalize_phone_number(result: str) -> Tuple[bool, Union[str, str]]:\n    \"\"\"Ensure phone numbers are in a consistent format.\"\"\"\n    import re\n    digits = re.sub(r'\\D', '', result)\n    if len(digits) == 10:\n        formatted = f\"({digits[:3]}) {digits[3:6]}-{digits[6:]}\"\n        return (True, formatted)\n    return (False, \"Output must be a 10-digit phone number\")"
    },
    {
      "content": "def chain_validations(*validators):\n    \"\"\"Chain multiple validators together.\"\"\"\n    def combined_validator(result):\n        for validator in validators:\n            success, data = validator(result)\n            if not success:\n                return (False, data)\n            result = data\n        return (True, result)\n    return combined_validator\n\n# Usage\ntask = Task(\n    description=\"Get user contact info\",\n    expected_output=\"Email and phone\",\n    guardrail=chain_validations(\n        validate_email_format,\n        filter_sensitive_info\n    )\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tasks",
          "level": 1
        },
        {
          "title": "Task Guardrails",
          "level": 2
        },
        {
          "title": "Advanced Features",
          "level": 3
        },
        {
          "title": "Chaining Multiple Validations",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tasks",
            "level": 1
          },
          {
            "title": "Task Guardrails",
            "level": 2
          },
          {
            "title": "Advanced Features",
            "level": 3
          },
          {
            "title": "Chaining Multiple Validations",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tasks > Task Guardrails > Advanced Features > Chaining Multiple Validations"
      },
      "enhanced_content": "Context: Changelog > Tasks > Task Guardrails > Advanced Features > Chaining Multiple Validations\n\ndef chain_validations(*validators):\n    \"\"\"Chain multiple validators together.\"\"\"\n    def combined_validator(result):\n        for validator in validators:\n            success, data = validator(result)\n            if not success:\n                return (False, data)\n            result = data\n        return (True, result)\n    return combined_validator\n\n# Usage\ntask = Task(\n    description=\"Get user contact info\",\n    expected_output=\"Email and phone\",\n    guardrail=chain_validations(\n        validate_email_format,\n        filter_sensitive_info\n    )\n)",
      "formatted_path": "Changelog > Tasks > Task Guardrails > Advanced Features > Chaining Multiple Validations",
      "enhanced_text": "Context: Changelog > Tasks > Task Guardrails > Advanced Features > Chaining Multiple Validations\n\ndef chain_validations(*validators):\n    \"\"\"Chain multiple validators together.\"\"\"\n    def combined_validator(result):\n        for validator in validators:\n            success, data = validator(result)\n            if not success:\n                return (False, data)\n            result = data\n        return (True, result)\n    return combined_validator\n\n# Usage\ntask = Task(\n    description=\"Get user contact info\",\n    expected_output=\"Email and phone\",\n    guardrail=chain_validations(\n        validate_email_format,\n        filter_sensitive_info\n    )\n)"
    },
    {
      "content": "task = Task(\n    description=\"Generate data\",\n    expected_output=\"Valid data\",\n    guardrail=validate_data,\n    max_retries=5  # Override default retry limit\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tasks",
          "level": 1
        },
        {
          "title": "Task Guardrails",
          "level": 2
        },
        {
          "title": "Advanced Features",
          "level": 3
        },
        {
          "title": "Custom Retry Logic",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tasks",
            "level": 1
          },
          {
            "title": "Task Guardrails",
            "level": 2
          },
          {
            "title": "Advanced Features",
            "level": 3
          },
          {
            "title": "Custom Retry Logic",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tasks > Task Guardrails > Advanced Features > Custom Retry Logic"
      },
      "enhanced_content": "Context: Changelog > Tasks > Task Guardrails > Advanced Features > Custom Retry Logic\n\ntask = Task(\n    description=\"Generate data\",\n    expected_output=\"Valid data\",\n    guardrail=validate_data,\n    max_retries=5  # Override default retry limit\n)",
      "formatted_path": "Changelog > Tasks > Task Guardrails > Advanced Features > Custom Retry Logic",
      "enhanced_text": "Context: Changelog > Tasks > Task Guardrails > Advanced Features > Custom Retry Logic\n\ntask = Task(\n    description=\"Generate data\",\n    expected_output=\"Valid data\",\n    guardrail=validate_data,\n    max_retries=5  # Override default retry limit\n)"
    },
    {
      "content": "# ...\n\nsave_output_task = Task(\n    description='Save the summarized AI news to a file',\n    expected_output='File saved successfully',\n    agent=research_agent,\n    tools=[file_save_tool],\n    output_file='outputs/ai_news_summary.txt',\n    create_directory=True\n)\n\n#...",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tasks",
          "level": 1
        },
        {
          "title": "Creating Directories when Saving Files",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tasks",
            "level": 1
          },
          {
            "title": "Creating Directories when Saving Files",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tasks > Creating Directories when Saving Files"
      },
      "enhanced_content": "Context: Changelog > Tasks > Creating Directories when Saving Files\n\n# ...\n\nsave_output_task = Task(\n    description='Save the summarized AI news to a file',\n    expected_output='File saved successfully',\n    agent=research_agent,\n    tools=[file_save_tool],\n    output_file='outputs/ai_news_summary.txt',\n    create_directory=True\n)\n\n#...",
      "formatted_path": "Changelog > Tasks > Creating Directories when Saving Files",
      "enhanced_text": "Context: Changelog > Tasks > Creating Directories when Saving Files\n\n# ...\n\nsave_output_task = Task(\n    description='Save the summarized AI news to a file',\n    expected_output='File saved successfully',\n    agent=research_agent,\n    tools=[file_save_tool],\n    output_file='outputs/ai_news_summary.txt',\n    create_directory=True\n)\n\n#..."
    },
    {
      "content": "Source: https://docs.crewai.com/concepts/testing Learn how to test your CrewAI Crew and evaluate their performance.",
      "title": "Testing",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Testing",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Testing",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Testing"
      },
      "enhanced_content": "Context: Changelog > Testing\n\n# Testing\n\nSource: https://docs.crewai.com/concepts/testing Learn how to test your CrewAI Crew and evaluate their performance.",
      "formatted_path": "Changelog > Testing",
      "enhanced_text": "Context: Changelog > Testing\n\n Testing\n\nSource: https://docs.crewai.com/concepts/testing Learn how to test your CrewAI Crew and evaluate their performance.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "crewai test",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Testing",
          "level": 1
        },
        {
          "title": "Introduction",
          "level": 2
        },
        {
          "title": "Using the Testing Feature",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Testing",
            "level": 1
          },
          {
            "title": "Introduction",
            "level": 2
          },
          {
            "title": "Using the Testing Feature",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Testing > Introduction > Using the Testing Feature"
      },
      "enhanced_content": "Context: Changelog > Testing > Introduction > Using the Testing Feature\n\ncrewai test",
      "formatted_path": "Changelog > Testing > Introduction > Using the Testing Feature",
      "enhanced_text": "Context: Changelog > Testing > Introduction > Using the Testing Feature\n\ncrewai test"
    },
    {
      "content": "crewai test --n_iterations 5 --model gpt-4o",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Testing",
          "level": 1
        },
        {
          "title": "Introduction",
          "level": 2
        },
        {
          "title": "Using the Testing Feature",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Testing",
            "level": 1
          },
          {
            "title": "Introduction",
            "level": 2
          },
          {
            "title": "Using the Testing Feature",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Testing > Introduction > Using the Testing Feature"
      },
      "enhanced_content": "Context: Changelog > Testing > Introduction > Using the Testing Feature\n\ncrewai test --n_iterations 5 --model gpt-4o",
      "formatted_path": "Changelog > Testing > Introduction > Using the Testing Feature",
      "enhanced_text": "Context: Changelog > Testing > Introduction > Using the Testing Feature\n\ncrewai test --n_iterations 5 --model gpt-4o"
    },
    {
      "content": "crewai test -n 5 -m gpt-4o",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Testing",
          "level": 1
        },
        {
          "title": "Introduction",
          "level": 2
        },
        {
          "title": "Using the Testing Feature",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Testing",
            "level": 1
          },
          {
            "title": "Introduction",
            "level": 2
          },
          {
            "title": "Using the Testing Feature",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Testing > Introduction > Using the Testing Feature"
      },
      "enhanced_content": "Context: Changelog > Testing > Introduction > Using the Testing Feature\n\ncrewai test -n 5 -m gpt-4o",
      "formatted_path": "Changelog > Testing > Introduction > Using the Testing Feature",
      "enhanced_text": "Context: Changelog > Testing > Introduction > Using the Testing Feature\n\ncrewai test -n 5 -m gpt-4o"
    },
    {
      "content": "Source: https://docs.crewai.com/concepts/tools Understanding and leveraging tools within the CrewAI framework for agent collaboration and task execution.",
      "title": "Tools",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tools",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tools",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tools"
      },
      "enhanced_content": "Context: Changelog > Tools\n\n# Tools\n\nSource: https://docs.crewai.com/concepts/tools Understanding and leveraging tools within the CrewAI framework for agent collaboration and task execution.",
      "formatted_path": "Changelog > Tools",
      "enhanced_text": "Context: Changelog > Tools\n\n Tools\n\nSource: https://docs.crewai.com/concepts/tools Understanding and leveraging tools within the CrewAI framework for agent collaboration and task execution.\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "A tool in CrewAI is a skill or function that agents can utilize to perform various actions.\nThis includes tools from the [CrewAI Toolkit](https://github.com/joaomdmoura/crewai-tools) and [LangChain Tools](https://python.langchain.com/docs/integrations/tools),\nenabling everything from simple searches to complex interactions and effective teamwork among agents.",
      "title": "What is a Tool?",
      "type": "link_list",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tools",
          "level": 1
        },
        {
          "title": "What is a Tool?",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tools",
            "level": 1
          },
          {
            "title": "What is a Tool?",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 2,
        "formatted_path": "Changelog > Tools > What is a Tool?"
      },
      "enhanced_content": "Context: Changelog > Tools > What is a Tool?\n\n## What is a Tool?\n\nA tool in CrewAI is a skill or function that agents can utilize to perform various actions.\nThis includes tools from the [CrewAI Toolkit](https://github.com/joaomdmoura/crewai-tools) and [LangChain Tools](https://python.langchain.com/docs/integrations/tools),\nenabling everything from simple searches to complex interactions and effective teamwork among agents.",
      "formatted_path": "Changelog > Tools > What is a Tool?",
      "enhanced_text": "Context: Changelog > Tools > What is a Tool?\n\n What is a Tool?\n\nA tool in CrewAI is a skill or function that agents can utilize to perform various actions.\nThis includes tools from the [CrewAI Toolkit](https://github.com/joaomdmoura/crewai-tools) and [LangChain Tools](https://python.langchain.com/docs/integrations/tools),\nenabling everything from simple searches to complex interactions and effective teamwork among agents."
    },
    {
      "content": "**Utility**: Crafted for tasks such as web searching, data analysis, content generation, and agent collaboration. **Integration**: Boosts agent capabilities by seamlessly integrating tools into their workflow. **Customizability**: Provides the flexibility to develop custom tools or utilize existing ones, catering to the specific needs of agents. **Error Handling**: Incorporates robust error handling mechanisms to ensure smooth operation. **Caching Mechanism**: Features intelligent caching to optimize performance and reduce redundant operations.",
      "title": "Key Characteristics of Tools",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tools",
          "level": 1
        },
        {
          "title": "Key Characteristics of Tools",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tools",
            "level": 1
          },
          {
            "title": "Key Characteristics of Tools",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tools > Key Characteristics of Tools"
      },
      "enhanced_content": "Context: Changelog > Tools > Key Characteristics of Tools\n\n## Key Characteristics of Tools\n\n**Utility**: Crafted for tasks such as web searching, data analysis, content generation, and agent collaboration. **Integration**: Boosts agent capabilities by seamlessly integrating tools into their workflow. **Customizability**: Provides the flexibility to develop custom tools or utilize existing ones, catering to the specific needs of agents. **Error Handling**: Incorporates robust error handling mechanisms to ensure smooth operation. **Caching Mechanism**: Features intelligent caching to optimize performance and reduce redundant operations.",
      "formatted_path": "Changelog > Tools > Key Characteristics of Tools",
      "enhanced_text": "Context: Changelog > Tools > Key Characteristics of Tools\n\n Key Characteristics of Tools\n\n**Utility**: Crafted for tasks such as web searching, data analysis, content generation, and agent collaboration. **Integration**: Boosts agent capabilities by seamlessly integrating tools into their workflow. **Customizability**: Provides the flexibility to develop custom tools or utilize existing ones, catering to the specific needs of agents. **Error Handling**: Incorporates robust error handling mechanisms to ensure smooth operation. **Caching Mechanism**: Features intelligent caching to optimize performance and reduce redundant operations.\n\nRelated sections:\n- \n"
    },
    {
      "content": "pip install 'crewai[tools]'",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tools",
          "level": 1
        },
        {
          "title": "Using CrewAI Tools",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tools",
            "level": 1
          },
          {
            "title": "Using CrewAI Tools",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tools > Using CrewAI Tools"
      },
      "enhanced_content": "Context: Changelog > Tools > Using CrewAI Tools\n\npip install 'crewai[tools]'",
      "formatted_path": "Changelog > Tools > Using CrewAI Tools",
      "enhanced_text": "Context: Changelog > Tools > Using CrewAI Tools\n\npip install 'crewai[tools]'"
    },
    {
      "content": "import os\nfrom crewai import Agent, Task, Crew\n# Importing crewAI tools\nfrom crewai_tools import (\n    DirectoryReadTool,\n    FileReadTool,\n    SerperDevTool,\n    WebsiteSearchTool\n)\n\n# Set up API keys\nos.environ[\"SERPER_API_KEY\"] = \"Your Key\" # serper.dev API key\nos.environ[\"OPENAI_API_KEY\"] = \"Your Key\"\n\n# Instantiate tools\ndocs_tool = DirectoryReadTool(directory='./blog-posts')\nfile_tool = FileReadTool()\nsearch_tool = SerperDevTool()\nweb_rag_tool = WebsiteSearchTool()\n\n# Create agents\nresearcher = Agent(\n    role='Market Research Analyst',\n    goal='Provide up-to-date market analysis of the AI industry',\n    backstory='An expert analyst with a keen eye for market trends.',\n    tools=[search_tool, web_rag_tool],\n    verbose=True\n)\n\nwriter = Agent(\n    role='Content Writer',\n    goal='Craft engaging blog posts about the AI industry',\n    backstory='A skilled writer with a passion for technology.',\n    tools=[docs_tool, file_tool],\n    verbose=True\n)\n\n# Define tasks\nresearch = Task(\n    description='Research the latest trends in the AI industry and provide a summary.',\n    expected_output='A summary of the top 3 trending developments in the AI industry with a unique perspective on their significance.',\n    agent=researcher\n)\n\nwrite = Task(\n    description='Write an engaging blog post about the AI industry, based on the research analyst\u2019s summary. Draw inspiration from the latest blog posts in the directory.',\n    expected_output='A 4-paragraph blog post formatted in markdown with engaging, informative, and accessible content, avoiding complex jargon.',\n    agent=writer,\n    output_file='blog-posts/new_post.md'  # The final blog post will be saved here\n)\n\n# Assemble a crew with planning enabled\ncrew = Crew(\n    agents=[researcher, writer],\n    tasks=[research, write],\n    verbose=True,\n    planning=True,  # Enable planning feature\n)\n\n# Execute tasks\ncrew.kickoff()",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tools",
          "level": 1
        },
        {
          "title": "Using CrewAI Tools",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tools",
            "level": 1
          },
          {
            "title": "Using CrewAI Tools",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tools > Using CrewAI Tools"
      },
      "enhanced_content": "Context: Changelog > Tools > Using CrewAI Tools\n\nimport os\nfrom crewai import Agent, Task, Crew\n# Importing crewAI tools\nfrom crewai_tools import (\n    DirectoryReadTool,\n    FileReadTool,\n    SerperDevTool,\n    WebsiteSearchTool\n)\n\n# Set up API keys\nos.environ[\"SERPER_API_KEY\"] = \"Your Key\" # serper.dev API key\nos.environ[\"OPENAI_API_KEY\"] = \"Your Key\"\n\n# Instantiate tools\ndocs_tool = DirectoryReadTool(directory='./blog-posts')\nfile_tool = FileReadTool()\nsearch_tool = SerperDevTool()\nweb_rag_tool = WebsiteSearchTool()\n\n# Create agents\nresearcher = Agent(\n    role='Market Research Analyst',\n    goal='Provide up-to-date market analysis of the AI industry',\n    backstory='An expert analyst with a keen eye for market trends.',\n    tools=[search_tool, web_rag_tool],\n    verbose=True\n)\n\nwriter = Agent(\n    role='Content Writer',\n    goal='Craft engaging blog posts about the AI industry',\n    backstory='A skilled writer with a passion for technology.',\n    tools=[docs_tool, file_tool],\n    verbose=True\n)\n\n# Define tasks\nresearch = Task(\n    description='Research the latest trends in the AI industry and provide a summary.',\n    expected_output='A summary of the top 3 trending developments in the AI industry with a unique perspective on their significance.',\n    agent=researcher\n)\n\nwrite = Task(\n    description='Write an engaging blog post about the AI industry, based on the research analyst\u2019s summary. Draw inspiration from the latest blog posts in the directory.',\n    expected_output='A 4-paragraph blog post formatted in markdown with engaging, informative, and accessible content, avoiding complex jargon.',\n    agent=writer,\n    output_file='blog-posts/new_post.md'  # The final blog post will be saved here\n)\n\n# Assemble a crew with planning enabled\ncrew = Crew(\n    agents=[researcher, writer],\n    tasks=[research, write],\n    verbose=True,\n    planning=True,  # Enable planning feature\n)\n\n# Execute tasks\ncrew.kickoff()",
      "formatted_path": "Changelog > Tools > Using CrewAI Tools",
      "enhanced_text": "Context: Changelog > Tools > Using CrewAI Tools\n\nimport os\nfrom crewai import Agent, Task, Crew\n# Importing crewAI tools\nfrom crewai_tools import (\n    DirectoryReadTool,\n    FileReadTool,\n    SerperDevTool,\n    WebsiteSearchTool\n)\n\n# Set up API keys\nos.environ[\"SERPER_API_KEY\"] = \"Your Key\" # serper.dev API key\nos.environ[\"OPENAI_API_KEY\"] = \"Your Key\"\n\n# Instantiate tools\ndocs_tool = DirectoryReadTool(directory='./blog-posts')\nfile_tool = FileReadTool()\nsearch_tool = SerperDevTool()\nweb_rag_tool = WebsiteSearchTool()\n\n# Create agents\nresearcher = Agent(\n    role='Market Research Analyst',\n    goal='Provide up-to-date market analysis of the AI industry',\n    backstory='An expert analyst with a keen eye for market trends.',\n    tools=[search_tool, web_rag_tool],\n    verbose=True\n)\n\nwriter = Agent(\n    role='Content Writer',\n    goal='Craft engaging blog posts about the AI industry',\n    backstory='A skilled writer with a passion for technology.',\n    tools=[docs_tool, file_tool],\n    verbose=True\n)\n\n# Define tasks\nresearch = Task(\n    description='Research the latest trends in the AI industry and provide a summary.',\n    expected_output='A summary of the top 3 trending developments in the AI industry with a unique perspective on their significance.',\n    agent=researcher\n)\n\nwrite = Task(\n    description='Write an engaging blog post about the AI industry, based on the research analyst\u2019s summary. Draw inspiration from the latest blog posts in the directory.',\n    expected_output='A 4-paragraph blog post formatted in markdown with engaging, informative, and accessible content, avoiding complex jargon.',\n    agent=writer,\n    output_file='blog-posts/new_post.md'  # The final blog post will be saved here\n)\n\n# Assemble a crew with planning enabled\ncrew = Crew(\n    agents=[researcher, writer],\n    tasks=[research, write],\n    verbose=True,\n    planning=True,  # Enable planning feature\n)\n\n# Execute tasks\ncrew.kickoff()"
    },
    {
      "content": "**Error Handling**: All tools are built with error handling capabilities, allowing agents to gracefully manage exceptions and continue their tasks. **Caching Mechanism**: All tools support caching, enabling agents to efficiently reuse previously obtained results, reducing the load on external resources and speeding up the execution time. You can also define finer control over the caching mechanism using the `cache_function` attribute on the tool. Here is a list of the available tools and their descriptions: | Tool                             | Description                                                                                    |\n| :------------------------------- | :--------------------------------------------------------------------------------------------- |\n| **ApifyActorsTool**              | A tool that integrates Apify Actors with your workflows for web scraping and automation tasks. |\n| **BrowserbaseLoadTool**          | A tool for interacting with and extracting data from web browsers.                             |\n| **CodeDocsSearchTool**           | A RAG tool optimized for searching through code documentation and related technical documents. |\n| **CodeInterpreterTool**          | A tool for interpreting python code.                                                           |\n| **ComposioTool**                 | Enables use of Composio tools.                                                                 |\n| **CSVSearchTool**                | A RAG tool designed for searching within CSV files, tailored to handle structured data.        |\n| **DALL-E Tool**                  | A tool for generating images using the DALL-E API.                                             |\n| **DirectorySearchTool**          | A RAG tool for searching within directories, useful for navigating through file systems.       |\n| **DOCXSearchTool**               | A RAG tool aimed at searching within DOCX documents, ideal for processing Word files.          |\n| **DirectoryReadTool**            | Facilitates reading and processing of directory structures and their contents.                 |\n| **EXASearchTool**                | A tool designed for performing exhaustive searches across various data sources.                |\n| **FileReadTool**                 | Enables reading and extracting data from files, supporting various file formats.               |\n| **FirecrawlSearchTool**          | A tool to search webpages using Firecrawl and return the results.                              |\n| **FirecrawlCrawlWebsiteTool**    | A tool for crawling webpages using Firecrawl.                                                  |\n| **FirecrawlScrapeWebsiteTool**   | A tool for scraping webpages URL using Firecrawl and returning its contents.                   |\n| **GithubSearchTool**             | A RAG tool for searching within GitHub repositories, useful for code and documentation search. |\n| **SerperDevTool**                | A specialized tool for development purposes, with specific functionalities under development.  |\n| **TXTSearchTool**                | A RAG tool focused on searching within text (.txt) files, suitable for unstructured data.      |\n| **JSONSearchTool**               | A RAG tool designed for searching within JSON files, catering to structured data handling.     |\n| **LlamaIndexTool**               | Enables the use of LlamaIndex tools.                                                           |\n| **MDXSearchTool**                | A RAG tool tailored for searching within Markdown (MDX) files, useful for documentation.       |\n| **PDFSearchTool**                | A RAG tool aimed at searching within PDF documents, ideal for processing scanned documents.    |\n| **PGSearchTool**                 | A RAG tool optimized for searching within PostgreSQL databases, suitable for database queries. |\n| **Vision Tool**                  | A tool for generating images using the DALL-E API.                                             |\n| **RagTool**                      | A general-purpose RAG tool capable of handling various data sources and types.                 |\n| **ScrapeElementFromWebsiteTool** | Enables scraping specific elements from websites, useful for targeted data extraction.         |\n| **ScrapeWebsiteTool**            | Facilitates scraping entire websites, ideal for comprehensive data collection.                 |\n| **WebsiteSearchTool**            | A RAG tool for searching website content, optimized for web data extraction.                   |\n| **XMLSearchTool**                | A RAG tool designed for searching within XML files, suitable for structured data formats.      |\n| **YoutubeChannelSearchTool**     | A RAG tool for searching within YouTube channels, useful for video content analysis.           |\n| **YoutubeVideoSearchTool**       | A RAG tool aimed at searching within YouTube videos, ideal for video data extraction.          |",
      "title": "Available CrewAI Tools",
      "type": "descriptive_text_oversized",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tools",
          "level": 1
        },
        {
          "title": "Available CrewAI Tools",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tools",
            "level": 1
          },
          {
            "title": "Available CrewAI Tools",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tools > Available CrewAI Tools"
      },
      "enhanced_content": "Context: Changelog > Tools > Available CrewAI Tools\n\n## Available CrewAI Tools\n\n**Error Handling**: All tools are built with error handling capabilities, allowing agents to gracefully manage exceptions and continue their tasks. **Caching Mechanism**: All tools support caching, enabling agents to efficiently reuse previously obtained results, reducing the load on external resources and speeding up the execution time. You can also define finer control over the caching mechanism using the `cache_function` attribute on the tool. Here is a list of the available tools and their descriptions: | Tool                             | Description                                                                                    |\n| :------------------------------- | :--------------------------------------------------------------------------------------------- |\n| **ApifyActorsTool**              | A tool that integrates Apify Actors with your workflows for web scraping and automation tasks. |\n| **BrowserbaseLoadTool**          | A tool for interacting with and extracting data from web browsers.                             |\n| **CodeDocsSearchTool**           | A RAG tool optimized for searching through code documentation and related technical documents. |\n| **CodeInterpreterTool**          | A tool for interpreting python code.                                                           |\n| **ComposioTool**                 | Enables use of Composio tools.                                                                 |\n| **CSVSearchTool**                | A RAG tool designed for searching within CSV files, tailored to handle structured data.        |\n| **DALL-E Tool**                  | A tool for generating images using the DALL-E API.                                             |\n| **DirectorySearchTool**          | A RAG tool for searching within directories, useful for navigating through file systems.       |\n| **DOCXSearchTool**               | A RAG tool aimed at searching within DOCX documents, ideal for processing Word files.          |\n| **DirectoryReadTool**            | Facilitates reading and processing of directory structures and their contents.                 |\n| **EXASearchTool**                | A tool designed for performing exhaustive searches across various data sources.                |\n| **FileReadTool**                 | Enables reading and extracting data from files, supporting various file formats.               |\n| **FirecrawlSearchTool**          | A tool to search webpages using Firecrawl and return the results.                              |\n| **FirecrawlCrawlWebsiteTool**    | A tool for crawling webpages using Firecrawl.                                                  |\n| **FirecrawlScrapeWebsiteTool**   | A tool for scraping webpages URL using Firecrawl and returning its contents.                   |\n| **GithubSearchTool**             | A RAG tool for searching within GitHub repositories, useful for code and documentation search. |\n| **SerperDevTool**                | A specialized tool for development purposes, with specific functionalities under development.  |\n| **TXTSearchTool**                | A RAG tool focused on searching within text (.txt) files, suitable for unstructured data.      |\n| **JSONSearchTool**               | A RAG tool designed for searching within JSON files, catering to structured data handling.     |\n| **LlamaIndexTool**               | Enables the use of LlamaIndex tools.                                                           |\n| **MDXSearchTool**                | A RAG tool tailored for searching within Markdown (MDX) files, useful for documentation.       |\n| **PDFSearchTool**                | A RAG tool aimed at searching within PDF documents, ideal for processing scanned documents.    |\n| **PGSearchTool**                 | A RAG tool optimized for searching within PostgreSQL databases, suitable for database queries. |\n| **Vision Tool**                  | A tool for generating images using the DALL-E API.                                             |\n| **RagTool**                      | A general-purpose RAG tool capable of handling various data sources and types.                 |\n| **ScrapeElementFromWebsiteTool** | Enables scraping specific elements from websites, useful for targeted data extraction.         |\n| **ScrapeWebsiteTool**            | Facilitates scraping entire websites, ideal for comprehensive data collection.                 |\n| **WebsiteSearchTool**            | A RAG tool for searching website content, optimized for web data extraction.                   |\n| **XMLSearchTool**                | A RAG tool designed for searching within XML files, suitable for structured data formats.      |\n| **YoutubeChannelSearchTool**     | A RAG tool for searching within YouTube channels, useful for video content analysis.           |\n| **YoutubeVideoSearchTool**       | A RAG tool aimed at searching within YouTube videos, ideal for video data extraction.          |",
      "formatted_path": "Changelog > Tools > Available CrewAI Tools",
      "enhanced_text": "Context: Changelog > Tools > Available CrewAI Tools\n\n Available CrewAI Tools\n\n**Error Handling**: All tools are built with error handling capabilities, allowing agents to gracefully manage exceptions and continue their tasks. **Caching Mechanism**: All tools support caching, enabling agents to efficiently reuse previously obtained results, reducing the load on external resources and speeding up the execution time. You can also define finer control over the caching mechanism using the `cache_function` attribute on the tool. Here is a list of the available tools and their descriptions: | Tool                             | Description                                                                                    |\n| :------------------------------- | :--------------------------------------------------------------------------------------------- |\n| **ApifyActorsTool**              | A tool that integrates Apify Actors with your workflows for web scraping and automation tasks. |\n| **BrowserbaseLoadTool**          | A tool for interacting with and extracting data from web browsers.                             |\n| **CodeDocsSearchTool**           | A RAG tool optimized for searching through code documentation and related technical documents. |\n| **CodeInterpreterTool**          | A tool for interpreting python code.                                                           |\n| **ComposioTool**                 | Enables use of Composio tools.                                                                 |\n| **CSVSearchTool**                | A RAG tool designed for searching within CSV files, tailored to handle structured data.        |\n| **DALL-E Tool**                  | A tool for generating images using the DALL-E API.                                             |\n| **DirectorySearchTool**          | A RAG tool for searching within directories, useful for navigating through file systems.       |\n| **DOCXSearchTool**               | A RAG tool aimed at searching within DOCX documents, ideal for processing Word files.          |\n| **DirectoryReadTool**            | Facilitates reading and processing of directory structures and their contents.                 |\n| **EXASearchTool**                | A tool designed for performing exhaustive searches across various data sources.                |\n| **FileReadTool**                 | Enables reading and extracting data from files, supporting various file formats.               |\n| **FirecrawlSearchTool**          | A tool to search webpages using Firecrawl and return the results.                              |\n| **FirecrawlCrawlWebsiteTool**    | A tool for crawling webpages using Firecrawl.                                                  |\n| **FirecrawlScrapeWebsiteTool**   | A tool for scraping webpages URL using Firecrawl and returning its contents.                   |\n| **GithubSearchTool**             | A RAG tool for searching within GitHub repositories, useful for code and documentation search. |\n| **SerperDevTool**                | A specialized tool for development purposes, with specific functionalities under development.  |\n| **TXTSearchTool**                | A RAG tool focused on searching within text (.txt) files, suitable for unstructured data.      |\n| **JSONSearchTool**               | A RAG tool designed for searching within JSON files, catering to structured data handling.     |\n| **LlamaIndexTool**               | Enables the use of LlamaIndex tools.                                                           |\n| **MDXSearchTool**                | A RAG tool tailored for searching within Markdown (MDX) files, useful for documentation.       |\n| **PDFSearchTool**                | A RAG tool aimed at searching within PDF documents, ideal for processing scanned documents.    |\n| **PGSearchTool**                 | A RAG tool optimized for searching within PostgreSQL databases, suitable for database queries. |\n| **Vision Tool**                  | A tool for generating images using the DALL-E API.                                             |\n| **RagTool**                      | A general-purpose RAG tool capable of handling various data sources and types.                 |\n| **ScrapeElementFromWebsiteTool** | Enables scraping specific elements from websites, useful for targeted data extraction.         |\n| **ScrapeWebsiteTool**            | Facilitates scraping entire websites, ideal for comprehensive data collection.                 |\n| **WebsiteSearchTool**            | A RAG tool for searching website content, optimized for web data extraction.                   |\n| **XMLSearchTool**                | A RAG tool designed for searching within XML files, suitable for structured data formats.      |\n| **YoutubeChannelSearchTool**     | A RAG tool for searching within YouTube channels, useful for video content analysis.           |\n| **YoutubeVideoSearchTool**       | A RAG tool aimed at searching within YouTube videos, ideal for video data extraction.          |\n\nRelated sections:\n- \n"
    },
    {
      "content": "There are two main ways for one to create a CrewAI tool:",
      "title": "Creating your own Tools",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tools",
          "level": 1
        },
        {
          "title": "Creating your own Tools",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tools",
            "level": 1
          },
          {
            "title": "Creating your own Tools",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tools > Creating your own Tools"
      },
      "enhanced_content": "Context: Changelog > Tools > Creating your own Tools\n\n## Creating your own Tools\n\nThere are two main ways for one to create a CrewAI tool:",
      "formatted_path": "Changelog > Tools > Creating your own Tools",
      "enhanced_text": "Context: Changelog > Tools > Creating your own Tools\n\n Creating your own Tools\n\nThere are two main ways for one to create a CrewAI tool:\n\nRelated sections:\n- \n"
    },
    {
      "content": "from crewai.tools import tool\n@tool(\"Name of my tool\")\ndef my_tool(question: str) -> str:\n    \"\"\"Clear description for what this tool is useful for, your agent will need this information to use it.\"\"\"\n    # Function logic here\n    return \"Result from your custom tool\"",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tools",
          "level": 1
        },
        {
          "title": "Creating your own Tools",
          "level": 2
        },
        {
          "title": "Utilizing the `tool` Decorator",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tools",
            "level": 1
          },
          {
            "title": "Creating your own Tools",
            "level": 2
          },
          {
            "title": "Utilizing the `tool` Decorator",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tools > Creating your own Tools > Utilizing the `tool` Decorator"
      },
      "enhanced_content": "Context: Changelog > Tools > Creating your own Tools > Utilizing the `tool` Decorator\n\nfrom crewai.tools import tool\n@tool(\"Name of my tool\")\ndef my_tool(question: str) -> str:\n    \"\"\"Clear description for what this tool is useful for, your agent will need this information to use it.\"\"\"\n    # Function logic here\n    return \"Result from your custom tool\"",
      "formatted_path": "Changelog > Tools > Creating your own Tools > Utilizing the `tool` Decorator",
      "enhanced_text": "Context: Changelog > Tools > Creating your own Tools > Utilizing the `tool` Decorator\n\nfrom crewai.tools import tool\n@tool(\"Name of my tool\")\ndef my_tool(question: str) -> str:\n    \"\"\"Clear description for what this tool is useful for, your agent will need this information to use it.\"\"\"\n    # Function logic here\n    return \"Result from your custom tool\""
    },
    {
      "content": "The `StructuredTool` class wraps functions as tools, providing flexibility and validation while reducing boilerplate. It supports custom schemas and dynamic logic for seamless integration of complex functionalities.",
      "title": "Structured Tools",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tools",
          "level": 1
        },
        {
          "title": "Creating your own Tools",
          "level": 2
        },
        {
          "title": "Structured Tools",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tools",
            "level": 1
          },
          {
            "title": "Creating your own Tools",
            "level": 2
          },
          {
            "title": "Structured Tools",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tools > Creating your own Tools > Structured Tools"
      },
      "enhanced_content": "Context: Changelog > Tools > Creating your own Tools > Structured Tools\n\n### Structured Tools\n\nThe `StructuredTool` class wraps functions as tools, providing flexibility and validation while reducing boilerplate. It supports custom schemas and dynamic logic for seamless integration of complex functionalities.",
      "formatted_path": "Changelog > Tools > Creating your own Tools > Structured Tools",
      "enhanced_text": "Context: Changelog > Tools > Creating your own Tools > Structured Tools\n\n Structured Tools\n\nThe `StructuredTool` class wraps functions as tools, providing flexibility and validation while reducing boilerplate. It supports custom schemas and dynamic logic for seamless integration of complex functionalities.\n\nRelated sections:\n- \n"
    },
    {
      "content": "from crewai.tools import tool\n\n@tool\ndef multiplication_tool(first_number: int, second_number: int) -> str:\n    \"\"\"Useful for when you need to multiply two numbers together.\"\"\"\n    return first_number * second_number\n\ndef cache_func(args, result):\n    # In this case, we only cache the result if it's a multiple of 2\n    cache = result % 2 == 0\n    return cache\n\nmultiplication_tool.cache_function = cache_func\n\nwriter1 = Agent(\n        role=\"Writer\",\n        goal=\"You write lessons of math for kids.\",\n        backstory=\"You're an expert in writing and you love to teach kids but you know nothing of math.\",\n        tools=[multiplication_tool],\n        allow_delegation=False,\n    )\n    #...",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Tools",
          "level": 1
        },
        {
          "title": "Creating your own Tools",
          "level": 2
        },
        {
          "title": "Custom Caching Mechanism",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Tools",
            "level": 1
          },
          {
            "title": "Creating your own Tools",
            "level": 2
          },
          {
            "title": "Custom Caching Mechanism",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Tools > Creating your own Tools > Custom Caching Mechanism"
      },
      "enhanced_content": "Context: Changelog > Tools > Creating your own Tools > Custom Caching Mechanism\n\nfrom crewai.tools import tool\n\n@tool\ndef multiplication_tool(first_number: int, second_number: int) -> str:\n    \"\"\"Useful for when you need to multiply two numbers together.\"\"\"\n    return first_number * second_number\n\ndef cache_func(args, result):\n    # In this case, we only cache the result if it's a multiple of 2\n    cache = result % 2 == 0\n    return cache\n\nmultiplication_tool.cache_function = cache_func\n\nwriter1 = Agent(\n        role=\"Writer\",\n        goal=\"You write lessons of math for kids.\",\n        backstory=\"You're an expert in writing and you love to teach kids but you know nothing of math.\",\n        tools=[multiplication_tool],\n        allow_delegation=False,\n    )\n    #...",
      "formatted_path": "Changelog > Tools > Creating your own Tools > Custom Caching Mechanism",
      "enhanced_text": "Context: Changelog > Tools > Creating your own Tools > Custom Caching Mechanism\n\nfrom crewai.tools import tool\n\n@tool\ndef multiplication_tool(first_number: int, second_number: int) -> str:\n    \"\"\"Useful for when you need to multiply two numbers together.\"\"\"\n    return first_number * second_number\n\ndef cache_func(args, result):\n    # In this case, we only cache the result if it's a multiple of 2\n    cache = result % 2 == 0\n    return cache\n\nmultiplication_tool.cache_function = cache_func\n\nwriter1 = Agent(\n        role=\"Writer\",\n        goal=\"You write lessons of math for kids.\",\n        backstory=\"You're an expert in writing and you love to teach kids but you know nothing of math.\",\n        tools=[multiplication_tool],\n        allow_delegation=False,\n    )\n    #..."
    },
    {
      "content": "Source: https://docs.crewai.com/concepts/training Learn how to train your CrewAI agents by giving them feedback early on and get consistent results.",
      "title": "Training",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Training",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Training",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Training"
      },
      "enhanced_content": "Context: Changelog > Training\n\n# Training\n\nSource: https://docs.crewai.com/concepts/training Learn how to train your CrewAI agents by giving them feedback early on and get consistent results.",
      "formatted_path": "Changelog > Training",
      "enhanced_text": "Context: Changelog > Training\n\n Training\n\nSource: https://docs.crewai.com/concepts/training Learn how to train your CrewAI agents by giving them feedback early on and get consistent results.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "crewai train -n <n_iterations> <filename> (optional)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Training",
          "level": 1
        },
        {
          "title": "Introduction",
          "level": 2
        },
        {
          "title": "Training Your Crew Using the CLI",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Training",
            "level": 1
          },
          {
            "title": "Introduction",
            "level": 2
          },
          {
            "title": "Training Your Crew Using the CLI",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Training > Introduction > Training Your Crew Using the CLI"
      },
      "enhanced_content": "Context: Changelog > Training > Introduction > Training Your Crew Using the CLI\n\ncrewai train -n <n_iterations> <filename> (optional)",
      "formatted_path": "Changelog > Training > Introduction > Training Your Crew Using the CLI",
      "enhanced_text": "Context: Changelog > Training > Introduction > Training Your Crew Using the CLI\n\ncrewai train -n <n_iterations> <filename> (optional)"
    },
    {
      "content": "n_iterations = 2\ninputs = {\"topic\": \"CrewAI Training\"}\nfilename = \"your_model.pkl\"\n\ntry:\n    YourCrewName_Crew().crew().train(\n      n_iterations=n_iterations, \n      inputs=inputs, \n      filename=filename\n    )\n\nexcept Exception as e:\n    raise Exception(f\"An error occurred while training the crew: {e}\")",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Training",
          "level": 1
        },
        {
          "title": "Introduction",
          "level": 2
        },
        {
          "title": "Training Your Crew Programmatically",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Training",
            "level": 1
          },
          {
            "title": "Introduction",
            "level": 2
          },
          {
            "title": "Training Your Crew Programmatically",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Training > Introduction > Training Your Crew Programmatically"
      },
      "enhanced_content": "Context: Changelog > Training > Introduction > Training Your Crew Programmatically\n\nn_iterations = 2\ninputs = {\"topic\": \"CrewAI Training\"}\nfilename = \"your_model.pkl\"\n\ntry:\n    YourCrewName_Crew().crew().train(\n      n_iterations=n_iterations, \n      inputs=inputs, \n      filename=filename\n    )\n\nexcept Exception as e:\n    raise Exception(f\"An error occurred while training the crew: {e}\")",
      "formatted_path": "Changelog > Training > Introduction > Training Your Crew Programmatically",
      "enhanced_text": "Context: Changelog > Training > Introduction > Training Your Crew Programmatically\n\nn_iterations = 2\ninputs = {\"topic\": \"CrewAI Training\"}\nfilename = \"your_model.pkl\"\n\ntry:\n    YourCrewName_Crew().crew().train(\n      n_iterations=n_iterations, \n      inputs=inputs, \n      filename=filename\n    )\n\nexcept Exception as e:\n    raise Exception(f\"An error occurred while training the crew: {e}\")"
    },
    {
      "content": "**Positive Integer Requirement:** Ensure that the number of iterations (`n_iterations`) is a positive integer. The code will raise a `ValueError` if this condition is not met. **Filename Requirement:** Ensure that the filename ends with `.pkl`. The code will raise a `ValueError` if this condition is not met. **Error Handling:** The code handles subprocess errors and unexpected exceptions, providing error messages to the user. It is important to note that the training process may take some time, depending on the complexity of your agents and will also require your feedback on each iteration. Once the training is complete, your agents will be equipped with enhanced capabilities and knowledge, ready to tackle complex tasks and provide more consistent and valuable insights. Remember to regularly update and retrain your agents to ensure they stay up-to-date with the latest information and advancements in the field. Happy training with CrewAI! \ud83d\ude80",
      "title": "Key Points to Note",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Training",
          "level": 1
        },
        {
          "title": "Introduction",
          "level": 2
        },
        {
          "title": "Key Points to Note",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Training",
            "level": 1
          },
          {
            "title": "Introduction",
            "level": 2
          },
          {
            "title": "Key Points to Note",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Training > Introduction > Key Points to Note"
      },
      "enhanced_content": "Context: Changelog > Training > Introduction > Key Points to Note\n\n### Key Points to Note\n\n**Positive Integer Requirement:** Ensure that the number of iterations (`n_iterations`) is a positive integer. The code will raise a `ValueError` if this condition is not met. **Filename Requirement:** Ensure that the filename ends with `.pkl`. The code will raise a `ValueError` if this condition is not met. **Error Handling:** The code handles subprocess errors and unexpected exceptions, providing error messages to the user. It is important to note that the training process may take some time, depending on the complexity of your agents and will also require your feedback on each iteration. Once the training is complete, your agents will be equipped with enhanced capabilities and knowledge, ready to tackle complex tasks and provide more consistent and valuable insights. Remember to regularly update and retrain your agents to ensure they stay up-to-date with the latest information and advancements in the field. Happy training with CrewAI! \ud83d\ude80",
      "formatted_path": "Changelog > Training > Introduction > Key Points to Note",
      "enhanced_text": "Context: Changelog > Training > Introduction > Key Points to Note\n\n Key Points to Note\n\n**Positive Integer Requirement:** Ensure that the number of iterations (`n_iterations`) is a positive integer. The code will raise a `ValueError` if this condition is not met. **Filename Requirement:** Ensure that the filename ends with `.pkl`. The code will raise a `ValueError` if this condition is not met. **Error Handling:** The code handles subprocess errors and unexpected exceptions, providing error messages to the user. It is important to note that the training process may take some time, depending on the complexity of your agents and will also require your feedback on each iteration. Once the training is complete, your agents will be equipped with enhanced capabilities and knowledge, ready to tackle complex tasks and provide more consistent and valuable insights. Remember to regularly update and retrain your agents to ensure they stay up-to-date with the latest information and advancements in the field. Happy training with CrewAI! \ud83d\ude80"
    },
    {
      "content": "Source: https://docs.crewai.com/examples/example A collection of examples that show how to use CrewAI framework to automate workflows.",
      "title": "CrewAI Examples",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "CrewAI Examples",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "CrewAI Examples",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > CrewAI Examples"
      },
      "enhanced_content": "Context: Changelog > CrewAI Examples\n\n# CrewAI Examples\n\nSource: https://docs.crewai.com/examples/example A collection of examples that show how to use CrewAI framework to automate workflows.",
      "formatted_path": "Changelog > CrewAI Examples",
      "enhanced_text": "Context: Changelog > CrewAI Examples\n\n CrewAI Examples\n\nSource: https://docs.crewai.com/examples/example A collection of examples that show how to use CrewAI framework to automate workflows.\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "Source: https://docs.crewai.com/guides/advanced/customizing-prompts Dive deeper into low-level prompt customization for CrewAI, enabling super custom and complex use cases for different models and languages.",
      "title": "Customizing Prompts",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Customizing Prompts",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Customizing Prompts",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Customizing Prompts"
      },
      "enhanced_content": "Context: Changelog > Customizing Prompts\n\n# Customizing Prompts\n\nSource: https://docs.crewai.com/guides/advanced/customizing-prompts Dive deeper into low-level prompt customization for CrewAI, enabling super custom and complex use cases for different models and languages.",
      "formatted_path": "Changelog > Customizing Prompts",
      "enhanced_text": "Context: Changelog > Customizing Prompts\n\n Customizing Prompts\n\nSource: https://docs.crewai.com/guides/advanced/customizing-prompts Dive deeper into low-level prompt customization for CrewAI, enabling super custom and complex use cases for different models and languages.\n\nRelated sections:\n- \n"
    },
    {
      "content": "Although CrewAI's default prompts work well for many scenarios, low-level customization opens the door to significantly more flexible and powerful agent behavior. Here\u2019s why you might want to take advantage of this deeper control: **Optimize for specific LLMs** \u2013 Different models (such as GPT-4, Claude, or Llama) thrive with prompt formats tailored to their unique architectures. **Change the language** \u2013 Build agents that operate exclusively in languages beyond English, handling nuances with precision. **Specialize for complex domains** \u2013 Adapt prompts for highly specialized industries like healthcare, finance, or legal. **Adjust tone and style** \u2013 Make agents more formal, casual, creative, or analytical. **Support super custom use cases** \u2013 Utilize advanced prompt structures and formatting to meet intricate, project-specific requirements. This guide explores how to tap into CrewAI's prompts at a lower level, giving you fine-grained control over how agents think and interact.",
      "title": "Why Customize Prompts?",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Customizing Prompts at a Low Level",
          "level": 1
        },
        {
          "title": "Why Customize Prompts?",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Customizing Prompts at a Low Level",
            "level": 1
          },
          {
            "title": "Why Customize Prompts?",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Customizing Prompts at a Low Level > Why Customize Prompts?"
      },
      "enhanced_content": "Context: Changelog > Customizing Prompts at a Low Level > Why Customize Prompts?\n\n## Why Customize Prompts?\n\nAlthough CrewAI's default prompts work well for many scenarios, low-level customization opens the door to significantly more flexible and powerful agent behavior. Here\u2019s why you might want to take advantage of this deeper control: **Optimize for specific LLMs** \u2013 Different models (such as GPT-4, Claude, or Llama) thrive with prompt formats tailored to their unique architectures. **Change the language** \u2013 Build agents that operate exclusively in languages beyond English, handling nuances with precision. **Specialize for complex domains** \u2013 Adapt prompts for highly specialized industries like healthcare, finance, or legal. **Adjust tone and style** \u2013 Make agents more formal, casual, creative, or analytical. **Support super custom use cases** \u2013 Utilize advanced prompt structures and formatting to meet intricate, project-specific requirements. This guide explores how to tap into CrewAI's prompts at a lower level, giving you fine-grained control over how agents think and interact.",
      "formatted_path": "Changelog > Customizing Prompts at a Low Level > Why Customize Prompts?",
      "enhanced_text": "Context: Changelog > Customizing Prompts at a Low Level > Why Customize Prompts?\n\n Why Customize Prompts?\n\nAlthough CrewAI's default prompts work well for many scenarios, low-level customization opens the door to significantly more flexible and powerful agent behavior. Here\u2019s why you might want to take advantage of this deeper control: **Optimize for specific LLMs** \u2013 Different models (such as GPT-4, Claude, or Llama) thrive with prompt formats tailored to their unique architectures. **Change the language** \u2013 Build agents that operate exclusively in languages beyond English, handling nuances with precision. **Specialize for complex domains** \u2013 Adapt prompts for highly specialized industries like healthcare, finance, or legal. **Adjust tone and style** \u2013 Make agents more formal, casual, creative, or analytical. **Support super custom use cases** \u2013 Utilize advanced prompt structures and formatting to meet intricate, project-specific requirements. This guide explores how to tap into CrewAI's prompts at a lower level, giving you fine-grained control over how agents think and interact."
    },
    {
      "content": "Under the hood, CrewAI employs a modular prompt system that you can customize extensively: **Agent templates** \u2013 Govern each agent\u2019s approach to their assigned role. **Prompt slices** \u2013 Control specialized behaviors such as tasks, tool usage, and output structure. **Error handling** \u2013 Direct how agents respond to failures, exceptions, or timeouts. **Tool-specific prompts** \u2013 Define detailed instructions for how tools are invoked or utilized. Check out the [original prompt templates in CrewAI's repository](https://github.com/crewAIInc/crewAI/blob/main/src/crewai/translations/en.json) to see how these elements are organized. From there, you can override or adapt them as needed to unlock advanced behaviors.",
      "title": "Understanding CrewAI's Prompt System",
      "type": "link_list",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Customizing Prompts at a Low Level",
          "level": 1
        },
        {
          "title": "Understanding CrewAI's Prompt System",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Customizing Prompts at a Low Level",
            "level": 1
          },
          {
            "title": "Understanding CrewAI's Prompt System",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 1,
        "formatted_path": "Changelog > Customizing Prompts at a Low Level > Understanding CrewAI's Prompt System"
      },
      "enhanced_content": "Context: Changelog > Customizing Prompts at a Low Level > Understanding CrewAI's Prompt System\n\n## Understanding CrewAI's Prompt System\n\nUnder the hood, CrewAI employs a modular prompt system that you can customize extensively: **Agent templates** \u2013 Govern each agent\u2019s approach to their assigned role. **Prompt slices** \u2013 Control specialized behaviors such as tasks, tool usage, and output structure. **Error handling** \u2013 Direct how agents respond to failures, exceptions, or timeouts. **Tool-specific prompts** \u2013 Define detailed instructions for how tools are invoked or utilized. Check out the [original prompt templates in CrewAI's repository](https://github.com/crewAIInc/crewAI/blob/main/src/crewai/translations/en.json) to see how these elements are organized. From there, you can override or adapt them as needed to unlock advanced behaviors.",
      "formatted_path": "Changelog > Customizing Prompts at a Low Level > Understanding CrewAI's Prompt System",
      "enhanced_text": "Context: Changelog > Customizing Prompts at a Low Level > Understanding CrewAI's Prompt System\n\n Understanding CrewAI's Prompt System\n\nUnder the hood, CrewAI employs a modular prompt system that you can customize extensively: **Agent templates** \u2013 Govern each agent\u2019s approach to their assigned role. **Prompt slices** \u2013 Control specialized behaviors such as tasks, tool usage, and output structure. **Error handling** \u2013 Direct how agents respond to failures, exceptions, or timeouts. **Tool-specific prompts** \u2013 Define detailed instructions for how tools are invoked or utilized. Check out the [original prompt templates in CrewAI's repository](https://github.com/crewAIInc/crewAI/blob/main/src/crewai/translations/en.json) to see how these elements are organized. From there, you can override or adapt them as needed to unlock advanced behaviors."
    },
    {
      "content": "When engaging in low-level prompt customization, follow these guidelines to keep things organized and maintainable: **Keep files separate** \u2013 Store your customized prompts in dedicated JSON files outside your main codebase. **Version control** \u2013 Track changes within your repository, ensuring clear documentation of prompt adjustments over time. **Organize by model or language** \u2013 Use naming schemes like `prompts_llama.json` or `prompts_es.json` to quickly identify specialized configurations. **Document changes** \u2013 Provide comments or maintain a README detailing the purpose and scope of your customizations. **Minimize alterations** \u2013 Only override the specific slices you genuinely need to adjust, keeping default functionality intact for everything else.",
      "title": "Best Practices for Managing Prompt Files",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Customizing Prompts at a Low Level",
          "level": 1
        },
        {
          "title": "Best Practices for Managing Prompt Files",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Customizing Prompts at a Low Level",
            "level": 1
          },
          {
            "title": "Best Practices for Managing Prompt Files",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Customizing Prompts at a Low Level > Best Practices for Managing Prompt Files"
      },
      "enhanced_content": "Context: Changelog > Customizing Prompts at a Low Level > Best Practices for Managing Prompt Files\n\n## Best Practices for Managing Prompt Files\n\nWhen engaging in low-level prompt customization, follow these guidelines to keep things organized and maintainable: **Keep files separate** \u2013 Store your customized prompts in dedicated JSON files outside your main codebase. **Version control** \u2013 Track changes within your repository, ensuring clear documentation of prompt adjustments over time. **Organize by model or language** \u2013 Use naming schemes like `prompts_llama.json` or `prompts_es.json` to quickly identify specialized configurations. **Document changes** \u2013 Provide comments or maintain a README detailing the purpose and scope of your customizations. **Minimize alterations** \u2013 Only override the specific slices you genuinely need to adjust, keeping default functionality intact for everything else.",
      "formatted_path": "Changelog > Customizing Prompts at a Low Level > Best Practices for Managing Prompt Files",
      "enhanced_text": "Context: Changelog > Customizing Prompts at a Low Level > Best Practices for Managing Prompt Files\n\n Best Practices for Managing Prompt Files\n\nWhen engaging in low-level prompt customization, follow these guidelines to keep things organized and maintainable: **Keep files separate** \u2013 Store your customized prompts in dedicated JSON files outside your main codebase. **Version control** \u2013 Track changes within your repository, ensuring clear documentation of prompt adjustments over time. **Organize by model or language** \u2013 Use naming schemes like `prompts_llama.json` or `prompts_es.json` to quickly identify specialized configurations. **Document changes** \u2013 Provide comments or maintain a README detailing the purpose and scope of your customizations. **Minimize alterations** \u2013 Only override the specific slices you genuinely need to adjust, keeping default functionality intact for everything else.\n\nRelated sections:\n- \n- \n- \n"
    },
    {
      "content": "One straightforward approach is to create a JSON file for the prompts you want to override and then point your Crew at that file: Craft a JSON file with your updated prompt slices. Reference that file via the `prompt_file` parameter in your Crew. CrewAI then merges your customizations with the defaults, so you don\u2019t have to redefine every prompt. Here\u2019s how:",
      "title": "The Simplest Way to Customize Prompts",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Customizing Prompts at a Low Level",
          "level": 1
        },
        {
          "title": "The Simplest Way to Customize Prompts",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Customizing Prompts at a Low Level",
            "level": 1
          },
          {
            "title": "The Simplest Way to Customize Prompts",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Customizing Prompts at a Low Level > The Simplest Way to Customize Prompts"
      },
      "enhanced_content": "Context: Changelog > Customizing Prompts at a Low Level > The Simplest Way to Customize Prompts\n\n## The Simplest Way to Customize Prompts\n\nOne straightforward approach is to create a JSON file for the prompts you want to override and then point your Crew at that file: Craft a JSON file with your updated prompt slices. Reference that file via the `prompt_file` parameter in your Crew. CrewAI then merges your customizations with the defaults, so you don\u2019t have to redefine every prompt. Here\u2019s how:",
      "formatted_path": "Changelog > Customizing Prompts at a Low Level > The Simplest Way to Customize Prompts",
      "enhanced_text": "Context: Changelog > Customizing Prompts at a Low Level > The Simplest Way to Customize Prompts\n\n The Simplest Way to Customize Prompts\n\nOne straightforward approach is to create a JSON file for the prompts you want to override and then point your Crew at that file: Craft a JSON file with your updated prompt slices. Reference that file via the `prompt_file` parameter in your Crew. CrewAI then merges your customizations with the defaults, so you don\u2019t have to redefine every prompt. Here\u2019s how:"
    },
    {
      "content": "{\n  \"slices\": {\n    \"format\": \"When responding, follow this structure:\\n\\nTHOUGHTS: Your step-by-step thinking\\nACTION: Any tool you're using\\nRESULT: Your final answer or conclusion\"\n  }\n}",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Customizing Prompts at a Low Level",
          "level": 1
        },
        {
          "title": "The Simplest Way to Customize Prompts",
          "level": 2
        },
        {
          "title": "Example: Basic Prompt Customization",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Customizing Prompts at a Low Level",
            "level": 1
          },
          {
            "title": "The Simplest Way to Customize Prompts",
            "level": 2
          },
          {
            "title": "Example: Basic Prompt Customization",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Customizing Prompts at a Low Level > The Simplest Way to Customize Prompts > Example: Basic Prompt Customization"
      },
      "enhanced_content": "Context: Changelog > Customizing Prompts at a Low Level > The Simplest Way to Customize Prompts > Example: Basic Prompt Customization\n\n{\n  \"slices\": {\n    \"format\": \"When responding, follow this structure:\\n\\nTHOUGHTS: Your step-by-step thinking\\nACTION: Any tool you're using\\nRESULT: Your final answer or conclusion\"\n  }\n}",
      "formatted_path": "Changelog > Customizing Prompts at a Low Level > The Simplest Way to Customize Prompts > Example: Basic Prompt Customization",
      "enhanced_text": "Context: Changelog > Customizing Prompts at a Low Level > The Simplest Way to Customize Prompts > Example: Basic Prompt Customization\n\n{\n  \"slices\": {\n    \"format\": \"When responding, follow this structure:\\n\\nTHOUGHTS: Your step-by-step thinking\\nACTION: Any tool you're using\\nRESULT: Your final answer or conclusion\"\n  }\n}"
    },
    {
      "content": "from crewai import Agent, Crew, Task, Process\n\n# Create agents and tasks as normal\nresearcher = Agent(\n    role=\"Research Specialist\",\n    goal=\"Find information on quantum computing\",\n    backstory=\"You are a quantum physics expert\",\n    verbose=True\n)\n\nresearch_task = Task(\n    description=\"Research quantum computing applications\",\n    expected_output=\"A summary of practical applications\",\n    agent=researcher\n)\n\n# Create a crew with your custom prompt file\ncrew = Crew(\n    agents=[researcher],\n    tasks=[research_task],\n    prompt_file=\"path/to/custom_prompts.json\",\n    verbose=True\n)\n\n# Run the crew\nresult = crew.kickoff()",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Customizing Prompts at a Low Level",
          "level": 1
        },
        {
          "title": "The Simplest Way to Customize Prompts",
          "level": 2
        },
        {
          "title": "Example: Basic Prompt Customization",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Customizing Prompts at a Low Level",
            "level": 1
          },
          {
            "title": "The Simplest Way to Customize Prompts",
            "level": 2
          },
          {
            "title": "Example: Basic Prompt Customization",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Customizing Prompts at a Low Level > The Simplest Way to Customize Prompts > Example: Basic Prompt Customization"
      },
      "enhanced_content": "Context: Changelog > Customizing Prompts at a Low Level > The Simplest Way to Customize Prompts > Example: Basic Prompt Customization\n\nfrom crewai import Agent, Crew, Task, Process\n\n# Create agents and tasks as normal\nresearcher = Agent(\n    role=\"Research Specialist\",\n    goal=\"Find information on quantum computing\",\n    backstory=\"You are a quantum physics expert\",\n    verbose=True\n)\n\nresearch_task = Task(\n    description=\"Research quantum computing applications\",\n    expected_output=\"A summary of practical applications\",\n    agent=researcher\n)\n\n# Create a crew with your custom prompt file\ncrew = Crew(\n    agents=[researcher],\n    tasks=[research_task],\n    prompt_file=\"path/to/custom_prompts.json\",\n    verbose=True\n)\n\n# Run the crew\nresult = crew.kickoff()",
      "formatted_path": "Changelog > Customizing Prompts at a Low Level > The Simplest Way to Customize Prompts > Example: Basic Prompt Customization",
      "enhanced_text": "Context: Changelog > Customizing Prompts at a Low Level > The Simplest Way to Customize Prompts > Example: Basic Prompt Customization\n\nfrom crewai import Agent, Crew, Task, Process\n\n# Create agents and tasks as normal\nresearcher = Agent(\n    role=\"Research Specialist\",\n    goal=\"Find information on quantum computing\",\n    backstory=\"You are a quantum physics expert\",\n    verbose=True\n)\n\nresearch_task = Task(\n    description=\"Research quantum computing applications\",\n    expected_output=\"A summary of practical applications\",\n    agent=researcher\n)\n\n# Create a crew with your custom prompt file\ncrew = Crew(\n    agents=[researcher],\n    tasks=[research_task],\n    prompt_file=\"path/to/custom_prompts.json\",\n    verbose=True\n)\n\n# Run the crew\nresult = crew.kickoff()"
    },
    {
      "content": "Different models thrive on differently structured prompts. Making deeper adjustments can significantly boost performance by aligning your prompts with a model\u2019s nuances.",
      "title": "Optimizing for Specific Models",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Customizing Prompts at a Low Level",
          "level": 1
        },
        {
          "title": "Optimizing for Specific Models",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Customizing Prompts at a Low Level",
            "level": 1
          },
          {
            "title": "Optimizing for Specific Models",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Customizing Prompts at a Low Level > Optimizing for Specific Models"
      },
      "enhanced_content": "Context: Changelog > Customizing Prompts at a Low Level > Optimizing for Specific Models\n\n## Optimizing for Specific Models\n\nDifferent models thrive on differently structured prompts. Making deeper adjustments can significantly boost performance by aligning your prompts with a model\u2019s nuances.",
      "formatted_path": "Changelog > Customizing Prompts at a Low Level > Optimizing for Specific Models",
      "enhanced_text": "Context: Changelog > Customizing Prompts at a Low Level > Optimizing for Specific Models\n\n Optimizing for Specific Models\n\nDifferent models thrive on differently structured prompts. Making deeper adjustments can significantly boost performance by aligning your prompts with a model\u2019s nuances."
    },
    {
      "content": "from crewai import Agent, Crew, Task, Process\nfrom crewai_tools import DirectoryReadTool, FileReadTool\n\n# Define templates for system, user (prompt), and assistant (response) messages\nsystem_template = \"\"\"<|begin_of_text|><|start_header_id|>system<|end_header_id|>{{ .System }}<|eot_id|>\"\"\"\nprompt_template = \"\"\"<|start_header_id|>user<|end_header_id|>{{ .Prompt }}<|eot_id|>\"\"\"\nresponse_template = \"\"\"<|start_header_id|>assistant<|end_header_id|>{{ .Response }}<|eot_id|>\"\"\"\n\n# Create an Agent using Llama-specific layouts\nprincipal_engineer = Agent(\n    role=\"Principal Engineer\",\n    goal=\"Oversee AI architecture and make high-level decisions\",\n    backstory=\"You are the lead engineer responsible for critical AI systems\",\n    verbose=True,\n    llm=\"groq/llama-3.3-70b-versatile\",  # Using the Llama 3 model\n    system_template=system_template,\n    prompt_template=prompt_template,\n    response_template=response_template,\n    tools=[DirectoryReadTool(), FileReadTool()]\n)\n\n# Define a sample task\nengineering_task = Task(\n    description=\"Review AI implementation files for potential improvements\",\n    expected_output=\"A summary of key findings and recommendations\",\n    agent=principal_engineer\n)\n\n# Create a Crew for the task\nllama_crew = Crew(\n    agents=[principal_engineer],\n    tasks=[engineering_task],\n    process=Process.sequential,\n    verbose=True\n)\n\n# Execute the crew\nresult = llama_crew.kickoff()\nprint(result.raw)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Customizing Prompts at a Low Level",
          "level": 1
        },
        {
          "title": "Optimizing for Specific Models",
          "level": 2
        },
        {
          "title": "Example: Llama 3.3 Prompting Template",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Customizing Prompts at a Low Level",
            "level": 1
          },
          {
            "title": "Optimizing for Specific Models",
            "level": 2
          },
          {
            "title": "Example: Llama 3.3 Prompting Template",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Customizing Prompts at a Low Level > Optimizing for Specific Models > Example: Llama 3.3 Prompting Template"
      },
      "enhanced_content": "Context: Changelog > Customizing Prompts at a Low Level > Optimizing for Specific Models > Example: Llama 3.3 Prompting Template\n\nfrom crewai import Agent, Crew, Task, Process\nfrom crewai_tools import DirectoryReadTool, FileReadTool\n\n# Define templates for system, user (prompt), and assistant (response) messages\nsystem_template = \"\"\"<|begin_of_text|><|start_header_id|>system<|end_header_id|>{{ .System }}<|eot_id|>\"\"\"\nprompt_template = \"\"\"<|start_header_id|>user<|end_header_id|>{{ .Prompt }}<|eot_id|>\"\"\"\nresponse_template = \"\"\"<|start_header_id|>assistant<|end_header_id|>{{ .Response }}<|eot_id|>\"\"\"\n\n# Create an Agent using Llama-specific layouts\nprincipal_engineer = Agent(\n    role=\"Principal Engineer\",\n    goal=\"Oversee AI architecture and make high-level decisions\",\n    backstory=\"You are the lead engineer responsible for critical AI systems\",\n    verbose=True,\n    llm=\"groq/llama-3.3-70b-versatile\",  # Using the Llama 3 model\n    system_template=system_template,\n    prompt_template=prompt_template,\n    response_template=response_template,\n    tools=[DirectoryReadTool(), FileReadTool()]\n)\n\n# Define a sample task\nengineering_task = Task(\n    description=\"Review AI implementation files for potential improvements\",\n    expected_output=\"A summary of key findings and recommendations\",\n    agent=principal_engineer\n)\n\n# Create a Crew for the task\nllama_crew = Crew(\n    agents=[principal_engineer],\n    tasks=[engineering_task],\n    process=Process.sequential,\n    verbose=True\n)\n\n# Execute the crew\nresult = llama_crew.kickoff()\nprint(result.raw)",
      "formatted_path": "Changelog > Customizing Prompts at a Low Level > Optimizing for Specific Models > Example: Llama 3.3 Prompting Template",
      "enhanced_text": "Context: Changelog > Customizing Prompts at a Low Level > Optimizing for Specific Models > Example: Llama 3.3 Prompting Template\n\nfrom crewai import Agent, Crew, Task, Process\nfrom crewai_tools import DirectoryReadTool, FileReadTool\n\n# Define templates for system, user (prompt), and assistant (response) messages\nsystem_template = \"\"\"<|begin_of_text|><|start_header_id|>system<|end_header_id|>{{ .System }}<|eot_id|>\"\"\"\nprompt_template = \"\"\"<|start_header_id|>user<|end_header_id|>{{ .Prompt }}<|eot_id|>\"\"\"\nresponse_template = \"\"\"<|start_header_id|>assistant<|end_header_id|>{{ .Response }}<|eot_id|>\"\"\"\n\n# Create an Agent using Llama-specific layouts\nprincipal_engineer = Agent(\n    role=\"Principal Engineer\",\n    goal=\"Oversee AI architecture and make high-level decisions\",\n    backstory=\"You are the lead engineer responsible for critical AI systems\",\n    verbose=True,\n    llm=\"groq/llama-3.3-70b-versatile\",  # Using the Llama 3 model\n    system_template=system_template,\n    prompt_template=prompt_template,\n    response_template=response_template,\n    tools=[DirectoryReadTool(), FileReadTool()]\n)\n\n# Define a sample task\nengineering_task = Task(\n    description=\"Review AI implementation files for potential improvements\",\n    expected_output=\"A summary of key findings and recommendations\",\n    agent=principal_engineer\n)\n\n# Create a Crew for the task\nllama_crew = Crew(\n    agents=[principal_engineer],\n    tasks=[engineering_task],\n    process=Process.sequential,\n    verbose=True\n)\n\n# Execute the crew\nresult = llama_crew.kickoff()\nprint(result.raw)"
    },
    {
      "content": "Source: https://docs.crewai.com/guides/advanced/fingerprinting Learn how to use CrewAI's fingerprinting system to uniquely identify and track components throughout their lifecycle.",
      "title": "Fingerprinting",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Fingerprinting",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Fingerprinting",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Fingerprinting"
      },
      "enhanced_content": "Context: Changelog > Fingerprinting\n\n# Fingerprinting\n\nSource: https://docs.crewai.com/guides/advanced/fingerprinting Learn how to use CrewAI's fingerprinting system to uniquely identify and track components throughout their lifecycle.",
      "formatted_path": "Changelog > Fingerprinting",
      "enhanced_text": "Context: Changelog > Fingerprinting\n\n Fingerprinting\n\nSource: https://docs.crewai.com/guides/advanced/fingerprinting Learn how to use CrewAI's fingerprinting system to uniquely identify and track components throughout their lifecycle.\n\nRelated sections:\n- \n"
    },
    {
      "content": "A fingerprint is an instance of the `Fingerprint` class from the `crewai.security` module. Each fingerprint contains: A UUID string: A unique identifier for the component that is automatically generated and cannot be manually set A creation timestamp: When the fingerprint was generated, automatically set and cannot be manually modified Metadata: A dictionary of additional information that can be customized Fingerprints are automatically generated and assigned when a component is created. Each component exposes its fingerprint through a read-only property.",
      "title": "How Fingerprints Work",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Fingerprinting in CrewAI",
          "level": 1
        },
        {
          "title": "How Fingerprints Work",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Fingerprinting in CrewAI",
            "level": 1
          },
          {
            "title": "How Fingerprints Work",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Fingerprinting in CrewAI > How Fingerprints Work"
      },
      "enhanced_content": "Context: Changelog > Fingerprinting in CrewAI > How Fingerprints Work\n\n## How Fingerprints Work\n\nA fingerprint is an instance of the `Fingerprint` class from the `crewai.security` module. Each fingerprint contains: A UUID string: A unique identifier for the component that is automatically generated and cannot be manually set A creation timestamp: When the fingerprint was generated, automatically set and cannot be manually modified Metadata: A dictionary of additional information that can be customized Fingerprints are automatically generated and assigned when a component is created. Each component exposes its fingerprint through a read-only property.",
      "formatted_path": "Changelog > Fingerprinting in CrewAI > How Fingerprints Work",
      "enhanced_text": "Context: Changelog > Fingerprinting in CrewAI > How Fingerprints Work\n\n How Fingerprints Work\n\nA fingerprint is an instance of the `Fingerprint` class from the `crewai.security` module. Each fingerprint contains: A UUID string: A unique identifier for the component that is automatically generated and cannot be manually set A creation timestamp: When the fingerprint was generated, automatically set and cannot be manually modified Metadata: A dictionary of additional information that can be customized Fingerprints are automatically generated and assigned when a component is created. Each component exposes its fingerprint through a read-only property."
    },
    {
      "content": "from crewai import Agent, Crew, Task\n\n# Create components - fingerprints are automatically generated\nagent = Agent(\n    role=\"Data Scientist\",\n    goal=\"Analyze data\",\n    backstory=\"Expert in data analysis\"\n)\n\ncrew = Crew(\n    agents=[agent],\n    tasks=[]\n)\n\ntask = Task(\n    description=\"Analyze customer data\",\n    expected_output=\"Insights from data analysis\",\n    agent=agent\n)\n\n# Access the fingerprints\nagent_fingerprint = agent.fingerprint\ncrew_fingerprint = crew.fingerprint\ntask_fingerprint = task.fingerprint\n\n# Print the UUID strings\nprint(f\"Agent fingerprint: {agent_fingerprint.uuid_str}\")\nprint(f\"Crew fingerprint: {crew_fingerprint.uuid_str}\")\nprint(f\"Task fingerprint: {task_fingerprint.uuid_str}\")",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Fingerprinting in CrewAI",
          "level": 1
        },
        {
          "title": "Basic Usage",
          "level": 2
        },
        {
          "title": "Accessing Fingerprints",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Fingerprinting in CrewAI",
            "level": 1
          },
          {
            "title": "Basic Usage",
            "level": 2
          },
          {
            "title": "Accessing Fingerprints",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Fingerprinting in CrewAI > Basic Usage > Accessing Fingerprints"
      },
      "enhanced_content": "Context: Changelog > Fingerprinting in CrewAI > Basic Usage > Accessing Fingerprints\n\nfrom crewai import Agent, Crew, Task\n\n# Create components - fingerprints are automatically generated\nagent = Agent(\n    role=\"Data Scientist\",\n    goal=\"Analyze data\",\n    backstory=\"Expert in data analysis\"\n)\n\ncrew = Crew(\n    agents=[agent],\n    tasks=[]\n)\n\ntask = Task(\n    description=\"Analyze customer data\",\n    expected_output=\"Insights from data analysis\",\n    agent=agent\n)\n\n# Access the fingerprints\nagent_fingerprint = agent.fingerprint\ncrew_fingerprint = crew.fingerprint\ntask_fingerprint = task.fingerprint\n\n# Print the UUID strings\nprint(f\"Agent fingerprint: {agent_fingerprint.uuid_str}\")\nprint(f\"Crew fingerprint: {crew_fingerprint.uuid_str}\")\nprint(f\"Task fingerprint: {task_fingerprint.uuid_str}\")",
      "formatted_path": "Changelog > Fingerprinting in CrewAI > Basic Usage > Accessing Fingerprints",
      "enhanced_text": "Context: Changelog > Fingerprinting in CrewAI > Basic Usage > Accessing Fingerprints\n\nfrom crewai import Agent, Crew, Task\n\n# Create components - fingerprints are automatically generated\nagent = Agent(\n    role=\"Data Scientist\",\n    goal=\"Analyze data\",\n    backstory=\"Expert in data analysis\"\n)\n\ncrew = Crew(\n    agents=[agent],\n    tasks=[]\n)\n\ntask = Task(\n    description=\"Analyze customer data\",\n    expected_output=\"Insights from data analysis\",\n    agent=agent\n)\n\n# Access the fingerprints\nagent_fingerprint = agent.fingerprint\ncrew_fingerprint = crew.fingerprint\ntask_fingerprint = task.fingerprint\n\n# Print the UUID strings\nprint(f\"Agent fingerprint: {agent_fingerprint.uuid_str}\")\nprint(f\"Crew fingerprint: {crew_fingerprint.uuid_str}\")\nprint(f\"Task fingerprint: {task_fingerprint.uuid_str}\")"
    },
    {
      "content": "# Add metadata to the agent's fingerprint\nagent.security_config.fingerprint.metadata = {\n    \"version\": \"1.0\",\n    \"department\": \"Data Science\",\n    \"project\": \"Customer Analysis\"\n}\n\n# Access the metadata\nprint(f\"Agent metadata: {agent.fingerprint.metadata}\")",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Fingerprinting in CrewAI",
          "level": 1
        },
        {
          "title": "Basic Usage",
          "level": 2
        },
        {
          "title": "Working with Fingerprint Metadata",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Fingerprinting in CrewAI",
            "level": 1
          },
          {
            "title": "Basic Usage",
            "level": 2
          },
          {
            "title": "Working with Fingerprint Metadata",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Fingerprinting in CrewAI > Basic Usage > Working with Fingerprint Metadata"
      },
      "enhanced_content": "Context: Changelog > Fingerprinting in CrewAI > Basic Usage > Working with Fingerprint Metadata\n\n# Add metadata to the agent's fingerprint\nagent.security_config.fingerprint.metadata = {\n    \"version\": \"1.0\",\n    \"department\": \"Data Science\",\n    \"project\": \"Customer Analysis\"\n}\n\n# Access the metadata\nprint(f\"Agent metadata: {agent.fingerprint.metadata}\")",
      "formatted_path": "Changelog > Fingerprinting in CrewAI > Basic Usage > Working with Fingerprint Metadata",
      "enhanced_text": "Context: Changelog > Fingerprinting in CrewAI > Basic Usage > Working with Fingerprint Metadata\n\n# Add metadata to the agent's fingerprint\nagent.security_config.fingerprint.metadata = {\n    \"version\": \"1.0\",\n    \"department\": \"Data Science\",\n    \"project\": \"Customer Analysis\"\n}\n\n# Access the metadata\nprint(f\"Agent metadata: {agent.fingerprint.metadata}\")"
    },
    {
      "content": "original_fingerprint = agent.fingerprint.uuid_str\n\n# Modify the agent\nagent.goal = \"New goal for analysis\"\n\n# The fingerprint remains unchanged\nassert agent.fingerprint.uuid_str == original_fingerprint",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Fingerprinting in CrewAI",
          "level": 1
        },
        {
          "title": "Fingerprint Persistence",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Fingerprinting in CrewAI",
            "level": 1
          },
          {
            "title": "Fingerprint Persistence",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Fingerprinting in CrewAI > Fingerprint Persistence"
      },
      "enhanced_content": "Context: Changelog > Fingerprinting in CrewAI > Fingerprint Persistence\n\noriginal_fingerprint = agent.fingerprint.uuid_str\n\n# Modify the agent\nagent.goal = \"New goal for analysis\"\n\n# The fingerprint remains unchanged\nassert agent.fingerprint.uuid_str == original_fingerprint",
      "formatted_path": "Changelog > Fingerprinting in CrewAI > Fingerprint Persistence",
      "enhanced_text": "Context: Changelog > Fingerprinting in CrewAI > Fingerprint Persistence\n\noriginal_fingerprint = agent.fingerprint.uuid_str\n\n# Modify the agent\nagent.goal = \"New goal for analysis\"\n\n# The fingerprint remains unchanged\nassert agent.fingerprint.uuid_str == original_fingerprint"
    },
    {
      "content": "from crewai.security import Fingerprint\n\n# Create a deterministic fingerprint using a seed string\ndeterministic_fingerprint = Fingerprint.generate(seed=\"my-agent-id\")\n\n# The same seed always produces the same fingerprint\nsame_fingerprint = Fingerprint.generate(seed=\"my-agent-id\")\nassert deterministic_fingerprint.uuid_str == same_fingerprint.uuid_str\n\n# You can also set metadata\ncustom_fingerprint = Fingerprint.generate(\n    seed=\"my-agent-id\",\n    metadata={\"version\": \"1.0\"}\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Fingerprinting in CrewAI",
          "level": 1
        },
        {
          "title": "Deterministic Fingerprints",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Fingerprinting in CrewAI",
            "level": 1
          },
          {
            "title": "Deterministic Fingerprints",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Fingerprinting in CrewAI > Deterministic Fingerprints"
      },
      "enhanced_content": "Context: Changelog > Fingerprinting in CrewAI > Deterministic Fingerprints\n\nfrom crewai.security import Fingerprint\n\n# Create a deterministic fingerprint using a seed string\ndeterministic_fingerprint = Fingerprint.generate(seed=\"my-agent-id\")\n\n# The same seed always produces the same fingerprint\nsame_fingerprint = Fingerprint.generate(seed=\"my-agent-id\")\nassert deterministic_fingerprint.uuid_str == same_fingerprint.uuid_str\n\n# You can also set metadata\ncustom_fingerprint = Fingerprint.generate(\n    seed=\"my-agent-id\",\n    metadata={\"version\": \"1.0\"}\n)",
      "formatted_path": "Changelog > Fingerprinting in CrewAI > Deterministic Fingerprints",
      "enhanced_text": "Context: Changelog > Fingerprinting in CrewAI > Deterministic Fingerprints\n\nfrom crewai.security import Fingerprint\n\n# Create a deterministic fingerprint using a seed string\ndeterministic_fingerprint = Fingerprint.generate(seed=\"my-agent-id\")\n\n# The same seed always produces the same fingerprint\nsame_fingerprint = Fingerprint.generate(seed=\"my-agent-id\")\nassert deterministic_fingerprint.uuid_str == same_fingerprint.uuid_str\n\n# You can also set metadata\ncustom_fingerprint = Fingerprint.generate(\n    seed=\"my-agent-id\",\n    metadata={\"version\": \"1.0\"}\n)"
    },
    {
      "content": "from crewai.security import Fingerprint\n\nfingerprint = agent.fingerprint\n\n# UUID string - the unique identifier (auto-generated)\nuuid_str = fingerprint.uuid_str  # e.g., \"123e4567-e89b-12d3-a456-426614174000\"\n\n# Creation timestamp (auto-generated)\ncreated_at = fingerprint.created_at  # A datetime object\n\n# Metadata - for additional information (can be customized)\nmetadata = fingerprint.metadata  # A dictionary, defaults to {}",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Fingerprinting in CrewAI",
          "level": 1
        },
        {
          "title": "Advanced Usage",
          "level": 2
        },
        {
          "title": "Fingerprint Structure",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Fingerprinting in CrewAI",
            "level": 1
          },
          {
            "title": "Advanced Usage",
            "level": 2
          },
          {
            "title": "Fingerprint Structure",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Fingerprinting in CrewAI > Advanced Usage > Fingerprint Structure"
      },
      "enhanced_content": "Context: Changelog > Fingerprinting in CrewAI > Advanced Usage > Fingerprint Structure\n\nfrom crewai.security import Fingerprint\n\nfingerprint = agent.fingerprint\n\n# UUID string - the unique identifier (auto-generated)\nuuid_str = fingerprint.uuid_str  # e.g., \"123e4567-e89b-12d3-a456-426614174000\"\n\n# Creation timestamp (auto-generated)\ncreated_at = fingerprint.created_at  # A datetime object\n\n# Metadata - for additional information (can be customized)\nmetadata = fingerprint.metadata  # A dictionary, defaults to {}",
      "formatted_path": "Changelog > Fingerprinting in CrewAI > Advanced Usage > Fingerprint Structure",
      "enhanced_text": "Context: Changelog > Fingerprinting in CrewAI > Advanced Usage > Fingerprint Structure\n\nfrom crewai.security import Fingerprint\n\nfingerprint = agent.fingerprint\n\n# UUID string - the unique identifier (auto-generated)\nuuid_str = fingerprint.uuid_str  # e.g., \"123e4567-e89b-12d3-a456-426614174000\"\n\n# Creation timestamp (auto-generated)\ncreated_at = fingerprint.created_at  # A datetime object\n\n# Metadata - for additional information (can be customized)\nmetadata = fingerprint.metadata  # A dictionary, defaults to {}"
    },
    {
      "content": "Source: https://docs.crewai.com/guides/agents/crafting-effective-agents Learn best practices for designing powerful, specialized AI agents that collaborate effectively to solve complex problems.",
      "title": "Crafting Effective Agents",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crafting Effective Agents",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crafting Effective Agents",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crafting Effective Agents"
      },
      "enhanced_content": "Context: Changelog > Crafting Effective Agents\n\n# Crafting Effective Agents\n\nSource: https://docs.crewai.com/guides/agents/crafting-effective-agents Learn best practices for designing powerful, specialized AI agents that collaborate effectively to solve complex problems.",
      "formatted_path": "Changelog > Crafting Effective Agents",
      "enhanced_text": "Context: Changelog > Crafting Effective Agents\n\n Crafting Effective Agents\n\nSource: https://docs.crewai.com/guides/agents/crafting-effective-agents Learn best practices for designing powerful, specialized AI agents that collaborate effectively to solve complex problems.\n\nRelated sections:\n- \n"
    },
    {
      "content": "At the heart of CrewAI lies the agent - a specialized AI entity designed to perform specific roles within a collaborative framework. While creating basic agents is simple, crafting truly effective agents that produce exceptional results requires understanding key design principles and best practices. This guide will help you master the art of agent design, enabling you to create specialized AI personas that collaborate effectively, think critically, and produce high-quality outputs tailored to your specific needs.",
      "title": "The Art and Science of Agent Design",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crafting Effective Agents",
          "level": 1
        },
        {
          "title": "The Art and Science of Agent Design",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crafting Effective Agents",
            "level": 1
          },
          {
            "title": "The Art and Science of Agent Design",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crafting Effective Agents > The Art and Science of Agent Design"
      },
      "enhanced_content": "Context: Changelog > Crafting Effective Agents > The Art and Science of Agent Design\n\n## The Art and Science of Agent Design\n\nAt the heart of CrewAI lies the agent - a specialized AI entity designed to perform specific roles within a collaborative framework. While creating basic agents is simple, crafting truly effective agents that produce exceptional results requires understanding key design principles and best practices. This guide will help you master the art of agent design, enabling you to create specialized AI personas that collaborate effectively, think critically, and produce high-quality outputs tailored to your specific needs.",
      "formatted_path": "Changelog > Crafting Effective Agents > The Art and Science of Agent Design",
      "enhanced_text": "Context: Changelog > Crafting Effective Agents > The Art and Science of Agent Design\n\n The Art and Science of Agent Design\n\nAt the heart of CrewAI lies the agent - a specialized AI entity designed to perform specific roles within a collaborative framework. While creating basic agents is simple, crafting truly effective agents that produce exceptional results requires understanding key design principles and best practices. This guide will help you master the art of agent design, enabling you to create specialized AI personas that collaborate effectively, think critically, and produce high-quality outputs tailored to your specific needs."
    },
    {
      "content": "The way you define your agents significantly impacts: **Output quality**: Well-designed agents produce more relevant, high-quality results **Collaboration effectiveness**: Agents with complementary skills work together more efficiently **Task performance**: Agents with clear roles and goals execute tasks more effectively **System scalability**: Thoughtfully designed agents can be reused across multiple crews and contexts Let's explore best practices for creating agents that excel in these dimensions.",
      "title": "Why Agent Design Matters",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crafting Effective Agents",
          "level": 1
        },
        {
          "title": "The Art and Science of Agent Design",
          "level": 2
        },
        {
          "title": "Why Agent Design Matters",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crafting Effective Agents",
            "level": 1
          },
          {
            "title": "The Art and Science of Agent Design",
            "level": 2
          },
          {
            "title": "Why Agent Design Matters",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crafting Effective Agents > The Art and Science of Agent Design > Why Agent Design Matters"
      },
      "enhanced_content": "Context: Changelog > Crafting Effective Agents > The Art and Science of Agent Design > Why Agent Design Matters\n\n### Why Agent Design Matters\n\nThe way you define your agents significantly impacts: **Output quality**: Well-designed agents produce more relevant, high-quality results **Collaboration effectiveness**: Agents with complementary skills work together more efficiently **Task performance**: Agents with clear roles and goals execute tasks more effectively **System scalability**: Thoughtfully designed agents can be reused across multiple crews and contexts Let's explore best practices for creating agents that excel in these dimensions.",
      "formatted_path": "Changelog > Crafting Effective Agents > The Art and Science of Agent Design > Why Agent Design Matters",
      "enhanced_text": "Context: Changelog > Crafting Effective Agents > The Art and Science of Agent Design > Why Agent Design Matters\n\n Why Agent Design Matters\n\nThe way you define your agents significantly impacts: **Output quality**: Well-designed agents produce more relevant, high-quality results **Collaboration effectiveness**: Agents with complementary skills work together more efficiently **Task performance**: Agents with clear roles and goals execute tasks more effectively **System scalability**: Thoughtfully designed agents can be reused across multiple crews and contexts Let's explore best practices for creating agents that excel in these dimensions."
    },
    {
      "content": "When building effective AI systems, remember this crucial principle: **80% of your effort should go into designing tasks, and only 20% into defining agents**. Why? Because even the most perfectly defined agent will fail with poorly designed tasks, but well-designed tasks can elevate even a simple agent. This means: Spend most of your time writing clear task instructions Define detailed inputs and expected outputs Add examples and context to guide execution Dedicate the remaining time to agent role, goal, and backstory This doesn't mean agent design isn't important - it absolutely is. But task design is where most execution failures occur, so prioritize accordingly.",
      "title": "The 80/20 Rule: Focus on Tasks Over Agents",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crafting Effective Agents",
          "level": 1
        },
        {
          "title": "The 80/20 Rule: Focus on Tasks Over Agents",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crafting Effective Agents",
            "level": 1
          },
          {
            "title": "The 80/20 Rule: Focus on Tasks Over Agents",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crafting Effective Agents > The 80/20 Rule: Focus on Tasks Over Agents"
      },
      "enhanced_content": "Context: Changelog > Crafting Effective Agents > The 80/20 Rule: Focus on Tasks Over Agents\n\n## The 80/20 Rule: Focus on Tasks Over Agents\n\nWhen building effective AI systems, remember this crucial principle: **80% of your effort should go into designing tasks, and only 20% into defining agents**. Why? Because even the most perfectly defined agent will fail with poorly designed tasks, but well-designed tasks can elevate even a simple agent. This means: Spend most of your time writing clear task instructions Define detailed inputs and expected outputs Add examples and context to guide execution Dedicate the remaining time to agent role, goal, and backstory This doesn't mean agent design isn't important - it absolutely is. But task design is where most execution failures occur, so prioritize accordingly.",
      "formatted_path": "Changelog > Crafting Effective Agents > The 80/20 Rule: Focus on Tasks Over Agents",
      "enhanced_text": "Context: Changelog > Crafting Effective Agents > The 80/20 Rule: Focus on Tasks Over Agents\n\n The 80/20 Rule: Focus on Tasks Over Agents\n\nWhen building effective AI systems, remember this crucial principle: **80% of your effort should go into designing tasks, and only 20% into defining agents**. Why? Because even the most perfectly defined agent will fail with poorly designed tasks, but well-designed tasks can elevate even a simple agent. This means: Spend most of your time writing clear task instructions Define detailed inputs and expected outputs Add examples and context to guide execution Dedicate the remaining time to agent role, goal, and backstory This doesn't mean agent design isn't important - it absolutely is. But task design is where most execution failures occur, so prioritize accordingly.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "The most powerful agents in CrewAI are built on a strong foundation of three key elements:",
      "title": "1. The Role-Goal-Backstory Framework",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crafting Effective Agents",
          "level": 1
        },
        {
          "title": "Core Principles of Effective Agent Design",
          "level": 2
        },
        {
          "title": "1. The Role-Goal-Backstory Framework",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crafting Effective Agents",
            "level": 1
          },
          {
            "title": "Core Principles of Effective Agent Design",
            "level": 2
          },
          {
            "title": "1. The Role-Goal-Backstory Framework",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crafting Effective Agents > Core Principles of Effective Agent Design > 1. The Role-Goal-Backstory Framework"
      },
      "enhanced_content": "Context: Changelog > Crafting Effective Agents > Core Principles of Effective Agent Design > 1. The Role-Goal-Backstory Framework\n\n### 1. The Role-Goal-Backstory Framework\n\nThe most powerful agents in CrewAI are built on a strong foundation of three key elements:",
      "formatted_path": "Changelog > Crafting Effective Agents > Core Principles of Effective Agent Design > 1. The Role-Goal-Backstory Framework",
      "enhanced_text": "Context: Changelog > Crafting Effective Agents > Core Principles of Effective Agent Design > 1. The Role-Goal-Backstory Framework\n\n 1. The Role-Goal-Backstory Framework\n\nThe most powerful agents in CrewAI are built on a strong foundation of three key elements:"
    },
    {
      "content": "role: \"Senior UX Researcher specializing in user interview analysis\"\nrole: \"Full-Stack Software Architect with expertise in distributed systems\"\nrole: \"Corporate Communications Director specializing in crisis management\"",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crafting Effective Agents",
          "level": 1
        },
        {
          "title": "Core Principles of Effective Agent Design",
          "level": 2
        },
        {
          "title": "1. The Role-Goal-Backstory Framework",
          "level": 3
        },
        {
          "title": "Role: The Agent's Specialized Function",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crafting Effective Agents",
            "level": 1
          },
          {
            "title": "Core Principles of Effective Agent Design",
            "level": 2
          },
          {
            "title": "1. The Role-Goal-Backstory Framework",
            "level": 3
          },
          {
            "title": "Role: The Agent's Specialized Function",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crafting Effective Agents > Core Principles of Effective Agent Design > 1. The Role-Goal-Backstory Framework > Role: The Agent's Specialized Function"
      },
      "enhanced_content": "Context: Changelog > Crafting Effective Agents > Core Principles of Effective Agent Design > 1. The Role-Goal-Backstory Framework > Role: The Agent's Specialized Function\n\nrole: \"Senior UX Researcher specializing in user interview analysis\"\nrole: \"Full-Stack Software Architect with expertise in distributed systems\"\nrole: \"Corporate Communications Director specializing in crisis management\"",
      "formatted_path": "Changelog > Crafting Effective Agents > Core Principles of Effective Agent Design > 1. The Role-Goal-Backstory Framework > Role: The Agent's Specialized Function",
      "enhanced_text": "Context: Changelog > Crafting Effective Agents > Core Principles of Effective Agent Design > 1. The Role-Goal-Backstory Framework > Role: The Agent's Specialized Function\n\nrole: \"Senior UX Researcher specializing in user interview analysis\"\nrole: \"Full-Stack Software Architect with expertise in distributed systems\"\nrole: \"Corporate Communications Director specializing in crisis management\""
    },
    {
      "content": "goal: \"Uncover actionable user insights by analyzing interview data and identifying recurring patterns, unmet needs, and improvement opportunities\"\ngoal: \"Design robust, scalable system architectures that balance performance, maintainability, and cost-effectiveness\"\ngoal: \"Craft clear, empathetic crisis communications that address stakeholder concerns while protecting organizational reputation\"",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crafting Effective Agents",
          "level": 1
        },
        {
          "title": "Core Principles of Effective Agent Design",
          "level": 2
        },
        {
          "title": "1. The Role-Goal-Backstory Framework",
          "level": 3
        },
        {
          "title": "Goal: The Agent's Purpose and Motivation",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crafting Effective Agents",
            "level": 1
          },
          {
            "title": "Core Principles of Effective Agent Design",
            "level": 2
          },
          {
            "title": "1. The Role-Goal-Backstory Framework",
            "level": 3
          },
          {
            "title": "Goal: The Agent's Purpose and Motivation",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crafting Effective Agents > Core Principles of Effective Agent Design > 1. The Role-Goal-Backstory Framework > Goal: The Agent's Purpose and Motivation"
      },
      "enhanced_content": "Context: Changelog > Crafting Effective Agents > Core Principles of Effective Agent Design > 1. The Role-Goal-Backstory Framework > Goal: The Agent's Purpose and Motivation\n\ngoal: \"Uncover actionable user insights by analyzing interview data and identifying recurring patterns, unmet needs, and improvement opportunities\"\ngoal: \"Design robust, scalable system architectures that balance performance, maintainability, and cost-effectiveness\"\ngoal: \"Craft clear, empathetic crisis communications that address stakeholder concerns while protecting organizational reputation\"",
      "formatted_path": "Changelog > Crafting Effective Agents > Core Principles of Effective Agent Design > 1. The Role-Goal-Backstory Framework > Goal: The Agent's Purpose and Motivation",
      "enhanced_text": "Context: Changelog > Crafting Effective Agents > Core Principles of Effective Agent Design > 1. The Role-Goal-Backstory Framework > Goal: The Agent's Purpose and Motivation\n\ngoal: \"Uncover actionable user insights by analyzing interview data and identifying recurring patterns, unmet needs, and improvement opportunities\"\ngoal: \"Design robust, scalable system architectures that balance performance, maintainability, and cost-effectiveness\"\ngoal: \"Craft clear, empathetic crisis communications that address stakeholder concerns while protecting organizational reputation\""
    },
    {
      "content": "backstory: \"You have spent 15 years conducting and analyzing user research for top tech companies. You have a talent for reading between the lines and identifying patterns that others miss. You believe that good UX is invisible and that the best insights come from listening to what users don't say as much as what they do say.\"\n\nbackstory: \"With 20+ years of experience building distributed systems at scale, you've developed a pragmatic approach to software architecture. You've seen both successful and failed systems and have learned valuable lessons from each. You balance theoretical best practices with practical constraints and always consider the maintenance and operational aspects of your designs.\"\n\nbackstory: \"As a seasoned communications professional who has guided multiple organizations through high-profile crises, you understand the importance of transparency, speed, and empathy in crisis response. You have a methodical approach to crafting messages that address concerns while maintaining organizational credibility.\"",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crafting Effective Agents",
          "level": 1
        },
        {
          "title": "Core Principles of Effective Agent Design",
          "level": 2
        },
        {
          "title": "1. The Role-Goal-Backstory Framework",
          "level": 3
        },
        {
          "title": "Backstory: The Agent's Experience and Perspective",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crafting Effective Agents",
            "level": 1
          },
          {
            "title": "Core Principles of Effective Agent Design",
            "level": 2
          },
          {
            "title": "1. The Role-Goal-Backstory Framework",
            "level": 3
          },
          {
            "title": "Backstory: The Agent's Experience and Perspective",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crafting Effective Agents > Core Principles of Effective Agent Design > 1. The Role-Goal-Backstory Framework > Backstory: The Agent's Experience and Perspective"
      },
      "enhanced_content": "Context: Changelog > Crafting Effective Agents > Core Principles of Effective Agent Design > 1. The Role-Goal-Backstory Framework > Backstory: The Agent's Experience and Perspective\n\nbackstory: \"You have spent 15 years conducting and analyzing user research for top tech companies. You have a talent for reading between the lines and identifying patterns that others miss. You believe that good UX is invisible and that the best insights come from listening to what users don't say as much as what they do say.\"\n\nbackstory: \"With 20+ years of experience building distributed systems at scale, you've developed a pragmatic approach to software architecture. You've seen both successful and failed systems and have learned valuable lessons from each. You balance theoretical best practices with practical constraints and always consider the maintenance and operational aspects of your designs.\"\n\nbackstory: \"As a seasoned communications professional who has guided multiple organizations through high-profile crises, you understand the importance of transparency, speed, and empathy in crisis response. You have a methodical approach to crafting messages that address concerns while maintaining organizational credibility.\"",
      "formatted_path": "Changelog > Crafting Effective Agents > Core Principles of Effective Agent Design > 1. The Role-Goal-Backstory Framework > Backstory: The Agent's Experience and Perspective",
      "enhanced_text": "Context: Changelog > Crafting Effective Agents > Core Principles of Effective Agent Design > 1. The Role-Goal-Backstory Framework > Backstory: The Agent's Experience and Perspective\n\nbackstory: \"You have spent 15 years conducting and analyzing user research for top tech companies. You have a talent for reading between the lines and identifying patterns that others miss. You believe that good UX is invisible and that the best insights come from listening to what users don't say as much as what they do say.\"\n\nbackstory: \"With 20+ years of experience building distributed systems at scale, you've developed a pragmatic approach to software architecture. You've seen both successful and failed systems and have learned valuable lessons from each. You balance theoretical best practices with practical constraints and always consider the maintenance and operational aspects of your designs.\"\n\nbackstory: \"As a seasoned communications professional who has guided multiple organizations through high-profile crises, you understand the importance of transparency, speed, and empathy in crisis response. You have a methodical approach to crafting messages that address concerns while maintaining organizational credibility.\""
    },
    {
      "content": "role: \"Writer\"",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crafting Effective Agents",
          "level": 1
        },
        {
          "title": "Core Principles of Effective Agent Design",
          "level": 2
        },
        {
          "title": "2. Specialists Over Generalists",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crafting Effective Agents",
            "level": 1
          },
          {
            "title": "Core Principles of Effective Agent Design",
            "level": 2
          },
          {
            "title": "2. Specialists Over Generalists",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crafting Effective Agents > Core Principles of Effective Agent Design > 2. Specialists Over Generalists"
      },
      "enhanced_content": "Context: Changelog > Crafting Effective Agents > Core Principles of Effective Agent Design > 2. Specialists Over Generalists\n\nrole: \"Writer\"",
      "formatted_path": "Changelog > Crafting Effective Agents > Core Principles of Effective Agent Design > 2. Specialists Over Generalists",
      "enhanced_text": "Context: Changelog > Crafting Effective Agents > Core Principles of Effective Agent Design > 2. Specialists Over Generalists\n\nrole: \"Writer\""
    },
    {
      "content": "role: \"Technical Blog Writer specializing in explaining complex AI concepts to non-technical audiences\"",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crafting Effective Agents",
          "level": 1
        },
        {
          "title": "Core Principles of Effective Agent Design",
          "level": 2
        },
        {
          "title": "2. Specialists Over Generalists",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crafting Effective Agents",
            "level": 1
          },
          {
            "title": "Core Principles of Effective Agent Design",
            "level": 2
          },
          {
            "title": "2. Specialists Over Generalists",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crafting Effective Agents > Core Principles of Effective Agent Design > 2. Specialists Over Generalists"
      },
      "enhanced_content": "Context: Changelog > Crafting Effective Agents > Core Principles of Effective Agent Design > 2. Specialists Over Generalists\n\nrole: \"Technical Blog Writer specializing in explaining complex AI concepts to non-technical audiences\"",
      "formatted_path": "Changelog > Crafting Effective Agents > Core Principles of Effective Agent Design > 2. Specialists Over Generalists",
      "enhanced_text": "Context: Changelog > Crafting Effective Agents > Core Principles of Effective Agent Design > 2. Specialists Over Generalists\n\nrole: \"Technical Blog Writer specializing in explaining complex AI concepts to non-technical audiences\""
    },
    {
      "content": "Effective agents strike the right balance between specialization (doing one thing extremely well) and versatility (being adaptable to various situations): **Specialize in role, versatile in application**: Create agents with specialized skills that can be applied across multiple contexts **Avoid overly narrow definitions**: Ensure agents can handle variations within their domain of expertise **Consider the collaborative context**: Design agents whose specializations complement the other agents they'll work with",
      "title": "3. Balancing Specialization and Versatility",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crafting Effective Agents",
          "level": 1
        },
        {
          "title": "Core Principles of Effective Agent Design",
          "level": 2
        },
        {
          "title": "3. Balancing Specialization and Versatility",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crafting Effective Agents",
            "level": 1
          },
          {
            "title": "Core Principles of Effective Agent Design",
            "level": 2
          },
          {
            "title": "3. Balancing Specialization and Versatility",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crafting Effective Agents > Core Principles of Effective Agent Design > 3. Balancing Specialization and Versatility"
      },
      "enhanced_content": "Context: Changelog > Crafting Effective Agents > Core Principles of Effective Agent Design > 3. Balancing Specialization and Versatility\n\n### 3. Balancing Specialization and Versatility\n\nEffective agents strike the right balance between specialization (doing one thing extremely well) and versatility (being adaptable to various situations): **Specialize in role, versatile in application**: Create agents with specialized skills that can be applied across multiple contexts **Avoid overly narrow definitions**: Ensure agents can handle variations within their domain of expertise **Consider the collaborative context**: Design agents whose specializations complement the other agents they'll work with",
      "formatted_path": "Changelog > Crafting Effective Agents > Core Principles of Effective Agent Design > 3. Balancing Specialization and Versatility",
      "enhanced_text": "Context: Changelog > Crafting Effective Agents > Core Principles of Effective Agent Design > 3. Balancing Specialization and Versatility\n\n 3. Balancing Specialization and Versatility\n\nEffective agents strike the right balance between specialization (doing one thing extremely well) and versatility (being adaptable to various situations): **Specialize in role, versatile in application**: Create agents with specialized skills that can be applied across multiple contexts **Avoid overly narrow definitions**: Ensure agents can handle variations within their domain of expertise **Consider the collaborative context**: Design agents whose specializations complement the other agents they'll work with"
    },
    {
      "content": "The expertise level you assign to your agent shapes how they approach tasks: **Novice agents**: Good for straightforward tasks, brainstorming, or initial drafts **Intermediate agents**: Suitable for most standard tasks with reliable execution **Expert agents**: Best for complex, specialized tasks requiring depth and nuance **World-class agents**: Reserved for critical tasks where exceptional quality is needed Choose the appropriate expertise level based on task complexity and quality requirements. For most collaborative crews, a mix of expertise levels often works best, with higher expertise assigned to core specialized functions.",
      "title": "4. Setting Appropriate Expertise Levels",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crafting Effective Agents",
          "level": 1
        },
        {
          "title": "Core Principles of Effective Agent Design",
          "level": 2
        },
        {
          "title": "4. Setting Appropriate Expertise Levels",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crafting Effective Agents",
            "level": 1
          },
          {
            "title": "Core Principles of Effective Agent Design",
            "level": 2
          },
          {
            "title": "4. Setting Appropriate Expertise Levels",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crafting Effective Agents > Core Principles of Effective Agent Design > 4. Setting Appropriate Expertise Levels"
      },
      "enhanced_content": "Context: Changelog > Crafting Effective Agents > Core Principles of Effective Agent Design > 4. Setting Appropriate Expertise Levels\n\n### 4. Setting Appropriate Expertise Levels\n\nThe expertise level you assign to your agent shapes how they approach tasks: **Novice agents**: Good for straightforward tasks, brainstorming, or initial drafts **Intermediate agents**: Suitable for most standard tasks with reliable execution **Expert agents**: Best for complex, specialized tasks requiring depth and nuance **World-class agents**: Reserved for critical tasks where exceptional quality is needed Choose the appropriate expertise level based on task complexity and quality requirements. For most collaborative crews, a mix of expertise levels often works best, with higher expertise assigned to core specialized functions.",
      "formatted_path": "Changelog > Crafting Effective Agents > Core Principles of Effective Agent Design > 4. Setting Appropriate Expertise Levels",
      "enhanced_text": "Context: Changelog > Crafting Effective Agents > Core Principles of Effective Agent Design > 4. Setting Appropriate Expertise Levels\n\n 4. Setting Appropriate Expertise Levels\n\nThe expertise level you assign to your agent shapes how they approach tasks: **Novice agents**: Good for straightforward tasks, brainstorming, or initial drafts **Intermediate agents**: Suitable for most standard tasks with reliable execution **Expert agents**: Best for complex, specialized tasks requiring depth and nuance **World-class agents**: Reserved for critical tasks where exceptional quality is needed Choose the appropriate expertise level based on task complexity and quality requirements. For most collaborative crews, a mix of expertise levels often works best, with higher expertise assigned to core specialized functions."
    },
    {
      "content": "Let's look at some examples of agent definitions before and after applying these best practices:",
      "title": "Practical Examples: Before and After",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crafting Effective Agents",
          "level": 1
        },
        {
          "title": "Practical Examples: Before and After",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crafting Effective Agents",
            "level": 1
          },
          {
            "title": "Practical Examples: Before and After",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crafting Effective Agents > Practical Examples: Before and After"
      },
      "enhanced_content": "Context: Changelog > Crafting Effective Agents > Practical Examples: Before and After\n\n## Practical Examples: Before and After\n\nLet's look at some examples of agent definitions before and after applying these best practices:",
      "formatted_path": "Changelog > Crafting Effective Agents > Practical Examples: Before and After",
      "enhanced_text": "Context: Changelog > Crafting Effective Agents > Practical Examples: Before and After\n\n Practical Examples: Before and After\n\nLet's look at some examples of agent definitions before and after applying these best practices:\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "role: \"Writer\"\ngoal: \"Write good content\"\nbackstory: \"You are a writer who creates content for websites.\"",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crafting Effective Agents",
          "level": 1
        },
        {
          "title": "Practical Examples: Before and After",
          "level": 2
        },
        {
          "title": "Example 1: Content Creation Agent",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crafting Effective Agents",
            "level": 1
          },
          {
            "title": "Practical Examples: Before and After",
            "level": 2
          },
          {
            "title": "Example 1: Content Creation Agent",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crafting Effective Agents > Practical Examples: Before and After > Example 1: Content Creation Agent"
      },
      "enhanced_content": "Context: Changelog > Crafting Effective Agents > Practical Examples: Before and After > Example 1: Content Creation Agent\n\nrole: \"Writer\"\ngoal: \"Write good content\"\nbackstory: \"You are a writer who creates content for websites.\"",
      "formatted_path": "Changelog > Crafting Effective Agents > Practical Examples: Before and After > Example 1: Content Creation Agent",
      "enhanced_text": "Context: Changelog > Crafting Effective Agents > Practical Examples: Before and After > Example 1: Content Creation Agent\n\nrole: \"Writer\"\ngoal: \"Write good content\"\nbackstory: \"You are a writer who creates content for websites.\""
    },
    {
      "content": "role: \"B2B Technology Content Strategist\"\ngoal: \"Create compelling, technically accurate content that explains complex topics in accessible language while driving reader engagement and supporting business objectives\"\nbackstory: \"You have spent a decade creating content for leading technology companies, specializing in translating technical concepts for business audiences. You excel at research, interviewing subject matter experts, and structuring information for maximum clarity and impact. You believe that the best B2B content educates first and sells second, building trust through genuine expertise rather than marketing hype.\"",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crafting Effective Agents",
          "level": 1
        },
        {
          "title": "Practical Examples: Before and After",
          "level": 2
        },
        {
          "title": "Example 1: Content Creation Agent",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crafting Effective Agents",
            "level": 1
          },
          {
            "title": "Practical Examples: Before and After",
            "level": 2
          },
          {
            "title": "Example 1: Content Creation Agent",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crafting Effective Agents > Practical Examples: Before and After > Example 1: Content Creation Agent"
      },
      "enhanced_content": "Context: Changelog > Crafting Effective Agents > Practical Examples: Before and After > Example 1: Content Creation Agent\n\nrole: \"B2B Technology Content Strategist\"\ngoal: \"Create compelling, technically accurate content that explains complex topics in accessible language while driving reader engagement and supporting business objectives\"\nbackstory: \"You have spent a decade creating content for leading technology companies, specializing in translating technical concepts for business audiences. You excel at research, interviewing subject matter experts, and structuring information for maximum clarity and impact. You believe that the best B2B content educates first and sells second, building trust through genuine expertise rather than marketing hype.\"",
      "formatted_path": "Changelog > Crafting Effective Agents > Practical Examples: Before and After > Example 1: Content Creation Agent",
      "enhanced_text": "Context: Changelog > Crafting Effective Agents > Practical Examples: Before and After > Example 1: Content Creation Agent\n\nrole: \"B2B Technology Content Strategist\"\ngoal: \"Create compelling, technically accurate content that explains complex topics in accessible language while driving reader engagement and supporting business objectives\"\nbackstory: \"You have spent a decade creating content for leading technology companies, specializing in translating technical concepts for business audiences. You excel at research, interviewing subject matter experts, and structuring information for maximum clarity and impact. You believe that the best B2B content educates first and sells second, building trust through genuine expertise rather than marketing hype.\""
    },
    {
      "content": "role: \"Researcher\"\ngoal: \"Find information\"\nbackstory: \"You are good at finding information online.\"",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crafting Effective Agents",
          "level": 1
        },
        {
          "title": "Practical Examples: Before and After",
          "level": 2
        },
        {
          "title": "Example 2: Research Agent",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crafting Effective Agents",
            "level": 1
          },
          {
            "title": "Practical Examples: Before and After",
            "level": 2
          },
          {
            "title": "Example 2: Research Agent",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crafting Effective Agents > Practical Examples: Before and After > Example 2: Research Agent"
      },
      "enhanced_content": "Context: Changelog > Crafting Effective Agents > Practical Examples: Before and After > Example 2: Research Agent\n\nrole: \"Researcher\"\ngoal: \"Find information\"\nbackstory: \"You are good at finding information online.\"",
      "formatted_path": "Changelog > Crafting Effective Agents > Practical Examples: Before and After > Example 2: Research Agent",
      "enhanced_text": "Context: Changelog > Crafting Effective Agents > Practical Examples: Before and After > Example 2: Research Agent\n\nrole: \"Researcher\"\ngoal: \"Find information\"\nbackstory: \"You are good at finding information online.\""
    },
    {
      "content": "role: \"Academic Research Specialist in Emerging Technologies\"\ngoal: \"Discover and synthesize cutting-edge research, identifying key trends, methodologies, and findings while evaluating the quality and reliability of sources\"\nbackstory: \"With a background in both computer science and library science, you've mastered the art of digital research. You've worked with research teams at prestigious universities and know how to navigate academic databases, evaluate research quality, and synthesize findings across disciplines. You're methodical in your approach, always cross-referencing information and tracing claims to primary sources before drawing conclusions.\"",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crafting Effective Agents",
          "level": 1
        },
        {
          "title": "Practical Examples: Before and After",
          "level": 2
        },
        {
          "title": "Example 2: Research Agent",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crafting Effective Agents",
            "level": 1
          },
          {
            "title": "Practical Examples: Before and After",
            "level": 2
          },
          {
            "title": "Example 2: Research Agent",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crafting Effective Agents > Practical Examples: Before and After > Example 2: Research Agent"
      },
      "enhanced_content": "Context: Changelog > Crafting Effective Agents > Practical Examples: Before and After > Example 2: Research Agent\n\nrole: \"Academic Research Specialist in Emerging Technologies\"\ngoal: \"Discover and synthesize cutting-edge research, identifying key trends, methodologies, and findings while evaluating the quality and reliability of sources\"\nbackstory: \"With a background in both computer science and library science, you've mastered the art of digital research. You've worked with research teams at prestigious universities and know how to navigate academic databases, evaluate research quality, and synthesize findings across disciplines. You're methodical in your approach, always cross-referencing information and tracing claims to primary sources before drawing conclusions.\"",
      "formatted_path": "Changelog > Crafting Effective Agents > Practical Examples: Before and After > Example 2: Research Agent",
      "enhanced_text": "Context: Changelog > Crafting Effective Agents > Practical Examples: Before and After > Example 2: Research Agent\n\nrole: \"Academic Research Specialist in Emerging Technologies\"\ngoal: \"Discover and synthesize cutting-edge research, identifying key trends, methodologies, and findings while evaluating the quality and reliability of sources\"\nbackstory: \"With a background in both computer science and library science, you've mastered the art of digital research. You've worked with research teams at prestigious universities and know how to navigate academic databases, evaluate research quality, and synthesize findings across disciplines. You're methodical in your approach, always cross-referencing information and tracing claims to primary sources before drawing conclusions.\""
    },
    {
      "content": "While agent design is important, task design is critical for successful execution. Here are best practices for designing tasks that set your agents up for success:",
      "title": "Crafting Effective Tasks for Your Agents",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crafting Effective Agents",
          "level": 1
        },
        {
          "title": "Crafting Effective Tasks for Your Agents",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crafting Effective Agents",
            "level": 1
          },
          {
            "title": "Crafting Effective Tasks for Your Agents",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crafting Effective Agents > Crafting Effective Tasks for Your Agents"
      },
      "enhanced_content": "Context: Changelog > Crafting Effective Agents > Crafting Effective Tasks for Your Agents\n\n## Crafting Effective Tasks for Your Agents\n\nWhile agent design is important, task design is critical for successful execution. Here are best practices for designing tasks that set your agents up for success:",
      "formatted_path": "Changelog > Crafting Effective Agents > Crafting Effective Tasks for Your Agents",
      "enhanced_text": "Context: Changelog > Crafting Effective Agents > Crafting Effective Tasks for Your Agents\n\n Crafting Effective Tasks for Your Agents\n\nWhile agent design is important, task design is critical for successful execution. Here are best practices for designing tasks that set your agents up for success:\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "A well-designed task has two key components that serve different purposes:",
      "title": "The Anatomy of an Effective Task",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crafting Effective Agents",
          "level": 1
        },
        {
          "title": "Crafting Effective Tasks for Your Agents",
          "level": 2
        },
        {
          "title": "The Anatomy of an Effective Task",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crafting Effective Agents",
            "level": 1
          },
          {
            "title": "Crafting Effective Tasks for Your Agents",
            "level": 2
          },
          {
            "title": "The Anatomy of an Effective Task",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crafting Effective Agents > Crafting Effective Tasks for Your Agents > The Anatomy of an Effective Task"
      },
      "enhanced_content": "Context: Changelog > Crafting Effective Agents > Crafting Effective Tasks for Your Agents > The Anatomy of an Effective Task\n\n### The Anatomy of an Effective Task\n\nA well-designed task has two key components that serve different purposes:",
      "formatted_path": "Changelog > Crafting Effective Agents > Crafting Effective Tasks for Your Agents > The Anatomy of an Effective Task",
      "enhanced_text": "Context: Changelog > Crafting Effective Agents > Crafting Effective Tasks for Your Agents > The Anatomy of an Effective Task\n\n The Anatomy of an Effective Task\n\nA well-designed task has two key components that serve different purposes:"
    },
    {
      "content": "The description should focus on what to do and how to do it, including: Detailed instructions for execution Context and background information Scope and constraints Process steps to follow",
      "title": "Task Description: The Process",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crafting Effective Agents",
          "level": 1
        },
        {
          "title": "Crafting Effective Tasks for Your Agents",
          "level": 2
        },
        {
          "title": "The Anatomy of an Effective Task",
          "level": 3
        },
        {
          "title": "Task Description: The Process",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crafting Effective Agents",
            "level": 1
          },
          {
            "title": "Crafting Effective Tasks for Your Agents",
            "level": 2
          },
          {
            "title": "The Anatomy of an Effective Task",
            "level": 3
          },
          {
            "title": "Task Description: The Process",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crafting Effective Agents > Crafting Effective Tasks for Your Agents > The Anatomy of an Effective Task > Task Description: The Process"
      },
      "enhanced_content": "Context: Changelog > Crafting Effective Agents > Crafting Effective Tasks for Your Agents > The Anatomy of an Effective Task > Task Description: The Process\n\n#### Task Description: The Process\n\nThe description should focus on what to do and how to do it, including: Detailed instructions for execution Context and background information Scope and constraints Process steps to follow",
      "formatted_path": "Changelog > Crafting Effective Agents > Crafting Effective Tasks for Your Agents > The Anatomy of an Effective Task > Task Description: The Process",
      "enhanced_text": "Context: Changelog > Crafting Effective Agents > Crafting Effective Tasks for Your Agents > The Anatomy of an Effective Task > Task Description: The Process\n\n Task Description: The Process\n\nThe description should focus on what to do and how to do it, including: Detailed instructions for execution Context and background information Scope and constraints Process steps to follow\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "The expected output should define what the final result should look like: Format specifications (markdown, JSON, etc.) Structure requirements Quality criteria Examples of good outputs (when possible)",
      "title": "Expected Output: The Deliverable",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crafting Effective Agents",
          "level": 1
        },
        {
          "title": "Crafting Effective Tasks for Your Agents",
          "level": 2
        },
        {
          "title": "The Anatomy of an Effective Task",
          "level": 3
        },
        {
          "title": "Expected Output: The Deliverable",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crafting Effective Agents",
            "level": 1
          },
          {
            "title": "Crafting Effective Tasks for Your Agents",
            "level": 2
          },
          {
            "title": "The Anatomy of an Effective Task",
            "level": 3
          },
          {
            "title": "Expected Output: The Deliverable",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crafting Effective Agents > Crafting Effective Tasks for Your Agents > The Anatomy of an Effective Task > Expected Output: The Deliverable"
      },
      "enhanced_content": "Context: Changelog > Crafting Effective Agents > Crafting Effective Tasks for Your Agents > The Anatomy of an Effective Task > Expected Output: The Deliverable\n\n#### Expected Output: The Deliverable\n\nThe expected output should define what the final result should look like: Format specifications (markdown, JSON, etc.) Structure requirements Quality criteria Examples of good outputs (when possible)",
      "formatted_path": "Changelog > Crafting Effective Agents > Crafting Effective Tasks for Your Agents > The Anatomy of an Effective Task > Expected Output: The Deliverable",
      "enhanced_text": "Context: Changelog > Crafting Effective Agents > Crafting Effective Tasks for Your Agents > The Anatomy of an Effective Task > Expected Output: The Deliverable\n\n Expected Output: The Deliverable\n\nThe expected output should define what the final result should look like: Format specifications (markdown, JSON, etc.) Structure requirements Quality criteria Examples of good outputs (when possible)"
    },
    {
      "content": "task_description: \"Research market trends, analyze the data, and create a visualization.\"",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crafting Effective Agents",
          "level": 1
        },
        {
          "title": "Crafting Effective Tasks for Your Agents",
          "level": 2
        },
        {
          "title": "Task Design Best Practices",
          "level": 3
        },
        {
          "title": "1. Single Purpose, Single Output",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crafting Effective Agents",
            "level": 1
          },
          {
            "title": "Crafting Effective Tasks for Your Agents",
            "level": 2
          },
          {
            "title": "Task Design Best Practices",
            "level": 3
          },
          {
            "title": "1. Single Purpose, Single Output",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crafting Effective Agents > Crafting Effective Tasks for Your Agents > Task Design Best Practices > 1. Single Purpose, Single Output"
      },
      "enhanced_content": "Context: Changelog > Crafting Effective Agents > Crafting Effective Tasks for Your Agents > Task Design Best Practices > 1. Single Purpose, Single Output\n\ntask_description: \"Research market trends, analyze the data, and create a visualization.\"",
      "formatted_path": "Changelog > Crafting Effective Agents > Crafting Effective Tasks for Your Agents > Task Design Best Practices > 1. Single Purpose, Single Output",
      "enhanced_text": "Context: Changelog > Crafting Effective Agents > Crafting Effective Tasks for Your Agents > Task Design Best Practices > 1. Single Purpose, Single Output\n\ntask_description: \"Research market trends, analyze the data, and create a visualization.\""
    },
    {
      "content": "# Task 1\nresearch_task:\n  description: \"Research the top 5 market trends in the AI industry for 2024.\"\n  expected_output: \"A markdown list of the 5 trends with supporting evidence.\"\n\n# Task 2\nanalysis_task:\n  description: \"Analyze the identified trends to determine potential business impacts.\"\n  expected_output: \"A structured analysis with impact ratings (High/Medium/Low).\"\n\n# Task 3\nvisualization_task:\n  description: \"Create a visual representation of the analyzed trends.\"\n  expected_output: \"A description of a chart showing trends and their impact ratings.\"",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crafting Effective Agents",
          "level": 1
        },
        {
          "title": "Crafting Effective Tasks for Your Agents",
          "level": 2
        },
        {
          "title": "Task Design Best Practices",
          "level": 3
        },
        {
          "title": "1. Single Purpose, Single Output",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crafting Effective Agents",
            "level": 1
          },
          {
            "title": "Crafting Effective Tasks for Your Agents",
            "level": 2
          },
          {
            "title": "Task Design Best Practices",
            "level": 3
          },
          {
            "title": "1. Single Purpose, Single Output",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crafting Effective Agents > Crafting Effective Tasks for Your Agents > Task Design Best Practices > 1. Single Purpose, Single Output"
      },
      "enhanced_content": "Context: Changelog > Crafting Effective Agents > Crafting Effective Tasks for Your Agents > Task Design Best Practices > 1. Single Purpose, Single Output\n\n# Task 1\nresearch_task:\n  description: \"Research the top 5 market trends in the AI industry for 2024.\"\n  expected_output: \"A markdown list of the 5 trends with supporting evidence.\"\n\n# Task 2\nanalysis_task:\n  description: \"Analyze the identified trends to determine potential business impacts.\"\n  expected_output: \"A structured analysis with impact ratings (High/Medium/Low).\"\n\n# Task 3\nvisualization_task:\n  description: \"Create a visual representation of the analyzed trends.\"\n  expected_output: \"A description of a chart showing trends and their impact ratings.\"",
      "formatted_path": "Changelog > Crafting Effective Agents > Crafting Effective Tasks for Your Agents > Task Design Best Practices > 1. Single Purpose, Single Output",
      "enhanced_text": "Context: Changelog > Crafting Effective Agents > Crafting Effective Tasks for Your Agents > Task Design Best Practices > 1. Single Purpose, Single Output\n\n# Task 1\nresearch_task:\n  description: \"Research the top 5 market trends in the AI industry for 2024.\"\n  expected_output: \"A markdown list of the 5 trends with supporting evidence.\"\n\n# Task 2\nanalysis_task:\n  description: \"Analyze the identified trends to determine potential business impacts.\"\n  expected_output: \"A structured analysis with impact ratings (High/Medium/Low).\"\n\n# Task 3\nvisualization_task:\n  description: \"Create a visual representation of the analyzed trends.\"\n  expected_output: \"A description of a chart showing trends and their impact ratings.\""
    },
    {
      "content": "analysis_task:\n  description: >\n    Analyze the customer feedback data from the CSV file.\n    Focus on identifying recurring themes related to product usability.\n    Consider sentiment and frequency when determining importance.\n  expected_output: >\n    A markdown report with the following sections:\n    1. Executive summary (3-5 bullet points)\n    2. Top 3 usability issues with supporting data\n    3. Recommendations for improvement",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crafting Effective Agents",
          "level": 1
        },
        {
          "title": "Crafting Effective Tasks for Your Agents",
          "level": 2
        },
        {
          "title": "Task Design Best Practices",
          "level": 3
        },
        {
          "title": "2. Be Explicit About Inputs and Outputs",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crafting Effective Agents",
            "level": 1
          },
          {
            "title": "Crafting Effective Tasks for Your Agents",
            "level": 2
          },
          {
            "title": "Task Design Best Practices",
            "level": 3
          },
          {
            "title": "2. Be Explicit About Inputs and Outputs",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crafting Effective Agents > Crafting Effective Tasks for Your Agents > Task Design Best Practices > 2. Be Explicit About Inputs and Outputs"
      },
      "enhanced_content": "Context: Changelog > Crafting Effective Agents > Crafting Effective Tasks for Your Agents > Task Design Best Practices > 2. Be Explicit About Inputs and Outputs\n\nanalysis_task:\n  description: >\n    Analyze the customer feedback data from the CSV file.\n    Focus on identifying recurring themes related to product usability.\n    Consider sentiment and frequency when determining importance.\n  expected_output: >\n    A markdown report with the following sections:\n    1. Executive summary (3-5 bullet points)\n    2. Top 3 usability issues with supporting data\n    3. Recommendations for improvement",
      "formatted_path": "Changelog > Crafting Effective Agents > Crafting Effective Tasks for Your Agents > Task Design Best Practices > 2. Be Explicit About Inputs and Outputs",
      "enhanced_text": "Context: Changelog > Crafting Effective Agents > Crafting Effective Tasks for Your Agents > Task Design Best Practices > 2. Be Explicit About Inputs and Outputs\n\nanalysis_task:\n  description: >\n    Analyze the customer feedback data from the CSV file.\n    Focus on identifying recurring themes related to product usability.\n    Consider sentiment and frequency when determining importance.\n  expected_output: >\n    A markdown report with the following sections:\n    1. Executive summary (3-5 bullet points)\n    2. Top 3 usability issues with supporting data\n    3. Recommendations for improvement"
    },
    {
      "content": "competitor_analysis_task:\n  description: >\n    Analyze our three main competitors' pricing strategies.\n    This analysis will inform our upcoming pricing model revision.\n    Focus on identifying patterns in how they price premium features\n    and how they structure their tiered offerings.",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crafting Effective Agents",
          "level": 1
        },
        {
          "title": "Crafting Effective Tasks for Your Agents",
          "level": 2
        },
        {
          "title": "Task Design Best Practices",
          "level": 3
        },
        {
          "title": "3. Include Purpose and Context",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crafting Effective Agents",
            "level": 1
          },
          {
            "title": "Crafting Effective Tasks for Your Agents",
            "level": 2
          },
          {
            "title": "Task Design Best Practices",
            "level": 3
          },
          {
            "title": "3. Include Purpose and Context",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crafting Effective Agents > Crafting Effective Tasks for Your Agents > Task Design Best Practices > 3. Include Purpose and Context"
      },
      "enhanced_content": "Context: Changelog > Crafting Effective Agents > Crafting Effective Tasks for Your Agents > Task Design Best Practices > 3. Include Purpose and Context\n\ncompetitor_analysis_task:\n  description: >\n    Analyze our three main competitors' pricing strategies.\n    This analysis will inform our upcoming pricing model revision.\n    Focus on identifying patterns in how they price premium features\n    and how they structure their tiered offerings.",
      "formatted_path": "Changelog > Crafting Effective Agents > Crafting Effective Tasks for Your Agents > Task Design Best Practices > 3. Include Purpose and Context",
      "enhanced_text": "Context: Changelog > Crafting Effective Agents > Crafting Effective Tasks for Your Agents > Task Design Best Practices > 3. Include Purpose and Context\n\ncompetitor_analysis_task:\n  description: >\n    Analyze our three main competitors' pricing strategies.\n    This analysis will inform our upcoming pricing model revision.\n    Focus on identifying patterns in how they price premium features\n    and how they structure their tiered offerings."
    },
    {
      "content": "data_extraction_task:\n  description: \"Extract key metrics from the quarterly report.\"\n  expected_output: \"JSON object with the following keys: revenue, growth_rate, customer_acquisition_cost, and retention_rate.\"",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crafting Effective Agents",
          "level": 1
        },
        {
          "title": "Crafting Effective Tasks for Your Agents",
          "level": 2
        },
        {
          "title": "Task Design Best Practices",
          "level": 3
        },
        {
          "title": "4. Use Structured Output Tools",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crafting Effective Agents",
            "level": 1
          },
          {
            "title": "Crafting Effective Tasks for Your Agents",
            "level": 2
          },
          {
            "title": "Task Design Best Practices",
            "level": 3
          },
          {
            "title": "4. Use Structured Output Tools",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crafting Effective Agents > Crafting Effective Tasks for Your Agents > Task Design Best Practices > 4. Use Structured Output Tools"
      },
      "enhanced_content": "Context: Changelog > Crafting Effective Agents > Crafting Effective Tasks for Your Agents > Task Design Best Practices > 4. Use Structured Output Tools\n\ndata_extraction_task:\n  description: \"Extract key metrics from the quarterly report.\"\n  expected_output: \"JSON object with the following keys: revenue, growth_rate, customer_acquisition_cost, and retention_rate.\"",
      "formatted_path": "Changelog > Crafting Effective Agents > Crafting Effective Tasks for Your Agents > Task Design Best Practices > 4. Use Structured Output Tools",
      "enhanced_text": "Context: Changelog > Crafting Effective Agents > Crafting Effective Tasks for Your Agents > Task Design Best Practices > 4. Use Structured Output Tools\n\ndata_extraction_task:\n  description: \"Extract key metrics from the quarterly report.\"\n  expected_output: \"JSON object with the following keys: revenue, growth_rate, customer_acquisition_cost, and retention_rate.\""
    },
    {
      "content": "Based on lessons learned from real-world implementations, here are the most common pitfalls in agent and task design:",
      "title": "Common Mistakes to Avoid",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crafting Effective Agents",
          "level": 1
        },
        {
          "title": "Common Mistakes to Avoid",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crafting Effective Agents",
            "level": 1
          },
          {
            "title": "Common Mistakes to Avoid",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crafting Effective Agents > Common Mistakes to Avoid"
      },
      "enhanced_content": "Context: Changelog > Crafting Effective Agents > Common Mistakes to Avoid\n\n## Common Mistakes to Avoid\n\nBased on lessons learned from real-world implementations, here are the most common pitfalls in agent and task design:",
      "formatted_path": "Changelog > Crafting Effective Agents > Common Mistakes to Avoid",
      "enhanced_text": "Context: Changelog > Crafting Effective Agents > Common Mistakes to Avoid\n\n Common Mistakes to Avoid\n\nBased on lessons learned from real-world implementations, here are the most common pitfalls in agent and task design:"
    },
    {
      "content": "research_task:\n  description: \"Research AI trends.\"\n  expected_output: \"A report on AI trends.\"",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crafting Effective Agents",
          "level": 1
        },
        {
          "title": "Common Mistakes to Avoid",
          "level": 2
        },
        {
          "title": "1. Unclear Task Instructions",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crafting Effective Agents",
            "level": 1
          },
          {
            "title": "Common Mistakes to Avoid",
            "level": 2
          },
          {
            "title": "1. Unclear Task Instructions",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crafting Effective Agents > Common Mistakes to Avoid > 1. Unclear Task Instructions"
      },
      "enhanced_content": "Context: Changelog > Crafting Effective Agents > Common Mistakes to Avoid > 1. Unclear Task Instructions\n\nresearch_task:\n  description: \"Research AI trends.\"\n  expected_output: \"A report on AI trends.\"",
      "formatted_path": "Changelog > Crafting Effective Agents > Common Mistakes to Avoid > 1. Unclear Task Instructions",
      "enhanced_text": "Context: Changelog > Crafting Effective Agents > Common Mistakes to Avoid > 1. Unclear Task Instructions\n\nresearch_task:\n  description: \"Research AI trends.\"\n  expected_output: \"A report on AI trends.\""
    },
    {
      "content": "research_task:\n  description: >\n    Research the top emerging AI trends for 2024 with a focus on:\n    1. Enterprise adoption patterns\n    2. Technical breakthroughs in the past 6 months\n    3. Regulatory developments affecting implementation\n\n    For each trend, identify key companies, technologies, and potential business impacts.\n  expected_output: >\n    A comprehensive markdown report with:\n    - Executive summary (5 bullet points)\n    - 5-7 major trends with supporting evidence\n    - For each trend: definition, examples, and business implications\n    - References to authoritative sources",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crafting Effective Agents",
          "level": 1
        },
        {
          "title": "Common Mistakes to Avoid",
          "level": 2
        },
        {
          "title": "1. Unclear Task Instructions",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crafting Effective Agents",
            "level": 1
          },
          {
            "title": "Common Mistakes to Avoid",
            "level": 2
          },
          {
            "title": "1. Unclear Task Instructions",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crafting Effective Agents > Common Mistakes to Avoid > 1. Unclear Task Instructions"
      },
      "enhanced_content": "Context: Changelog > Crafting Effective Agents > Common Mistakes to Avoid > 1. Unclear Task Instructions\n\nresearch_task:\n  description: >\n    Research the top emerging AI trends for 2024 with a focus on:\n    1. Enterprise adoption patterns\n    2. Technical breakthroughs in the past 6 months\n    3. Regulatory developments affecting implementation\n\n    For each trend, identify key companies, technologies, and potential business impacts.\n  expected_output: >\n    A comprehensive markdown report with:\n    - Executive summary (5 bullet points)\n    - 5-7 major trends with supporting evidence\n    - For each trend: definition, examples, and business implications\n    - References to authoritative sources",
      "formatted_path": "Changelog > Crafting Effective Agents > Common Mistakes to Avoid > 1. Unclear Task Instructions",
      "enhanced_text": "Context: Changelog > Crafting Effective Agents > Common Mistakes to Avoid > 1. Unclear Task Instructions\n\nresearch_task:\n  description: >\n    Research the top emerging AI trends for 2024 with a focus on:\n    1. Enterprise adoption patterns\n    2. Technical breakthroughs in the past 6 months\n    3. Regulatory developments affecting implementation\n\n    For each trend, identify key companies, technologies, and potential business impacts.\n  expected_output: >\n    A comprehensive markdown report with:\n    - Executive summary (5 bullet points)\n    - 5-7 major trends with supporting evidence\n    - For each trend: definition, examples, and business implications\n    - References to authoritative sources"
    },
    {
      "content": "comprehensive_task:\n  description: \"Research market trends, analyze competitor strategies, create a marketing plan, and design a launch timeline.\"",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crafting Effective Agents",
          "level": 1
        },
        {
          "title": "Common Mistakes to Avoid",
          "level": 2
        },
        {
          "title": "2. \"God Tasks\" That Try to Do Too Much",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crafting Effective Agents",
            "level": 1
          },
          {
            "title": "Common Mistakes to Avoid",
            "level": 2
          },
          {
            "title": "2. \"God Tasks\" That Try to Do Too Much",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crafting Effective Agents > Common Mistakes to Avoid > 2. \"God Tasks\" That Try to Do Too Much"
      },
      "enhanced_content": "Context: Changelog > Crafting Effective Agents > Common Mistakes to Avoid > 2. \"God Tasks\" That Try to Do Too Much\n\ncomprehensive_task:\n  description: \"Research market trends, analyze competitor strategies, create a marketing plan, and design a launch timeline.\"",
      "formatted_path": "Changelog > Crafting Effective Agents > Common Mistakes to Avoid > 2. \"God Tasks\" That Try to Do Too Much",
      "enhanced_text": "Context: Changelog > Crafting Effective Agents > Common Mistakes to Avoid > 2. \"God Tasks\" That Try to Do Too Much\n\ncomprehensive_task:\n  description: \"Research market trends, analyze competitor strategies, create a marketing plan, and design a launch timeline.\""
    },
    {
      "content": "# Task 1: Research\nmarket_research_task:\n  description: \"Research current market trends in the SaaS project management space.\"\n  expected_output: \"A markdown summary of key market trends.\"\n\n# Task 2: Competitive Analysis\ncompetitor_analysis_task:\n  description: \"Analyze strategies of the top 3 competitors based on the market research.\"\n  expected_output: \"A comparison table of competitor strategies.\"\n  context: [market_research_task]\n\n# Continue with additional focused tasks...",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crafting Effective Agents",
          "level": 1
        },
        {
          "title": "Common Mistakes to Avoid",
          "level": 2
        },
        {
          "title": "2. \"God Tasks\" That Try to Do Too Much",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crafting Effective Agents",
            "level": 1
          },
          {
            "title": "Common Mistakes to Avoid",
            "level": 2
          },
          {
            "title": "2. \"God Tasks\" That Try to Do Too Much",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crafting Effective Agents > Common Mistakes to Avoid > 2. \"God Tasks\" That Try to Do Too Much"
      },
      "enhanced_content": "Context: Changelog > Crafting Effective Agents > Common Mistakes to Avoid > 2. \"God Tasks\" That Try to Do Too Much\n\n# Task 1: Research\nmarket_research_task:\n  description: \"Research current market trends in the SaaS project management space.\"\n  expected_output: \"A markdown summary of key market trends.\"\n\n# Task 2: Competitive Analysis\ncompetitor_analysis_task:\n  description: \"Analyze strategies of the top 3 competitors based on the market research.\"\n  expected_output: \"A comparison table of competitor strategies.\"\n  context: [market_research_task]\n\n# Continue with additional focused tasks...",
      "formatted_path": "Changelog > Crafting Effective Agents > Common Mistakes to Avoid > 2. \"God Tasks\" That Try to Do Too Much",
      "enhanced_text": "Context: Changelog > Crafting Effective Agents > Common Mistakes to Avoid > 2. \"God Tasks\" That Try to Do Too Much\n\n# Task 1: Research\nmarket_research_task:\n  description: \"Research current market trends in the SaaS project management space.\"\n  expected_output: \"A markdown summary of key market trends.\"\n\n# Task 2: Competitive Analysis\ncompetitor_analysis_task:\n  description: \"Analyze strategies of the top 3 competitors based on the market research.\"\n  expected_output: \"A comparison table of competitor strategies.\"\n  context: [market_research_task]\n\n# Continue with additional focused tasks..."
    },
    {
      "content": "analysis_task:\n  description: \"Analyze customer feedback to find areas of improvement.\"\n  expected_output: \"A marketing plan for the next quarter.\"",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crafting Effective Agents",
          "level": 1
        },
        {
          "title": "Common Mistakes to Avoid",
          "level": 2
        },
        {
          "title": "3. Misaligned Description and Expected Output",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crafting Effective Agents",
            "level": 1
          },
          {
            "title": "Common Mistakes to Avoid",
            "level": 2
          },
          {
            "title": "3. Misaligned Description and Expected Output",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crafting Effective Agents > Common Mistakes to Avoid > 3. Misaligned Description and Expected Output"
      },
      "enhanced_content": "Context: Changelog > Crafting Effective Agents > Common Mistakes to Avoid > 3. Misaligned Description and Expected Output\n\nanalysis_task:\n  description: \"Analyze customer feedback to find areas of improvement.\"\n  expected_output: \"A marketing plan for the next quarter.\"",
      "formatted_path": "Changelog > Crafting Effective Agents > Common Mistakes to Avoid > 3. Misaligned Description and Expected Output",
      "enhanced_text": "Context: Changelog > Crafting Effective Agents > Common Mistakes to Avoid > 3. Misaligned Description and Expected Output\n\nanalysis_task:\n  description: \"Analyze customer feedback to find areas of improvement.\"\n  expected_output: \"A marketing plan for the next quarter.\""
    },
    {
      "content": "analysis_task:\n  description: \"Analyze customer feedback to identify the top 3 areas for product improvement.\"\n  expected_output: \"A report listing the 3 priority improvement areas with supporting customer quotes and data points.\"",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crafting Effective Agents",
          "level": 1
        },
        {
          "title": "Common Mistakes to Avoid",
          "level": 2
        },
        {
          "title": "3. Misaligned Description and Expected Output",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crafting Effective Agents",
            "level": 1
          },
          {
            "title": "Common Mistakes to Avoid",
            "level": 2
          },
          {
            "title": "3. Misaligned Description and Expected Output",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crafting Effective Agents > Common Mistakes to Avoid > 3. Misaligned Description and Expected Output"
      },
      "enhanced_content": "Context: Changelog > Crafting Effective Agents > Common Mistakes to Avoid > 3. Misaligned Description and Expected Output\n\nanalysis_task:\n  description: \"Analyze customer feedback to identify the top 3 areas for product improvement.\"\n  expected_output: \"A report listing the 3 priority improvement areas with supporting customer quotes and data points.\"",
      "formatted_path": "Changelog > Crafting Effective Agents > Common Mistakes to Avoid > 3. Misaligned Description and Expected Output",
      "enhanced_text": "Context: Changelog > Crafting Effective Agents > Common Mistakes to Avoid > 3. Misaligned Description and Expected Output\n\nanalysis_task:\n  description: \"Analyze customer feedback to identify the top 3 areas for product improvement.\"\n  expected_output: \"A report listing the 3 priority improvement areas with supporting customer quotes and data points.\""
    },
    {
      "content": "**Problem:** Asking agents to execute tasks that you yourself don't fully understand. **Solution:** Try to perform the task manually first Document your process, decision points, and information sources Use this documentation as the basis for your task description",
      "title": "4. Not Understanding the Process Yourself",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crafting Effective Agents",
          "level": 1
        },
        {
          "title": "Common Mistakes to Avoid",
          "level": 2
        },
        {
          "title": "4. Not Understanding the Process Yourself",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crafting Effective Agents",
            "level": 1
          },
          {
            "title": "Common Mistakes to Avoid",
            "level": 2
          },
          {
            "title": "4. Not Understanding the Process Yourself",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crafting Effective Agents > Common Mistakes to Avoid > 4. Not Understanding the Process Yourself"
      },
      "enhanced_content": "Context: Changelog > Crafting Effective Agents > Common Mistakes to Avoid > 4. Not Understanding the Process Yourself\n\n### 4. Not Understanding the Process Yourself\n\n**Problem:** Asking agents to execute tasks that you yourself don't fully understand. **Solution:** Try to perform the task manually first Document your process, decision points, and information sources Use this documentation as the basis for your task description",
      "formatted_path": "Changelog > Crafting Effective Agents > Common Mistakes to Avoid > 4. Not Understanding the Process Yourself",
      "enhanced_text": "Context: Changelog > Crafting Effective Agents > Common Mistakes to Avoid > 4. Not Understanding the Process Yourself\n\n 4. Not Understanding the Process Yourself\n\n**Problem:** Asking agents to execute tasks that you yourself don't fully understand. **Solution:** Try to perform the task manually first Document your process, decision points, and information sources Use this documentation as the basis for your task description"
    },
    {
      "content": "**Problem:** Creating unnecessarily complex agent hierarchies where sequential processes would work better. **Solution:** Start with sequential processes and only move to hierarchical models when the workflow complexity truly requires it.",
      "title": "5. Premature Use of Hierarchical Structures",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crafting Effective Agents",
          "level": 1
        },
        {
          "title": "Common Mistakes to Avoid",
          "level": 2
        },
        {
          "title": "5. Premature Use of Hierarchical Structures",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crafting Effective Agents",
            "level": 1
          },
          {
            "title": "Common Mistakes to Avoid",
            "level": 2
          },
          {
            "title": "5. Premature Use of Hierarchical Structures",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crafting Effective Agents > Common Mistakes to Avoid > 5. Premature Use of Hierarchical Structures"
      },
      "enhanced_content": "Context: Changelog > Crafting Effective Agents > Common Mistakes to Avoid > 5. Premature Use of Hierarchical Structures\n\n### 5. Premature Use of Hierarchical Structures\n\n**Problem:** Creating unnecessarily complex agent hierarchies where sequential processes would work better. **Solution:** Start with sequential processes and only move to hierarchical models when the workflow complexity truly requires it.",
      "formatted_path": "Changelog > Crafting Effective Agents > Common Mistakes to Avoid > 5. Premature Use of Hierarchical Structures",
      "enhanced_text": "Context: Changelog > Crafting Effective Agents > Common Mistakes to Avoid > 5. Premature Use of Hierarchical Structures\n\n 5. Premature Use of Hierarchical Structures\n\n**Problem:** Creating unnecessarily complex agent hierarchies where sequential processes would work better. **Solution:** Start with sequential processes and only move to hierarchical models when the workflow complexity truly requires it."
    },
    {
      "content": "agent:\n  role: \"Business Analyst\"\n  goal: \"Analyze business data\"\n  backstory: \"You are good at business analysis.\"",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crafting Effective Agents",
          "level": 1
        },
        {
          "title": "Common Mistakes to Avoid",
          "level": 2
        },
        {
          "title": "6. Vague or Generic Agent Definitions",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crafting Effective Agents",
            "level": 1
          },
          {
            "title": "Common Mistakes to Avoid",
            "level": 2
          },
          {
            "title": "6. Vague or Generic Agent Definitions",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crafting Effective Agents > Common Mistakes to Avoid > 6. Vague or Generic Agent Definitions"
      },
      "enhanced_content": "Context: Changelog > Crafting Effective Agents > Common Mistakes to Avoid > 6. Vague or Generic Agent Definitions\n\nagent:\n  role: \"Business Analyst\"\n  goal: \"Analyze business data\"\n  backstory: \"You are good at business analysis.\"",
      "formatted_path": "Changelog > Crafting Effective Agents > Common Mistakes to Avoid > 6. Vague or Generic Agent Definitions",
      "enhanced_text": "Context: Changelog > Crafting Effective Agents > Common Mistakes to Avoid > 6. Vague or Generic Agent Definitions\n\nagent:\n  role: \"Business Analyst\"\n  goal: \"Analyze business data\"\n  backstory: \"You are good at business analysis.\""
    },
    {
      "content": "agent:\n  role: \"SaaS Metrics Specialist focusing on growth-stage startups\"\n  goal: \"Identify actionable insights from business data that can directly impact customer retention and revenue growth\"\n  backstory: \"With 10+ years analyzing SaaS business models, you've developed a keen eye for the metrics that truly matter for sustainable growth. You've helped numerous companies identify the leverage points that turned around their business trajectory. You believe in connecting data to specific, actionable recommendations rather than general observations.\"",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crafting Effective Agents",
          "level": 1
        },
        {
          "title": "Common Mistakes to Avoid",
          "level": 2
        },
        {
          "title": "6. Vague or Generic Agent Definitions",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crafting Effective Agents",
            "level": 1
          },
          {
            "title": "Common Mistakes to Avoid",
            "level": 2
          },
          {
            "title": "6. Vague or Generic Agent Definitions",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crafting Effective Agents > Common Mistakes to Avoid > 6. Vague or Generic Agent Definitions"
      },
      "enhanced_content": "Context: Changelog > Crafting Effective Agents > Common Mistakes to Avoid > 6. Vague or Generic Agent Definitions\n\nagent:\n  role: \"SaaS Metrics Specialist focusing on growth-stage startups\"\n  goal: \"Identify actionable insights from business data that can directly impact customer retention and revenue growth\"\n  backstory: \"With 10+ years analyzing SaaS business models, you've developed a keen eye for the metrics that truly matter for sustainable growth. You've helped numerous companies identify the leverage points that turned around their business trajectory. You believe in connecting data to specific, actionable recommendations rather than general observations.\"",
      "formatted_path": "Changelog > Crafting Effective Agents > Common Mistakes to Avoid > 6. Vague or Generic Agent Definitions",
      "enhanced_text": "Context: Changelog > Crafting Effective Agents > Common Mistakes to Avoid > 6. Vague or Generic Agent Definitions\n\nagent:\n  role: \"SaaS Metrics Specialist focusing on growth-stage startups\"\n  goal: \"Identify actionable insights from business data that can directly impact customer retention and revenue growth\"\n  backstory: \"With 10+ years analyzing SaaS business models, you've developed a keen eye for the metrics that truly matter for sustainable growth. You've helped numerous companies identify the leverage points that turned around their business trajectory. You believe in connecting data to specific, actionable recommendations rather than general observations.\""
    },
    {
      "content": "# Research Agent\nrole: \"Research Specialist for technical topics\"\ngoal: \"Gather comprehensive, accurate information from authoritative sources\"\nbackstory: \"You are a meticulous researcher with a background in library science...\"\n\n# Writer Agent\nrole: \"Technical Content Writer\"\ngoal: \"Transform research into engaging, clear content that educates and informs\"\nbackstory: \"You are an experienced writer who excels at explaining complex concepts...\"\n\n# Editor Agent\nrole: \"Content Quality Editor\"\ngoal: \"Ensure content is accurate, well-structured, and polished while maintaining consistency\"\nbackstory: \"With years of experience in publishing, you have a keen eye for detail...\"",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crafting Effective Agents",
          "level": 1
        },
        {
          "title": "Advanced Agent Design Strategies",
          "level": 2
        },
        {
          "title": "Designing for Collaboration",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crafting Effective Agents",
            "level": 1
          },
          {
            "title": "Advanced Agent Design Strategies",
            "level": 2
          },
          {
            "title": "Designing for Collaboration",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crafting Effective Agents > Advanced Agent Design Strategies > Designing for Collaboration"
      },
      "enhanced_content": "Context: Changelog > Crafting Effective Agents > Advanced Agent Design Strategies > Designing for Collaboration\n\n# Research Agent\nrole: \"Research Specialist for technical topics\"\ngoal: \"Gather comprehensive, accurate information from authoritative sources\"\nbackstory: \"You are a meticulous researcher with a background in library science...\"\n\n# Writer Agent\nrole: \"Technical Content Writer\"\ngoal: \"Transform research into engaging, clear content that educates and informs\"\nbackstory: \"You are an experienced writer who excels at explaining complex concepts...\"\n\n# Editor Agent\nrole: \"Content Quality Editor\"\ngoal: \"Ensure content is accurate, well-structured, and polished while maintaining consistency\"\nbackstory: \"With years of experience in publishing, you have a keen eye for detail...\"",
      "formatted_path": "Changelog > Crafting Effective Agents > Advanced Agent Design Strategies > Designing for Collaboration",
      "enhanced_text": "Context: Changelog > Crafting Effective Agents > Advanced Agent Design Strategies > Designing for Collaboration\n\n# Research Agent\nrole: \"Research Specialist for technical topics\"\ngoal: \"Gather comprehensive, accurate information from authoritative sources\"\nbackstory: \"You are a meticulous researcher with a background in library science...\"\n\n# Writer Agent\nrole: \"Technical Content Writer\"\ngoal: \"Transform research into engaging, clear content that educates and informs\"\nbackstory: \"You are an experienced writer who excels at explaining complex concepts...\"\n\n# Editor Agent\nrole: \"Content Quality Editor\"\ngoal: \"Ensure content is accurate, well-structured, and polished while maintaining consistency\"\nbackstory: \"With years of experience in publishing, you have a keen eye for detail...\""
    },
    {
      "content": "role: \"Data Analysis Specialist\"\ngoal: \"Derive meaningful insights from complex datasets through statistical analysis\"\nbackstory: \"With a background in data science, you excel at working with structured and unstructured data...\"\ntools: [PythonREPLTool, DataVisualizationTool, CSVAnalysisTool]",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crafting Effective Agents",
          "level": 1
        },
        {
          "title": "Advanced Agent Design Strategies",
          "level": 2
        },
        {
          "title": "Creating Specialized Tool Users",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crafting Effective Agents",
            "level": 1
          },
          {
            "title": "Advanced Agent Design Strategies",
            "level": 2
          },
          {
            "title": "Creating Specialized Tool Users",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crafting Effective Agents > Advanced Agent Design Strategies > Creating Specialized Tool Users"
      },
      "enhanced_content": "Context: Changelog > Crafting Effective Agents > Advanced Agent Design Strategies > Creating Specialized Tool Users\n\nrole: \"Data Analysis Specialist\"\ngoal: \"Derive meaningful insights from complex datasets through statistical analysis\"\nbackstory: \"With a background in data science, you excel at working with structured and unstructured data...\"\ntools: [PythonREPLTool, DataVisualizationTool, CSVAnalysisTool]",
      "formatted_path": "Changelog > Crafting Effective Agents > Advanced Agent Design Strategies > Creating Specialized Tool Users",
      "enhanced_text": "Context: Changelog > Crafting Effective Agents > Advanced Agent Design Strategies > Creating Specialized Tool Users\n\nrole: \"Data Analysis Specialist\"\ngoal: \"Derive meaningful insights from complex datasets through statistical analysis\"\nbackstory: \"With a background in data science, you excel at working with structured and unstructured data...\"\ntools: [PythonREPLTool, DataVisualizationTool, CSVAnalysisTool]"
    },
    {
      "content": "# For complex reasoning tasks\nanalyst:\n  role: \"Data Insights Analyst\"\n  goal: \"...\"\n  backstory: \"...\"\n  llm: openai/gpt-4o\n\n# For creative content\nwriter:\n  role: \"Creative Content Writer\"\n  goal: \"...\"\n  backstory: \"...\"\n  llm: anthropic/claude-3-opus",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crafting Effective Agents",
          "level": 1
        },
        {
          "title": "Advanced Agent Design Strategies",
          "level": 2
        },
        {
          "title": "Tailoring Agents to LLM Capabilities",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crafting Effective Agents",
            "level": 1
          },
          {
            "title": "Advanced Agent Design Strategies",
            "level": 2
          },
          {
            "title": "Tailoring Agents to LLM Capabilities",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crafting Effective Agents > Advanced Agent Design Strategies > Tailoring Agents to LLM Capabilities"
      },
      "enhanced_content": "Context: Changelog > Crafting Effective Agents > Advanced Agent Design Strategies > Tailoring Agents to LLM Capabilities\n\n# For complex reasoning tasks\nanalyst:\n  role: \"Data Insights Analyst\"\n  goal: \"...\"\n  backstory: \"...\"\n  llm: openai/gpt-4o\n\n# For creative content\nwriter:\n  role: \"Creative Content Writer\"\n  goal: \"...\"\n  backstory: \"...\"\n  llm: anthropic/claude-3-opus",
      "formatted_path": "Changelog > Crafting Effective Agents > Advanced Agent Design Strategies > Tailoring Agents to LLM Capabilities",
      "enhanced_text": "Context: Changelog > Crafting Effective Agents > Advanced Agent Design Strategies > Tailoring Agents to LLM Capabilities\n\n# For complex reasoning tasks\nanalyst:\n  role: \"Data Insights Analyst\"\n  goal: \"...\"\n  backstory: \"...\"\n  llm: openai/gpt-4o\n\n# For creative content\nwriter:\n  role: \"Creative Content Writer\"\n  goal: \"...\"\n  backstory: \"...\"\n  llm: anthropic/claude-3-opus"
    },
    {
      "content": "Agent design is often an iterative process. Here's a practical approach: **Start with a prototype**: Create an initial agent definition **Test with sample tasks**: Evaluate performance on representative tasks **Analyze outputs**: Identify strengths and weaknesses **Refine the definition**: Adjust role, goal, and backstory based on observations **Test in collaboration**: Evaluate how the agent performs in a crew setting",
      "title": "Testing and Iterating on Agent Design",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Crafting Effective Agents",
          "level": 1
        },
        {
          "title": "Testing and Iterating on Agent Design",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Crafting Effective Agents",
            "level": 1
          },
          {
            "title": "Testing and Iterating on Agent Design",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Crafting Effective Agents > Testing and Iterating on Agent Design"
      },
      "enhanced_content": "Context: Changelog > Crafting Effective Agents > Testing and Iterating on Agent Design\n\n## Testing and Iterating on Agent Design\n\nAgent design is often an iterative process. Here's a practical approach: **Start with a prototype**: Create an initial agent definition **Test with sample tasks**: Evaluate performance on representative tasks **Analyze outputs**: Identify strengths and weaknesses **Refine the definition**: Adjust role, goal, and backstory based on observations **Test in collaboration**: Evaluate how the agent performs in a crew setting",
      "formatted_path": "Changelog > Crafting Effective Agents > Testing and Iterating on Agent Design",
      "enhanced_text": "Context: Changelog > Crafting Effective Agents > Testing and Iterating on Agent Design\n\n Testing and Iterating on Agent Design\n\nAgent design is often an iterative process. Here's a practical approach: **Start with a prototype**: Create an initial agent definition **Test with sample tasks**: Evaluate performance on representative tasks **Analyze outputs**: Identify strengths and weaknesses **Refine the definition**: Adjust role, goal, and backstory based on observations **Test in collaboration**: Evaluate how the agent performs in a crew setting\n\nRelated sections:\n- \n"
    },
    {
      "content": "Source: https://docs.crewai.com/guides/concepts/evaluating-use-cases Learn how to assess your AI application needs and choose the right approach between Crews and Flows based on complexity and precision requirements.",
      "title": "Evaluating Use Cases for CrewAI",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Evaluating Use Cases for CrewAI",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Evaluating Use Cases for CrewAI",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Evaluating Use Cases for CrewAI"
      },
      "enhanced_content": "Context: Changelog > Evaluating Use Cases for CrewAI\n\n# Evaluating Use Cases for CrewAI\n\nSource: https://docs.crewai.com/guides/concepts/evaluating-use-cases Learn how to assess your AI application needs and choose the right approach between Crews and Flows based on complexity and precision requirements.",
      "formatted_path": "Changelog > Evaluating Use Cases for CrewAI",
      "enhanced_text": "Context: Changelog > Evaluating Use Cases for CrewAI\n\n Evaluating Use Cases for CrewAI\n\nSource: https://docs.crewai.com/guides/concepts/evaluating-use-cases Learn how to assess your AI application needs and choose the right approach between Crews and Flows based on complexity and precision requirements.\n\nRelated sections:\n- \n- \n- \n"
    },
    {
      "content": "When building AI applications with CrewAI, one of the most important decisions you'll make is choosing the right approach for your specific use case. Should you use a Crew? A Flow? A combination of both? This guide will help you evaluate your requirements and make informed architectural decisions. At the heart of this decision is understanding the relationship between **complexity** and **precision** in your application: This matrix helps visualize how different approaches align with varying requirements for complexity and precision. Let's explore what each quadrant means and how it guides your architectural choices.",
      "title": "Understanding the Decision Framework",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Evaluating Use Cases for CrewAI",
          "level": 1
        },
        {
          "title": "Understanding the Decision Framework",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Evaluating Use Cases for CrewAI",
            "level": 1
          },
          {
            "title": "Understanding the Decision Framework",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Evaluating Use Cases for CrewAI > Understanding the Decision Framework"
      },
      "enhanced_content": "Context: Changelog > Evaluating Use Cases for CrewAI > Understanding the Decision Framework\n\n## Understanding the Decision Framework\n\nWhen building AI applications with CrewAI, one of the most important decisions you'll make is choosing the right approach for your specific use case. Should you use a Crew? A Flow? A combination of both? This guide will help you evaluate your requirements and make informed architectural decisions. At the heart of this decision is understanding the relationship between **complexity** and **precision** in your application: This matrix helps visualize how different approaches align with varying requirements for complexity and precision. Let's explore what each quadrant means and how it guides your architectural choices.",
      "formatted_path": "Changelog > Evaluating Use Cases for CrewAI > Understanding the Decision Framework",
      "enhanced_text": "Context: Changelog > Evaluating Use Cases for CrewAI > Understanding the Decision Framework\n\n Understanding the Decision Framework\n\nWhen building AI applications with CrewAI, one of the most important decisions you'll make is choosing the right approach for your specific use case. Should you use a Crew? A Flow? A combination of both? This guide will help you evaluate your requirements and make informed architectural decisions. At the heart of this decision is understanding the relationship between **complexity** and **precision** in your application: This matrix helps visualize how different approaches align with varying requirements for complexity and precision. Let's explore what each quadrant means and how it guides your architectural choices.\n\nRelated sections:\n- \n"
    },
    {
      "content": "In the context of CrewAI applications, **complexity** refers to: The number of distinct steps or operations required The diversity of tasks that need to be performed The interdependencies between different components The need for conditional logic and branching The sophistication of the overall workflow",
      "title": "What is Complexity?",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Evaluating Use Cases for CrewAI",
          "level": 1
        },
        {
          "title": "The Complexity-Precision Matrix Explained",
          "level": 2
        },
        {
          "title": "What is Complexity?",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Evaluating Use Cases for CrewAI",
            "level": 1
          },
          {
            "title": "The Complexity-Precision Matrix Explained",
            "level": 2
          },
          {
            "title": "What is Complexity?",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Evaluating Use Cases for CrewAI > The Complexity-Precision Matrix Explained > What is Complexity?"
      },
      "enhanced_content": "Context: Changelog > Evaluating Use Cases for CrewAI > The Complexity-Precision Matrix Explained > What is Complexity?\n\n### What is Complexity?\n\nIn the context of CrewAI applications, **complexity** refers to: The number of distinct steps or operations required The diversity of tasks that need to be performed The interdependencies between different components The need for conditional logic and branching The sophistication of the overall workflow",
      "formatted_path": "Changelog > Evaluating Use Cases for CrewAI > The Complexity-Precision Matrix Explained > What is Complexity?",
      "enhanced_text": "Context: Changelog > Evaluating Use Cases for CrewAI > The Complexity-Precision Matrix Explained > What is Complexity?\n\n What is Complexity?\n\nIn the context of CrewAI applications, **complexity** refers to: The number of distinct steps or operations required The diversity of tasks that need to be performed The interdependencies between different components The need for conditional logic and branching The sophistication of the overall workflow"
    },
    {
      "content": "**Precision** in this context refers to: The accuracy required in the final output The need for structured, predictable results The importance of reproducibility The level of control needed over each step The tolerance for variation in outputs",
      "title": "What is Precision?",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Evaluating Use Cases for CrewAI",
          "level": 1
        },
        {
          "title": "The Complexity-Precision Matrix Explained",
          "level": 2
        },
        {
          "title": "What is Precision?",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Evaluating Use Cases for CrewAI",
            "level": 1
          },
          {
            "title": "The Complexity-Precision Matrix Explained",
            "level": 2
          },
          {
            "title": "What is Precision?",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Evaluating Use Cases for CrewAI > The Complexity-Precision Matrix Explained > What is Precision?"
      },
      "enhanced_content": "Context: Changelog > Evaluating Use Cases for CrewAI > The Complexity-Precision Matrix Explained > What is Precision?\n\n### What is Precision?\n\n**Precision** in this context refers to: The accuracy required in the final output The need for structured, predictable results The importance of reproducibility The level of control needed over each step The tolerance for variation in outputs",
      "formatted_path": "Changelog > Evaluating Use Cases for CrewAI > The Complexity-Precision Matrix Explained > What is Precision?",
      "enhanced_text": "Context: Changelog > Evaluating Use Cases for CrewAI > The Complexity-Precision Matrix Explained > What is Precision?\n\n What is Precision?\n\n**Precision** in this context refers to: The accuracy required in the final output The need for structured, predictable results The importance of reproducibility The level of control needed over each step The tolerance for variation in outputs"
    },
    {
      "content": "**Characteristics:** Simple, straightforward tasks Tolerance for some variation in outputs Limited number of steps Creative or exploratory applications **Recommended Approach:** Simple Crews with minimal agents **Example Use Cases:** Basic content generation Idea brainstorming Simple summarization tasks Creative writing assistance",
      "title": "1. Low Complexity, Low Precision",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Evaluating Use Cases for CrewAI",
          "level": 1
        },
        {
          "title": "The Complexity-Precision Matrix Explained",
          "level": 2
        },
        {
          "title": "The Four Quadrants",
          "level": 3
        },
        {
          "title": "1. Low Complexity, Low Precision",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Evaluating Use Cases for CrewAI",
            "level": 1
          },
          {
            "title": "The Complexity-Precision Matrix Explained",
            "level": 2
          },
          {
            "title": "The Four Quadrants",
            "level": 3
          },
          {
            "title": "1. Low Complexity, Low Precision",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Evaluating Use Cases for CrewAI > The Complexity-Precision Matrix Explained > The Four Quadrants > 1. Low Complexity, Low Precision"
      },
      "enhanced_content": "Context: Changelog > Evaluating Use Cases for CrewAI > The Complexity-Precision Matrix Explained > The Four Quadrants > 1. Low Complexity, Low Precision\n\n#### 1. Low Complexity, Low Precision\n\n**Characteristics:** Simple, straightforward tasks Tolerance for some variation in outputs Limited number of steps Creative or exploratory applications **Recommended Approach:** Simple Crews with minimal agents **Example Use Cases:** Basic content generation Idea brainstorming Simple summarization tasks Creative writing assistance",
      "formatted_path": "Changelog > Evaluating Use Cases for CrewAI > The Complexity-Precision Matrix Explained > The Four Quadrants > 1. Low Complexity, Low Precision",
      "enhanced_text": "Context: Changelog > Evaluating Use Cases for CrewAI > The Complexity-Precision Matrix Explained > The Four Quadrants > 1. Low Complexity, Low Precision\n\n 1. Low Complexity, Low Precision\n\n**Characteristics:** Simple, straightforward tasks Tolerance for some variation in outputs Limited number of steps Creative or exploratory applications **Recommended Approach:** Simple Crews with minimal agents **Example Use Cases:** Basic content generation Idea brainstorming Simple summarization tasks Creative writing assistance"
    },
    {
      "content": "**Characteristics:** Simple workflows that require exact, structured outputs Need for reproducible results Limited steps but high accuracy requirements Often involves data processing or transformation **Recommended Approach:** Flows with direct LLM calls or simple Crews with structured outputs **Example Use Cases:** Data extraction and transformation Form filling and validation Structured content generation (JSON, XML) Simple classification tasks",
      "title": "2. Low Complexity, High Precision",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Evaluating Use Cases for CrewAI",
          "level": 1
        },
        {
          "title": "The Complexity-Precision Matrix Explained",
          "level": 2
        },
        {
          "title": "The Four Quadrants",
          "level": 3
        },
        {
          "title": "2. Low Complexity, High Precision",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Evaluating Use Cases for CrewAI",
            "level": 1
          },
          {
            "title": "The Complexity-Precision Matrix Explained",
            "level": 2
          },
          {
            "title": "The Four Quadrants",
            "level": 3
          },
          {
            "title": "2. Low Complexity, High Precision",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Evaluating Use Cases for CrewAI > The Complexity-Precision Matrix Explained > The Four Quadrants > 2. Low Complexity, High Precision"
      },
      "enhanced_content": "Context: Changelog > Evaluating Use Cases for CrewAI > The Complexity-Precision Matrix Explained > The Four Quadrants > 2. Low Complexity, High Precision\n\n#### 2. Low Complexity, High Precision\n\n**Characteristics:** Simple workflows that require exact, structured outputs Need for reproducible results Limited steps but high accuracy requirements Often involves data processing or transformation **Recommended Approach:** Flows with direct LLM calls or simple Crews with structured outputs **Example Use Cases:** Data extraction and transformation Form filling and validation Structured content generation (JSON, XML) Simple classification tasks",
      "formatted_path": "Changelog > Evaluating Use Cases for CrewAI > The Complexity-Precision Matrix Explained > The Four Quadrants > 2. Low Complexity, High Precision",
      "enhanced_text": "Context: Changelog > Evaluating Use Cases for CrewAI > The Complexity-Precision Matrix Explained > The Four Quadrants > 2. Low Complexity, High Precision\n\n 2. Low Complexity, High Precision\n\n**Characteristics:** Simple workflows that require exact, structured outputs Need for reproducible results Limited steps but high accuracy requirements Often involves data processing or transformation **Recommended Approach:** Flows with direct LLM calls or simple Crews with structured outputs **Example Use Cases:** Data extraction and transformation Form filling and validation Structured content generation (JSON, XML) Simple classification tasks"
    },
    {
      "content": "**Characteristics:** Multi-stage processes with many steps Creative or exploratory outputs Complex interactions between components Tolerance for variation in final results **Recommended Approach:** Complex Crews with multiple specialized agents **Example Use Cases:** Research and analysis Content creation pipelines Exploratory data analysis Creative problem-solving",
      "title": "3. High Complexity, Low Precision",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Evaluating Use Cases for CrewAI",
          "level": 1
        },
        {
          "title": "The Complexity-Precision Matrix Explained",
          "level": 2
        },
        {
          "title": "The Four Quadrants",
          "level": 3
        },
        {
          "title": "3. High Complexity, Low Precision",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Evaluating Use Cases for CrewAI",
            "level": 1
          },
          {
            "title": "The Complexity-Precision Matrix Explained",
            "level": 2
          },
          {
            "title": "The Four Quadrants",
            "level": 3
          },
          {
            "title": "3. High Complexity, Low Precision",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Evaluating Use Cases for CrewAI > The Complexity-Precision Matrix Explained > The Four Quadrants > 3. High Complexity, Low Precision"
      },
      "enhanced_content": "Context: Changelog > Evaluating Use Cases for CrewAI > The Complexity-Precision Matrix Explained > The Four Quadrants > 3. High Complexity, Low Precision\n\n#### 3. High Complexity, Low Precision\n\n**Characteristics:** Multi-stage processes with many steps Creative or exploratory outputs Complex interactions between components Tolerance for variation in final results **Recommended Approach:** Complex Crews with multiple specialized agents **Example Use Cases:** Research and analysis Content creation pipelines Exploratory data analysis Creative problem-solving",
      "formatted_path": "Changelog > Evaluating Use Cases for CrewAI > The Complexity-Precision Matrix Explained > The Four Quadrants > 3. High Complexity, Low Precision",
      "enhanced_text": "Context: Changelog > Evaluating Use Cases for CrewAI > The Complexity-Precision Matrix Explained > The Four Quadrants > 3. High Complexity, Low Precision\n\n 3. High Complexity, Low Precision\n\n**Characteristics:** Multi-stage processes with many steps Creative or exploratory outputs Complex interactions between components Tolerance for variation in final results **Recommended Approach:** Complex Crews with multiple specialized agents **Example Use Cases:** Research and analysis Content creation pipelines Exploratory data analysis Creative problem-solving"
    },
    {
      "content": "**Characteristics:** Complex workflows requiring structured outputs Multiple interdependent steps with strict accuracy requirements Need for both sophisticated processing and precise results Often mission-critical applications **Recommended Approach:** Flows orchestrating multiple Crews with validation steps **Example Use Cases:** Enterprise decision support systems Complex data processing pipelines Multi-stage document processing Regulated industry applications",
      "title": "4. High Complexity, High Precision",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Evaluating Use Cases for CrewAI",
          "level": 1
        },
        {
          "title": "The Complexity-Precision Matrix Explained",
          "level": 2
        },
        {
          "title": "The Four Quadrants",
          "level": 3
        },
        {
          "title": "4. High Complexity, High Precision",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Evaluating Use Cases for CrewAI",
            "level": 1
          },
          {
            "title": "The Complexity-Precision Matrix Explained",
            "level": 2
          },
          {
            "title": "The Four Quadrants",
            "level": 3
          },
          {
            "title": "4. High Complexity, High Precision",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Evaluating Use Cases for CrewAI > The Complexity-Precision Matrix Explained > The Four Quadrants > 4. High Complexity, High Precision"
      },
      "enhanced_content": "Context: Changelog > Evaluating Use Cases for CrewAI > The Complexity-Precision Matrix Explained > The Four Quadrants > 4. High Complexity, High Precision\n\n#### 4. High Complexity, High Precision\n\n**Characteristics:** Complex workflows requiring structured outputs Multiple interdependent steps with strict accuracy requirements Need for both sophisticated processing and precise results Often mission-critical applications **Recommended Approach:** Flows orchestrating multiple Crews with validation steps **Example Use Cases:** Enterprise decision support systems Complex data processing pipelines Multi-stage document processing Regulated industry applications",
      "formatted_path": "Changelog > Evaluating Use Cases for CrewAI > The Complexity-Precision Matrix Explained > The Four Quadrants > 4. High Complexity, High Precision",
      "enhanced_text": "Context: Changelog > Evaluating Use Cases for CrewAI > The Complexity-Precision Matrix Explained > The Four Quadrants > 4. High Complexity, High Precision\n\n 4. High Complexity, High Precision\n\n**Characteristics:** Complex workflows requiring structured outputs Multiple interdependent steps with strict accuracy requirements Need for both sophisticated processing and precise results Often mission-critical applications **Recommended Approach:** Flows orchestrating multiple Crews with validation steps **Example Use Cases:** Enterprise decision support systems Complex data processing pipelines Multi-stage document processing Regulated industry applications"
    },
    {
      "content": "# Example: Research Crew for market analysis\nfrom crewai import Agent, Crew, Process, Task\n\n# Create specialized agents\nresearcher = Agent(\n    role=\"Market Research Specialist\",\n    goal=\"Find comprehensive market data on emerging technologies\",\n    backstory=\"You are an expert at discovering market trends and gathering data.\"\n)\n\nanalyst = Agent(\n    role=\"Market Analyst\",\n    goal=\"Analyze market data and identify key opportunities\",\n    backstory=\"You excel at interpreting market data and spotting valuable insights.\"\n)\n\n# Define their tasks\nresearch_task = Task(\n    description=\"Research the current market landscape for AI-powered healthcare solutions\",\n    expected_output=\"Comprehensive market data including key players, market size, and growth trends\",\n    agent=researcher\n)\n\nanalysis_task = Task(\n    description=\"Analyze the market data and identify the top 3 investment opportunities\",\n    expected_output=\"Analysis report with 3 recommended investment opportunities and rationale\",\n    agent=analyst,\n    context=[research_task]\n)\n\n# Create the crew\nmarket_analysis_crew = Crew(\n    agents=[researcher, analyst],\n    tasks=[research_task, analysis_task],\n    process=Process.sequential,\n    verbose=True\n)\n\n# Run the crew\nresult = market_analysis_crew.kickoff()",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Evaluating Use Cases for CrewAI",
          "level": 1
        },
        {
          "title": "Choosing Between Crews and Flows",
          "level": 2
        },
        {
          "title": "When to Choose Crews",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Evaluating Use Cases for CrewAI",
            "level": 1
          },
          {
            "title": "Choosing Between Crews and Flows",
            "level": 2
          },
          {
            "title": "When to Choose Crews",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Evaluating Use Cases for CrewAI > Choosing Between Crews and Flows > When to Choose Crews"
      },
      "enhanced_content": "Context: Changelog > Evaluating Use Cases for CrewAI > Choosing Between Crews and Flows > When to Choose Crews\n\n# Example: Research Crew for market analysis\nfrom crewai import Agent, Crew, Process, Task\n\n# Create specialized agents\nresearcher = Agent(\n    role=\"Market Research Specialist\",\n    goal=\"Find comprehensive market data on emerging technologies\",\n    backstory=\"You are an expert at discovering market trends and gathering data.\"\n)\n\nanalyst = Agent(\n    role=\"Market Analyst\",\n    goal=\"Analyze market data and identify key opportunities\",\n    backstory=\"You excel at interpreting market data and spotting valuable insights.\"\n)\n\n# Define their tasks\nresearch_task = Task(\n    description=\"Research the current market landscape for AI-powered healthcare solutions\",\n    expected_output=\"Comprehensive market data including key players, market size, and growth trends\",\n    agent=researcher\n)\n\nanalysis_task = Task(\n    description=\"Analyze the market data and identify the top 3 investment opportunities\",\n    expected_output=\"Analysis report with 3 recommended investment opportunities and rationale\",\n    agent=analyst,\n    context=[research_task]\n)\n\n# Create the crew\nmarket_analysis_crew = Crew(\n    agents=[researcher, analyst],\n    tasks=[research_task, analysis_task],\n    process=Process.sequential,\n    verbose=True\n)\n\n# Run the crew\nresult = market_analysis_crew.kickoff()",
      "formatted_path": "Changelog > Evaluating Use Cases for CrewAI > Choosing Between Crews and Flows > When to Choose Crews",
      "enhanced_text": "Context: Changelog > Evaluating Use Cases for CrewAI > Choosing Between Crews and Flows > When to Choose Crews\n\n# Example: Research Crew for market analysis\nfrom crewai import Agent, Crew, Process, Task\n\n# Create specialized agents\nresearcher = Agent(\n    role=\"Market Research Specialist\",\n    goal=\"Find comprehensive market data on emerging technologies\",\n    backstory=\"You are an expert at discovering market trends and gathering data.\"\n)\n\nanalyst = Agent(\n    role=\"Market Analyst\",\n    goal=\"Analyze market data and identify key opportunities\",\n    backstory=\"You excel at interpreting market data and spotting valuable insights.\"\n)\n\n# Define their tasks\nresearch_task = Task(\n    description=\"Research the current market landscape for AI-powered healthcare solutions\",\n    expected_output=\"Comprehensive market data including key players, market size, and growth trends\",\n    agent=researcher\n)\n\nanalysis_task = Task(\n    description=\"Analyze the market data and identify the top 3 investment opportunities\",\n    expected_output=\"Analysis report with 3 recommended investment opportunities and rationale\",\n    agent=analyst,\n    context=[research_task]\n)\n\n# Create the crew\nmarket_analysis_crew = Crew(\n    agents=[researcher, analyst],\n    tasks=[research_task, analysis_task],\n    process=Process.sequential,\n    verbose=True\n)\n\n# Run the crew\nresult = market_analysis_crew.kickoff()"
    },
    {
      "content": "# Example: Customer Support Flow with structured processing\nfrom crewai.flow.flow import Flow, listen, router, start\nfrom pydantic import BaseModel\nfrom typing import List, Dict\n\n# Define structured state\nclass SupportTicketState(BaseModel):\n    ticket_id: str = \"\"\n    customer_name: str = \"\"\n    issue_description: str = \"\"\n    category: str = \"\"\n    priority: str = \"medium\"\n    resolution: str = \"\"\n    satisfaction_score: int = 0\n\nclass CustomerSupportFlow(Flow[SupportTicketState]):\n    @start()\n    def receive_ticket(self):\n        # In a real app, this might come from an API\n        self.state.ticket_id = \"TKT-12345\"\n        self.state.customer_name = \"Alex Johnson\"\n        self.state.issue_description = \"Unable to access premium features after payment\"\n        return \"Ticket received\"\n\n    @listen(receive_ticket)\n    def categorize_ticket(self, _):\n        # Use a direct LLM call for categorization\n        from crewai import LLM\n        llm = LLM(model=\"openai/gpt-4o-mini\")\n\n        prompt = f\"\"\"\n        Categorize the following customer support issue into one of these categories:\n        - Billing\n        - Account Access\n        - Technical Issue\n        - Feature Request\n        - Other\n\n        Issue: {self.state.issue_description}\n\n        Return only the category name.\n        \"\"\"\n\n        self.state.category = llm.call(prompt).strip()\n        return self.state.category\n\n    @router(categorize_ticket)\n    def route_by_category(self, category):\n        # Route to different handlers based on category\n        return category.lower().replace(\" \", \"_\")\n\n    @listen(\"billing\")\n    def handle_billing_issue(self):\n        # Handle billing-specific logic\n        self.state.priority = \"high\"\n        # More billing-specific processing...\n        return \"Billing issue handled\"\n\n    @listen(\"account_access\")\n    def handle_access_issue(self):\n        # Handle access-specific logic\n        self.state.priority = \"high\"\n        # More access-specific processing...\n        return \"Access issue handled\"\n\n    # Additional category handlers...\n\n    @listen(\"billing\", \"account_access\", \"technical_issue\", \"feature_request\", \"other\")\n    def resolve_ticket(self, resolution_info):\n        # Final resolution step\n        self.state.resolution = f\"Issue resolved: {resolution_info}\"\n        return self.state.resolution\n\n# Run the flow\nsupport_flow = CustomerSupportFlow()\nresult = support_flow.kickoff()",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Evaluating Use Cases for CrewAI",
          "level": 1
        },
        {
          "title": "Choosing Between Crews and Flows",
          "level": 2
        },
        {
          "title": "When to Choose Flows",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Evaluating Use Cases for CrewAI",
            "level": 1
          },
          {
            "title": "Choosing Between Crews and Flows",
            "level": 2
          },
          {
            "title": "When to Choose Flows",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Evaluating Use Cases for CrewAI > Choosing Between Crews and Flows > When to Choose Flows"
      },
      "enhanced_content": "Context: Changelog > Evaluating Use Cases for CrewAI > Choosing Between Crews and Flows > When to Choose Flows\n\n# Example: Customer Support Flow with structured processing\nfrom crewai.flow.flow import Flow, listen, router, start\nfrom pydantic import BaseModel\nfrom typing import List, Dict\n\n# Define structured state\nclass SupportTicketState(BaseModel):\n    ticket_id: str = \"\"\n    customer_name: str = \"\"\n    issue_description: str = \"\"\n    category: str = \"\"\n    priority: str = \"medium\"\n    resolution: str = \"\"\n    satisfaction_score: int = 0\n\nclass CustomerSupportFlow(Flow[SupportTicketState]):\n    @start()\n    def receive_ticket(self):\n        # In a real app, this might come from an API\n        self.state.ticket_id = \"TKT-12345\"\n        self.state.customer_name = \"Alex Johnson\"\n        self.state.issue_description = \"Unable to access premium features after payment\"\n        return \"Ticket received\"\n\n    @listen(receive_ticket)\n    def categorize_ticket(self, _):\n        # Use a direct LLM call for categorization\n        from crewai import LLM\n        llm = LLM(model=\"openai/gpt-4o-mini\")\n\n        prompt = f\"\"\"\n        Categorize the following customer support issue into one of these categories:\n        - Billing\n        - Account Access\n        - Technical Issue\n        - Feature Request\n        - Other\n\n        Issue: {self.state.issue_description}\n\n        Return only the category name.\n        \"\"\"\n\n        self.state.category = llm.call(prompt).strip()\n        return self.state.category\n\n    @router(categorize_ticket)\n    def route_by_category(self, category):\n        # Route to different handlers based on category\n        return category.lower().replace(\" \", \"_\")\n\n    @listen(\"billing\")\n    def handle_billing_issue(self):\n        # Handle billing-specific logic\n        self.state.priority = \"high\"\n        # More billing-specific processing...\n        return \"Billing issue handled\"\n\n    @listen(\"account_access\")\n    def handle_access_issue(self):\n        # Handle access-specific logic\n        self.state.priority = \"high\"\n        # More access-specific processing...\n        return \"Access issue handled\"\n\n    # Additional category handlers...\n\n    @listen(\"billing\", \"account_access\", \"technical_issue\", \"feature_request\", \"other\")\n    def resolve_ticket(self, resolution_info):\n        # Final resolution step\n        self.state.resolution = f\"Issue resolved: {resolution_info}\"\n        return self.state.resolution\n\n# Run the flow\nsupport_flow = CustomerSupportFlow()\nresult = support_flow.kickoff()",
      "formatted_path": "Changelog > Evaluating Use Cases for CrewAI > Choosing Between Crews and Flows > When to Choose Flows",
      "enhanced_text": "Context: Changelog > Evaluating Use Cases for CrewAI > Choosing Between Crews and Flows > When to Choose Flows\n\n# Example: Customer Support Flow with structured processing\nfrom crewai.flow.flow import Flow, listen, router, start\nfrom pydantic import BaseModel\nfrom typing import List, Dict\n\n# Define structured state\nclass SupportTicketState(BaseModel):\n    ticket_id: str = \"\"\n    customer_name: str = \"\"\n    issue_description: str = \"\"\n    category: str = \"\"\n    priority: str = \"medium\"\n    resolution: str = \"\"\n    satisfaction_score: int = 0\n\nclass CustomerSupportFlow(Flow[SupportTicketState]):\n    @start()\n    def receive_ticket(self):\n        # In a real app, this might come from an API\n        self.state.ticket_id = \"TKT-12345\"\n        self.state.customer_name = \"Alex Johnson\"\n        self.state.issue_description = \"Unable to access premium features after payment\"\n        return \"Ticket received\"\n\n    @listen(receive_ticket)\n    def categorize_ticket(self, _):\n        # Use a direct LLM call for categorization\n        from crewai import LLM\n        llm = LLM(model=\"openai/gpt-4o-mini\")\n\n        prompt = f\"\"\"\n        Categorize the following customer support issue into one of these categories:\n        - Billing\n        - Account Access\n        - Technical Issue\n        - Feature Request\n        - Other\n\n        Issue: {self.state.issue_description}\n\n        Return only the category name.\n        \"\"\"\n\n        self.state.category = llm.call(prompt).strip()\n        return self.state.category\n\n    @router(categorize_ticket)\n    def route_by_category(self, category):\n        # Route to different handlers based on category\n        return category.lower().replace(\" \", \"_\")\n\n    @listen(\"billing\")\n    def handle_billing_issue(self):\n        # Handle billing-specific logic\n        self.state.priority = \"high\"\n        # More billing-specific processing...\n        return \"Billing issue handled\"\n\n    @listen(\"account_access\")\n    def handle_access_issue(self):\n        # Handle access-specific logic\n        self.state.priority = \"high\"\n        # More access-specific processing...\n        return \"Access issue handled\"\n\n    # Additional category handlers...\n\n    @listen(\"billing\", \"account_access\", \"technical_issue\", \"feature_request\", \"other\")\n    def resolve_ticket(self, resolution_info):\n        # Final resolution step\n        self.state.resolution = f\"Issue resolved: {resolution_info}\"\n        return self.state.resolution\n\n# Run the flow\nsupport_flow = CustomerSupportFlow()\nresult = support_flow.kickoff()"
    },
    {
      "content": "# Example: Content Production Pipeline combining Crews and Flows\nfrom crewai.flow.flow import Flow, listen, start\nfrom crewai import Agent, Crew, Process, Task\nfrom pydantic import BaseModel\nfrom typing import List, Dict\n\nclass ContentState(BaseModel):\n    topic: str = \"\"\n    target_audience: str = \"\"\n    content_type: str = \"\"\n    outline: Dict = {}\n    draft_content: str = \"\"\n    final_content: str = \"\"\n    seo_score: int = 0\n\nclass ContentProductionFlow(Flow[ContentState]):\n    @start()\n    def initialize_project(self):\n        # Set initial parameters\n        self.state.topic = \"Sustainable Investing\"\n        self.state.target_audience = \"Millennial Investors\"\n        self.state.content_type = \"Blog Post\"\n        return \"Project initialized\"\n\n    @listen(initialize_project)\n    def create_outline(self, _):\n        # Use a research crew to create an outline\n        researcher = Agent(\n            role=\"Content Researcher\",\n            goal=f\"Research {self.state.topic} for {self.state.target_audience}\",\n            backstory=\"You are an expert researcher with deep knowledge of content creation.\"\n        )\n\n        outliner = Agent(\n            role=\"Content Strategist\",\n            goal=f\"Create an engaging outline for a {self.state.content_type}\",\n            backstory=\"You excel at structuring content for maximum engagement.\"\n        )\n\n        research_task = Task(\n            description=f\"Research {self.state.topic} focusing on what would interest {self.state.target_audience}\",\n            expected_output=\"Comprehensive research notes with key points and statistics\",\n            agent=researcher\n        )\n\n        outline_task = Task(\n            description=f\"Create an outline for a {self.state.content_type} about {self.state.topic}\",\n            expected_output=\"Detailed content outline with sections and key points\",\n            agent=outliner,\n            context=[research_task]\n        )\n\n        outline_crew = Crew(\n            agents=[researcher, outliner],\n            tasks=[research_task, outline_task],\n            process=Process.sequential,\n            verbose=True\n        )\n\n        # Run the crew and store the result\n        result = outline_crew.kickoff()\n\n        # Parse the outline (in a real app, you might use a more robust parsing approach)\n        import json\n        try:\n            self.state.outline = json.loads(result.raw)\n        except:\n            # Fallback if not valid JSON\n            self.state.outline = {\"sections\": result.raw}\n\n        return \"Outline created\"\n\n    @listen(create_outline)\n    def write_content(self, _):\n        # Use a writing crew to create the content\n        writer = Agent(\n            role=\"Content Writer\",\n            goal=f\"Write engaging content for {self.state.target_audience}\",\n            backstory=\"You are a skilled writer who creates compelling content.\"\n        )\n\n        editor = Agent(\n            role=\"Content Editor\",\n            goal=\"Ensure content is polished, accurate, and engaging\",\n            backstory=\"You have a keen eye for detail and a talent for improving content.\"\n        )\n\n        writing_task = Task(\n            description=f\"Write a {self.state.content_type} about {self.state.topic} following this outline: {self.state.outline}\",\n            expected_output=\"Complete draft content in markdown format\",\n            agent=writer\n        )\n\n        editing_task = Task(\n            description=\"Edit and improve the draft content for clarity, engagement, and accuracy\",\n            expected_output=\"Polished final content in markdown format\",\n            agent=editor,\n            context=[writing_task]\n        )\n\n        writing_crew = Crew(\n            agents=[writer, editor],\n            tasks=[writing_task, editing_task],\n            process=Process.sequential,\n            verbose=True\n        )\n\n        # Run the crew and store the result\n        result = writing_crew.kickoff()\n        self.state.final_content = result.raw\n\n        return \"Content created\"\n\n    @listen(write_content)\n    def optimize_for_seo(self, _):\n        # Use a direct LLM call for SEO optimization\n        from crewai import LLM\n        llm = LLM(model=\"openai/gpt-4o-mini\")\n\n        prompt = f\"\"\"\n        Analyze this content for SEO effectiveness for the keyword \"{self.state.topic}\".\n        Rate it on a scale of 1-100 and provide 3 specific recommendations for improvement.\n\n        Content: {self.state.final_content[:1000]}... (truncated for brevity)\n\n        Format your response as JSON with the following structure:\n        {{\n            \"score\": 85,\n            \"recommendations\": [\n                \"Recommendation 1\",\n                \"Recommendation 2\",\n                \"Recommendation 3\"\n            ]\n        }}\n        \"\"\"\n\n        seo_analysis = llm.call(prompt)\n\n        # Parse the SEO analysis\n        import json\n        try:\n            analysis = json.loads(seo_analysis)\n            self.state.seo_score = analysis.get(\"score\", 0)\n            return analysis\n        except:\n            self.state.seo_score = 50\n            return {\"score\": 50, \"recommendations\": [\"Unable to parse SEO analysis\"]}\n\n# Run the flow\ncontent_flow = ContentProductionFlow()\nresult = content_flow.kickoff()",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Evaluating Use Cases for CrewAI",
          "level": 1
        },
        {
          "title": "Choosing Between Crews and Flows",
          "level": 2
        },
        {
          "title": "When to Combine Crews and Flows",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Evaluating Use Cases for CrewAI",
            "level": 1
          },
          {
            "title": "Choosing Between Crews and Flows",
            "level": 2
          },
          {
            "title": "When to Combine Crews and Flows",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Evaluating Use Cases for CrewAI > Choosing Between Crews and Flows > When to Combine Crews and Flows"
      },
      "enhanced_content": "Context: Changelog > Evaluating Use Cases for CrewAI > Choosing Between Crews and Flows > When to Combine Crews and Flows\n\n# Example: Content Production Pipeline combining Crews and Flows\nfrom crewai.flow.flow import Flow, listen, start\nfrom crewai import Agent, Crew, Process, Task\nfrom pydantic import BaseModel\nfrom typing import List, Dict\n\nclass ContentState(BaseModel):\n    topic: str = \"\"\n    target_audience: str = \"\"\n    content_type: str = \"\"\n    outline: Dict = {}\n    draft_content: str = \"\"\n    final_content: str = \"\"\n    seo_score: int = 0\n\nclass ContentProductionFlow(Flow[ContentState]):\n    @start()\n    def initialize_project(self):\n        # Set initial parameters\n        self.state.topic = \"Sustainable Investing\"\n        self.state.target_audience = \"Millennial Investors\"\n        self.state.content_type = \"Blog Post\"\n        return \"Project initialized\"\n\n    @listen(initialize_project)\n    def create_outline(self, _):\n        # Use a research crew to create an outline\n        researcher = Agent(\n            role=\"Content Researcher\",\n            goal=f\"Research {self.state.topic} for {self.state.target_audience}\",\n            backstory=\"You are an expert researcher with deep knowledge of content creation.\"\n        )\n\n        outliner = Agent(\n            role=\"Content Strategist\",\n            goal=f\"Create an engaging outline for a {self.state.content_type}\",\n            backstory=\"You excel at structuring content for maximum engagement.\"\n        )\n\n        research_task = Task(\n            description=f\"Research {self.state.topic} focusing on what would interest {self.state.target_audience}\",\n            expected_output=\"Comprehensive research notes with key points and statistics\",\n            agent=researcher\n        )\n\n        outline_task = Task(\n            description=f\"Create an outline for a {self.state.content_type} about {self.state.topic}\",\n            expected_output=\"Detailed content outline with sections and key points\",\n            agent=outliner,\n            context=[research_task]\n        )\n\n        outline_crew = Crew(\n            agents=[researcher, outliner],\n            tasks=[research_task, outline_task],\n            process=Process.sequential,\n            verbose=True\n        )\n\n        # Run the crew and store the result\n        result = outline_crew.kickoff()\n\n        # Parse the outline (in a real app, you might use a more robust parsing approach)\n        import json\n        try:\n            self.state.outline = json.loads(result.raw)\n        except:\n            # Fallback if not valid JSON\n            self.state.outline = {\"sections\": result.raw}\n\n        return \"Outline created\"\n\n    @listen(create_outline)\n    def write_content(self, _):\n        # Use a writing crew to create the content\n        writer = Agent(\n            role=\"Content Writer\",\n            goal=f\"Write engaging content for {self.state.target_audience}\",\n            backstory=\"You are a skilled writer who creates compelling content.\"\n        )\n\n        editor = Agent(\n            role=\"Content Editor\",\n            goal=\"Ensure content is polished, accurate, and engaging\",\n            backstory=\"You have a keen eye for detail and a talent for improving content.\"\n        )\n\n        writing_task = Task(\n            description=f\"Write a {self.state.content_type} about {self.state.topic} following this outline: {self.state.outline}\",\n            expected_output=\"Complete draft content in markdown format\",\n            agent=writer\n        )\n\n        editing_task = Task(\n            description=\"Edit and improve the draft content for clarity, engagement, and accuracy\",\n            expected_output=\"Polished final content in markdown format\",\n            agent=editor,\n            context=[writing_task]\n        )\n\n        writing_crew = Crew(\n            agents=[writer, editor],\n            tasks=[writing_task, editing_task],\n            process=Process.sequential,\n            verbose=True\n        )\n\n        # Run the crew and store the result\n        result = writing_crew.kickoff()\n        self.state.final_content = result.raw\n\n        return \"Content created\"\n\n    @listen(write_content)\n    def optimize_for_seo(self, _):\n        # Use a direct LLM call for SEO optimization\n        from crewai import LLM\n        llm = LLM(model=\"openai/gpt-4o-mini\")\n\n        prompt = f\"\"\"\n        Analyze this content for SEO effectiveness for the keyword \"{self.state.topic}\".\n        Rate it on a scale of 1-100 and provide 3 specific recommendations for improvement.\n\n        Content: {self.state.final_content[:1000]}... (truncated for brevity)\n\n        Format your response as JSON with the following structure:\n        {{\n            \"score\": 85,\n            \"recommendations\": [\n                \"Recommendation 1\",\n                \"Recommendation 2\",\n                \"Recommendation 3\"\n            ]\n        }}\n        \"\"\"\n\n        seo_analysis = llm.call(prompt)\n\n        # Parse the SEO analysis\n        import json\n        try:\n            analysis = json.loads(seo_analysis)\n            self.state.seo_score = analysis.get(\"score\", 0)\n            return analysis\n        except:\n            self.state.seo_score = 50\n            return {\"score\": 50, \"recommendations\": [\"Unable to parse SEO analysis\"]}\n\n# Run the flow\ncontent_flow = ContentProductionFlow()\nresult = content_flow.kickoff()",
      "formatted_path": "Changelog > Evaluating Use Cases for CrewAI > Choosing Between Crews and Flows > When to Combine Crews and Flows",
      "enhanced_text": "Context: Changelog > Evaluating Use Cases for CrewAI > Choosing Between Crews and Flows > When to Combine Crews and Flows\n\n# Example: Content Production Pipeline combining Crews and Flows\nfrom crewai.flow.flow import Flow, listen, start\nfrom crewai import Agent, Crew, Process, Task\nfrom pydantic import BaseModel\nfrom typing import List, Dict\n\nclass ContentState(BaseModel):\n    topic: str = \"\"\n    target_audience: str = \"\"\n    content_type: str = \"\"\n    outline: Dict = {}\n    draft_content: str = \"\"\n    final_content: str = \"\"\n    seo_score: int = 0\n\nclass ContentProductionFlow(Flow[ContentState]):\n    @start()\n    def initialize_project(self):\n        # Set initial parameters\n        self.state.topic = \"Sustainable Investing\"\n        self.state.target_audience = \"Millennial Investors\"\n        self.state.content_type = \"Blog Post\"\n        return \"Project initialized\"\n\n    @listen(initialize_project)\n    def create_outline(self, _):\n        # Use a research crew to create an outline\n        researcher = Agent(\n            role=\"Content Researcher\",\n            goal=f\"Research {self.state.topic} for {self.state.target_audience}\",\n            backstory=\"You are an expert researcher with deep knowledge of content creation.\"\n        )\n\n        outliner = Agent(\n            role=\"Content Strategist\",\n            goal=f\"Create an engaging outline for a {self.state.content_type}\",\n            backstory=\"You excel at structuring content for maximum engagement.\"\n        )\n\n        research_task = Task(\n            description=f\"Research {self.state.topic} focusing on what would interest {self.state.target_audience}\",\n            expected_output=\"Comprehensive research notes with key points and statistics\",\n            agent=researcher\n        )\n\n        outline_task = Task(\n            description=f\"Create an outline for a {self.state.content_type} about {self.state.topic}\",\n            expected_output=\"Detailed content outline with sections and key points\",\n            agent=outliner,\n            context=[research_task]\n        )\n\n        outline_crew = Crew(\n            agents=[researcher, outliner],\n            tasks=[research_task, outline_task],\n            process=Process.sequential,\n            verbose=True\n        )\n\n        # Run the crew and store the result\n        result = outline_crew.kickoff()\n\n        # Parse the outline (in a real app, you might use a more robust parsing approach)\n        import json\n        try:\n            self.state.outline = json.loads(result.raw)\n        except:\n            # Fallback if not valid JSON\n            self.state.outline = {\"sections\": result.raw}\n\n        return \"Outline created\"\n\n    @listen(create_outline)\n    def write_content(self, _):\n        # Use a writing crew to create the content\n        writer = Agent(\n            role=\"Content Writer\",\n            goal=f\"Write engaging content for {self.state.target_audience}\",\n            backstory=\"You are a skilled writer who creates compelling content.\"\n        )\n\n        editor = Agent(\n            role=\"Content Editor\",\n            goal=\"Ensure content is polished, accurate, and engaging\",\n            backstory=\"You have a keen eye for detail and a talent for improving content.\"\n        )\n\n        writing_task = Task(\n            description=f\"Write a {self.state.content_type} about {self.state.topic} following this outline: {self.state.outline}\",\n            expected_output=\"Complete draft content in markdown format\",\n            agent=writer\n        )\n\n        editing_task = Task(\n            description=\"Edit and improve the draft content for clarity, engagement, and accuracy\",\n            expected_output=\"Polished final content in markdown format\",\n            agent=editor,\n            context=[writing_task]\n        )\n\n        writing_crew = Crew(\n            agents=[writer, editor],\n            tasks=[writing_task, editing_task],\n            process=Process.sequential,\n            verbose=True\n        )\n\n        # Run the crew and store the result\n        result = writing_crew.kickoff()\n        self.state.final_content = result.raw\n\n        return \"Content created\"\n\n    @listen(write_content)\n    def optimize_for_seo(self, _):\n        # Use a direct LLM call for SEO optimization\n        from crewai import LLM\n        llm = LLM(model=\"openai/gpt-4o-mini\")\n\n        prompt = f\"\"\"\n        Analyze this content for SEO effectiveness for the keyword \"{self.state.topic}\".\n        Rate it on a scale of 1-100 and provide 3 specific recommendations for improvement.\n\n        Content: {self.state.final_content[:1000]}... (truncated for brevity)\n\n        Format your response as JSON with the following structure:\n        {{\n            \"score\": 85,\n            \"recommendations\": [\n                \"Recommendation 1\",\n                \"Recommendation 2\",\n                \"Recommendation 3\"\n            ]\n        }}\n        \"\"\"\n\n        seo_analysis = llm.call(prompt)\n\n        # Parse the SEO analysis\n        import json\n        try:\n            analysis = json.loads(seo_analysis)\n            self.state.seo_score = analysis.get(\"score\", 0)\n            return analysis\n        except:\n            self.state.seo_score = 50\n            return {\"score\": 50, \"recommendations\": [\"Unable to parse SEO analysis\"]}\n\n# Run the flow\ncontent_flow = ContentProductionFlow()\nresult = content_flow.kickoff()"
    },
    {
      "content": "To determine the right approach for your specific use case, follow this step-by-step evaluation framework:",
      "title": "Practical Evaluation Framework",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Evaluating Use Cases for CrewAI",
          "level": 1
        },
        {
          "title": "Practical Evaluation Framework",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Evaluating Use Cases for CrewAI",
            "level": 1
          },
          {
            "title": "Practical Evaluation Framework",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Evaluating Use Cases for CrewAI > Practical Evaluation Framework"
      },
      "enhanced_content": "Context: Changelog > Evaluating Use Cases for CrewAI > Practical Evaluation Framework\n\n## Practical Evaluation Framework\n\nTo determine the right approach for your specific use case, follow this step-by-step evaluation framework:",
      "formatted_path": "Changelog > Evaluating Use Cases for CrewAI > Practical Evaluation Framework",
      "enhanced_text": "Context: Changelog > Evaluating Use Cases for CrewAI > Practical Evaluation Framework\n\n Practical Evaluation Framework\n\nTo determine the right approach for your specific use case, follow this step-by-step evaluation framework:"
    },
    {
      "content": "Rate your application's complexity on a scale of 1-10 by considering: **Number of steps**: How many distinct operations are required? 1-3 steps: Low complexity (1-3) 4-7 steps: Medium complexity (4-7) 8+ steps: High complexity (8-10) **Interdependencies**: How interconnected are the different parts? Few dependencies: Low complexity (1-3) Some dependencies: Medium complexity (4-7) Many complex dependencies: High complexity (8-10) **Conditional logic**: How much branching and decision-making is needed? Linear process: Low complexity (1-3) Some branching: Medium complexity (4-7) Complex decision trees: High complexity (8-10) **Domain knowledge**: How specialized is the knowledge required? General knowledge: Low complexity (1-3) Some specialized knowledge: Medium complexity (4-7) Deep expertise in multiple domains: High complexity (8-10) Calculate your average score to determine overall complexity.",
      "title": "Step 1: Assess Complexity",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Evaluating Use Cases for CrewAI",
          "level": 1
        },
        {
          "title": "Practical Evaluation Framework",
          "level": 2
        },
        {
          "title": "Step 1: Assess Complexity",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Evaluating Use Cases for CrewAI",
            "level": 1
          },
          {
            "title": "Practical Evaluation Framework",
            "level": 2
          },
          {
            "title": "Step 1: Assess Complexity",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Evaluating Use Cases for CrewAI > Practical Evaluation Framework > Step 1: Assess Complexity"
      },
      "enhanced_content": "Context: Changelog > Evaluating Use Cases for CrewAI > Practical Evaluation Framework > Step 1: Assess Complexity\n\n### Step 1: Assess Complexity\n\nRate your application's complexity on a scale of 1-10 by considering: **Number of steps**: How many distinct operations are required? 1-3 steps: Low complexity (1-3) 4-7 steps: Medium complexity (4-7) 8+ steps: High complexity (8-10) **Interdependencies**: How interconnected are the different parts? Few dependencies: Low complexity (1-3) Some dependencies: Medium complexity (4-7) Many complex dependencies: High complexity (8-10) **Conditional logic**: How much branching and decision-making is needed? Linear process: Low complexity (1-3) Some branching: Medium complexity (4-7) Complex decision trees: High complexity (8-10) **Domain knowledge**: How specialized is the knowledge required? General knowledge: Low complexity (1-3) Some specialized knowledge: Medium complexity (4-7) Deep expertise in multiple domains: High complexity (8-10) Calculate your average score to determine overall complexity.",
      "formatted_path": "Changelog > Evaluating Use Cases for CrewAI > Practical Evaluation Framework > Step 1: Assess Complexity",
      "enhanced_text": "Context: Changelog > Evaluating Use Cases for CrewAI > Practical Evaluation Framework > Step 1: Assess Complexity\n\n Step 1: Assess Complexity\n\nRate your application's complexity on a scale of 1-10 by considering: **Number of steps**: How many distinct operations are required? 1-3 steps: Low complexity (1-3) 4-7 steps: Medium complexity (4-7) 8+ steps: High complexity (8-10) **Interdependencies**: How interconnected are the different parts? Few dependencies: Low complexity (1-3) Some dependencies: Medium complexity (4-7) Many complex dependencies: High complexity (8-10) **Conditional logic**: How much branching and decision-making is needed? Linear process: Low complexity (1-3) Some branching: Medium complexity (4-7) Complex decision trees: High complexity (8-10) **Domain knowledge**: How specialized is the knowledge required? General knowledge: Low complexity (1-3) Some specialized knowledge: Medium complexity (4-7) Deep expertise in multiple domains: High complexity (8-10) Calculate your average score to determine overall complexity."
    },
    {
      "content": "Rate your precision requirements on a scale of 1-10 by considering: **Output structure**: How structured must the output be? Free-form text: Low precision (1-3) Semi-structured: Medium precision (4-7) Strictly formatted (JSON, XML): High precision (8-10) **Accuracy needs**: How important is factual accuracy? Creative content: Low precision (1-3) Informational content: Medium precision (4-7) Critical information: High precision (8-10) **Reproducibility**: How consistent must results be across runs? Variation acceptable: Low precision (1-3) Some consistency needed: Medium precision (4-7) Exact reproducibility required: High precision (8-10) **Error tolerance**: What is the impact of errors? Low impact: Low precision (1-3) Moderate impact: Medium precision (4-7) High impact: High precision (8-10) Calculate your average score to determine overall precision requirements.",
      "title": "Step 2: Assess Precision Requirements",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Evaluating Use Cases for CrewAI",
          "level": 1
        },
        {
          "title": "Practical Evaluation Framework",
          "level": 2
        },
        {
          "title": "Step 2: Assess Precision Requirements",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Evaluating Use Cases for CrewAI",
            "level": 1
          },
          {
            "title": "Practical Evaluation Framework",
            "level": 2
          },
          {
            "title": "Step 2: Assess Precision Requirements",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Evaluating Use Cases for CrewAI > Practical Evaluation Framework > Step 2: Assess Precision Requirements"
      },
      "enhanced_content": "Context: Changelog > Evaluating Use Cases for CrewAI > Practical Evaluation Framework > Step 2: Assess Precision Requirements\n\n### Step 2: Assess Precision Requirements\n\nRate your precision requirements on a scale of 1-10 by considering: **Output structure**: How structured must the output be? Free-form text: Low precision (1-3) Semi-structured: Medium precision (4-7) Strictly formatted (JSON, XML): High precision (8-10) **Accuracy needs**: How important is factual accuracy? Creative content: Low precision (1-3) Informational content: Medium precision (4-7) Critical information: High precision (8-10) **Reproducibility**: How consistent must results be across runs? Variation acceptable: Low precision (1-3) Some consistency needed: Medium precision (4-7) Exact reproducibility required: High precision (8-10) **Error tolerance**: What is the impact of errors? Low impact: Low precision (1-3) Moderate impact: Medium precision (4-7) High impact: High precision (8-10) Calculate your average score to determine overall precision requirements.",
      "formatted_path": "Changelog > Evaluating Use Cases for CrewAI > Practical Evaluation Framework > Step 2: Assess Precision Requirements",
      "enhanced_text": "Context: Changelog > Evaluating Use Cases for CrewAI > Practical Evaluation Framework > Step 2: Assess Precision Requirements\n\n Step 2: Assess Precision Requirements\n\nRate your precision requirements on a scale of 1-10 by considering: **Output structure**: How structured must the output be? Free-form text: Low precision (1-3) Semi-structured: Medium precision (4-7) Strictly formatted (JSON, XML): High precision (8-10) **Accuracy needs**: How important is factual accuracy? Creative content: Low precision (1-3) Informational content: Medium precision (4-7) Critical information: High precision (8-10) **Reproducibility**: How consistent must results be across runs? Variation acceptable: Low precision (1-3) Some consistency needed: Medium precision (4-7) Exact reproducibility required: High precision (8-10) **Error tolerance**: What is the impact of errors? Low impact: Low precision (1-3) Moderate impact: Medium precision (4-7) High impact: High precision (8-10) Calculate your average score to determine overall precision requirements.\n\nRelated sections:\n- \n- \n- \n- \n"
    },
    {
      "content": "Plot your complexity and precision scores on the matrix: **Low Complexity (1-4), Low Precision (1-4)**: Simple Crews **Low Complexity (1-4), High Precision (5-10)**: Flows with direct LLM calls **High Complexity (5-10), Low Precision (1-4)**: Complex Crews **High Complexity (5-10), High Precision (5-10)**: Flows orchestrating Crews",
      "title": "Step 3: Map to the Matrix",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Evaluating Use Cases for CrewAI",
          "level": 1
        },
        {
          "title": "Practical Evaluation Framework",
          "level": 2
        },
        {
          "title": "Step 3: Map to the Matrix",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Evaluating Use Cases for CrewAI",
            "level": 1
          },
          {
            "title": "Practical Evaluation Framework",
            "level": 2
          },
          {
            "title": "Step 3: Map to the Matrix",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Evaluating Use Cases for CrewAI > Practical Evaluation Framework > Step 3: Map to the Matrix"
      },
      "enhanced_content": "Context: Changelog > Evaluating Use Cases for CrewAI > Practical Evaluation Framework > Step 3: Map to the Matrix\n\n### Step 3: Map to the Matrix\n\nPlot your complexity and precision scores on the matrix: **Low Complexity (1-4), Low Precision (1-4)**: Simple Crews **Low Complexity (1-4), High Precision (5-10)**: Flows with direct LLM calls **High Complexity (5-10), Low Precision (1-4)**: Complex Crews **High Complexity (5-10), High Precision (5-10)**: Flows orchestrating Crews",
      "formatted_path": "Changelog > Evaluating Use Cases for CrewAI > Practical Evaluation Framework > Step 3: Map to the Matrix",
      "enhanced_text": "Context: Changelog > Evaluating Use Cases for CrewAI > Practical Evaluation Framework > Step 3: Map to the Matrix\n\n Step 3: Map to the Matrix\n\nPlot your complexity and precision scores on the matrix: **Low Complexity (1-4), Low Precision (1-4)**: Simple Crews **Low Complexity (1-4), High Precision (5-10)**: Flows with direct LLM calls **High Complexity (5-10), Low Precision (1-4)**: Complex Crews **High Complexity (5-10), High Precision (5-10)**: Flows orchestrating Crews"
    },
    {
      "content": "Beyond complexity and precision, consider: **Development time**: Crews are often faster to prototype **Maintenance needs**: Flows provide better long-term maintainability **Team expertise**: Consider your team's familiarity with different approaches **Scalability requirements**: Flows typically scale better for complex applications **Integration needs**: Consider how the solution will integrate with existing systems",
      "title": "Step 4: Consider Additional Factors",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Evaluating Use Cases for CrewAI",
          "level": 1
        },
        {
          "title": "Practical Evaluation Framework",
          "level": 2
        },
        {
          "title": "Step 4: Consider Additional Factors",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Evaluating Use Cases for CrewAI",
            "level": 1
          },
          {
            "title": "Practical Evaluation Framework",
            "level": 2
          },
          {
            "title": "Step 4: Consider Additional Factors",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Evaluating Use Cases for CrewAI > Practical Evaluation Framework > Step 4: Consider Additional Factors"
      },
      "enhanced_content": "Context: Changelog > Evaluating Use Cases for CrewAI > Practical Evaluation Framework > Step 4: Consider Additional Factors\n\n### Step 4: Consider Additional Factors\n\nBeyond complexity and precision, consider: **Development time**: Crews are often faster to prototype **Maintenance needs**: Flows provide better long-term maintainability **Team expertise**: Consider your team's familiarity with different approaches **Scalability requirements**: Flows typically scale better for complex applications **Integration needs**: Consider how the solution will integrate with existing systems",
      "formatted_path": "Changelog > Evaluating Use Cases for CrewAI > Practical Evaluation Framework > Step 4: Consider Additional Factors",
      "enhanced_text": "Context: Changelog > Evaluating Use Cases for CrewAI > Practical Evaluation Framework > Step 4: Consider Additional Factors\n\n Step 4: Consider Additional Factors\n\nBeyond complexity and precision, consider: **Development time**: Crews are often faster to prototype **Maintenance needs**: Flows provide better long-term maintainability **Team expertise**: Consider your team's familiarity with different approaches **Scalability requirements**: Flows typically scale better for complex applications **Integration needs**: Consider how the solution will integrate with existing systems"
    },
    {
      "content": "Source: https://docs.crewai.com/guides/crews/first-crew Step-by-step tutorial to create a collaborative AI team that works together to solve complex problems.",
      "title": "Build Your First Crew",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Crew",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Crew",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Crew"
      },
      "enhanced_content": "Context: Changelog > Build Your First Crew\n\n# Build Your First Crew\n\nSource: https://docs.crewai.com/guides/crews/first-crew Step-by-step tutorial to create a collaborative AI team that works together to solve complex problems.",
      "formatted_path": "Changelog > Build Your First Crew",
      "enhanced_text": "Context: Changelog > Build Your First Crew\n\n Build Your First Crew\n\nSource: https://docs.crewai.com/guides/crews/first-crew Step-by-step tutorial to create a collaborative AI team that works together to solve complex problems."
    },
    {
      "content": "Imagine having a team of specialized AI agents working together seamlessly to solve complex problems, each contributing their unique skills to achieve a common goal. This is the power of CrewAI - a framework that enables you to create collaborative AI systems that can accomplish tasks far beyond what a single AI could achieve alone. In this guide, we'll walk through creating a research crew that will help us research and analyze a topic, then create a comprehensive report. This practical example demonstrates how AI agents can collaborate to accomplish complex tasks, but it's just the beginning of what's possible with CrewAI.",
      "title": "Unleashing the Power of Collaborative AI",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Crew",
          "level": 1
        },
        {
          "title": "Unleashing the Power of Collaborative AI",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Crew",
            "level": 1
          },
          {
            "title": "Unleashing the Power of Collaborative AI",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Crew > Unleashing the Power of Collaborative AI"
      },
      "enhanced_content": "Context: Changelog > Build Your First Crew > Unleashing the Power of Collaborative AI\n\n## Unleashing the Power of Collaborative AI\n\nImagine having a team of specialized AI agents working together seamlessly to solve complex problems, each contributing their unique skills to achieve a common goal. This is the power of CrewAI - a framework that enables you to create collaborative AI systems that can accomplish tasks far beyond what a single AI could achieve alone. In this guide, we'll walk through creating a research crew that will help us research and analyze a topic, then create a comprehensive report. This practical example demonstrates how AI agents can collaborate to accomplish complex tasks, but it's just the beginning of what's possible with CrewAI.",
      "formatted_path": "Changelog > Build Your First Crew > Unleashing the Power of Collaborative AI",
      "enhanced_text": "Context: Changelog > Build Your First Crew > Unleashing the Power of Collaborative AI\n\n Unleashing the Power of Collaborative AI\n\nImagine having a team of specialized AI agents working together seamlessly to solve complex problems, each contributing their unique skills to achieve a common goal. This is the power of CrewAI - a framework that enables you to create collaborative AI systems that can accomplish tasks far beyond what a single AI could achieve alone. In this guide, we'll walk through creating a research crew that will help us research and analyze a topic, then create a comprehensive report. This practical example demonstrates how AI agents can collaborate to accomplish complex tasks, but it's just the beginning of what's possible with CrewAI."
    },
    {
      "content": "crewai create crew research_crew\ncd research_crew",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Crew",
          "level": 1
        },
        {
          "title": "Step 1: Create a New CrewAI Project",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Crew",
            "level": 1
          },
          {
            "title": "Step 1: Create a New CrewAI Project",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Crew > Step 1: Create a New CrewAI Project"
      },
      "enhanced_content": "Context: Changelog > Build Your First Crew > Step 1: Create a New CrewAI Project\n\ncrewai create crew research_crew\ncd research_crew",
      "formatted_path": "Changelog > Build Your First Crew > Step 1: Create a New CrewAI Project",
      "enhanced_text": "Context: Changelog > Build Your First Crew > Step 1: Create a New CrewAI Project\n\ncrewai create crew research_crew\ncd research_crew"
    },
    {
      "content": "research_crew/\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 .env\n\u2514\u2500\u2500 src/\n    \u2514\u2500\u2500 research_crew/\n        \u251c\u2500\u2500 __init__.py\n        \u251c\u2500\u2500 main.py\n        \u251c\u2500\u2500 crew.py\n        \u251c\u2500\u2500 tools/\n        \u2502   \u251c\u2500\u2500 custom_tool.py\n        \u2502   \u2514\u2500\u2500 __init__.py\n        \u2514\u2500\u2500 config/\n            \u251c\u2500\u2500 agents.yaml\n            \u2514\u2500\u2500 tasks.yaml",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Crew",
          "level": 1
        },
        {
          "title": "Step 2: Explore the Project Structure",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Crew",
            "level": 1
          },
          {
            "title": "Step 2: Explore the Project Structure",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Crew > Step 2: Explore the Project Structure"
      },
      "enhanced_content": "Context: Changelog > Build Your First Crew > Step 2: Explore the Project Structure\n\nresearch_crew/\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 .env\n\u2514\u2500\u2500 src/\n    \u2514\u2500\u2500 research_crew/\n        \u251c\u2500\u2500 __init__.py\n        \u251c\u2500\u2500 main.py\n        \u251c\u2500\u2500 crew.py\n        \u251c\u2500\u2500 tools/\n        \u2502   \u251c\u2500\u2500 custom_tool.py\n        \u2502   \u2514\u2500\u2500 __init__.py\n        \u2514\u2500\u2500 config/\n            \u251c\u2500\u2500 agents.yaml\n            \u2514\u2500\u2500 tasks.yaml",
      "formatted_path": "Changelog > Build Your First Crew > Step 2: Explore the Project Structure",
      "enhanced_text": "Context: Changelog > Build Your First Crew > Step 2: Explore the Project Structure\n\nresearch_crew/\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 .env\n\u2514\u2500\u2500 src/\n    \u2514\u2500\u2500 research_crew/\n        \u251c\u2500\u2500 __init__.py\n        \u251c\u2500\u2500 main.py\n        \u251c\u2500\u2500 crew.py\n        \u251c\u2500\u2500 tools/\n        \u2502   \u251c\u2500\u2500 custom_tool.py\n        \u2502   \u2514\u2500\u2500 __init__.py\n        \u2514\u2500\u2500 config/\n            \u251c\u2500\u2500 agents.yaml\n            \u2514\u2500\u2500 tasks.yaml"
    },
    {
      "content": "# src/research_crew/config/agents.yaml\nresearcher:\n  role: >\n    Senior Research Specialist for {topic}\n  goal: >\n    Find comprehensive and accurate information about {topic}\n    with a focus on recent developments and key insights\n  backstory: >\n    You are an experienced research specialist with a talent for\n    finding relevant information from various sources. You excel at\n    organizing information in a clear and structured manner, making\n    complex topics accessible to others.\n  llm: openai/gpt-4o-mini\n\nanalyst:\n  role: >\n    Data Analyst and Report Writer for {topic}\n  goal: >\n    Analyze research findings and create a comprehensive, well-structured\n    report that presents insights in a clear and engaging way\n  backstory: >\n    You are a skilled analyst with a background in data interpretation\n    and technical writing. You have a talent for identifying patterns\n    and extracting meaningful insights from research data, then\n    communicating those insights effectively through well-crafted reports.\n  llm: openai/gpt-4o-mini",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Crew",
          "level": 1
        },
        {
          "title": "Step 3: Configure Your Agents",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Crew",
            "level": 1
          },
          {
            "title": "Step 3: Configure Your Agents",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Crew > Step 3: Configure Your Agents"
      },
      "enhanced_content": "Context: Changelog > Build Your First Crew > Step 3: Configure Your Agents\n\n# src/research_crew/config/agents.yaml\nresearcher:\n  role: >\n    Senior Research Specialist for {topic}\n  goal: >\n    Find comprehensive and accurate information about {topic}\n    with a focus on recent developments and key insights\n  backstory: >\n    You are an experienced research specialist with a talent for\n    finding relevant information from various sources. You excel at\n    organizing information in a clear and structured manner, making\n    complex topics accessible to others.\n  llm: openai/gpt-4o-mini\n\nanalyst:\n  role: >\n    Data Analyst and Report Writer for {topic}\n  goal: >\n    Analyze research findings and create a comprehensive, well-structured\n    report that presents insights in a clear and engaging way\n  backstory: >\n    You are a skilled analyst with a background in data interpretation\n    and technical writing. You have a talent for identifying patterns\n    and extracting meaningful insights from research data, then\n    communicating those insights effectively through well-crafted reports.\n  llm: openai/gpt-4o-mini",
      "formatted_path": "Changelog > Build Your First Crew > Step 3: Configure Your Agents",
      "enhanced_text": "Context: Changelog > Build Your First Crew > Step 3: Configure Your Agents\n\n# src/research_crew/config/agents.yaml\nresearcher:\n  role: >\n    Senior Research Specialist for {topic}\n  goal: >\n    Find comprehensive and accurate information about {topic}\n    with a focus on recent developments and key insights\n  backstory: >\n    You are an experienced research specialist with a talent for\n    finding relevant information from various sources. You excel at\n    organizing information in a clear and structured manner, making\n    complex topics accessible to others.\n  llm: openai/gpt-4o-mini\n\nanalyst:\n  role: >\n    Data Analyst and Report Writer for {topic}\n  goal: >\n    Analyze research findings and create a comprehensive, well-structured\n    report that presents insights in a clear and engaging way\n  backstory: >\n    You are a skilled analyst with a background in data interpretation\n    and technical writing. You have a talent for identifying patterns\n    and extracting meaningful insights from research data, then\n    communicating those insights effectively through well-crafted reports.\n  llm: openai/gpt-4o-mini"
    },
    {
      "content": "# src/research_crew/config/tasks.yaml\nresearch_task:\n  description: >\n    Conduct thorough research on {topic}. Focus on:\n    1. Key concepts and definitions\n    2. Historical development and recent trends\n    3. Major challenges and opportunities\n    4. Notable applications or case studies\n    5. Future outlook and potential developments\n\n    Make sure to organize your findings in a structured format with clear sections.\n  expected_output: >\n    A comprehensive research document with well-organized sections covering\n    all the requested aspects of {topic}. Include specific facts, figures,\n    and examples where relevant.\n  agent: researcher\n\nanalysis_task:\n  description: >\n    Analyze the research findings and create a comprehensive report on {topic}.\n    Your report should:\n    1. Begin with an executive summary\n    2. Include all key information from the research\n    3. Provide insightful analysis of trends and patterns\n    4. Offer recommendations or future considerations\n    5. Be formatted in a professional, easy-to-read style with clear headings\n  expected_output: >\n    A polished, professional report on {topic} that presents the research\n    findings with added analysis and insights. The report should be well-structured\n    with an executive summary, main sections, and conclusion.\n  agent: analyst\n  context:\n    - research_task\n  output_file: output/report.md",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Crew",
          "level": 1
        },
        {
          "title": "Step 4: Define Your Tasks",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Crew",
            "level": 1
          },
          {
            "title": "Step 4: Define Your Tasks",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Crew > Step 4: Define Your Tasks"
      },
      "enhanced_content": "Context: Changelog > Build Your First Crew > Step 4: Define Your Tasks\n\n# src/research_crew/config/tasks.yaml\nresearch_task:\n  description: >\n    Conduct thorough research on {topic}. Focus on:\n    1. Key concepts and definitions\n    2. Historical development and recent trends\n    3. Major challenges and opportunities\n    4. Notable applications or case studies\n    5. Future outlook and potential developments\n\n    Make sure to organize your findings in a structured format with clear sections.\n  expected_output: >\n    A comprehensive research document with well-organized sections covering\n    all the requested aspects of {topic}. Include specific facts, figures,\n    and examples where relevant.\n  agent: researcher\n\nanalysis_task:\n  description: >\n    Analyze the research findings and create a comprehensive report on {topic}.\n    Your report should:\n    1. Begin with an executive summary\n    2. Include all key information from the research\n    3. Provide insightful analysis of trends and patterns\n    4. Offer recommendations or future considerations\n    5. Be formatted in a professional, easy-to-read style with clear headings\n  expected_output: >\n    A polished, professional report on {topic} that presents the research\n    findings with added analysis and insights. The report should be well-structured\n    with an executive summary, main sections, and conclusion.\n  agent: analyst\n  context:\n    - research_task\n  output_file: output/report.md",
      "formatted_path": "Changelog > Build Your First Crew > Step 4: Define Your Tasks",
      "enhanced_text": "Context: Changelog > Build Your First Crew > Step 4: Define Your Tasks\n\n# src/research_crew/config/tasks.yaml\nresearch_task:\n  description: >\n    Conduct thorough research on {topic}. Focus on:\n    1. Key concepts and definitions\n    2. Historical development and recent trends\n    3. Major challenges and opportunities\n    4. Notable applications or case studies\n    5. Future outlook and potential developments\n\n    Make sure to organize your findings in a structured format with clear sections.\n  expected_output: >\n    A comprehensive research document with well-organized sections covering\n    all the requested aspects of {topic}. Include specific facts, figures,\n    and examples where relevant.\n  agent: researcher\n\nanalysis_task:\n  description: >\n    Analyze the research findings and create a comprehensive report on {topic}.\n    Your report should:\n    1. Begin with an executive summary\n    2. Include all key information from the research\n    3. Provide insightful analysis of trends and patterns\n    4. Offer recommendations or future considerations\n    5. Be formatted in a professional, easy-to-read style with clear headings\n  expected_output: >\n    A polished, professional report on {topic} that presents the research\n    findings with added analysis and insights. The report should be well-structured\n    with an executive summary, main sections, and conclusion.\n  agent: analyst\n  context:\n    - research_task\n  output_file: output/report.md"
    },
    {
      "content": "# src/research_crew/crew.py\nfrom crewai import Agent, Crew, Process, Task\nfrom crewai.project import CrewBase, agent, crew, task\nfrom crewai_tools import SerperDevTool\n\n@CrewBase\nclass ResearchCrew():\n    \"\"\"Research crew for comprehensive topic analysis and reporting\"\"\"\n\n    @agent\n    def researcher(self) -> Agent:\n        return Agent(\n            config=self.agents_config['researcher'],\n            verbose=True,\n            tools=[SerperDevTool()]\n        )\n\n    @agent\n    def analyst(self) -> Agent:\n        return Agent(\n            config=self.agents_config['analyst'],\n            verbose=True\n        )\n\n    @task\n    def research_task(self) -> Task:\n        return Task(\n            config=self.tasks_config['research_task']\n        )\n\n    @task\n    def analysis_task(self) -> Task:\n        return Task(\n            config=self.tasks_config['analysis_task'],\n            output_file='output/report.md'\n        )\n\n    @crew\n    def crew(self) -> Crew:\n        \"\"\"Creates the research crew\"\"\"\n        return Crew(\n            agents=self.agents,\n            tasks=self.tasks,\n            process=Process.sequential,\n            verbose=True,\n        )",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Crew",
          "level": 1
        },
        {
          "title": "Step 5: Configure Your Crew",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Crew",
            "level": 1
          },
          {
            "title": "Step 5: Configure Your Crew",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Crew > Step 5: Configure Your Crew"
      },
      "enhanced_content": "Context: Changelog > Build Your First Crew > Step 5: Configure Your Crew\n\n# src/research_crew/crew.py\nfrom crewai import Agent, Crew, Process, Task\nfrom crewai.project import CrewBase, agent, crew, task\nfrom crewai_tools import SerperDevTool\n\n@CrewBase\nclass ResearchCrew():\n    \"\"\"Research crew for comprehensive topic analysis and reporting\"\"\"\n\n    @agent\n    def researcher(self) -> Agent:\n        return Agent(\n            config=self.agents_config['researcher'],\n            verbose=True,\n            tools=[SerperDevTool()]\n        )\n\n    @agent\n    def analyst(self) -> Agent:\n        return Agent(\n            config=self.agents_config['analyst'],\n            verbose=True\n        )\n\n    @task\n    def research_task(self) -> Task:\n        return Task(\n            config=self.tasks_config['research_task']\n        )\n\n    @task\n    def analysis_task(self) -> Task:\n        return Task(\n            config=self.tasks_config['analysis_task'],\n            output_file='output/report.md'\n        )\n\n    @crew\n    def crew(self) -> Crew:\n        \"\"\"Creates the research crew\"\"\"\n        return Crew(\n            agents=self.agents,\n            tasks=self.tasks,\n            process=Process.sequential,\n            verbose=True,\n        )",
      "formatted_path": "Changelog > Build Your First Crew > Step 5: Configure Your Crew",
      "enhanced_text": "Context: Changelog > Build Your First Crew > Step 5: Configure Your Crew\n\n# src/research_crew/crew.py\nfrom crewai import Agent, Crew, Process, Task\nfrom crewai.project import CrewBase, agent, crew, task\nfrom crewai_tools import SerperDevTool\n\n@CrewBase\nclass ResearchCrew():\n    \"\"\"Research crew for comprehensive topic analysis and reporting\"\"\"\n\n    @agent\n    def researcher(self) -> Agent:\n        return Agent(\n            config=self.agents_config['researcher'],\n            verbose=True,\n            tools=[SerperDevTool()]\n        )\n\n    @agent\n    def analyst(self) -> Agent:\n        return Agent(\n            config=self.agents_config['analyst'],\n            verbose=True\n        )\n\n    @task\n    def research_task(self) -> Task:\n        return Task(\n            config=self.tasks_config['research_task']\n        )\n\n    @task\n    def analysis_task(self) -> Task:\n        return Task(\n            config=self.tasks_config['analysis_task'],\n            output_file='output/report.md'\n        )\n\n    @crew\n    def crew(self) -> Crew:\n        \"\"\"Creates the research crew\"\"\"\n        return Crew(\n            agents=self.agents,\n            tasks=self.tasks,\n            process=Process.sequential,\n            verbose=True,\n        )"
    },
    {
      "content": "#!/usr/bin/env python\n# src/research_crew/main.py\nimport os\nfrom research_crew.crew import ResearchCrew\n\n# Create output directory if it doesn't exist\nos.makedirs('output', exist_ok=True)\n\ndef run():\n    \"\"\"\n    Run the research crew.\n    \"\"\"\n    inputs = {\n        'topic': 'Artificial Intelligence in Healthcare'\n    }\n\n    # Create and run the crew\n    result = ResearchCrew().crew().kickoff(inputs=inputs)\n\n    # Print the result\n    print(\"\\n\\n=== FINAL REPORT ===\\n\\n\")\n    print(result.raw)\n\n    print(\"\\n\\nReport has been saved to output/report.md\")\n\nif __name__ == \"__main__\":\n    run()",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Crew",
          "level": 1
        },
        {
          "title": "Step 6: Set Up Your Main Script",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Crew",
            "level": 1
          },
          {
            "title": "Step 6: Set Up Your Main Script",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Crew > Step 6: Set Up Your Main Script"
      },
      "enhanced_content": "Context: Changelog > Build Your First Crew > Step 6: Set Up Your Main Script\n\n#!/usr/bin/env python\n# src/research_crew/main.py\nimport os\nfrom research_crew.crew import ResearchCrew\n\n# Create output directory if it doesn't exist\nos.makedirs('output', exist_ok=True)\n\ndef run():\n    \"\"\"\n    Run the research crew.\n    \"\"\"\n    inputs = {\n        'topic': 'Artificial Intelligence in Healthcare'\n    }\n\n    # Create and run the crew\n    result = ResearchCrew().crew().kickoff(inputs=inputs)\n\n    # Print the result\n    print(\"\\n\\n=== FINAL REPORT ===\\n\\n\")\n    print(result.raw)\n\n    print(\"\\n\\nReport has been saved to output/report.md\")\n\nif __name__ == \"__main__\":\n    run()",
      "formatted_path": "Changelog > Build Your First Crew > Step 6: Set Up Your Main Script",
      "enhanced_text": "Context: Changelog > Build Your First Crew > Step 6: Set Up Your Main Script\n\n#!/usr/bin/env python\n# src/research_crew/main.py\nimport os\nfrom research_crew.crew import ResearchCrew\n\n# Create output directory if it doesn't exist\nos.makedirs('output', exist_ok=True)\n\ndef run():\n    \"\"\"\n    Run the research crew.\n    \"\"\"\n    inputs = {\n        'topic': 'Artificial Intelligence in Healthcare'\n    }\n\n    # Create and run the crew\n    result = ResearchCrew().crew().kickoff(inputs=inputs)\n\n    # Print the result\n    print(\"\\n\\n=== FINAL REPORT ===\\n\\n\")\n    print(result.raw)\n\n    print(\"\\n\\nReport has been saved to output/report.md\")\n\nif __name__ == \"__main__\":\n    run()"
    },
    {
      "content": "OPENAI_API_KEY=your_openai_api_key\nSERPER_API_KEY=your_serper_api_key",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Crew",
          "level": 1
        },
        {
          "title": "Step 7: Set Up Your Environment Variables",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Crew",
            "level": 1
          },
          {
            "title": "Step 7: Set Up Your Environment Variables",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Crew > Step 7: Set Up Your Environment Variables"
      },
      "enhanced_content": "Context: Changelog > Build Your First Crew > Step 7: Set Up Your Environment Variables\n\nOPENAI_API_KEY=your_openai_api_key\nSERPER_API_KEY=your_serper_api_key",
      "formatted_path": "Changelog > Build Your First Crew > Step 7: Set Up Your Environment Variables",
      "enhanced_text": "Context: Changelog > Build Your First Crew > Step 7: Set Up Your Environment Variables\n\nOPENAI_API_KEY=your_openai_api_key\nSERPER_API_KEY=your_serper_api_key"
    },
    {
      "content": "crewai install",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Crew",
          "level": 1
        },
        {
          "title": "Step 8: Install Dependencies",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Crew",
            "level": 1
          },
          {
            "title": "Step 8: Install Dependencies",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Crew > Step 8: Install Dependencies"
      },
      "enhanced_content": "Context: Changelog > Build Your First Crew > Step 8: Install Dependencies\n\ncrewai install",
      "formatted_path": "Changelog > Build Your First Crew > Step 8: Install Dependencies",
      "enhanced_text": "Context: Changelog > Build Your First Crew > Step 8: Install Dependencies\n\ncrewai install"
    },
    {
      "content": "crewai run",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Crew",
          "level": 1
        },
        {
          "title": "Step 9: Run Your Crew",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Crew",
            "level": 1
          },
          {
            "title": "Step 9: Run Your Crew",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Crew > Step 9: Run Your Crew"
      },
      "enhanced_content": "Context: Changelog > Build Your First Crew > Step 9: Run Your Crew\n\ncrewai run",
      "formatted_path": "Changelog > Build Your First Crew > Step 9: Run Your Crew",
      "enhanced_text": "Context: Changelog > Build Your First Crew > Step 9: Run Your Crew\n\ncrewai run"
    },
    {
      "content": "# View all available commands\ncrewai --help\n\n# Run the crew\ncrewai run\n\n# Test the crew\ncrewai test\n\n# Reset crew memories\ncrewai reset-memories\n\n# Replay from a specific task\ncrewai replay -t <task_id>",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Crew",
          "level": 1
        },
        {
          "title": "Exploring Other CLI Commands",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Crew",
            "level": 1
          },
          {
            "title": "Exploring Other CLI Commands",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Crew > Exploring Other CLI Commands"
      },
      "enhanced_content": "Context: Changelog > Build Your First Crew > Exploring Other CLI Commands\n\n# View all available commands\ncrewai --help\n\n# Run the crew\ncrewai run\n\n# Test the crew\ncrewai test\n\n# Reset crew memories\ncrewai reset-memories\n\n# Replay from a specific task\ncrewai replay -t <task_id>",
      "formatted_path": "Changelog > Build Your First Crew > Exploring Other CLI Commands",
      "enhanced_text": "Context: Changelog > Build Your First Crew > Exploring Other CLI Commands\n\n# View all available commands\ncrewai --help\n\n# Run the crew\ncrewai run\n\n# Test the crew\ncrewai test\n\n# Reset crew memories\ncrewai reset-memories\n\n# Replay from a specific task\ncrewai replay -t <task_id>"
    },
    {
      "content": "What you've built in this guide is just the beginning. The skills and patterns you've learned can be applied to create increasingly sophisticated AI systems. Here are some ways you could extend this basic research crew:",
      "title": "The Art of the Possible: Beyond Your First Crew",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Crew",
          "level": 1
        },
        {
          "title": "The Art of the Possible: Beyond Your First Crew",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Crew",
            "level": 1
          },
          {
            "title": "The Art of the Possible: Beyond Your First Crew",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Crew > The Art of the Possible: Beyond Your First Crew"
      },
      "enhanced_content": "Context: Changelog > Build Your First Crew > The Art of the Possible: Beyond Your First Crew\n\n## The Art of the Possible: Beyond Your First Crew\n\nWhat you've built in this guide is just the beginning. The skills and patterns you've learned can be applied to create increasingly sophisticated AI systems. Here are some ways you could extend this basic research crew:",
      "formatted_path": "Changelog > Build Your First Crew > The Art of the Possible: Beyond Your First Crew",
      "enhanced_text": "Context: Changelog > Build Your First Crew > The Art of the Possible: Beyond Your First Crew\n\n The Art of the Possible: Beyond Your First Crew\n\nWhat you've built in this guide is just the beginning. The skills and patterns you've learned can be applied to create increasingly sophisticated AI systems. Here are some ways you could extend this basic research crew:"
    },
    {
      "content": "You could add more specialized agents to your crew: A **fact-checker** to verify research findings A **data visualizer** to create charts and graphs A **domain expert** with specialized knowledge in a particular area A **critic** to identify weaknesses in the analysis",
      "title": "Expanding Your Crew",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Crew",
          "level": 1
        },
        {
          "title": "The Art of the Possible: Beyond Your First Crew",
          "level": 2
        },
        {
          "title": "Expanding Your Crew",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Crew",
            "level": 1
          },
          {
            "title": "The Art of the Possible: Beyond Your First Crew",
            "level": 2
          },
          {
            "title": "Expanding Your Crew",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Crew > The Art of the Possible: Beyond Your First Crew > Expanding Your Crew"
      },
      "enhanced_content": "Context: Changelog > Build Your First Crew > The Art of the Possible: Beyond Your First Crew > Expanding Your Crew\n\n### Expanding Your Crew\n\nYou could add more specialized agents to your crew: A **fact-checker** to verify research findings A **data visualizer** to create charts and graphs A **domain expert** with specialized knowledge in a particular area A **critic** to identify weaknesses in the analysis",
      "formatted_path": "Changelog > Build Your First Crew > The Art of the Possible: Beyond Your First Crew > Expanding Your Crew",
      "enhanced_text": "Context: Changelog > Build Your First Crew > The Art of the Possible: Beyond Your First Crew > Expanding Your Crew\n\n Expanding Your Crew\n\nYou could add more specialized agents to your crew: A **fact-checker** to verify research findings A **data visualizer** to create charts and graphs A **domain expert** with specialized knowledge in a particular area A **critic** to identify weaknesses in the analysis"
    },
    {
      "content": "You could enhance your agents with additional tools: Web browsing tools for real-time research CSV/database tools for data analysis Code execution tools for data processing API connections to external services",
      "title": "Adding Tools and Capabilities",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Crew",
          "level": 1
        },
        {
          "title": "The Art of the Possible: Beyond Your First Crew",
          "level": 2
        },
        {
          "title": "Adding Tools and Capabilities",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Crew",
            "level": 1
          },
          {
            "title": "The Art of the Possible: Beyond Your First Crew",
            "level": 2
          },
          {
            "title": "Adding Tools and Capabilities",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Crew > The Art of the Possible: Beyond Your First Crew > Adding Tools and Capabilities"
      },
      "enhanced_content": "Context: Changelog > Build Your First Crew > The Art of the Possible: Beyond Your First Crew > Adding Tools and Capabilities\n\n### Adding Tools and Capabilities\n\nYou could enhance your agents with additional tools: Web browsing tools for real-time research CSV/database tools for data analysis Code execution tools for data processing API connections to external services",
      "formatted_path": "Changelog > Build Your First Crew > The Art of the Possible: Beyond Your First Crew > Adding Tools and Capabilities",
      "enhanced_text": "Context: Changelog > Build Your First Crew > The Art of the Possible: Beyond Your First Crew > Adding Tools and Capabilities\n\n Adding Tools and Capabilities\n\nYou could enhance your agents with additional tools: Web browsing tools for real-time research CSV/database tools for data analysis Code execution tools for data processing API connections to external services\n\nRelated sections:\n- \n"
    },
    {
      "content": "You could implement more sophisticated processes: Hierarchical processes where manager agents delegate to worker agents Iterative processes with feedback loops for refinement Parallel processes where multiple agents work simultaneously Dynamic processes that adapt based on intermediate results",
      "title": "Creating More Complex Workflows",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Crew",
          "level": 1
        },
        {
          "title": "The Art of the Possible: Beyond Your First Crew",
          "level": 2
        },
        {
          "title": "Creating More Complex Workflows",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Crew",
            "level": 1
          },
          {
            "title": "The Art of the Possible: Beyond Your First Crew",
            "level": 2
          },
          {
            "title": "Creating More Complex Workflows",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Crew > The Art of the Possible: Beyond Your First Crew > Creating More Complex Workflows"
      },
      "enhanced_content": "Context: Changelog > Build Your First Crew > The Art of the Possible: Beyond Your First Crew > Creating More Complex Workflows\n\n### Creating More Complex Workflows\n\nYou could implement more sophisticated processes: Hierarchical processes where manager agents delegate to worker agents Iterative processes with feedback loops for refinement Parallel processes where multiple agents work simultaneously Dynamic processes that adapt based on intermediate results",
      "formatted_path": "Changelog > Build Your First Crew > The Art of the Possible: Beyond Your First Crew > Creating More Complex Workflows",
      "enhanced_text": "Context: Changelog > Build Your First Crew > The Art of the Possible: Beyond Your First Crew > Creating More Complex Workflows\n\n Creating More Complex Workflows\n\nYou could implement more sophisticated processes: Hierarchical processes where manager agents delegate to worker agents Iterative processes with feedback loops for refinement Parallel processes where multiple agents work simultaneously Dynamic processes that adapt based on intermediate results"
    },
    {
      "content": "Source: https://docs.crewai.com/guides/flows/first-flow Learn how to create structured, event-driven workflows with precise control over execution.",
      "title": "Build Your First Flow",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Flow",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Flow",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Flow"
      },
      "enhanced_content": "Context: Changelog > Build Your First Flow\n\n# Build Your First Flow\n\nSource: https://docs.crewai.com/guides/flows/first-flow Learn how to create structured, event-driven workflows with precise control over execution.",
      "formatted_path": "Changelog > Build Your First Flow",
      "enhanced_text": "Context: Changelog > Build Your First Flow\n\n Build Your First Flow\n\nSource: https://docs.crewai.com/guides/flows/first-flow Learn how to create structured, event-driven workflows with precise control over execution."
    },
    {
      "content": "CrewAI Flows represent the next level in AI orchestration - combining the collaborative power of AI agent crews with the precision and flexibility of procedural programming. While crews excel at agent collaboration, flows give you fine-grained control over exactly how and when different components of your AI system interact. In this guide, we'll walk through creating a powerful CrewAI Flow that generates a comprehensive learning guide on any topic. This tutorial will demonstrate how Flows provide structured, event-driven control over your AI workflows by combining regular code, direct LLM calls, and crew-based processing.",
      "title": "Taking Control of AI Workflows with Flows",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Flow",
          "level": 1
        },
        {
          "title": "Taking Control of AI Workflows with Flows",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Flow",
            "level": 1
          },
          {
            "title": "Taking Control of AI Workflows with Flows",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Flow > Taking Control of AI Workflows with Flows"
      },
      "enhanced_content": "Context: Changelog > Build Your First Flow > Taking Control of AI Workflows with Flows\n\n## Taking Control of AI Workflows with Flows\n\nCrewAI Flows represent the next level in AI orchestration - combining the collaborative power of AI agent crews with the precision and flexibility of procedural programming. While crews excel at agent collaboration, flows give you fine-grained control over exactly how and when different components of your AI system interact. In this guide, we'll walk through creating a powerful CrewAI Flow that generates a comprehensive learning guide on any topic. This tutorial will demonstrate how Flows provide structured, event-driven control over your AI workflows by combining regular code, direct LLM calls, and crew-based processing.",
      "formatted_path": "Changelog > Build Your First Flow > Taking Control of AI Workflows with Flows",
      "enhanced_text": "Context: Changelog > Build Your First Flow > Taking Control of AI Workflows with Flows\n\n Taking Control of AI Workflows with Flows\n\nCrewAI Flows represent the next level in AI orchestration - combining the collaborative power of AI agent crews with the precision and flexibility of procedural programming. While crews excel at agent collaboration, flows give you fine-grained control over exactly how and when different components of your AI system interact. In this guide, we'll walk through creating a powerful CrewAI Flow that generates a comprehensive learning guide on any topic. This tutorial will demonstrate how Flows provide structured, event-driven control over your AI workflows by combining regular code, direct LLM calls, and crew-based processing.\n\nRelated sections:\n- \n"
    },
    {
      "content": "Flows enable you to: **Combine different AI interaction patterns** - Use crews for complex collaborative tasks, direct LLM calls for simpler operations, and regular code for procedural logic **Build event-driven systems** - Define how components respond to specific events and data changes **Maintain state across components** - Share and transform data between different parts of your application **Integrate with external systems** - Seamlessly connect your AI workflow with databases, APIs, and user interfaces **Create complex execution paths** - Design conditional branches, parallel processing, and dynamic workflows",
      "title": "What Makes Flows Powerful",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Flow",
          "level": 1
        },
        {
          "title": "Taking Control of AI Workflows with Flows",
          "level": 2
        },
        {
          "title": "What Makes Flows Powerful",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Flow",
            "level": 1
          },
          {
            "title": "Taking Control of AI Workflows with Flows",
            "level": 2
          },
          {
            "title": "What Makes Flows Powerful",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Flow > Taking Control of AI Workflows with Flows > What Makes Flows Powerful"
      },
      "enhanced_content": "Context: Changelog > Build Your First Flow > Taking Control of AI Workflows with Flows > What Makes Flows Powerful\n\n### What Makes Flows Powerful\n\nFlows enable you to: **Combine different AI interaction patterns** - Use crews for complex collaborative tasks, direct LLM calls for simpler operations, and regular code for procedural logic **Build event-driven systems** - Define how components respond to specific events and data changes **Maintain state across components** - Share and transform data between different parts of your application **Integrate with external systems** - Seamlessly connect your AI workflow with databases, APIs, and user interfaces **Create complex execution paths** - Design conditional branches, parallel processing, and dynamic workflows",
      "formatted_path": "Changelog > Build Your First Flow > Taking Control of AI Workflows with Flows > What Makes Flows Powerful",
      "enhanced_text": "Context: Changelog > Build Your First Flow > Taking Control of AI Workflows with Flows > What Makes Flows Powerful\n\n What Makes Flows Powerful\n\nFlows enable you to: **Combine different AI interaction patterns** - Use crews for complex collaborative tasks, direct LLM calls for simpler operations, and regular code for procedural logic **Build event-driven systems** - Define how components respond to specific events and data changes **Maintain state across components** - Share and transform data between different parts of your application **Integrate with external systems** - Seamlessly connect your AI workflow with databases, APIs, and user interfaces **Create complex execution paths** - Design conditional branches, parallel processing, and dynamic workflows\n\nRelated sections:\n- \n"
    },
    {
      "content": "By the end of this guide, you'll have: **Created a specialized AI research team** with distinct roles and responsibilities **Orchestrated collaboration** between multiple AI agents **Automated a complex workflow** that involves gathering information, analysis, and report generation **Built foundational skills** that you can apply to more ambitious projects While we're building a simple research crew in this guide, the same patterns and techniques can be applied to create much more sophisticated teams for tasks like: Multi-stage content creation with specialized writers, editors, and fact-checkers Complex customer service systems with tiered support agents Autonomous business analysts that gather data, create visualizations, and generate insights Product development teams that ideate, design, and plan implementation Let's get started building your first crew!",
      "title": "What You'll Build and Learn",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Flow",
          "level": 1
        },
        {
          "title": "Taking Control of AI Workflows with Flows",
          "level": 2
        },
        {
          "title": "What You'll Build and Learn",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Flow",
            "level": 1
          },
          {
            "title": "Taking Control of AI Workflows with Flows",
            "level": 2
          },
          {
            "title": "What You'll Build and Learn",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Flow > Taking Control of AI Workflows with Flows > What You'll Build and Learn"
      },
      "enhanced_content": "Context: Changelog > Build Your First Flow > Taking Control of AI Workflows with Flows > What You'll Build and Learn\n\n### What You'll Build and Learn\n\nBy the end of this guide, you'll have: **Created a specialized AI research team** with distinct roles and responsibilities **Orchestrated collaboration** between multiple AI agents **Automated a complex workflow** that involves gathering information, analysis, and report generation **Built foundational skills** that you can apply to more ambitious projects While we're building a simple research crew in this guide, the same patterns and techniques can be applied to create much more sophisticated teams for tasks like: Multi-stage content creation with specialized writers, editors, and fact-checkers Complex customer service systems with tiered support agents Autonomous business analysts that gather data, create visualizations, and generate insights Product development teams that ideate, design, and plan implementation Let's get started building your first crew!",
      "formatted_path": "Changelog > Build Your First Flow > Taking Control of AI Workflows with Flows > What You'll Build and Learn",
      "enhanced_text": "Context: Changelog > Build Your First Flow > Taking Control of AI Workflows with Flows > What You'll Build and Learn\n\n What You'll Build and Learn\n\nBy the end of this guide, you'll have: **Created a specialized AI research team** with distinct roles and responsibilities **Orchestrated collaboration** between multiple AI agents **Automated a complex workflow** that involves gathering information, analysis, and report generation **Built foundational skills** that you can apply to more ambitious projects While we're building a simple research crew in this guide, the same patterns and techniques can be applied to create much more sophisticated teams for tasks like: Multi-stage content creation with specialized writers, editors, and fact-checkers Complex customer service systems with tiered support agents Autonomous business analysts that gather data, create visualizations, and generate insights Product development teams that ideate, design, and plan implementation Let's get started building your first crew!"
    },
    {
      "content": "By the end of this guide, you'll have: **Created a sophisticated content generation system** that combines user input, AI planning, and multi-agent content creation **Orchestrated the flow of information** between different components of your system **Implemented event-driven architecture** where each step responds to the completion of previous steps **Built a foundation for more complex AI applications** that you can expand and customize This guide creator flow demonstrates fundamental patterns that can be applied to create much more advanced applications, such as: Interactive AI assistants that combine multiple specialized subsystems Complex data processing pipelines with AI-enhanced transformations Autonomous agents that integrate with external services and APIs Multi-stage decision-making systems with human-in-the-loop processes Let's dive in and build your first flow!",
      "title": "What You'll Build and Learn",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Flow",
          "level": 1
        },
        {
          "title": "Taking Control of AI Workflows with Flows",
          "level": 2
        },
        {
          "title": "What You'll Build and Learn",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Flow",
            "level": 1
          },
          {
            "title": "Taking Control of AI Workflows with Flows",
            "level": 2
          },
          {
            "title": "What You'll Build and Learn",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Flow > Taking Control of AI Workflows with Flows > What You'll Build and Learn"
      },
      "enhanced_content": "Context: Changelog > Build Your First Flow > Taking Control of AI Workflows with Flows > What You'll Build and Learn\n\n### What You'll Build and Learn\n\nBy the end of this guide, you'll have: **Created a sophisticated content generation system** that combines user input, AI planning, and multi-agent content creation **Orchestrated the flow of information** between different components of your system **Implemented event-driven architecture** where each step responds to the completion of previous steps **Built a foundation for more complex AI applications** that you can expand and customize This guide creator flow demonstrates fundamental patterns that can be applied to create much more advanced applications, such as: Interactive AI assistants that combine multiple specialized subsystems Complex data processing pipelines with AI-enhanced transformations Autonomous agents that integrate with external services and APIs Multi-stage decision-making systems with human-in-the-loop processes Let's dive in and build your first flow!",
      "formatted_path": "Changelog > Build Your First Flow > Taking Control of AI Workflows with Flows > What You'll Build and Learn",
      "enhanced_text": "Context: Changelog > Build Your First Flow > Taking Control of AI Workflows with Flows > What You'll Build and Learn\n\n What You'll Build and Learn\n\nBy the end of this guide, you'll have: **Created a sophisticated content generation system** that combines user input, AI planning, and multi-agent content creation **Orchestrated the flow of information** between different components of your system **Implemented event-driven architecture** where each step responds to the completion of previous steps **Built a foundation for more complex AI applications** that you can expand and customize This guide creator flow demonstrates fundamental patterns that can be applied to create much more advanced applications, such as: Interactive AI assistants that combine multiple specialized subsystems Complex data processing pipelines with AI-enhanced transformations Autonomous agents that integrate with external services and APIs Multi-stage decision-making systems with human-in-the-loop processes Let's dive in and build your first flow!"
    },
    {
      "content": "dependencies = [\n    \"google-generativeai>=0.8.4\", #main version in January/2025 - crewai v.0.100.0 and crewai-tools 0.33.0\n    \"crewai[tools]>=0.100.0,<1.0.0\"\n]",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Flow",
          "level": 1
        },
        {
          "title": "Prerequisites",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Flow",
            "level": 1
          },
          {
            "title": "Prerequisites",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Flow > Prerequisites"
      },
      "enhanced_content": "Context: Changelog > Build Your First Flow > Prerequisites\n\ndependencies = [\n    \"google-generativeai>=0.8.4\", #main version in January/2025 - crewai v.0.100.0 and crewai-tools 0.33.0\n    \"crewai[tools]>=0.100.0,<1.0.0\"\n]",
      "formatted_path": "Changelog > Build Your First Flow > Prerequisites",
      "enhanced_text": "Context: Changelog > Build Your First Flow > Prerequisites\n\ndependencies = [\n    \"google-generativeai>=0.8.4\", #main version in January/2025 - crewai v.0.100.0 and crewai-tools 0.33.0\n    \"crewai[tools]>=0.100.0,<1.0.0\"\n]"
    },
    {
      "content": "from crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"google\",\n        \"config\": {\n            \"api_key\": \"<YOUR_API_KEY>\",\n            \"model\": \"<model_name>\"\n        }\n    }\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Flow",
          "level": 1
        },
        {
          "title": "Prerequisites",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Flow",
            "level": 1
          },
          {
            "title": "Prerequisites",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Flow > Prerequisites"
      },
      "enhanced_content": "Context: Changelog > Build Your First Flow > Prerequisites\n\nfrom crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"google\",\n        \"config\": {\n            \"api_key\": \"<YOUR_API_KEY>\",\n            \"model\": \"<model_name>\"\n        }\n    }\n)",
      "formatted_path": "Changelog > Build Your First Flow > Prerequisites",
      "enhanced_text": "Context: Changelog > Build Your First Flow > Prerequisites\n\nfrom crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"google\",\n        \"config\": {\n            \"api_key\": \"<YOUR_API_KEY>\",\n            \"model\": \"<model_name>\"\n        }\n    }\n)"
    },
    {
      "content": "crewai create flow guide_creator_flow\ncd guide_creator_flow",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Flow",
          "level": 1
        },
        {
          "title": "Step 1: Create a New CrewAI Flow Project",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Flow",
            "level": 1
          },
          {
            "title": "Step 1: Create a New CrewAI Flow Project",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Flow > Step 1: Create a New CrewAI Flow Project"
      },
      "enhanced_content": "Context: Changelog > Build Your First Flow > Step 1: Create a New CrewAI Flow Project\n\ncrewai create flow guide_creator_flow\ncd guide_creator_flow",
      "formatted_path": "Changelog > Build Your First Flow > Step 1: Create a New CrewAI Flow Project",
      "enhanced_text": "Context: Changelog > Build Your First Flow > Step 1: Create a New CrewAI Flow Project\n\ncrewai create flow guide_creator_flow\ncd guide_creator_flow"
    },
    {
      "content": "guide_creator_flow/\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 .env\n\u251c\u2500\u2500 main.py\n\u251c\u2500\u2500 crews/\n\u2502   \u2514\u2500\u2500 poem_crew/\n\u2502       \u251c\u2500\u2500 config/\n\u2502       \u2502   \u251c\u2500\u2500 agents.yaml\n\u2502       \u2502   \u2514\u2500\u2500 tasks.yaml\n\u2502       \u2514\u2500\u2500 poem_crew.py\n\u2514\u2500\u2500 tools/\n    \u2514\u2500\u2500 custom_tool.py",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Flow",
          "level": 1
        },
        {
          "title": "Step 2: Understanding the Project Structure",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Flow",
            "level": 1
          },
          {
            "title": "Step 2: Understanding the Project Structure",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Flow > Step 2: Understanding the Project Structure"
      },
      "enhanced_content": "Context: Changelog > Build Your First Flow > Step 2: Understanding the Project Structure\n\nguide_creator_flow/\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 .env\n\u251c\u2500\u2500 main.py\n\u251c\u2500\u2500 crews/\n\u2502   \u2514\u2500\u2500 poem_crew/\n\u2502       \u251c\u2500\u2500 config/\n\u2502       \u2502   \u251c\u2500\u2500 agents.yaml\n\u2502       \u2502   \u2514\u2500\u2500 tasks.yaml\n\u2502       \u2514\u2500\u2500 poem_crew.py\n\u2514\u2500\u2500 tools/\n    \u2514\u2500\u2500 custom_tool.py",
      "formatted_path": "Changelog > Build Your First Flow > Step 2: Understanding the Project Structure",
      "enhanced_text": "Context: Changelog > Build Your First Flow > Step 2: Understanding the Project Structure\n\nguide_creator_flow/\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 .env\n\u251c\u2500\u2500 main.py\n\u251c\u2500\u2500 crews/\n\u2502   \u2514\u2500\u2500 poem_crew/\n\u2502       \u251c\u2500\u2500 config/\n\u2502       \u2502   \u251c\u2500\u2500 agents.yaml\n\u2502       \u2502   \u2514\u2500\u2500 tasks.yaml\n\u2502       \u2514\u2500\u2500 poem_crew.py\n\u2514\u2500\u2500 tools/\n    \u2514\u2500\u2500 custom_tool.py"
    },
    {
      "content": "crewai flow add-crew content-crew",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Flow",
          "level": 1
        },
        {
          "title": "Step 3: Add a Content Writer Crew",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Flow",
            "level": 1
          },
          {
            "title": "Step 3: Add a Content Writer Crew",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Flow > Step 3: Add a Content Writer Crew"
      },
      "enhanced_content": "Context: Changelog > Build Your First Flow > Step 3: Add a Content Writer Crew\n\ncrewai flow add-crew content-crew",
      "formatted_path": "Changelog > Build Your First Flow > Step 3: Add a Content Writer Crew",
      "enhanced_text": "Context: Changelog > Build Your First Flow > Step 3: Add a Content Writer Crew\n\ncrewai flow add-crew content-crew"
    },
    {
      "content": "# src/guide_creator_flow/crews/content_crew/config/agents.yaml\ncontent_writer:\n  role: >\n    Educational Content Writer\n  goal: >\n    Create engaging, informative content that thoroughly explains the assigned topic\n    and provides valuable insights to the reader\n  backstory: >\n    You are a talented educational writer with expertise in creating clear, engaging\n    content. You have a gift for explaining complex concepts in accessible language\n    and organizing information in a way that helps readers build their understanding.\n  llm: openai/gpt-4o-mini\n\ncontent_reviewer:\n  role: >\n    Educational Content Reviewer and Editor\n  goal: >\n    Ensure content is accurate, comprehensive, well-structured, and maintains\n    consistency with previously written sections\n  backstory: >\n    You are a meticulous editor with years of experience reviewing educational\n    content. You have an eye for detail, clarity, and coherence. You excel at\n    improving content while maintaining the original author's voice and ensuring\n    consistent quality across multiple sections.\n  llm: openai/gpt-4o-mini",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Flow",
          "level": 1
        },
        {
          "title": "Step 4: Configure the Content Writer Crew",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Flow",
            "level": 1
          },
          {
            "title": "Step 4: Configure the Content Writer Crew",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Flow > Step 4: Configure the Content Writer Crew"
      },
      "enhanced_content": "Context: Changelog > Build Your First Flow > Step 4: Configure the Content Writer Crew\n\n# src/guide_creator_flow/crews/content_crew/config/agents.yaml\ncontent_writer:\n  role: >\n    Educational Content Writer\n  goal: >\n    Create engaging, informative content that thoroughly explains the assigned topic\n    and provides valuable insights to the reader\n  backstory: >\n    You are a talented educational writer with expertise in creating clear, engaging\n    content. You have a gift for explaining complex concepts in accessible language\n    and organizing information in a way that helps readers build their understanding.\n  llm: openai/gpt-4o-mini\n\ncontent_reviewer:\n  role: >\n    Educational Content Reviewer and Editor\n  goal: >\n    Ensure content is accurate, comprehensive, well-structured, and maintains\n    consistency with previously written sections\n  backstory: >\n    You are a meticulous editor with years of experience reviewing educational\n    content. You have an eye for detail, clarity, and coherence. You excel at\n    improving content while maintaining the original author's voice and ensuring\n    consistent quality across multiple sections.\n  llm: openai/gpt-4o-mini",
      "formatted_path": "Changelog > Build Your First Flow > Step 4: Configure the Content Writer Crew",
      "enhanced_text": "Context: Changelog > Build Your First Flow > Step 4: Configure the Content Writer Crew\n\n# src/guide_creator_flow/crews/content_crew/config/agents.yaml\ncontent_writer:\n  role: >\n    Educational Content Writer\n  goal: >\n    Create engaging, informative content that thoroughly explains the assigned topic\n    and provides valuable insights to the reader\n  backstory: >\n    You are a talented educational writer with expertise in creating clear, engaging\n    content. You have a gift for explaining complex concepts in accessible language\n    and organizing information in a way that helps readers build their understanding.\n  llm: openai/gpt-4o-mini\n\ncontent_reviewer:\n  role: >\n    Educational Content Reviewer and Editor\n  goal: >\n    Ensure content is accurate, comprehensive, well-structured, and maintains\n    consistency with previously written sections\n  backstory: >\n    You are a meticulous editor with years of experience reviewing educational\n    content. You have an eye for detail, clarity, and coherence. You excel at\n    improving content while maintaining the original author's voice and ensuring\n    consistent quality across multiple sections.\n  llm: openai/gpt-4o-mini"
    },
    {
      "content": "# src/guide_creator_flow/crews/content_crew/config/tasks.yaml\nwrite_section_task:\n  description: >\n    Write a comprehensive section on the topic: \"{section_title}\"\n\n    Section description: {section_description}\n    Target audience: {audience_level} level learners\n\n    Your content should:\n    1. Begin with a brief introduction to the section topic\n    2. Explain all key concepts clearly with examples\n    3. Include practical applications or exercises where appropriate\n    4. End with a summary of key points\n    5. Be approximately 500-800 words in length\n\n    Format your content in Markdown with appropriate headings, lists, and emphasis.\n\n    Previously written sections:\n    {previous_sections}\n\n    Make sure your content maintains consistency with previously written sections\n    and builds upon concepts that have already been explained.\n  expected_output: >\n    A well-structured, comprehensive section in Markdown format that thoroughly\n    explains the topic and is appropriate for the target audience.\n  agent: content_writer\n\nreview_section_task:\n  description: >\n    Review and improve the following section on \"{section_title}\":\n\n    {draft_content}\n\n    Target audience: {audience_level} level learners\n\n    Previously written sections:\n    {previous_sections}\n\n    Your review should:\n    1. Fix any grammatical or spelling errors\n    2. Improve clarity and readability\n    3. Ensure content is comprehensive and accurate\n    4. Verify consistency with previously written sections\n    5. Enhance the structure and flow\n    6. Add any missing key information\n\n    Provide the improved version of the section in Markdown format.\n  expected_output: >\n    An improved, polished version of the section that maintains the original\n    structure but enhances clarity, accuracy, and consistency.\n  agent: content_reviewer\n  context:\n    - write_section_task",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Flow",
          "level": 1
        },
        {
          "title": "Step 4: Configure the Content Writer Crew",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Flow",
            "level": 1
          },
          {
            "title": "Step 4: Configure the Content Writer Crew",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Flow > Step 4: Configure the Content Writer Crew"
      },
      "enhanced_content": "Context: Changelog > Build Your First Flow > Step 4: Configure the Content Writer Crew\n\n# src/guide_creator_flow/crews/content_crew/config/tasks.yaml\nwrite_section_task:\n  description: >\n    Write a comprehensive section on the topic: \"{section_title}\"\n\n    Section description: {section_description}\n    Target audience: {audience_level} level learners\n\n    Your content should:\n    1. Begin with a brief introduction to the section topic\n    2. Explain all key concepts clearly with examples\n    3. Include practical applications or exercises where appropriate\n    4. End with a summary of key points\n    5. Be approximately 500-800 words in length\n\n    Format your content in Markdown with appropriate headings, lists, and emphasis.\n\n    Previously written sections:\n    {previous_sections}\n\n    Make sure your content maintains consistency with previously written sections\n    and builds upon concepts that have already been explained.\n  expected_output: >\n    A well-structured, comprehensive section in Markdown format that thoroughly\n    explains the topic and is appropriate for the target audience.\n  agent: content_writer\n\nreview_section_task:\n  description: >\n    Review and improve the following section on \"{section_title}\":\n\n    {draft_content}\n\n    Target audience: {audience_level} level learners\n\n    Previously written sections:\n    {previous_sections}\n\n    Your review should:\n    1. Fix any grammatical or spelling errors\n    2. Improve clarity and readability\n    3. Ensure content is comprehensive and accurate\n    4. Verify consistency with previously written sections\n    5. Enhance the structure and flow\n    6. Add any missing key information\n\n    Provide the improved version of the section in Markdown format.\n  expected_output: >\n    An improved, polished version of the section that maintains the original\n    structure but enhances clarity, accuracy, and consistency.\n  agent: content_reviewer\n  context:\n    - write_section_task",
      "formatted_path": "Changelog > Build Your First Flow > Step 4: Configure the Content Writer Crew",
      "enhanced_text": "Context: Changelog > Build Your First Flow > Step 4: Configure the Content Writer Crew\n\n# src/guide_creator_flow/crews/content_crew/config/tasks.yaml\nwrite_section_task:\n  description: >\n    Write a comprehensive section on the topic: \"{section_title}\"\n\n    Section description: {section_description}\n    Target audience: {audience_level} level learners\n\n    Your content should:\n    1. Begin with a brief introduction to the section topic\n    2. Explain all key concepts clearly with examples\n    3. Include practical applications or exercises where appropriate\n    4. End with a summary of key points\n    5. Be approximately 500-800 words in length\n\n    Format your content in Markdown with appropriate headings, lists, and emphasis.\n\n    Previously written sections:\n    {previous_sections}\n\n    Make sure your content maintains consistency with previously written sections\n    and builds upon concepts that have already been explained.\n  expected_output: >\n    A well-structured, comprehensive section in Markdown format that thoroughly\n    explains the topic and is appropriate for the target audience.\n  agent: content_writer\n\nreview_section_task:\n  description: >\n    Review and improve the following section on \"{section_title}\":\n\n    {draft_content}\n\n    Target audience: {audience_level} level learners\n\n    Previously written sections:\n    {previous_sections}\n\n    Your review should:\n    1. Fix any grammatical or spelling errors\n    2. Improve clarity and readability\n    3. Ensure content is comprehensive and accurate\n    4. Verify consistency with previously written sections\n    5. Enhance the structure and flow\n    6. Add any missing key information\n\n    Provide the improved version of the section in Markdown format.\n  expected_output: >\n    An improved, polished version of the section that maintains the original\n    structure but enhances clarity, accuracy, and consistency.\n  agent: content_reviewer\n  context:\n    - write_section_task"
    },
    {
      "content": "# src/guide_creator_flow/crews/content_crew/content_crew.py\nfrom crewai import Agent, Crew, Process, Task\nfrom crewai.project import CrewBase, agent, crew, task\n\n@CrewBase\nclass ContentCrew():\n    \"\"\"Content writing crew\"\"\"\n\n    @agent\n    def content_writer(self) -> Agent:\n        return Agent(\n            config=self.agents_config['content_writer'],\n            verbose=True\n        )\n\n    @agent\n    def content_reviewer(self) -> Agent:\n        return Agent(\n            config=self.agents_config['content_reviewer'],\n            verbose=True\n        )\n\n    @task\n    def write_section_task(self) -> Task:\n        return Task(\n            config=self.tasks_config['write_section_task']\n        )\n\n    @task\n    def review_section_task(self) -> Task:\n        return Task(\n            config=self.tasks_config['review_section_task'],\n            context=[self.write_section_task()]\n        )\n\n    @crew\n    def crew(self) -> Crew:\n        \"\"\"Creates the content writing crew\"\"\"\n        return Crew(\n            agents=self.agents,\n            tasks=self.tasks,\n            process=Process.sequential,\n            verbose=True,\n        )",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Flow",
          "level": 1
        },
        {
          "title": "Step 4: Configure the Content Writer Crew",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Flow",
            "level": 1
          },
          {
            "title": "Step 4: Configure the Content Writer Crew",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Flow > Step 4: Configure the Content Writer Crew"
      },
      "enhanced_content": "Context: Changelog > Build Your First Flow > Step 4: Configure the Content Writer Crew\n\n# src/guide_creator_flow/crews/content_crew/content_crew.py\nfrom crewai import Agent, Crew, Process, Task\nfrom crewai.project import CrewBase, agent, crew, task\n\n@CrewBase\nclass ContentCrew():\n    \"\"\"Content writing crew\"\"\"\n\n    @agent\n    def content_writer(self) -> Agent:\n        return Agent(\n            config=self.agents_config['content_writer'],\n            verbose=True\n        )\n\n    @agent\n    def content_reviewer(self) -> Agent:\n        return Agent(\n            config=self.agents_config['content_reviewer'],\n            verbose=True\n        )\n\n    @task\n    def write_section_task(self) -> Task:\n        return Task(\n            config=self.tasks_config['write_section_task']\n        )\n\n    @task\n    def review_section_task(self) -> Task:\n        return Task(\n            config=self.tasks_config['review_section_task'],\n            context=[self.write_section_task()]\n        )\n\n    @crew\n    def crew(self) -> Crew:\n        \"\"\"Creates the content writing crew\"\"\"\n        return Crew(\n            agents=self.agents,\n            tasks=self.tasks,\n            process=Process.sequential,\n            verbose=True,\n        )",
      "formatted_path": "Changelog > Build Your First Flow > Step 4: Configure the Content Writer Crew",
      "enhanced_text": "Context: Changelog > Build Your First Flow > Step 4: Configure the Content Writer Crew\n\n# src/guide_creator_flow/crews/content_crew/content_crew.py\nfrom crewai import Agent, Crew, Process, Task\nfrom crewai.project import CrewBase, agent, crew, task\n\n@CrewBase\nclass ContentCrew():\n    \"\"\"Content writing crew\"\"\"\n\n    @agent\n    def content_writer(self) -> Agent:\n        return Agent(\n            config=self.agents_config['content_writer'],\n            verbose=True\n        )\n\n    @agent\n    def content_reviewer(self) -> Agent:\n        return Agent(\n            config=self.agents_config['content_reviewer'],\n            verbose=True\n        )\n\n    @task\n    def write_section_task(self) -> Task:\n        return Task(\n            config=self.tasks_config['write_section_task']\n        )\n\n    @task\n    def review_section_task(self) -> Task:\n        return Task(\n            config=self.tasks_config['review_section_task'],\n            context=[self.write_section_task()]\n        )\n\n    @crew\n    def crew(self) -> Crew:\n        \"\"\"Creates the content writing crew\"\"\"\n        return Crew(\n            agents=self.agents,\n            tasks=self.tasks,\n            process=Process.sequential,\n            verbose=True,\n        )"
    },
    {
      "content": "#!/usr/bin/env python\nimport json\nfrom typing import List, Dict\nfrom pydantic import BaseModel, Field\nfrom crewai import LLM\nfrom crewai.flow.flow import Flow, listen, start\nfrom guide_creator_flow.crews.content_crew.content_crew import ContentCrew\n\n# Define our models for structured data\nclass Section(BaseModel):\n    title: str = Field(description=\"Title of the section\")\n    description: str = Field(description=\"Brief description of what the section should cover\")\n\nclass GuideOutline(BaseModel):\n    title: str = Field(description=\"Title of the guide\")\n    introduction: str = Field(description=\"Introduction to the topic\")\n    target_audience: str = Field(description=\"Description of the target audience\")\n    sections: List[Section] = Field(description=\"List of sections in the guide\")\n    conclusion: str = Field(description=\"Conclusion or summary of the guide\")\n\n# Define our flow state\nclass GuideCreatorState(BaseModel):\n    topic: str = \"\"\n    audience_level: str = \"\"\n    guide_outline: GuideOutline = None\n    sections_content: Dict[str, str] = {}\n\nclass GuideCreatorFlow(Flow[GuideCreatorState]):\n    \"\"\"Flow for creating a comprehensive guide on any topic\"\"\"\n\n    @start()\n    def get_user_input(self):\n        \"\"\"Get input from the user about the guide topic and audience\"\"\"\n        print(\"\\n=== Create Your Comprehensive Guide ===\\n\")\n\n        # Get user input\n        self.state.topic = input(\"What topic would you like to create a guide for? \")\n\n        # Get audience level with validation\n        while True:\n            audience = input(\"Who is your target audience? (beginner/intermediate/advanced) \").lower()\n            if audience in [\"beginner\", \"intermediate\", \"advanced\"]:\n                self.state.audience_level = audience\n                break\n            print(\"Please enter 'beginner', 'intermediate', or 'advanced'\")\n\n        print(f\"\\nCreating a guide on {self.state.topic} for {self.state.audience_level} audience...\\n\")\n        return self.state\n\n    @listen(get_user_input)\n    def create_guide_outline(self, state):\n        \"\"\"Create a structured outline for the guide using a direct LLM call\"\"\"\n        print(\"Creating guide outline...\")\n\n        # Initialize the LLM\n        llm = LLM(model=\"openai/gpt-4o-mini\", response_format=GuideOutline)\n\n        # Create the messages for the outline\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are a helpful assistant designed to output JSON.\"},\n            {\"role\": \"user\", \"content\": f\"\"\"\n            Create a detailed outline for a comprehensive guide on \"{state.topic}\" for {state.audience_level} level learners.\n\n            The outline should include:\n            1. A compelling title for the guide\n            2. An introduction to the topic\n            3. 4-6 main sections that cover the most important aspects of the topic\n            4. A conclusion or summary\n\n            For each section, provide a clear title and a brief description of what it should cover.\n            \"\"\"}\n        ]\n\n        # Make the LLM call with JSON response format\n        response = llm.call(messages=messages)\n\n        # Parse the JSON response\n        outline_dict = json.loads(response)\n        self.state.guide_outline = GuideOutline(**outline_dict)\n\n        # Save the outline to a file\n        with open(\"output/guide_outline.json\", \"w\") as f:\n            json.dump(outline_dict, f, indent=2)\n\n        print(f\"Guide outline created with {len(self.state.guide_outline.sections)} sections\")\n        return self.state.guide_outline\n\n    @listen(create_guide_outline)\n    def write_and_compile_guide(self, outline):\n        \"\"\"Write all sections and compile the guide\"\"\"\n        print(\"Writing guide sections and compiling...\")\n        completed_sections = []\n\n        # Process sections one by one to maintain context flow\n        for section in outline.sections:\n            print(f\"Processing section: {section.title}\")\n\n            # Build context from previous sections\n            previous_sections_text = \"\"\n            if completed_sections:\n                previous_sections_text = \"# Previously Written Sections\\n\\n\"\n                for title in completed_sections:\n                    previous_sections_text += f\"## {title}\\n\\n\"\n                    previous_sections_text += self.state.sections_content.get(title, \"\") + \"\\n\\n\"\n            else:\n                previous_sections_text = \"No previous sections written yet.\"\n\n            # Run the content crew for this section\n            result = ContentCrew().crew().kickoff(inputs={\n                \"section_title\": section.title,\n                \"section_description\": section.description,\n                \"audience_level\": self.state.audience_level,\n                \"previous_sections\": previous_sections_text,\n                \"draft_content\": \"\"\n            })\n\n            # Store the content\n            self.state.sections_content[section.title] = result.raw\n            completed_sections.append(section.title)\n            print(f\"Section completed: {section.title}\")\n\n        # Compile the final guide\n        guide_content = f\"# {outline.title}\\n\\n\"\n        guide_content += f\"## Introduction\\n\\n{outline.introduction}\\n\\n\"\n\n        # Add each section in order\n        for section in outline.sections:\n            section_content = self.state.sections_content.get(section.title, \"\")\n            guide_content += f\"\\n\\n{section_content}\\n\\n\"\n\n        # Add conclusion\n        guide_content += f\"## Conclusion\\n\\n{outline.conclusion}\\n\\n\"\n\n        # Save the guide\n        with open(\"output/complete_guide.md\", \"w\") as f:\n            f.write(guide_content)\n\n        print(\"\\nComplete guide compiled and saved to output/complete_guide.md\")\n        return \"Guide creation completed successfully\"\n\ndef kickoff():\n    \"\"\"Run the guide creator flow\"\"\"\n    GuideCreatorFlow().kickoff()\n    print(\"\\n=== Flow Complete ===\")\n    print(\"Your comprehensive guide is ready in the output directory.\")\n    print(\"Open output/complete_guide.md to view it.\")\n\ndef plot():\n    \"\"\"Generate a visualization of the flow\"\"\"\n    flow = GuideCreatorFlow()\n    flow.plot(\"guide_creator_flow\")\n    print(\"Flow visualization saved to guide_creator_flow.html\")\n\nif __name__ == \"__main__\":\n    kickoff()",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Flow",
          "level": 1
        },
        {
          "title": "Step 5: Create the Flow",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Flow",
            "level": 1
          },
          {
            "title": "Step 5: Create the Flow",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Flow > Step 5: Create the Flow"
      },
      "enhanced_content": "Context: Changelog > Build Your First Flow > Step 5: Create the Flow\n\n#!/usr/bin/env python\nimport json\nfrom typing import List, Dict\nfrom pydantic import BaseModel, Field\nfrom crewai import LLM\nfrom crewai.flow.flow import Flow, listen, start\nfrom guide_creator_flow.crews.content_crew.content_crew import ContentCrew\n\n# Define our models for structured data\nclass Section(BaseModel):\n    title: str = Field(description=\"Title of the section\")\n    description: str = Field(description=\"Brief description of what the section should cover\")\n\nclass GuideOutline(BaseModel):\n    title: str = Field(description=\"Title of the guide\")\n    introduction: str = Field(description=\"Introduction to the topic\")\n    target_audience: str = Field(description=\"Description of the target audience\")\n    sections: List[Section] = Field(description=\"List of sections in the guide\")\n    conclusion: str = Field(description=\"Conclusion or summary of the guide\")\n\n# Define our flow state\nclass GuideCreatorState(BaseModel):\n    topic: str = \"\"\n    audience_level: str = \"\"\n    guide_outline: GuideOutline = None\n    sections_content: Dict[str, str] = {}\n\nclass GuideCreatorFlow(Flow[GuideCreatorState]):\n    \"\"\"Flow for creating a comprehensive guide on any topic\"\"\"\n\n    @start()\n    def get_user_input(self):\n        \"\"\"Get input from the user about the guide topic and audience\"\"\"\n        print(\"\\n=== Create Your Comprehensive Guide ===\\n\")\n\n        # Get user input\n        self.state.topic = input(\"What topic would you like to create a guide for? \")\n\n        # Get audience level with validation\n        while True:\n            audience = input(\"Who is your target audience? (beginner/intermediate/advanced) \").lower()\n            if audience in [\"beginner\", \"intermediate\", \"advanced\"]:\n                self.state.audience_level = audience\n                break\n            print(\"Please enter 'beginner', 'intermediate', or 'advanced'\")\n\n        print(f\"\\nCreating a guide on {self.state.topic} for {self.state.audience_level} audience...\\n\")\n        return self.state\n\n    @listen(get_user_input)\n    def create_guide_outline(self, state):\n        \"\"\"Create a structured outline for the guide using a direct LLM call\"\"\"\n        print(\"Creating guide outline...\")\n\n        # Initialize the LLM\n        llm = LLM(model=\"openai/gpt-4o-mini\", response_format=GuideOutline)\n\n        # Create the messages for the outline\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are a helpful assistant designed to output JSON.\"},\n            {\"role\": \"user\", \"content\": f\"\"\"\n            Create a detailed outline for a comprehensive guide on \"{state.topic}\" for {state.audience_level} level learners.\n\n            The outline should include:\n            1. A compelling title for the guide\n            2. An introduction to the topic\n            3. 4-6 main sections that cover the most important aspects of the topic\n            4. A conclusion or summary\n\n            For each section, provide a clear title and a brief description of what it should cover.\n            \"\"\"}\n        ]\n\n        # Make the LLM call with JSON response format\n        response = llm.call(messages=messages)\n\n        # Parse the JSON response\n        outline_dict = json.loads(response)\n        self.state.guide_outline = GuideOutline(**outline_dict)\n\n        # Save the outline to a file\n        with open(\"output/guide_outline.json\", \"w\") as f:\n            json.dump(outline_dict, f, indent=2)\n\n        print(f\"Guide outline created with {len(self.state.guide_outline.sections)} sections\")\n        return self.state.guide_outline\n\n    @listen(create_guide_outline)\n    def write_and_compile_guide(self, outline):\n        \"\"\"Write all sections and compile the guide\"\"\"\n        print(\"Writing guide sections and compiling...\")\n        completed_sections = []\n\n        # Process sections one by one to maintain context flow\n        for section in outline.sections:\n            print(f\"Processing section: {section.title}\")\n\n            # Build context from previous sections\n            previous_sections_text = \"\"\n            if completed_sections:\n                previous_sections_text = \"# Previously Written Sections\\n\\n\"\n                for title in completed_sections:\n                    previous_sections_text += f\"## {title}\\n\\n\"\n                    previous_sections_text += self.state.sections_content.get(title, \"\") + \"\\n\\n\"\n            else:\n                previous_sections_text = \"No previous sections written yet.\"\n\n            # Run the content crew for this section\n            result = ContentCrew().crew().kickoff(inputs={\n                \"section_title\": section.title,\n                \"section_description\": section.description,\n                \"audience_level\": self.state.audience_level,\n                \"previous_sections\": previous_sections_text,\n                \"draft_content\": \"\"\n            })\n\n            # Store the content\n            self.state.sections_content[section.title] = result.raw\n            completed_sections.append(section.title)\n            print(f\"Section completed: {section.title}\")\n\n        # Compile the final guide\n        guide_content = f\"# {outline.title}\\n\\n\"\n        guide_content += f\"## Introduction\\n\\n{outline.introduction}\\n\\n\"\n\n        # Add each section in order\n        for section in outline.sections:\n            section_content = self.state.sections_content.get(section.title, \"\")\n            guide_content += f\"\\n\\n{section_content}\\n\\n\"\n\n        # Add conclusion\n        guide_content += f\"## Conclusion\\n\\n{outline.conclusion}\\n\\n\"\n\n        # Save the guide\n        with open(\"output/complete_guide.md\", \"w\") as f:\n            f.write(guide_content)\n\n        print(\"\\nComplete guide compiled and saved to output/complete_guide.md\")\n        return \"Guide creation completed successfully\"\n\ndef kickoff():\n    \"\"\"Run the guide creator flow\"\"\"\n    GuideCreatorFlow().kickoff()\n    print(\"\\n=== Flow Complete ===\")\n    print(\"Your comprehensive guide is ready in the output directory.\")\n    print(\"Open output/complete_guide.md to view it.\")\n\ndef plot():\n    \"\"\"Generate a visualization of the flow\"\"\"\n    flow = GuideCreatorFlow()\n    flow.plot(\"guide_creator_flow\")\n    print(\"Flow visualization saved to guide_creator_flow.html\")\n\nif __name__ == \"__main__\":\n    kickoff()",
      "formatted_path": "Changelog > Build Your First Flow > Step 5: Create the Flow",
      "enhanced_text": "Context: Changelog > Build Your First Flow > Step 5: Create the Flow\n\n#!/usr/bin/env python\nimport json\nfrom typing import List, Dict\nfrom pydantic import BaseModel, Field\nfrom crewai import LLM\nfrom crewai.flow.flow import Flow, listen, start\nfrom guide_creator_flow.crews.content_crew.content_crew import ContentCrew\n\n# Define our models for structured data\nclass Section(BaseModel):\n    title: str = Field(description=\"Title of the section\")\n    description: str = Field(description=\"Brief description of what the section should cover\")\n\nclass GuideOutline(BaseModel):\n    title: str = Field(description=\"Title of the guide\")\n    introduction: str = Field(description=\"Introduction to the topic\")\n    target_audience: str = Field(description=\"Description of the target audience\")\n    sections: List[Section] = Field(description=\"List of sections in the guide\")\n    conclusion: str = Field(description=\"Conclusion or summary of the guide\")\n\n# Define our flow state\nclass GuideCreatorState(BaseModel):\n    topic: str = \"\"\n    audience_level: str = \"\"\n    guide_outline: GuideOutline = None\n    sections_content: Dict[str, str] = {}\n\nclass GuideCreatorFlow(Flow[GuideCreatorState]):\n    \"\"\"Flow for creating a comprehensive guide on any topic\"\"\"\n\n    @start()\n    def get_user_input(self):\n        \"\"\"Get input from the user about the guide topic and audience\"\"\"\n        print(\"\\n=== Create Your Comprehensive Guide ===\\n\")\n\n        # Get user input\n        self.state.topic = input(\"What topic would you like to create a guide for? \")\n\n        # Get audience level with validation\n        while True:\n            audience = input(\"Who is your target audience? (beginner/intermediate/advanced) \").lower()\n            if audience in [\"beginner\", \"intermediate\", \"advanced\"]:\n                self.state.audience_level = audience\n                break\n            print(\"Please enter 'beginner', 'intermediate', or 'advanced'\")\n\n        print(f\"\\nCreating a guide on {self.state.topic} for {self.state.audience_level} audience...\\n\")\n        return self.state\n\n    @listen(get_user_input)\n    def create_guide_outline(self, state):\n        \"\"\"Create a structured outline for the guide using a direct LLM call\"\"\"\n        print(\"Creating guide outline...\")\n\n        # Initialize the LLM\n        llm = LLM(model=\"openai/gpt-4o-mini\", response_format=GuideOutline)\n\n        # Create the messages for the outline\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are a helpful assistant designed to output JSON.\"},\n            {\"role\": \"user\", \"content\": f\"\"\"\n            Create a detailed outline for a comprehensive guide on \"{state.topic}\" for {state.audience_level} level learners.\n\n            The outline should include:\n            1. A compelling title for the guide\n            2. An introduction to the topic\n            3. 4-6 main sections that cover the most important aspects of the topic\n            4. A conclusion or summary\n\n            For each section, provide a clear title and a brief description of what it should cover.\n            \"\"\"}\n        ]\n\n        # Make the LLM call with JSON response format\n        response = llm.call(messages=messages)\n\n        # Parse the JSON response\n        outline_dict = json.loads(response)\n        self.state.guide_outline = GuideOutline(**outline_dict)\n\n        # Save the outline to a file\n        with open(\"output/guide_outline.json\", \"w\") as f:\n            json.dump(outline_dict, f, indent=2)\n\n        print(f\"Guide outline created with {len(self.state.guide_outline.sections)} sections\")\n        return self.state.guide_outline\n\n    @listen(create_guide_outline)\n    def write_and_compile_guide(self, outline):\n        \"\"\"Write all sections and compile the guide\"\"\"\n        print(\"Writing guide sections and compiling...\")\n        completed_sections = []\n\n        # Process sections one by one to maintain context flow\n        for section in outline.sections:\n            print(f\"Processing section: {section.title}\")\n\n            # Build context from previous sections\n            previous_sections_text = \"\"\n            if completed_sections:\n                previous_sections_text = \"# Previously Written Sections\\n\\n\"\n                for title in completed_sections:\n                    previous_sections_text += f\"## {title}\\n\\n\"\n                    previous_sections_text += self.state.sections_content.get(title, \"\") + \"\\n\\n\"\n            else:\n                previous_sections_text = \"No previous sections written yet.\"\n\n            # Run the content crew for this section\n            result = ContentCrew().crew().kickoff(inputs={\n                \"section_title\": section.title,\n                \"section_description\": section.description,\n                \"audience_level\": self.state.audience_level,\n                \"previous_sections\": previous_sections_text,\n                \"draft_content\": \"\"\n            })\n\n            # Store the content\n            self.state.sections_content[section.title] = result.raw\n            completed_sections.append(section.title)\n            print(f\"Section completed: {section.title}\")\n\n        # Compile the final guide\n        guide_content = f\"# {outline.title}\\n\\n\"\n        guide_content += f\"## Introduction\\n\\n{outline.introduction}\\n\\n\"\n\n        # Add each section in order\n        for section in outline.sections:\n            section_content = self.state.sections_content.get(section.title, \"\")\n            guide_content += f\"\\n\\n{section_content}\\n\\n\"\n\n        # Add conclusion\n        guide_content += f\"## Conclusion\\n\\n{outline.conclusion}\\n\\n\"\n\n        # Save the guide\n        with open(\"output/complete_guide.md\", \"w\") as f:\n            f.write(guide_content)\n\n        print(\"\\nComplete guide compiled and saved to output/complete_guide.md\")\n        return \"Guide creation completed successfully\"\n\ndef kickoff():\n    \"\"\"Run the guide creator flow\"\"\"\n    GuideCreatorFlow().kickoff()\n    print(\"\\n=== Flow Complete ===\")\n    print(\"Your comprehensive guide is ready in the output directory.\")\n    print(\"Open output/complete_guide.md to view it.\")\n\ndef plot():\n    \"\"\"Generate a visualization of the flow\"\"\"\n    flow = GuideCreatorFlow()\n    flow.plot(\"guide_creator_flow\")\n    print(\"Flow visualization saved to guide_creator_flow.html\")\n\nif __name__ == \"__main__\":\n    kickoff()"
    },
    {
      "content": "OPENAI_API_KEY=your_openai_api_key",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Flow",
          "level": 1
        },
        {
          "title": "Step 6: Set Up Your Environment Variables",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Flow",
            "level": 1
          },
          {
            "title": "Step 6: Set Up Your Environment Variables",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Flow > Step 6: Set Up Your Environment Variables"
      },
      "enhanced_content": "Context: Changelog > Build Your First Flow > Step 6: Set Up Your Environment Variables\n\nOPENAI_API_KEY=your_openai_api_key",
      "formatted_path": "Changelog > Build Your First Flow > Step 6: Set Up Your Environment Variables",
      "enhanced_text": "Context: Changelog > Build Your First Flow > Step 6: Set Up Your Environment Variables\n\nOPENAI_API_KEY=your_openai_api_key"
    },
    {
      "content": "crewai install",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Flow",
          "level": 1
        },
        {
          "title": "Step 7: Install Dependencies",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Flow",
            "level": 1
          },
          {
            "title": "Step 7: Install Dependencies",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Flow > Step 7: Install Dependencies"
      },
      "enhanced_content": "Context: Changelog > Build Your First Flow > Step 7: Install Dependencies\n\ncrewai install",
      "formatted_path": "Changelog > Build Your First Flow > Step 7: Install Dependencies",
      "enhanced_text": "Context: Changelog > Build Your First Flow > Step 7: Install Dependencies\n\ncrewai install"
    },
    {
      "content": "crewai flow kickoff",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Flow",
          "level": 1
        },
        {
          "title": "Step 8: Run Your Flow",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Flow",
            "level": 1
          },
          {
            "title": "Step 8: Run Your Flow",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Flow > Step 8: Run Your Flow"
      },
      "enhanced_content": "Context: Changelog > Build Your First Flow > Step 8: Run Your Flow\n\ncrewai flow kickoff",
      "formatted_path": "Changelog > Build Your First Flow > Step 8: Run Your Flow",
      "enhanced_text": "Context: Changelog > Build Your First Flow > Step 8: Run Your Flow\n\ncrewai flow kickoff"
    },
    {
      "content": "crewai flow plot",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Flow",
          "level": 1
        },
        {
          "title": "Step 9: Visualize Your Flow",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Flow",
            "level": 1
          },
          {
            "title": "Step 9: Visualize Your Flow",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Flow > Step 9: Visualize Your Flow"
      },
      "enhanced_content": "Context: Changelog > Build Your First Flow > Step 9: Visualize Your Flow\n\ncrewai flow plot",
      "formatted_path": "Changelog > Build Your First Flow > Step 9: Visualize Your Flow",
      "enhanced_text": "Context: Changelog > Build Your First Flow > Step 9: Visualize Your Flow\n\ncrewai flow plot"
    },
    {
      "content": "Once the crew completes its work, you'll find the final report in the `output/report.md` file. The report will include: An executive summary Detailed information about the topic Analysis and insights Recommendations or future considerations Take a moment to appreciate what you've accomplished - you've created a system where multiple AI agents collaborated on a complex task, each contributing their specialized skills to produce a result that's greater than what any single agent could achieve alone.\n\nOnce the flow completes, you'll find two files in the `output` directory: `guide_outline.json`: Contains the structured outline of the guide `complete_guide.md`: The comprehensive guide with all sections Take a moment to review these files and appreciate what you've built - a system that combines user input, direct AI interactions, and collaborative agent work to produce a complex, high-quality output.",
      "title": "Step 10: Review the Output",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Flow",
          "level": 1
        },
        {
          "title": "Step 10: Review the Output",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Flow",
            "level": 1
          },
          {
            "title": "Step 10: Review the Output",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Flow > Step 10: Review the Output"
      },
      "enhanced_content": "Context: Changelog > Build Your First Flow > Step 10: Review the Output\n\n## Step 10: Review the Output\n\nOnce the crew completes its work, you'll find the final report in the `output/report.md` file. The report will include: An executive summary Detailed information about the topic Analysis and insights Recommendations or future considerations Take a moment to appreciate what you've accomplished - you've created a system where multiple AI agents collaborated on a complex task, each contributing their specialized skills to produce a result that's greater than what any single agent could achieve alone.\n\nOnce the flow completes, you'll find two files in the `output` directory: `guide_outline.json`: Contains the structured outline of the guide `complete_guide.md`: The comprehensive guide with all sections Take a moment to review these files and appreciate what you've built - a system that combines user input, direct AI interactions, and collaborative agent work to produce a complex, high-quality output.",
      "formatted_path": "Changelog > Build Your First Flow > Step 10: Review the Output",
      "enhanced_text": "Context: Changelog > Build Your First Flow > Step 10: Review the Output\n\n Step 10: Review the Output\n\nOnce the crew completes its work, you'll find the final report in the `output/report.md` file. The report will include: An executive summary Detailed information about the topic Analysis and insights Recommendations or future considerations Take a moment to appreciate what you've accomplished - you've created a system where multiple AI agents collaborated on a complex task, each contributing their specialized skills to produce a result that's greater than what any single agent could achieve alone.\n\nOnce the flow completes, you'll find two files in the `output` directory: `guide_outline.json`: Contains the structured outline of the guide `complete_guide.md`: The comprehensive guide with all sections Take a moment to review these files and appreciate what you've built - a system that combines user input, direct AI interactions, and collaborative agent work to produce a complex, high-quality output."
    },
    {
      "content": "What you've learned in this guide provides a foundation for creating much more sophisticated AI systems. Here are some ways you could extend this basic flow:",
      "title": "The Art of the Possible: Beyond Your First Flow",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Flow",
          "level": 1
        },
        {
          "title": "The Art of the Possible: Beyond Your First Flow",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Flow",
            "level": 1
          },
          {
            "title": "The Art of the Possible: Beyond Your First Flow",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Flow > The Art of the Possible: Beyond Your First Flow"
      },
      "enhanced_content": "Context: Changelog > Build Your First Flow > The Art of the Possible: Beyond Your First Flow\n\n## The Art of the Possible: Beyond Your First Flow\n\nWhat you've learned in this guide provides a foundation for creating much more sophisticated AI systems. Here are some ways you could extend this basic flow:",
      "formatted_path": "Changelog > Build Your First Flow > The Art of the Possible: Beyond Your First Flow",
      "enhanced_text": "Context: Changelog > Build Your First Flow > The Art of the Possible: Beyond Your First Flow\n\n The Art of the Possible: Beyond Your First Flow\n\nWhat you've learned in this guide provides a foundation for creating much more sophisticated AI systems. Here are some ways you could extend this basic flow:"
    },
    {
      "content": "You could create more interactive flows with: Web interfaces for input and output Real-time progress updates Interactive feedback and refinement loops Multi-stage user interactions",
      "title": "Enhancing User Interaction",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Flow",
          "level": 1
        },
        {
          "title": "The Art of the Possible: Beyond Your First Flow",
          "level": 2
        },
        {
          "title": "Enhancing User Interaction",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Flow",
            "level": 1
          },
          {
            "title": "The Art of the Possible: Beyond Your First Flow",
            "level": 2
          },
          {
            "title": "Enhancing User Interaction",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Flow > The Art of the Possible: Beyond Your First Flow > Enhancing User Interaction"
      },
      "enhanced_content": "Context: Changelog > Build Your First Flow > The Art of the Possible: Beyond Your First Flow > Enhancing User Interaction\n\n### Enhancing User Interaction\n\nYou could create more interactive flows with: Web interfaces for input and output Real-time progress updates Interactive feedback and refinement loops Multi-stage user interactions",
      "formatted_path": "Changelog > Build Your First Flow > The Art of the Possible: Beyond Your First Flow > Enhancing User Interaction",
      "enhanced_text": "Context: Changelog > Build Your First Flow > The Art of the Possible: Beyond Your First Flow > Enhancing User Interaction\n\n Enhancing User Interaction\n\nYou could create more interactive flows with: Web interfaces for input and output Real-time progress updates Interactive feedback and refinement loops Multi-stage user interactions"
    },
    {
      "content": "You could expand your flow with additional steps for: Research before outline creation Image generation for illustrations Code snippet generation for technical guides Final quality assurance and fact-checking",
      "title": "Adding More Processing Steps",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Flow",
          "level": 1
        },
        {
          "title": "The Art of the Possible: Beyond Your First Flow",
          "level": 2
        },
        {
          "title": "Adding More Processing Steps",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Flow",
            "level": 1
          },
          {
            "title": "The Art of the Possible: Beyond Your First Flow",
            "level": 2
          },
          {
            "title": "Adding More Processing Steps",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Flow > The Art of the Possible: Beyond Your First Flow > Adding More Processing Steps"
      },
      "enhanced_content": "Context: Changelog > Build Your First Flow > The Art of the Possible: Beyond Your First Flow > Adding More Processing Steps\n\n### Adding More Processing Steps\n\nYou could expand your flow with additional steps for: Research before outline creation Image generation for illustrations Code snippet generation for technical guides Final quality assurance and fact-checking",
      "formatted_path": "Changelog > Build Your First Flow > The Art of the Possible: Beyond Your First Flow > Adding More Processing Steps",
      "enhanced_text": "Context: Changelog > Build Your First Flow > The Art of the Possible: Beyond Your First Flow > Adding More Processing Steps\n\n Adding More Processing Steps\n\nYou could expand your flow with additional steps for: Research before outline creation Image generation for illustrations Code snippet generation for technical guides Final quality assurance and fact-checking"
    },
    {
      "content": "You could implement more sophisticated flow patterns: Conditional branching based on user preferences or content type Parallel processing of independent sections Iterative refinement loops with feedback Integration with external APIs and services",
      "title": "Creating More Complex Flows",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Flow",
          "level": 1
        },
        {
          "title": "The Art of the Possible: Beyond Your First Flow",
          "level": 2
        },
        {
          "title": "Creating More Complex Flows",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Flow",
            "level": 1
          },
          {
            "title": "The Art of the Possible: Beyond Your First Flow",
            "level": 2
          },
          {
            "title": "Creating More Complex Flows",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Flow > The Art of the Possible: Beyond Your First Flow > Creating More Complex Flows"
      },
      "enhanced_content": "Context: Changelog > Build Your First Flow > The Art of the Possible: Beyond Your First Flow > Creating More Complex Flows\n\n### Creating More Complex Flows\n\nYou could implement more sophisticated flow patterns: Conditional branching based on user preferences or content type Parallel processing of independent sections Iterative refinement loops with feedback Integration with external APIs and services",
      "formatted_path": "Changelog > Build Your First Flow > The Art of the Possible: Beyond Your First Flow > Creating More Complex Flows",
      "enhanced_text": "Context: Changelog > Build Your First Flow > The Art of the Possible: Beyond Your First Flow > Creating More Complex Flows\n\n Creating More Complex Flows\n\nYou could implement more sophisticated flow patterns: Conditional branching based on user preferences or content type Parallel processing of independent sections Iterative refinement loops with feedback Integration with external APIs and services\n\nRelated sections:\n- \n"
    },
    {
      "content": "The same patterns can be applied to create crews for: **Content creation**: Writers, editors, fact-checkers, and designers working together **Customer service**: Triage agents, specialists, and quality control working together **Product development**: Researchers, designers, and planners collaborating **Data analysis**: Data collectors, analysts, and visualization specialists\n\nThe same patterns can be applied to create flows for: **Interactive storytelling**: Create personalized stories based on user input **Business intelligence**: Process data, generate insights, and create reports **Product development**: Facilitate ideation, design, and planning **Educational systems**: Create personalized learning experiences",
      "title": "Applying to Different Domains",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Flow",
          "level": 1
        },
        {
          "title": "The Art of the Possible: Beyond Your First Flow",
          "level": 2
        },
        {
          "title": "Applying to Different Domains",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Flow",
            "level": 1
          },
          {
            "title": "The Art of the Possible: Beyond Your First Flow",
            "level": 2
          },
          {
            "title": "Applying to Different Domains",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Flow > The Art of the Possible: Beyond Your First Flow > Applying to Different Domains"
      },
      "enhanced_content": "Context: Changelog > Build Your First Flow > The Art of the Possible: Beyond Your First Flow > Applying to Different Domains\n\n### Applying to Different Domains\n\nThe same patterns can be applied to create crews for: **Content creation**: Writers, editors, fact-checkers, and designers working together **Customer service**: Triage agents, specialists, and quality control working together **Product development**: Researchers, designers, and planners collaborating **Data analysis**: Data collectors, analysts, and visualization specialists\n\nThe same patterns can be applied to create flows for: **Interactive storytelling**: Create personalized stories based on user input **Business intelligence**: Process data, generate insights, and create reports **Product development**: Facilitate ideation, design, and planning **Educational systems**: Create personalized learning experiences",
      "formatted_path": "Changelog > Build Your First Flow > The Art of the Possible: Beyond Your First Flow > Applying to Different Domains",
      "enhanced_text": "Context: Changelog > Build Your First Flow > The Art of the Possible: Beyond Your First Flow > Applying to Different Domains\n\n Applying to Different Domains\n\nThe same patterns can be applied to create crews for: **Content creation**: Writers, editors, fact-checkers, and designers working together **Customer service**: Triage agents, specialists, and quality control working together **Product development**: Researchers, designers, and planners collaborating **Data analysis**: Data collectors, analysts, and visualization specialists\n\nThe same patterns can be applied to create flows for: **Interactive storytelling**: Create personalized stories based on user input **Business intelligence**: Process data, generate insights, and create reports **Product development**: Facilitate ideation, design, and planning **Educational systems**: Create personalized learning experiences"
    },
    {
      "content": "This guide creator flow demonstrates several powerful features of CrewAI: **User interaction**: The flow collects input directly from the user **Direct LLM calls**: Uses the LLM class for efficient, single-purpose AI interactions **Structured data with Pydantic**: Uses Pydantic models to ensure type safety **Sequential processing with context**: Writes sections in order, providing previous sections for context **Multi-agent crews**: Leverages specialized agents (writer and reviewer) for content creation **State management**: Maintains state across different steps of the process **Event-driven architecture**: Uses the `@listen` decorator to respond to events",
      "title": "Key Features Demonstrated",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Flow",
          "level": 1
        },
        {
          "title": "Key Features Demonstrated",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Flow",
            "level": 1
          },
          {
            "title": "Key Features Demonstrated",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Flow > Key Features Demonstrated"
      },
      "enhanced_content": "Context: Changelog > Build Your First Flow > Key Features Demonstrated\n\n## Key Features Demonstrated\n\nThis guide creator flow demonstrates several powerful features of CrewAI: **User interaction**: The flow collects input directly from the user **Direct LLM calls**: Uses the LLM class for efficient, single-purpose AI interactions **Structured data with Pydantic**: Uses Pydantic models to ensure type safety **Sequential processing with context**: Writes sections in order, providing previous sections for context **Multi-agent crews**: Leverages specialized agents (writer and reviewer) for content creation **State management**: Maintains state across different steps of the process **Event-driven architecture**: Uses the `@listen` decorator to respond to events",
      "formatted_path": "Changelog > Build Your First Flow > Key Features Demonstrated",
      "enhanced_text": "Context: Changelog > Build Your First Flow > Key Features Demonstrated\n\n Key Features Demonstrated\n\nThis guide creator flow demonstrates several powerful features of CrewAI: **User interaction**: The flow collects input directly from the user **Direct LLM calls**: Uses the LLM class for efficient, single-purpose AI interactions **Structured data with Pydantic**: Uses Pydantic models to ensure type safety **Sequential processing with context**: Writes sections in order, providing previous sections for context **Multi-agent crews**: Leverages specialized agents (writer and reviewer) for content creation **State management**: Maintains state across different steps of the process **Event-driven architecture**: Uses the `@listen` decorator to respond to events\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "Let's break down the key components of flows to help you understand how to build your own:",
      "title": "Understanding the Flow Structure",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Flow",
          "level": 1
        },
        {
          "title": "Understanding the Flow Structure",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Flow",
            "level": 1
          },
          {
            "title": "Understanding the Flow Structure",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Flow > Understanding the Flow Structure"
      },
      "enhanced_content": "Context: Changelog > Build Your First Flow > Understanding the Flow Structure\n\n## Understanding the Flow Structure\n\nLet's break down the key components of flows to help you understand how to build your own:",
      "formatted_path": "Changelog > Build Your First Flow > Understanding the Flow Structure",
      "enhanced_text": "Context: Changelog > Build Your First Flow > Understanding the Flow Structure\n\n Understanding the Flow Structure\n\nLet's break down the key components of flows to help you understand how to build your own:"
    },
    {
      "content": "llm = LLM(model=\"openai/gpt-4o-mini\", response_format=GuideOutline)\nresponse = llm.call(messages=messages)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Flow",
          "level": 1
        },
        {
          "title": "Understanding the Flow Structure",
          "level": 2
        },
        {
          "title": "1. Direct LLM Calls",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Flow",
            "level": 1
          },
          {
            "title": "Understanding the Flow Structure",
            "level": 2
          },
          {
            "title": "1. Direct LLM Calls",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Flow > Understanding the Flow Structure > 1. Direct LLM Calls"
      },
      "enhanced_content": "Context: Changelog > Build Your First Flow > Understanding the Flow Structure > 1. Direct LLM Calls\n\nllm = LLM(model=\"openai/gpt-4o-mini\", response_format=GuideOutline)\nresponse = llm.call(messages=messages)",
      "formatted_path": "Changelog > Build Your First Flow > Understanding the Flow Structure > 1. Direct LLM Calls",
      "enhanced_text": "Context: Changelog > Build Your First Flow > Understanding the Flow Structure > 1. Direct LLM Calls\n\nllm = LLM(model=\"openai/gpt-4o-mini\", response_format=GuideOutline)\nresponse = llm.call(messages=messages)"
    },
    {
      "content": "@start()\ndef get_user_input(self):\n    # First step in the flow\n    # ...\n\n@listen(get_user_input)\ndef create_guide_outline(self, state):\n    # This runs when get_user_input completes\n    # ...",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Flow",
          "level": 1
        },
        {
          "title": "Understanding the Flow Structure",
          "level": 2
        },
        {
          "title": "2. Event-Driven Architecture",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Flow",
            "level": 1
          },
          {
            "title": "Understanding the Flow Structure",
            "level": 2
          },
          {
            "title": "2. Event-Driven Architecture",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Flow > Understanding the Flow Structure > 2. Event-Driven Architecture"
      },
      "enhanced_content": "Context: Changelog > Build Your First Flow > Understanding the Flow Structure > 2. Event-Driven Architecture\n\n@start()\ndef get_user_input(self):\n    # First step in the flow\n    # ...\n\n@listen(get_user_input)\ndef create_guide_outline(self, state):\n    # This runs when get_user_input completes\n    # ...",
      "formatted_path": "Changelog > Build Your First Flow > Understanding the Flow Structure > 2. Event-Driven Architecture",
      "enhanced_text": "Context: Changelog > Build Your First Flow > Understanding the Flow Structure > 2. Event-Driven Architecture\n\n@start()\ndef get_user_input(self):\n    # First step in the flow\n    # ...\n\n@listen(get_user_input)\ndef create_guide_outline(self, state):\n    # This runs when get_user_input completes\n    # ..."
    },
    {
      "content": "class GuideCreatorState(BaseModel):\n    topic: str = \"\"\n    audience_level: str = \"\"\n    guide_outline: GuideOutline = None\n    sections_content: Dict[str, str] = {}",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Flow",
          "level": 1
        },
        {
          "title": "Understanding the Flow Structure",
          "level": 2
        },
        {
          "title": "3. State Management",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Flow",
            "level": 1
          },
          {
            "title": "Understanding the Flow Structure",
            "level": 2
          },
          {
            "title": "3. State Management",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Flow > Understanding the Flow Structure > 3. State Management"
      },
      "enhanced_content": "Context: Changelog > Build Your First Flow > Understanding the Flow Structure > 3. State Management\n\nclass GuideCreatorState(BaseModel):\n    topic: str = \"\"\n    audience_level: str = \"\"\n    guide_outline: GuideOutline = None\n    sections_content: Dict[str, str] = {}",
      "formatted_path": "Changelog > Build Your First Flow > Understanding the Flow Structure > 3. State Management",
      "enhanced_text": "Context: Changelog > Build Your First Flow > Understanding the Flow Structure > 3. State Management\n\nclass GuideCreatorState(BaseModel):\n    topic: str = \"\"\n    audience_level: str = \"\"\n    guide_outline: GuideOutline = None\n    sections_content: Dict[str, str] = {}"
    },
    {
      "content": "result = ContentCrew().crew().kickoff(inputs={\n    \"section_title\": section.title,\n    # ...\n})",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Build Your First Flow",
          "level": 1
        },
        {
          "title": "Understanding the Flow Structure",
          "level": 2
        },
        {
          "title": "4. Crew Integration",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Build Your First Flow",
            "level": 1
          },
          {
            "title": "Understanding the Flow Structure",
            "level": 2
          },
          {
            "title": "4. Crew Integration",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Build Your First Flow > Understanding the Flow Structure > 4. Crew Integration"
      },
      "enhanced_content": "Context: Changelog > Build Your First Flow > Understanding the Flow Structure > 4. Crew Integration\n\nresult = ContentCrew().crew().kickoff(inputs={\n    \"section_title\": section.title,\n    # ...\n})",
      "formatted_path": "Changelog > Build Your First Flow > Understanding the Flow Structure > 4. Crew Integration",
      "enhanced_text": "Context: Changelog > Build Your First Flow > Understanding the Flow Structure > 4. Crew Integration\n\nresult = ContentCrew().crew().kickoff(inputs={\n    \"section_title\": section.title,\n    # ...\n})"
    },
    {
      "content": "Source: https://docs.crewai.com/guides/flows/mastering-flow-state A comprehensive guide to managing, persisting, and leveraging state in CrewAI Flows for building robust AI applications.",
      "title": "Mastering Flow State Management",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Mastering Flow State Management",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Mastering Flow State Management",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Mastering Flow State Management"
      },
      "enhanced_content": "Context: Changelog > Mastering Flow State Management\n\n# Mastering Flow State Management\n\nSource: https://docs.crewai.com/guides/flows/mastering-flow-state A comprehensive guide to managing, persisting, and leveraging state in CrewAI Flows for building robust AI applications.",
      "formatted_path": "Changelog > Mastering Flow State Management",
      "enhanced_text": "Context: Changelog > Mastering Flow State Management\n\n Mastering Flow State Management\n\nSource: https://docs.crewai.com/guides/flows/mastering-flow-state A comprehensive guide to managing, persisting, and leveraging state in CrewAI Flows for building robust AI applications.\n\nRelated sections:\n- \n"
    },
    {
      "content": "State management is the backbone of any sophisticated AI workflow. In CrewAI Flows, the state system allows you to maintain context, share data between steps, and build complex application logic. Mastering state management is essential for creating reliable, maintainable, and powerful AI applications. This guide will walk you through everything you need to know about managing state in CrewAI Flows, from basic concepts to advanced techniques, with practical code examples along the way.",
      "title": "Understanding the Power of State in Flows",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Mastering Flow State Management",
          "level": 1
        },
        {
          "title": "Understanding the Power of State in Flows",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Mastering Flow State Management",
            "level": 1
          },
          {
            "title": "Understanding the Power of State in Flows",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Mastering Flow State Management > Understanding the Power of State in Flows"
      },
      "enhanced_content": "Context: Changelog > Mastering Flow State Management > Understanding the Power of State in Flows\n\n## Understanding the Power of State in Flows\n\nState management is the backbone of any sophisticated AI workflow. In CrewAI Flows, the state system allows you to maintain context, share data between steps, and build complex application logic. Mastering state management is essential for creating reliable, maintainable, and powerful AI applications. This guide will walk you through everything you need to know about managing state in CrewAI Flows, from basic concepts to advanced techniques, with practical code examples along the way.",
      "formatted_path": "Changelog > Mastering Flow State Management > Understanding the Power of State in Flows",
      "enhanced_text": "Context: Changelog > Mastering Flow State Management > Understanding the Power of State in Flows\n\n Understanding the Power of State in Flows\n\nState management is the backbone of any sophisticated AI workflow. In CrewAI Flows, the state system allows you to maintain context, share data between steps, and build complex application logic. Mastering state management is essential for creating reliable, maintainable, and powerful AI applications. This guide will walk you through everything you need to know about managing state in CrewAI Flows, from basic concepts to advanced techniques, with practical code examples along the way.\n\nRelated sections:\n- \n"
    },
    {
      "content": "Effective state management enables you to: **Maintain context across execution steps** - Pass information seamlessly between different stages of your workflow **Build complex conditional logic** - Make decisions based on accumulated data **Create persistent applications** - Save and restore workflow progress **Handle errors gracefully** - Implement recovery patterns for more robust applications **Scale your applications** - Support complex workflows with proper data organization **Enable conversational applications** - Store and access conversation history for context-aware AI interactions Let's explore how to leverage these capabilities effectively.",
      "title": "Why State Management Matters",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Mastering Flow State Management",
          "level": 1
        },
        {
          "title": "Understanding the Power of State in Flows",
          "level": 2
        },
        {
          "title": "Why State Management Matters",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Mastering Flow State Management",
            "level": 1
          },
          {
            "title": "Understanding the Power of State in Flows",
            "level": 2
          },
          {
            "title": "Why State Management Matters",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Mastering Flow State Management > Understanding the Power of State in Flows > Why State Management Matters"
      },
      "enhanced_content": "Context: Changelog > Mastering Flow State Management > Understanding the Power of State in Flows > Why State Management Matters\n\n### Why State Management Matters\n\nEffective state management enables you to: **Maintain context across execution steps** - Pass information seamlessly between different stages of your workflow **Build complex conditional logic** - Make decisions based on accumulated data **Create persistent applications** - Save and restore workflow progress **Handle errors gracefully** - Implement recovery patterns for more robust applications **Scale your applications** - Support complex workflows with proper data organization **Enable conversational applications** - Store and access conversation history for context-aware AI interactions Let's explore how to leverage these capabilities effectively.",
      "formatted_path": "Changelog > Mastering Flow State Management > Understanding the Power of State in Flows > Why State Management Matters",
      "enhanced_text": "Context: Changelog > Mastering Flow State Management > Understanding the Power of State in Flows > Why State Management Matters\n\n Why State Management Matters\n\nEffective state management enables you to: **Maintain context across execution steps** - Pass information seamlessly between different stages of your workflow **Build complex conditional logic** - Make decisions based on accumulated data **Create persistent applications** - Save and restore workflow progress **Handle errors gracefully** - Implement recovery patterns for more robust applications **Scale your applications** - Support complex workflows with proper data organization **Enable conversational applications** - Store and access conversation history for context-aware AI interactions Let's explore how to leverage these capabilities effectively."
    },
    {
      "content": "In CrewAI Flows, the state follows a predictable lifecycle: **Initialization** - When a flow is created, its state is initialized (either as an empty dictionary or a Pydantic model instance) **Modification** - Flow methods access and modify the state as they execute **Transmission** - State is passed automatically between flow methods **Persistence** (optional) - State can be saved to storage and later retrieved **Completion** - The final state reflects the cumulative changes from all executed methods Understanding this lifecycle is crucial for designing effective flows.",
      "title": "The Flow State Lifecycle",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Mastering Flow State Management",
          "level": 1
        },
        {
          "title": "State Management Fundamentals",
          "level": 2
        },
        {
          "title": "The Flow State Lifecycle",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Mastering Flow State Management",
            "level": 1
          },
          {
            "title": "State Management Fundamentals",
            "level": 2
          },
          {
            "title": "The Flow State Lifecycle",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Mastering Flow State Management > State Management Fundamentals > The Flow State Lifecycle"
      },
      "enhanced_content": "Context: Changelog > Mastering Flow State Management > State Management Fundamentals > The Flow State Lifecycle\n\n### The Flow State Lifecycle\n\nIn CrewAI Flows, the state follows a predictable lifecycle: **Initialization** - When a flow is created, its state is initialized (either as an empty dictionary or a Pydantic model instance) **Modification** - Flow methods access and modify the state as they execute **Transmission** - State is passed automatically between flow methods **Persistence** (optional) - State can be saved to storage and later retrieved **Completion** - The final state reflects the cumulative changes from all executed methods Understanding this lifecycle is crucial for designing effective flows.",
      "formatted_path": "Changelog > Mastering Flow State Management > State Management Fundamentals > The Flow State Lifecycle",
      "enhanced_text": "Context: Changelog > Mastering Flow State Management > State Management Fundamentals > The Flow State Lifecycle\n\n The Flow State Lifecycle\n\nIn CrewAI Flows, the state follows a predictable lifecycle: **Initialization** - When a flow is created, its state is initialized (either as an empty dictionary or a Pydantic model instance) **Modification** - Flow methods access and modify the state as they execute **Transmission** - State is passed automatically between flow methods **Persistence** (optional) - State can be saved to storage and later retrieved **Completion** - The final state reflects the cumulative changes from all executed methods Understanding this lifecycle is crucial for designing effective flows."
    },
    {
      "content": "CrewAI offers two ways to manage state in your flows: **Unstructured State** - Using dictionary-like objects for flexibility **Structured State** - Using Pydantic models for type safety and validation Let's examine each approach in detail.",
      "title": "Two Approaches to State Management",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Mastering Flow State Management",
          "level": 1
        },
        {
          "title": "State Management Fundamentals",
          "level": 2
        },
        {
          "title": "Two Approaches to State Management",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Mastering Flow State Management",
            "level": 1
          },
          {
            "title": "State Management Fundamentals",
            "level": 2
          },
          {
            "title": "Two Approaches to State Management",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Mastering Flow State Management > State Management Fundamentals > Two Approaches to State Management"
      },
      "enhanced_content": "Context: Changelog > Mastering Flow State Management > State Management Fundamentals > Two Approaches to State Management\n\n### Two Approaches to State Management\n\nCrewAI offers two ways to manage state in your flows: **Unstructured State** - Using dictionary-like objects for flexibility **Structured State** - Using Pydantic models for type safety and validation Let's examine each approach in detail.",
      "formatted_path": "Changelog > Mastering Flow State Management > State Management Fundamentals > Two Approaches to State Management",
      "enhanced_text": "Context: Changelog > Mastering Flow State Management > State Management Fundamentals > Two Approaches to State Management\n\n Two Approaches to State Management\n\nCrewAI offers two ways to manage state in your flows: **Unstructured State** - Using dictionary-like objects for flexibility **Structured State** - Using Pydantic models for type safety and validation Let's examine each approach in detail."
    },
    {
      "content": "from crewai.flow.flow import Flow, listen, start\n\nclass UnstructuredExampleFlow(Flow):\n\n    @start()\n    def first_method(self):\n        # The state automatically includes an 'id' field\n        print(f\"State ID: {self.state['id']}\")\n        self.state['counter'] = 0\n        self.state['message'] = \"Hello from structured flow\"\n\n    @listen(first_method)\n    def second_method(self):\n        self.state['counter'] += 1\n        self.state['message'] += \" - updated\"\n\n    @listen(second_method)\n    def third_method(self):\n        self.state['counter'] += 1\n        self.state['message'] += \" - updated again\"\n\n        print(f\"State after third_method: {self.state}\")\n\n\nflow = UnstructuredExampleFlow()\nflow.kickoff()",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Mastering Flow State Management",
          "level": 1
        },
        {
          "title": "Unstructured State Management",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Mastering Flow State Management",
            "level": 1
          },
          {
            "title": "Unstructured State Management",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Mastering Flow State Management > Unstructured State Management"
      },
      "enhanced_content": "Context: Changelog > Mastering Flow State Management > Unstructured State Management\n\nfrom crewai.flow.flow import Flow, listen, start\n\nclass UnstructuredExampleFlow(Flow):\n\n    @start()\n    def first_method(self):\n        # The state automatically includes an 'id' field\n        print(f\"State ID: {self.state['id']}\")\n        self.state['counter'] = 0\n        self.state['message'] = \"Hello from structured flow\"\n\n    @listen(first_method)\n    def second_method(self):\n        self.state['counter'] += 1\n        self.state['message'] += \" - updated\"\n\n    @listen(second_method)\n    def third_method(self):\n        self.state['counter'] += 1\n        self.state['message'] += \" - updated again\"\n\n        print(f\"State after third_method: {self.state}\")\n\n\nflow = UnstructuredExampleFlow()\nflow.kickoff()",
      "formatted_path": "Changelog > Mastering Flow State Management > Unstructured State Management",
      "enhanced_text": "Context: Changelog > Mastering Flow State Management > Unstructured State Management\n\nfrom crewai.flow.flow import Flow, listen, start\n\nclass UnstructuredExampleFlow(Flow):\n\n    @start()\n    def first_method(self):\n        # The state automatically includes an 'id' field\n        print(f\"State ID: {self.state['id']}\")\n        self.state['counter'] = 0\n        self.state['message'] = \"Hello from structured flow\"\n\n    @listen(first_method)\n    def second_method(self):\n        self.state['counter'] += 1\n        self.state['message'] += \" - updated\"\n\n    @listen(second_method)\n    def third_method(self):\n        self.state['counter'] += 1\n        self.state['message'] += \" - updated again\"\n\n        print(f\"State after third_method: {self.state}\")\n\n\nflow = UnstructuredExampleFlow()\nflow.kickoff()"
    },
    {
      "content": "Unstructured state is ideal for: Quick prototyping and simple flows Dynamically evolving state needs Cases where the structure may not be known in advance Flows with simple state requirements While flexible, unstructured state lacks type checking and schema validation, which can lead to errors in complex applications.",
      "title": "When to Use Unstructured State",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Mastering Flow State Management",
          "level": 1
        },
        {
          "title": "Unstructured State Management",
          "level": 2
        },
        {
          "title": "When to Use Unstructured State",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Mastering Flow State Management",
            "level": 1
          },
          {
            "title": "Unstructured State Management",
            "level": 2
          },
          {
            "title": "When to Use Unstructured State",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Mastering Flow State Management > Unstructured State Management > When to Use Unstructured State"
      },
      "enhanced_content": "Context: Changelog > Mastering Flow State Management > Unstructured State Management > When to Use Unstructured State\n\n### When to Use Unstructured State\n\nUnstructured state is ideal for: Quick prototyping and simple flows Dynamically evolving state needs Cases where the structure may not be known in advance Flows with simple state requirements While flexible, unstructured state lacks type checking and schema validation, which can lead to errors in complex applications.",
      "formatted_path": "Changelog > Mastering Flow State Management > Unstructured State Management > When to Use Unstructured State",
      "enhanced_text": "Context: Changelog > Mastering Flow State Management > Unstructured State Management > When to Use Unstructured State\n\n When to Use Unstructured State\n\nUnstructured state is ideal for: Quick prototyping and simple flows Dynamically evolving state needs Cases where the structure may not be known in advance Flows with simple state requirements While flexible, unstructured state lacks type checking and schema validation, which can lead to errors in complex applications."
    },
    {
      "content": "from crewai.flow.flow import Flow, listen, start\nfrom pydantic import BaseModel\n\n\nclass ExampleState(BaseModel):\n    # Note: 'id' field is automatically added to all states\n    counter: int = 0\n    message: str = \"\"\n\n\nclass StructuredExampleFlow(Flow[ExampleState]):\n\n    @start()\n    def first_method(self):\n        # Access the auto-generated ID if needed\n        print(f\"State ID: {self.state.id}\")\n        self.state.message = \"Hello from structured flow\"\n\n    @listen(first_method)\n    def second_method(self):\n        self.state.counter += 1\n        self.state.message += \" - updated\"\n\n    @listen(second_method)\n    def third_method(self):\n        self.state.counter += 1\n        self.state.message += \" - updated again\"\n\n        print(f\"State after third_method: {self.state}\")\n\n\nflow = StructuredExampleFlow()\nflow.kickoff()",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Mastering Flow State Management",
          "level": 1
        },
        {
          "title": "Structured State Management",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Mastering Flow State Management",
            "level": 1
          },
          {
            "title": "Structured State Management",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Mastering Flow State Management > Structured State Management"
      },
      "enhanced_content": "Context: Changelog > Mastering Flow State Management > Structured State Management\n\nfrom crewai.flow.flow import Flow, listen, start\nfrom pydantic import BaseModel\n\n\nclass ExampleState(BaseModel):\n    # Note: 'id' field is automatically added to all states\n    counter: int = 0\n    message: str = \"\"\n\n\nclass StructuredExampleFlow(Flow[ExampleState]):\n\n    @start()\n    def first_method(self):\n        # Access the auto-generated ID if needed\n        print(f\"State ID: {self.state.id}\")\n        self.state.message = \"Hello from structured flow\"\n\n    @listen(first_method)\n    def second_method(self):\n        self.state.counter += 1\n        self.state.message += \" - updated\"\n\n    @listen(second_method)\n    def third_method(self):\n        self.state.counter += 1\n        self.state.message += \" - updated again\"\n\n        print(f\"State after third_method: {self.state}\")\n\n\nflow = StructuredExampleFlow()\nflow.kickoff()",
      "formatted_path": "Changelog > Mastering Flow State Management > Structured State Management",
      "enhanced_text": "Context: Changelog > Mastering Flow State Management > Structured State Management\n\nfrom crewai.flow.flow import Flow, listen, start\nfrom pydantic import BaseModel\n\n\nclass ExampleState(BaseModel):\n    # Note: 'id' field is automatically added to all states\n    counter: int = 0\n    message: str = \"\"\n\n\nclass StructuredExampleFlow(Flow[ExampleState]):\n\n    @start()\n    def first_method(self):\n        # Access the auto-generated ID if needed\n        print(f\"State ID: {self.state.id}\")\n        self.state.message = \"Hello from structured flow\"\n\n    @listen(first_method)\n    def second_method(self):\n        self.state.counter += 1\n        self.state.message += \" - updated\"\n\n    @listen(second_method)\n    def third_method(self):\n        self.state.counter += 1\n        self.state.message += \" - updated again\"\n\n        print(f\"State after third_method: {self.state}\")\n\n\nflow = StructuredExampleFlow()\nflow.kickoff()"
    },
    {
      "content": "from crewai.flow.flow import Flow, listen, start\n\nclass UnstructuredStateFlow(Flow):\n    @start()\n    def initialize_data(self):\n        print(\"Initializing flow data\")\n        # Add key-value pairs to state\n        self.state[\"user_name\"] = \"Alex\"\n        self.state[\"preferences\"] = {\n            \"theme\": \"dark\",\n            \"language\": \"English\"\n        }\n        self.state[\"items\"] = []\n\n        # The flow state automatically gets a unique ID\n        print(f\"Flow ID: {self.state['id']}\")\n\n        return \"Initialized\"\n\n    @listen(initialize_data)\n    def process_data(self, previous_result):\n        print(f\"Previous step returned: {previous_result}\")\n\n        # Access and modify state\n        user = self.state[\"user_name\"]\n        print(f\"Processing data for {user}\")\n\n        # Add items to a list in state\n        self.state[\"items\"].append(\"item1\")\n        self.state[\"items\"].append(\"item2\")\n\n        # Add a new key-value pair\n        self.state[\"processed\"] = True\n\n        return \"Processed\"\n\n    @listen(process_data)\n    def generate_summary(self, previous_result):\n        # Access multiple state values\n        user = self.state[\"user_name\"]\n        theme = self.state[\"preferences\"][\"theme\"]\n        items = self.state[\"items\"]\n        processed = self.state.get(\"processed\", False)\n\n        summary = f\"User {user} has {len(items)} items with {theme} theme. \"\n        summary += \"Data is processed.\" if processed else \"Data is not processed.\"\n\n        return summary\n\n# Run the flow\nflow = UnstructuredStateFlow()\nresult = flow.kickoff()\nprint(f\"Final result: {result}\")\nprint(f\"Final state: {flow.state}\")",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Mastering Flow State Management",
          "level": 1
        },
        {
          "title": "Structured State Management",
          "level": 2
        },
        {
          "title": "Basic Example",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Mastering Flow State Management",
            "level": 1
          },
          {
            "title": "Structured State Management",
            "level": 2
          },
          {
            "title": "Basic Example",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Mastering Flow State Management > Structured State Management > Basic Example"
      },
      "enhanced_content": "Context: Changelog > Mastering Flow State Management > Structured State Management > Basic Example\n\nfrom crewai.flow.flow import Flow, listen, start\n\nclass UnstructuredStateFlow(Flow):\n    @start()\n    def initialize_data(self):\n        print(\"Initializing flow data\")\n        # Add key-value pairs to state\n        self.state[\"user_name\"] = \"Alex\"\n        self.state[\"preferences\"] = {\n            \"theme\": \"dark\",\n            \"language\": \"English\"\n        }\n        self.state[\"items\"] = []\n\n        # The flow state automatically gets a unique ID\n        print(f\"Flow ID: {self.state['id']}\")\n\n        return \"Initialized\"\n\n    @listen(initialize_data)\n    def process_data(self, previous_result):\n        print(f\"Previous step returned: {previous_result}\")\n\n        # Access and modify state\n        user = self.state[\"user_name\"]\n        print(f\"Processing data for {user}\")\n\n        # Add items to a list in state\n        self.state[\"items\"].append(\"item1\")\n        self.state[\"items\"].append(\"item2\")\n\n        # Add a new key-value pair\n        self.state[\"processed\"] = True\n\n        return \"Processed\"\n\n    @listen(process_data)\n    def generate_summary(self, previous_result):\n        # Access multiple state values\n        user = self.state[\"user_name\"]\n        theme = self.state[\"preferences\"][\"theme\"]\n        items = self.state[\"items\"]\n        processed = self.state.get(\"processed\", False)\n\n        summary = f\"User {user} has {len(items)} items with {theme} theme. \"\n        summary += \"Data is processed.\" if processed else \"Data is not processed.\"\n\n        return summary\n\n# Run the flow\nflow = UnstructuredStateFlow()\nresult = flow.kickoff()\nprint(f\"Final result: {result}\")\nprint(f\"Final state: {flow.state}\")",
      "formatted_path": "Changelog > Mastering Flow State Management > Structured State Management > Basic Example",
      "enhanced_text": "Context: Changelog > Mastering Flow State Management > Structured State Management > Basic Example\n\nfrom crewai.flow.flow import Flow, listen, start\n\nclass UnstructuredStateFlow(Flow):\n    @start()\n    def initialize_data(self):\n        print(\"Initializing flow data\")\n        # Add key-value pairs to state\n        self.state[\"user_name\"] = \"Alex\"\n        self.state[\"preferences\"] = {\n            \"theme\": \"dark\",\n            \"language\": \"English\"\n        }\n        self.state[\"items\"] = []\n\n        # The flow state automatically gets a unique ID\n        print(f\"Flow ID: {self.state['id']}\")\n\n        return \"Initialized\"\n\n    @listen(initialize_data)\n    def process_data(self, previous_result):\n        print(f\"Previous step returned: {previous_result}\")\n\n        # Access and modify state\n        user = self.state[\"user_name\"]\n        print(f\"Processing data for {user}\")\n\n        # Add items to a list in state\n        self.state[\"items\"].append(\"item1\")\n        self.state[\"items\"].append(\"item2\")\n\n        # Add a new key-value pair\n        self.state[\"processed\"] = True\n\n        return \"Processed\"\n\n    @listen(process_data)\n    def generate_summary(self, previous_result):\n        # Access multiple state values\n        user = self.state[\"user_name\"]\n        theme = self.state[\"preferences\"][\"theme\"]\n        items = self.state[\"items\"]\n        processed = self.state.get(\"processed\", False)\n\n        summary = f\"User {user} has {len(items)} items with {theme} theme. \"\n        summary += \"Data is processed.\" if processed else \"Data is not processed.\"\n\n        return summary\n\n# Run the flow\nflow = UnstructuredStateFlow()\nresult = flow.kickoff()\nprint(f\"Final result: {result}\")\nprint(f\"Final state: {flow.state}\")"
    },
    {
      "content": "from crewai.flow.flow import Flow, listen, start\nfrom pydantic import BaseModel, Field\nfrom typing import List, Dict, Optional\n\n# Define your state model\nclass UserPreferences(BaseModel):\n    theme: str = \"light\"\n    language: str = \"English\"\n\nclass AppState(BaseModel):\n    user_name: str = \"\"\n    preferences: UserPreferences = UserPreferences()\n    items: List[str] = []\n    processed: bool = False\n    completion_percentage: float = 0.0\n\n# Create a flow with typed state\nclass StructuredStateFlow(Flow[AppState]):\n    @start()\n    def initialize_data(self):\n        print(\"Initializing flow data\")\n        # Set state values (type-checked)\n        self.state.user_name = \"Taylor\"\n        self.state.preferences.theme = \"dark\"\n\n        # The ID field is automatically available\n        print(f\"Flow ID: {self.state.id}\")\n\n        return \"Initialized\"\n\n    @listen(initialize_data)\n    def process_data(self, previous_result):\n        print(f\"Processing data for {self.state.user_name}\")\n\n        # Modify state (with type checking)\n        self.state.items.append(\"item1\")\n        self.state.items.append(\"item2\")\n        self.state.processed = True\n        self.state.completion_percentage = 50.0\n\n        return \"Processed\"\n\n    @listen(process_data)\n    def generate_summary(self, previous_result):\n        # Access state (with autocompletion)\n        summary = f\"User {self.state.user_name} has {len(self.state.items)} items \"\n        summary += f\"with {self.state.preferences.theme} theme. \"\n        summary += \"Data is processed.\" if self.state.processed else \"Data is not processed.\"\n        summary += f\" Completion: {self.state.completion_percentage}%\"\n\n        return summary\n\n# Run the flow\nflow = StructuredStateFlow()\nresult = flow.kickoff()\nprint(f\"Final result: {result}\")\nprint(f\"Final state: {flow.state}\")",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Mastering Flow State Management",
          "level": 1
        },
        {
          "title": "Structured State Management",
          "level": 2
        },
        {
          "title": "Basic Example",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Mastering Flow State Management",
            "level": 1
          },
          {
            "title": "Structured State Management",
            "level": 2
          },
          {
            "title": "Basic Example",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Mastering Flow State Management > Structured State Management > Basic Example"
      },
      "enhanced_content": "Context: Changelog > Mastering Flow State Management > Structured State Management > Basic Example\n\nfrom crewai.flow.flow import Flow, listen, start\nfrom pydantic import BaseModel, Field\nfrom typing import List, Dict, Optional\n\n# Define your state model\nclass UserPreferences(BaseModel):\n    theme: str = \"light\"\n    language: str = \"English\"\n\nclass AppState(BaseModel):\n    user_name: str = \"\"\n    preferences: UserPreferences = UserPreferences()\n    items: List[str] = []\n    processed: bool = False\n    completion_percentage: float = 0.0\n\n# Create a flow with typed state\nclass StructuredStateFlow(Flow[AppState]):\n    @start()\n    def initialize_data(self):\n        print(\"Initializing flow data\")\n        # Set state values (type-checked)\n        self.state.user_name = \"Taylor\"\n        self.state.preferences.theme = \"dark\"\n\n        # The ID field is automatically available\n        print(f\"Flow ID: {self.state.id}\")\n\n        return \"Initialized\"\n\n    @listen(initialize_data)\n    def process_data(self, previous_result):\n        print(f\"Processing data for {self.state.user_name}\")\n\n        # Modify state (with type checking)\n        self.state.items.append(\"item1\")\n        self.state.items.append(\"item2\")\n        self.state.processed = True\n        self.state.completion_percentage = 50.0\n\n        return \"Processed\"\n\n    @listen(process_data)\n    def generate_summary(self, previous_result):\n        # Access state (with autocompletion)\n        summary = f\"User {self.state.user_name} has {len(self.state.items)} items \"\n        summary += f\"with {self.state.preferences.theme} theme. \"\n        summary += \"Data is processed.\" if self.state.processed else \"Data is not processed.\"\n        summary += f\" Completion: {self.state.completion_percentage}%\"\n\n        return summary\n\n# Run the flow\nflow = StructuredStateFlow()\nresult = flow.kickoff()\nprint(f\"Final result: {result}\")\nprint(f\"Final state: {flow.state}\")",
      "formatted_path": "Changelog > Mastering Flow State Management > Structured State Management > Basic Example",
      "enhanced_text": "Context: Changelog > Mastering Flow State Management > Structured State Management > Basic Example\n\nfrom crewai.flow.flow import Flow, listen, start\nfrom pydantic import BaseModel, Field\nfrom typing import List, Dict, Optional\n\n# Define your state model\nclass UserPreferences(BaseModel):\n    theme: str = \"light\"\n    language: str = \"English\"\n\nclass AppState(BaseModel):\n    user_name: str = \"\"\n    preferences: UserPreferences = UserPreferences()\n    items: List[str] = []\n    processed: bool = False\n    completion_percentage: float = 0.0\n\n# Create a flow with typed state\nclass StructuredStateFlow(Flow[AppState]):\n    @start()\n    def initialize_data(self):\n        print(\"Initializing flow data\")\n        # Set state values (type-checked)\n        self.state.user_name = \"Taylor\"\n        self.state.preferences.theme = \"dark\"\n\n        # The ID field is automatically available\n        print(f\"Flow ID: {self.state.id}\")\n\n        return \"Initialized\"\n\n    @listen(initialize_data)\n    def process_data(self, previous_result):\n        print(f\"Processing data for {self.state.user_name}\")\n\n        # Modify state (with type checking)\n        self.state.items.append(\"item1\")\n        self.state.items.append(\"item2\")\n        self.state.processed = True\n        self.state.completion_percentage = 50.0\n\n        return \"Processed\"\n\n    @listen(process_data)\n    def generate_summary(self, previous_result):\n        # Access state (with autocompletion)\n        summary = f\"User {self.state.user_name} has {len(self.state.items)} items \"\n        summary += f\"with {self.state.preferences.theme} theme. \"\n        summary += \"Data is processed.\" if self.state.processed else \"Data is not processed.\"\n        summary += f\" Completion: {self.state.completion_percentage}%\"\n\n        return summary\n\n# Run the flow\nflow = StructuredStateFlow()\nresult = flow.kickoff()\nprint(f\"Final result: {result}\")\nprint(f\"Final state: {flow.state}\")"
    },
    {
      "content": "Using structured state provides several advantages: **Type Safety** - Catch type errors at development time **Self-Documentation** - The state model clearly documents what data is available **Validation** - Automatic validation of data types and constraints **IDE Support** - Get autocomplete and inline documentation **Default Values** - Easily define fallbacks for missing data",
      "title": "Benefits of Structured State",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Mastering Flow State Management",
          "level": 1
        },
        {
          "title": "Structured State Management",
          "level": 2
        },
        {
          "title": "Benefits of Structured State",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Mastering Flow State Management",
            "level": 1
          },
          {
            "title": "Structured State Management",
            "level": 2
          },
          {
            "title": "Benefits of Structured State",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Mastering Flow State Management > Structured State Management > Benefits of Structured State"
      },
      "enhanced_content": "Context: Changelog > Mastering Flow State Management > Structured State Management > Benefits of Structured State\n\n### Benefits of Structured State\n\nUsing structured state provides several advantages: **Type Safety** - Catch type errors at development time **Self-Documentation** - The state model clearly documents what data is available **Validation** - Automatic validation of data types and constraints **IDE Support** - Get autocomplete and inline documentation **Default Values** - Easily define fallbacks for missing data",
      "formatted_path": "Changelog > Mastering Flow State Management > Structured State Management > Benefits of Structured State",
      "enhanced_text": "Context: Changelog > Mastering Flow State Management > Structured State Management > Benefits of Structured State\n\n Benefits of Structured State\n\nUsing structured state provides several advantages: **Type Safety** - Catch type errors at development time **Self-Documentation** - The state model clearly documents what data is available **Validation** - Automatic validation of data types and constraints **IDE Support** - Get autocomplete and inline documentation **Default Values** - Easily define fallbacks for missing data"
    },
    {
      "content": "Structured state is recommended for: Complex flows with well-defined data schemas Team projects where multiple developers work on the same code Applications where data validation is important Flows that need to enforce specific data types and constraints",
      "title": "When to Use Structured State",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Mastering Flow State Management",
          "level": 1
        },
        {
          "title": "Structured State Management",
          "level": 2
        },
        {
          "title": "When to Use Structured State",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Mastering Flow State Management",
            "level": 1
          },
          {
            "title": "Structured State Management",
            "level": 2
          },
          {
            "title": "When to Use Structured State",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Mastering Flow State Management > Structured State Management > When to Use Structured State"
      },
      "enhanced_content": "Context: Changelog > Mastering Flow State Management > Structured State Management > When to Use Structured State\n\n### When to Use Structured State\n\nStructured state is recommended for: Complex flows with well-defined data schemas Team projects where multiple developers work on the same code Applications where data validation is important Flows that need to enforce specific data types and constraints",
      "formatted_path": "Changelog > Mastering Flow State Management > Structured State Management > When to Use Structured State",
      "enhanced_text": "Context: Changelog > Mastering Flow State Management > Structured State Management > When to Use Structured State\n\n When to Use Structured State\n\nStructured state is recommended for: Complex flows with well-defined data schemas Team projects where multiple developers work on the same code Applications where data validation is important Flows that need to enforce specific data types and constraints"
    },
    {
      "content": "Both unstructured and structured states automatically receive a unique identifier (UUID) to help track and manage state instances.",
      "title": "The Automatic State ID",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Mastering Flow State Management",
          "level": 1
        },
        {
          "title": "The Automatic State ID",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Mastering Flow State Management",
            "level": 1
          },
          {
            "title": "The Automatic State ID",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Mastering Flow State Management > The Automatic State ID"
      },
      "enhanced_content": "Context: Changelog > Mastering Flow State Management > The Automatic State ID\n\n## The Automatic State ID\n\nBoth unstructured and structured states automatically receive a unique identifier (UUID) to help track and manage state instances.",
      "formatted_path": "Changelog > Mastering Flow State Management > The Automatic State ID",
      "enhanced_text": "Context: Changelog > Mastering Flow State Management > The Automatic State ID\n\n The Automatic State ID\n\nBoth unstructured and structured states automatically receive a unique identifier (UUID) to help track and manage state instances."
    },
    {
      "content": "CrewAI uses an event bus architecture to emit events throughout the execution lifecycle. The event system is built on the following components: **CrewAIEventsBus**: A singleton event bus that manages event registration and emission **CrewEvent**: Base class for all events in the system **BaseEventListener**: Abstract base class for creating custom event listeners When specific actions occur in CrewAI (like a Crew starting execution, an Agent completing a task, or a tool being used), the system emits corresponding events. You can register handlers for these events to execute custom code when they occur.",
      "title": "How It Works",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Mastering Flow State Management",
          "level": 1
        },
        {
          "title": "The Automatic State ID",
          "level": 2
        },
        {
          "title": "How It Works",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Mastering Flow State Management",
            "level": 1
          },
          {
            "title": "The Automatic State ID",
            "level": 2
          },
          {
            "title": "How It Works",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Mastering Flow State Management > The Automatic State ID > How It Works"
      },
      "enhanced_content": "Context: Changelog > Mastering Flow State Management > The Automatic State ID > How It Works\n\n### How It Works\n\nCrewAI uses an event bus architecture to emit events throughout the execution lifecycle. The event system is built on the following components: **CrewAIEventsBus**: A singleton event bus that manages event registration and emission **CrewEvent**: Base class for all events in the system **BaseEventListener**: Abstract base class for creating custom event listeners When specific actions occur in CrewAI (like a Crew starting execution, an Agent completing a task, or a tool being used), the system emits corresponding events. You can register handlers for these events to execute custom code when they occur.",
      "formatted_path": "Changelog > Mastering Flow State Management > The Automatic State ID > How It Works",
      "enhanced_text": "Context: Changelog > Mastering Flow State Management > The Automatic State ID > How It Works\n\n How It Works\n\nCrewAI uses an event bus architecture to emit events throughout the execution lifecycle. The event system is built on the following components: **CrewAIEventsBus**: A singleton event bus that manages event registration and emission **CrewEvent**: Base class for all events in the system **BaseEventListener**: Abstract base class for creating custom event listeners When specific actions occur in CrewAI (like a Crew starting execution, an Agent completing a task, or a tool being used), the system emits corresponding events. You can register handlers for these events to execute custom code when they occur."
    },
    {
      "content": "**Unique State Identification** Each flow state automatically receives a unique UUID The ID is preserved across state updates and method calls Supports both structured (Pydantic BaseModel) and unstructured (dictionary) states **Default SQLite Backend** SQLiteFlowPersistence is the default storage backend States are automatically saved to a local SQLite database Robust error handling ensures clear messages if database operations fail **Error Handling** Comprehensive error messages for database operations Automatic state validation during save and load Clear feedback when persistence operations encounter issues\n\nWith unstructured state: You access state via `self.state` which behaves like a dictionary You can freely add, modify, or remove keys at any point All state is automatically available to all flow methods",
      "title": "How It Works",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Mastering Flow State Management",
          "level": 1
        },
        {
          "title": "The Automatic State ID",
          "level": 2
        },
        {
          "title": "How It Works",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Mastering Flow State Management",
            "level": 1
          },
          {
            "title": "The Automatic State ID",
            "level": 2
          },
          {
            "title": "How It Works",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Mastering Flow State Management > The Automatic State ID > How It Works"
      },
      "enhanced_content": "Context: Changelog > Mastering Flow State Management > The Automatic State ID > How It Works\n\n### How It Works\n\n**Unique State Identification** Each flow state automatically receives a unique UUID The ID is preserved across state updates and method calls Supports both structured (Pydantic BaseModel) and unstructured (dictionary) states **Default SQLite Backend** SQLiteFlowPersistence is the default storage backend States are automatically saved to a local SQLite database Robust error handling ensures clear messages if database operations fail **Error Handling** Comprehensive error messages for database operations Automatic state validation during save and load Clear feedback when persistence operations encounter issues\n\nWith unstructured state: You access state via `self.state` which behaves like a dictionary You can freely add, modify, or remove keys at any point All state is automatically available to all flow methods",
      "formatted_path": "Changelog > Mastering Flow State Management > The Automatic State ID > How It Works",
      "enhanced_text": "Context: Changelog > Mastering Flow State Management > The Automatic State ID > How It Works\n\n How It Works\n\n**Unique State Identification** Each flow state automatically receives a unique UUID The ID is preserved across state updates and method calls Supports both structured (Pydantic BaseModel) and unstructured (dictionary) states **Default SQLite Backend** SQLiteFlowPersistence is the default storage backend States are automatically saved to a local SQLite database Robust error handling ensures clear messages if database operations fail **Error Handling** Comprehensive error messages for database operations Automatic state validation during save and load Clear feedback when persistence operations encounter issues\n\nWith unstructured state: You access state via `self.state` which behaves like a dictionary You can freely add, modify, or remove keys at any point All state is automatically available to all flow methods"
    },
    {
      "content": "With structured state: You define a Pydantic model that represents your state structure You pass this model type to your Flow class as a type parameter You access state via `self.state`, which behaves like a Pydantic model instance All fields are validated according to their defined types You get IDE autocompletion and type checking support\n\nFor unstructured state, the ID is accessible as `self.state[\"id\"]` For structured state, the ID is accessible as `self.state.id` This ID is generated automatically when the flow is created The ID remains the same throughout the flow's lifecycle The ID can be used for tracking, logging, and retrieving persisted states This UUID is particularly valuable when implementing persistence or tracking multiple flow executions.",
      "title": "How It Works",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Mastering Flow State Management",
          "level": 1
        },
        {
          "title": "The Automatic State ID",
          "level": 2
        },
        {
          "title": "How It Works",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Mastering Flow State Management",
            "level": 1
          },
          {
            "title": "The Automatic State ID",
            "level": 2
          },
          {
            "title": "How It Works",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Mastering Flow State Management > The Automatic State ID > How It Works"
      },
      "enhanced_content": "Context: Changelog > Mastering Flow State Management > The Automatic State ID > How It Works\n\n### How It Works\n\nWith structured state: You define a Pydantic model that represents your state structure You pass this model type to your Flow class as a type parameter You access state via `self.state`, which behaves like a Pydantic model instance All fields are validated according to their defined types You get IDE autocompletion and type checking support\n\nFor unstructured state, the ID is accessible as `self.state[\"id\"]` For structured state, the ID is accessible as `self.state.id` This ID is generated automatically when the flow is created The ID remains the same throughout the flow's lifecycle The ID can be used for tracking, logging, and retrieving persisted states This UUID is particularly valuable when implementing persistence or tracking multiple flow executions.",
      "formatted_path": "Changelog > Mastering Flow State Management > The Automatic State ID > How It Works",
      "enhanced_text": "Context: Changelog > Mastering Flow State Management > The Automatic State ID > How It Works\n\n How It Works\n\nWith structured state: You define a Pydantic model that represents your state structure You pass this model type to your Flow class as a type parameter You access state via `self.state`, which behaves like a Pydantic model instance All fields are validated according to their defined types You get IDE autocompletion and type checking support\n\nFor unstructured state, the ID is accessible as `self.state[\"id\"]` For structured state, the ID is accessible as `self.state.id` This ID is generated automatically when the flow is created The ID remains the same throughout the flow's lifecycle The ID can be used for tracking, logging, and retrieving persisted states This UUID is particularly valuable when implementing persistence or tracking multiple flow executions."
    },
    {
      "content": "Regardless of whether you're using structured or unstructured state, you can update state dynamically throughout your flow's execution.",
      "title": "Dynamic State Updates",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Mastering Flow State Management",
          "level": 1
        },
        {
          "title": "Dynamic State Updates",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Mastering Flow State Management",
            "level": 1
          },
          {
            "title": "Dynamic State Updates",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Mastering Flow State Management > Dynamic State Updates"
      },
      "enhanced_content": "Context: Changelog > Mastering Flow State Management > Dynamic State Updates\n\n## Dynamic State Updates\n\nRegardless of whether you're using structured or unstructured state, you can update state dynamically throughout your flow's execution.",
      "formatted_path": "Changelog > Mastering Flow State Management > Dynamic State Updates",
      "enhanced_text": "Context: Changelog > Mastering Flow State Management > Dynamic State Updates\n\n Dynamic State Updates\n\nRegardless of whether you're using structured or unstructured state, you can update state dynamically throughout your flow's execution."
    },
    {
      "content": "from crewai.flow.flow import Flow, listen, start\n\nclass DataPassingFlow(Flow):\n    @start()\n    def generate_data(self):\n        # This return value will be passed to listening methods\n        return \"Generated data\"\n\n    @listen(generate_data)\n    def process_data(self, data_from_previous_step):\n        print(f\"Received: {data_from_previous_step}\")\n        # You can modify the data and pass it along\n        processed_data = f\"{data_from_previous_step} - processed\"\n        # Also update state\n        self.state[\"last_processed\"] = processed_data\n        return processed_data\n\n    @listen(process_data)\n    def finalize_data(self, processed_data):\n        print(f\"Received processed data: {processed_data}\")\n        # Access both the passed data and state\n        last_processed = self.state.get(\"last_processed\", \"\")\n        return f\"Final: {processed_data} (from state: {last_processed})\"",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Mastering Flow State Management",
          "level": 1
        },
        {
          "title": "Dynamic State Updates",
          "level": 2
        },
        {
          "title": "Passing Data Between Steps",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Mastering Flow State Management",
            "level": 1
          },
          {
            "title": "Dynamic State Updates",
            "level": 2
          },
          {
            "title": "Passing Data Between Steps",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Mastering Flow State Management > Dynamic State Updates > Passing Data Between Steps"
      },
      "enhanced_content": "Context: Changelog > Mastering Flow State Management > Dynamic State Updates > Passing Data Between Steps\n\nfrom crewai.flow.flow import Flow, listen, start\n\nclass DataPassingFlow(Flow):\n    @start()\n    def generate_data(self):\n        # This return value will be passed to listening methods\n        return \"Generated data\"\n\n    @listen(generate_data)\n    def process_data(self, data_from_previous_step):\n        print(f\"Received: {data_from_previous_step}\")\n        # You can modify the data and pass it along\n        processed_data = f\"{data_from_previous_step} - processed\"\n        # Also update state\n        self.state[\"last_processed\"] = processed_data\n        return processed_data\n\n    @listen(process_data)\n    def finalize_data(self, processed_data):\n        print(f\"Received processed data: {processed_data}\")\n        # Access both the passed data and state\n        last_processed = self.state.get(\"last_processed\", \"\")\n        return f\"Final: {processed_data} (from state: {last_processed})\"",
      "formatted_path": "Changelog > Mastering Flow State Management > Dynamic State Updates > Passing Data Between Steps",
      "enhanced_text": "Context: Changelog > Mastering Flow State Management > Dynamic State Updates > Passing Data Between Steps\n\nfrom crewai.flow.flow import Flow, listen, start\n\nclass DataPassingFlow(Flow):\n    @start()\n    def generate_data(self):\n        # This return value will be passed to listening methods\n        return \"Generated data\"\n\n    @listen(generate_data)\n    def process_data(self, data_from_previous_step):\n        print(f\"Received: {data_from_previous_step}\")\n        # You can modify the data and pass it along\n        processed_data = f\"{data_from_previous_step} - processed\"\n        # Also update state\n        self.state[\"last_processed\"] = processed_data\n        return processed_data\n\n    @listen(process_data)\n    def finalize_data(self, processed_data):\n        print(f\"Received processed data: {processed_data}\")\n        # Access both the passed data and state\n        last_processed = self.state.get(\"last_processed\", \"\")\n        return f\"Final: {processed_data} (from state: {last_processed})\""
    },
    {
      "content": "One of CrewAI's most powerful features is the ability to persist flow state across executions. This enables workflows that can be paused, resumed, and even recovered after failures.",
      "title": "Persisting Flow State",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Mastering Flow State Management",
          "level": 1
        },
        {
          "title": "Persisting Flow State",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Mastering Flow State Management",
            "level": 1
          },
          {
            "title": "Persisting Flow State",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Mastering Flow State Management > Persisting Flow State"
      },
      "enhanced_content": "Context: Changelog > Mastering Flow State Management > Persisting Flow State\n\n## Persisting Flow State\n\nOne of CrewAI's most powerful features is the ability to persist flow state across executions. This enables workflows that can be paused, resumed, and even recovered after failures.",
      "formatted_path": "Changelog > Mastering Flow State Management > Persisting Flow State",
      "enhanced_text": "Context: Changelog > Mastering Flow State Management > Persisting Flow State\n\n Persisting Flow State\n\nOne of CrewAI's most powerful features is the ability to persist flow state across executions. This enables workflows that can be paused, resumed, and even recovered after failures."
    },
    {
      "content": "The `@persist` decorator automates state persistence, saving your flow's state at key points in execution.",
      "title": "The @persist Decorator",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Mastering Flow State Management",
          "level": 1
        },
        {
          "title": "Persisting Flow State",
          "level": 2
        },
        {
          "title": "The @persist Decorator",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Mastering Flow State Management",
            "level": 1
          },
          {
            "title": "Persisting Flow State",
            "level": 2
          },
          {
            "title": "The @persist Decorator",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Mastering Flow State Management > Persisting Flow State > The @persist Decorator"
      },
      "enhanced_content": "Context: Changelog > Mastering Flow State Management > Persisting Flow State > The @persist Decorator\n\n### The @persist Decorator\n\nThe `@persist` decorator automates state persistence, saving your flow's state at key points in execution.",
      "formatted_path": "Changelog > Mastering Flow State Management > Persisting Flow State > The @persist Decorator",
      "enhanced_text": "Context: Changelog > Mastering Flow State Management > Persisting Flow State > The @persist Decorator\n\n The @persist Decorator\n\nThe `@persist` decorator automates state persistence, saving your flow's state at key points in execution."
    },
    {
      "content": "@persist  # Using SQLiteFlowPersistence by default\nclass MyFlow(Flow[MyState]):\n    @start()\n    def initialize_flow(self):\n        # This method will automatically have its state persisted\n        self.state.counter = 1\n        print(\"Initialized flow. State ID:\", self.state.id)\n\n    @listen(initialize_flow)\n    def next_step(self):\n        # The state (including self.state.id) is automatically reloaded\n        self.state.counter += 1\n        print(\"Flow state is persisted. Counter:\", self.state.counter)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Mastering Flow State Management",
          "level": 1
        },
        {
          "title": "Persisting Flow State",
          "level": 2
        },
        {
          "title": "The @persist Decorator",
          "level": 3
        },
        {
          "title": "Class-Level Persistence",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Mastering Flow State Management",
            "level": 1
          },
          {
            "title": "Persisting Flow State",
            "level": 2
          },
          {
            "title": "The @persist Decorator",
            "level": 3
          },
          {
            "title": "Class-Level Persistence",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Mastering Flow State Management > Persisting Flow State > The @persist Decorator > Class-Level Persistence"
      },
      "enhanced_content": "Context: Changelog > Mastering Flow State Management > Persisting Flow State > The @persist Decorator > Class-Level Persistence\n\n@persist  # Using SQLiteFlowPersistence by default\nclass MyFlow(Flow[MyState]):\n    @start()\n    def initialize_flow(self):\n        # This method will automatically have its state persisted\n        self.state.counter = 1\n        print(\"Initialized flow. State ID:\", self.state.id)\n\n    @listen(initialize_flow)\n    def next_step(self):\n        # The state (including self.state.id) is automatically reloaded\n        self.state.counter += 1\n        print(\"Flow state is persisted. Counter:\", self.state.counter)",
      "formatted_path": "Changelog > Mastering Flow State Management > Persisting Flow State > The @persist Decorator > Class-Level Persistence",
      "enhanced_text": "Context: Changelog > Mastering Flow State Management > Persisting Flow State > The @persist Decorator > Class-Level Persistence\n\n@persist  # Using SQLiteFlowPersistence by default\nclass MyFlow(Flow[MyState]):\n    @start()\n    def initialize_flow(self):\n        # This method will automatically have its state persisted\n        self.state.counter = 1\n        print(\"Initialized flow. State ID:\", self.state.id)\n\n    @listen(initialize_flow)\n    def next_step(self):\n        # The state (including self.state.id) is automatically reloaded\n        self.state.counter += 1\n        print(\"Flow state is persisted. Counter:\", self.state.counter)"
    },
    {
      "content": "from crewai.flow.flow import Flow, listen, persist, start\nfrom pydantic import BaseModel\n\nclass CounterState(BaseModel):\n    value: int = 0\n\n@persist  # Apply to the entire flow class\nclass PersistentCounterFlow(Flow[CounterState]):\n    @start()\n    def increment(self):\n        self.state.value += 1\n        print(f\"Incremented to {self.state.value}\")\n        return self.state.value\n\n    @listen(increment)\n    def double(self, value):\n        self.state.value = value * 2\n        print(f\"Doubled to {self.state.value}\")\n        return self.state.value\n\n# First run\nflow1 = PersistentCounterFlow()\nresult1 = flow1.kickoff()\nprint(f\"First run result: {result1}\")\n\n# Second run - state is automatically loaded\nflow2 = PersistentCounterFlow()\nresult2 = flow2.kickoff()\nprint(f\"Second run result: {result2}\")  # Will be higher due to persisted state",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Mastering Flow State Management",
          "level": 1
        },
        {
          "title": "Persisting Flow State",
          "level": 2
        },
        {
          "title": "The @persist Decorator",
          "level": 3
        },
        {
          "title": "Class-Level Persistence",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Mastering Flow State Management",
            "level": 1
          },
          {
            "title": "Persisting Flow State",
            "level": 2
          },
          {
            "title": "The @persist Decorator",
            "level": 3
          },
          {
            "title": "Class-Level Persistence",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Mastering Flow State Management > Persisting Flow State > The @persist Decorator > Class-Level Persistence"
      },
      "enhanced_content": "Context: Changelog > Mastering Flow State Management > Persisting Flow State > The @persist Decorator > Class-Level Persistence\n\nfrom crewai.flow.flow import Flow, listen, persist, start\nfrom pydantic import BaseModel\n\nclass CounterState(BaseModel):\n    value: int = 0\n\n@persist  # Apply to the entire flow class\nclass PersistentCounterFlow(Flow[CounterState]):\n    @start()\n    def increment(self):\n        self.state.value += 1\n        print(f\"Incremented to {self.state.value}\")\n        return self.state.value\n\n    @listen(increment)\n    def double(self, value):\n        self.state.value = value * 2\n        print(f\"Doubled to {self.state.value}\")\n        return self.state.value\n\n# First run\nflow1 = PersistentCounterFlow()\nresult1 = flow1.kickoff()\nprint(f\"First run result: {result1}\")\n\n# Second run - state is automatically loaded\nflow2 = PersistentCounterFlow()\nresult2 = flow2.kickoff()\nprint(f\"Second run result: {result2}\")  # Will be higher due to persisted state",
      "formatted_path": "Changelog > Mastering Flow State Management > Persisting Flow State > The @persist Decorator > Class-Level Persistence",
      "enhanced_text": "Context: Changelog > Mastering Flow State Management > Persisting Flow State > The @persist Decorator > Class-Level Persistence\n\nfrom crewai.flow.flow import Flow, listen, persist, start\nfrom pydantic import BaseModel\n\nclass CounterState(BaseModel):\n    value: int = 0\n\n@persist  # Apply to the entire flow class\nclass PersistentCounterFlow(Flow[CounterState]):\n    @start()\n    def increment(self):\n        self.state.value += 1\n        print(f\"Incremented to {self.state.value}\")\n        return self.state.value\n\n    @listen(increment)\n    def double(self, value):\n        self.state.value = value * 2\n        print(f\"Doubled to {self.state.value}\")\n        return self.state.value\n\n# First run\nflow1 = PersistentCounterFlow()\nresult1 = flow1.kickoff()\nprint(f\"First run result: {result1}\")\n\n# Second run - state is automatically loaded\nflow2 = PersistentCounterFlow()\nresult2 = flow2.kickoff()\nprint(f\"Second run result: {result2}\")  # Will be higher due to persisted state"
    },
    {
      "content": "class AnotherFlow(Flow[dict]):\n    @persist  # Persists only this method's state\n    @start()\n    def begin(self):\n        if \"runs\" not in self.state:\n            self.state[\"runs\"] = 0\n        self.state[\"runs\"] += 1\n        print(\"Method-level persisted runs:\", self.state[\"runs\"])",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Mastering Flow State Management",
          "level": 1
        },
        {
          "title": "Persisting Flow State",
          "level": 2
        },
        {
          "title": "The @persist Decorator",
          "level": 3
        },
        {
          "title": "Method-Level Persistence",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Mastering Flow State Management",
            "level": 1
          },
          {
            "title": "Persisting Flow State",
            "level": 2
          },
          {
            "title": "The @persist Decorator",
            "level": 3
          },
          {
            "title": "Method-Level Persistence",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Mastering Flow State Management > Persisting Flow State > The @persist Decorator > Method-Level Persistence"
      },
      "enhanced_content": "Context: Changelog > Mastering Flow State Management > Persisting Flow State > The @persist Decorator > Method-Level Persistence\n\nclass AnotherFlow(Flow[dict]):\n    @persist  # Persists only this method's state\n    @start()\n    def begin(self):\n        if \"runs\" not in self.state:\n            self.state[\"runs\"] = 0\n        self.state[\"runs\"] += 1\n        print(\"Method-level persisted runs:\", self.state[\"runs\"])",
      "formatted_path": "Changelog > Mastering Flow State Management > Persisting Flow State > The @persist Decorator > Method-Level Persistence",
      "enhanced_text": "Context: Changelog > Mastering Flow State Management > Persisting Flow State > The @persist Decorator > Method-Level Persistence\n\nclass AnotherFlow(Flow[dict]):\n    @persist  # Persists only this method's state\n    @start()\n    def begin(self):\n        if \"runs\" not in self.state:\n            self.state[\"runs\"] = 0\n        self.state[\"runs\"] += 1\n        print(\"Method-level persisted runs:\", self.state[\"runs\"])"
    },
    {
      "content": "from crewai.flow.flow import Flow, listen, persist, start\n\nclass SelectivePersistFlow(Flow):\n    @start()\n    def first_step(self):\n        self.state[\"count\"] = 1\n        return \"First step\"\n\n    @persist  # Only persist after this method\n    @listen(first_step)\n    def important_step(self, prev_result):\n        self.state[\"count\"] += 1\n        self.state[\"important_data\"] = \"This will be persisted\"\n        return \"Important step completed\"\n\n    @listen(important_step)\n    def final_step(self, prev_result):\n        self.state[\"count\"] += 1\n        return f\"Complete with count {self.state['count']}\"",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Mastering Flow State Management",
          "level": 1
        },
        {
          "title": "Persisting Flow State",
          "level": 2
        },
        {
          "title": "The @persist Decorator",
          "level": 3
        },
        {
          "title": "Method-Level Persistence",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Mastering Flow State Management",
            "level": 1
          },
          {
            "title": "Persisting Flow State",
            "level": 2
          },
          {
            "title": "The @persist Decorator",
            "level": 3
          },
          {
            "title": "Method-Level Persistence",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Mastering Flow State Management > Persisting Flow State > The @persist Decorator > Method-Level Persistence"
      },
      "enhanced_content": "Context: Changelog > Mastering Flow State Management > Persisting Flow State > The @persist Decorator > Method-Level Persistence\n\nfrom crewai.flow.flow import Flow, listen, persist, start\n\nclass SelectivePersistFlow(Flow):\n    @start()\n    def first_step(self):\n        self.state[\"count\"] = 1\n        return \"First step\"\n\n    @persist  # Only persist after this method\n    @listen(first_step)\n    def important_step(self, prev_result):\n        self.state[\"count\"] += 1\n        self.state[\"important_data\"] = \"This will be persisted\"\n        return \"Important step completed\"\n\n    @listen(important_step)\n    def final_step(self, prev_result):\n        self.state[\"count\"] += 1\n        return f\"Complete with count {self.state['count']}\"",
      "formatted_path": "Changelog > Mastering Flow State Management > Persisting Flow State > The @persist Decorator > Method-Level Persistence",
      "enhanced_text": "Context: Changelog > Mastering Flow State Management > Persisting Flow State > The @persist Decorator > Method-Level Persistence\n\nfrom crewai.flow.flow import Flow, listen, persist, start\n\nclass SelectivePersistFlow(Flow):\n    @start()\n    def first_step(self):\n        self.state[\"count\"] = 1\n        return \"First step\"\n\n    @persist  # Only persist after this method\n    @listen(first_step)\n    def important_step(self, prev_result):\n        self.state[\"count\"] += 1\n        self.state[\"important_data\"] = \"This will be persisted\"\n        return \"Important step completed\"\n\n    @listen(important_step)\n    def final_step(self, prev_result):\n        self.state[\"count\"] += 1\n        return f\"Complete with count {self.state['count']}\""
    },
    {
      "content": "from crewai.flow.flow import Flow, listen, router, start\nfrom pydantic import BaseModel\n\nclass PaymentState(BaseModel):\n    amount: float = 0.0\n    is_approved: bool = False\n    retry_count: int = 0\n\nclass PaymentFlow(Flow[PaymentState]):\n    @start()\n    def process_payment(self):\n        # Simulate payment processing\n        self.state.amount = 100.0\n        self.state.is_approved = self.state.amount < 1000\n        return \"Payment processed\"\n\n    @router(process_payment)\n    def check_approval(self, previous_result):\n        if self.state.is_approved:\n            return \"approved\"\n        elif self.state.retry_count < 3:\n            return \"retry\"\n        else:\n            return \"rejected\"\n\n    @listen(\"approved\")\n    def handle_approval(self):\n        return f\"Payment of ${self.state.amount} approved!\"\n\n    @listen(\"retry\")\n    def handle_retry(self):\n        self.state.retry_count += 1\n        print(f\"Retrying payment (attempt {self.state.retry_count})...\")\n        # Could implement retry logic here\n        return \"Retry initiated\"\n\n    @listen(\"rejected\")\n    def handle_rejection(self):\n        return f\"Payment of ${self.state.amount} rejected after {self.state.retry_count} retries.\"",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Mastering Flow State Management",
          "level": 1
        },
        {
          "title": "Advanced State Patterns",
          "level": 2
        },
        {
          "title": "State-Based Conditional Logic",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Mastering Flow State Management",
            "level": 1
          },
          {
            "title": "Advanced State Patterns",
            "level": 2
          },
          {
            "title": "State-Based Conditional Logic",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Mastering Flow State Management > Advanced State Patterns > State-Based Conditional Logic"
      },
      "enhanced_content": "Context: Changelog > Mastering Flow State Management > Advanced State Patterns > State-Based Conditional Logic\n\nfrom crewai.flow.flow import Flow, listen, router, start\nfrom pydantic import BaseModel\n\nclass PaymentState(BaseModel):\n    amount: float = 0.0\n    is_approved: bool = False\n    retry_count: int = 0\n\nclass PaymentFlow(Flow[PaymentState]):\n    @start()\n    def process_payment(self):\n        # Simulate payment processing\n        self.state.amount = 100.0\n        self.state.is_approved = self.state.amount < 1000\n        return \"Payment processed\"\n\n    @router(process_payment)\n    def check_approval(self, previous_result):\n        if self.state.is_approved:\n            return \"approved\"\n        elif self.state.retry_count < 3:\n            return \"retry\"\n        else:\n            return \"rejected\"\n\n    @listen(\"approved\")\n    def handle_approval(self):\n        return f\"Payment of ${self.state.amount} approved!\"\n\n    @listen(\"retry\")\n    def handle_retry(self):\n        self.state.retry_count += 1\n        print(f\"Retrying payment (attempt {self.state.retry_count})...\")\n        # Could implement retry logic here\n        return \"Retry initiated\"\n\n    @listen(\"rejected\")\n    def handle_rejection(self):\n        return f\"Payment of ${self.state.amount} rejected after {self.state.retry_count} retries.\"",
      "formatted_path": "Changelog > Mastering Flow State Management > Advanced State Patterns > State-Based Conditional Logic",
      "enhanced_text": "Context: Changelog > Mastering Flow State Management > Advanced State Patterns > State-Based Conditional Logic\n\nfrom crewai.flow.flow import Flow, listen, router, start\nfrom pydantic import BaseModel\n\nclass PaymentState(BaseModel):\n    amount: float = 0.0\n    is_approved: bool = False\n    retry_count: int = 0\n\nclass PaymentFlow(Flow[PaymentState]):\n    @start()\n    def process_payment(self):\n        # Simulate payment processing\n        self.state.amount = 100.0\n        self.state.is_approved = self.state.amount < 1000\n        return \"Payment processed\"\n\n    @router(process_payment)\n    def check_approval(self, previous_result):\n        if self.state.is_approved:\n            return \"approved\"\n        elif self.state.retry_count < 3:\n            return \"retry\"\n        else:\n            return \"rejected\"\n\n    @listen(\"approved\")\n    def handle_approval(self):\n        return f\"Payment of ${self.state.amount} approved!\"\n\n    @listen(\"retry\")\n    def handle_retry(self):\n        self.state.retry_count += 1\n        print(f\"Retrying payment (attempt {self.state.retry_count})...\")\n        # Could implement retry logic here\n        return \"Retry initiated\"\n\n    @listen(\"rejected\")\n    def handle_rejection(self):\n        return f\"Payment of ${self.state.amount} rejected after {self.state.retry_count} retries.\""
    },
    {
      "content": "from crewai.flow.flow import Flow, listen, start\nfrom pydantic import BaseModel\nfrom typing import List, Dict\n\nclass UserData(BaseModel):\n    name: str\n    active: bool = True\n    login_count: int = 0\n\nclass ComplexState(BaseModel):\n    users: Dict[str, UserData] = {}\n    active_user_count: int = 0\n\nclass TransformationFlow(Flow[ComplexState]):\n    @start()\n    def initialize(self):\n        # Add some users\n        self.add_user(\"alice\", \"Alice\")\n        self.add_user(\"bob\", \"Bob\")\n        self.add_user(\"charlie\", \"Charlie\")\n        return \"Initialized\"\n\n    @listen(initialize)\n    def process_users(self, _):\n        # Increment login counts\n        for user_id in self.state.users:\n            self.increment_login(user_id)\n\n        # Deactivate one user\n        self.deactivate_user(\"bob\")\n\n        # Update active count\n        self.update_active_count()\n\n        return f\"Processed {len(self.state.users)} users\"\n\n    # Helper methods for state transformations\n    def add_user(self, user_id: str, name: str):\n        self.state.users[user_id] = UserData(name=name)\n        self.update_active_count()\n\n    def increment_login(self, user_id: str):\n        if user_id in self.state.users:\n            self.state.users[user_id].login_count += 1\n\n    def deactivate_user(self, user_id: str):\n        if user_id in self.state.users:\n            self.state.users[user_id].active = False\n            self.update_active_count()\n\n    def update_active_count(self):\n        self.state.active_user_count = sum(\n            1 for user in self.state.users.values() if user.active\n        )",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Mastering Flow State Management",
          "level": 1
        },
        {
          "title": "Advanced State Patterns",
          "level": 2
        },
        {
          "title": "Handling Complex State Transformations",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Mastering Flow State Management",
            "level": 1
          },
          {
            "title": "Advanced State Patterns",
            "level": 2
          },
          {
            "title": "Handling Complex State Transformations",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Mastering Flow State Management > Advanced State Patterns > Handling Complex State Transformations"
      },
      "enhanced_content": "Context: Changelog > Mastering Flow State Management > Advanced State Patterns > Handling Complex State Transformations\n\nfrom crewai.flow.flow import Flow, listen, start\nfrom pydantic import BaseModel\nfrom typing import List, Dict\n\nclass UserData(BaseModel):\n    name: str\n    active: bool = True\n    login_count: int = 0\n\nclass ComplexState(BaseModel):\n    users: Dict[str, UserData] = {}\n    active_user_count: int = 0\n\nclass TransformationFlow(Flow[ComplexState]):\n    @start()\n    def initialize(self):\n        # Add some users\n        self.add_user(\"alice\", \"Alice\")\n        self.add_user(\"bob\", \"Bob\")\n        self.add_user(\"charlie\", \"Charlie\")\n        return \"Initialized\"\n\n    @listen(initialize)\n    def process_users(self, _):\n        # Increment login counts\n        for user_id in self.state.users:\n            self.increment_login(user_id)\n\n        # Deactivate one user\n        self.deactivate_user(\"bob\")\n\n        # Update active count\n        self.update_active_count()\n\n        return f\"Processed {len(self.state.users)} users\"\n\n    # Helper methods for state transformations\n    def add_user(self, user_id: str, name: str):\n        self.state.users[user_id] = UserData(name=name)\n        self.update_active_count()\n\n    def increment_login(self, user_id: str):\n        if user_id in self.state.users:\n            self.state.users[user_id].login_count += 1\n\n    def deactivate_user(self, user_id: str):\n        if user_id in self.state.users:\n            self.state.users[user_id].active = False\n            self.update_active_count()\n\n    def update_active_count(self):\n        self.state.active_user_count = sum(\n            1 for user in self.state.users.values() if user.active\n        )",
      "formatted_path": "Changelog > Mastering Flow State Management > Advanced State Patterns > Handling Complex State Transformations",
      "enhanced_text": "Context: Changelog > Mastering Flow State Management > Advanced State Patterns > Handling Complex State Transformations\n\nfrom crewai.flow.flow import Flow, listen, start\nfrom pydantic import BaseModel\nfrom typing import List, Dict\n\nclass UserData(BaseModel):\n    name: str\n    active: bool = True\n    login_count: int = 0\n\nclass ComplexState(BaseModel):\n    users: Dict[str, UserData] = {}\n    active_user_count: int = 0\n\nclass TransformationFlow(Flow[ComplexState]):\n    @start()\n    def initialize(self):\n        # Add some users\n        self.add_user(\"alice\", \"Alice\")\n        self.add_user(\"bob\", \"Bob\")\n        self.add_user(\"charlie\", \"Charlie\")\n        return \"Initialized\"\n\n    @listen(initialize)\n    def process_users(self, _):\n        # Increment login counts\n        for user_id in self.state.users:\n            self.increment_login(user_id)\n\n        # Deactivate one user\n        self.deactivate_user(\"bob\")\n\n        # Update active count\n        self.update_active_count()\n\n        return f\"Processed {len(self.state.users)} users\"\n\n    # Helper methods for state transformations\n    def add_user(self, user_id: str, name: str):\n        self.state.users[user_id] = UserData(name=name)\n        self.update_active_count()\n\n    def increment_login(self, user_id: str):\n        if user_id in self.state.users:\n            self.state.users[user_id].login_count += 1\n\n    def deactivate_user(self, user_id: str):\n        if user_id in self.state.users:\n            self.state.users[user_id].active = False\n            self.update_active_count()\n\n    def update_active_count(self):\n        self.state.active_user_count = sum(\n            1 for user in self.state.users.values() if user.active\n        )"
    },
    {
      "content": "One of the most powerful patterns in CrewAI is combining flow state management with crew execution.",
      "title": "State Management with Crews",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Mastering Flow State Management",
          "level": 1
        },
        {
          "title": "State Management with Crews",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Mastering Flow State Management",
            "level": 1
          },
          {
            "title": "State Management with Crews",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Mastering Flow State Management > State Management with Crews"
      },
      "enhanced_content": "Context: Changelog > Mastering Flow State Management > State Management with Crews\n\n## State Management with Crews\n\nOne of the most powerful patterns in CrewAI is combining flow state management with crew execution.",
      "formatted_path": "Changelog > Mastering Flow State Management > State Management with Crews",
      "enhanced_text": "Context: Changelog > Mastering Flow State Management > State Management with Crews\n\n State Management with Crews\n\nOne of the most powerful patterns in CrewAI is combining flow state management with crew execution.\n\nRelated sections:\n- \n"
    },
    {
      "content": "from crewai.flow.flow import Flow, listen, start\nfrom crewai import Agent, Crew, Process, Task\nfrom pydantic import BaseModel\n\nclass ResearchState(BaseModel):\n    topic: str = \"\"\n    depth: str = \"medium\"\n    results: str = \"\"\n\nclass ResearchFlow(Flow[ResearchState]):\n    @start()\n    def get_parameters(self):\n        # In a real app, this might come from user input\n        self.state.topic = \"Artificial Intelligence Ethics\"\n        self.state.depth = \"deep\"\n        return \"Parameters set\"\n\n    @listen(get_parameters)\n    def execute_research(self, _):\n        # Create agents\n        researcher = Agent(\n            role=\"Research Specialist\",\n            goal=f\"Research {self.state.topic} in {self.state.depth} detail\",\n            backstory=\"You are an expert researcher with a talent for finding accurate information.\"\n        )\n\n        writer = Agent(\n            role=\"Content Writer\",\n            goal=\"Transform research into clear, engaging content\",\n            backstory=\"You excel at communicating complex ideas clearly and concisely.\"\n        )\n\n        # Create tasks\n        research_task = Task(\n            description=f\"Research {self.state.topic} with {self.state.depth} analysis\",\n            expected_output=\"Comprehensive research notes in markdown format\",\n            agent=researcher\n        )\n\n        writing_task = Task(\n            description=f\"Create a summary on {self.state.topic} based on the research\",\n            expected_output=\"Well-written article in markdown format\",\n            agent=writer,\n            context=[research_task]\n        )\n\n        # Create and run crew\n        research_crew = Crew(\n            agents=[researcher, writer],\n            tasks=[research_task, writing_task],\n            process=Process.sequential,\n            verbose=True\n        )\n\n        # Run crew and store result in state\n        result = research_crew.kickoff()\n        self.state.results = result.raw\n\n        return \"Research completed\"\n\n    @listen(execute_research)\n    def summarize_results(self, _):\n        # Access the stored results\n        result_length = len(self.state.results)\n        return f\"Research on {self.state.topic} completed with {result_length} characters of results.\"",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Mastering Flow State Management",
          "level": 1
        },
        {
          "title": "State Management with Crews",
          "level": 2
        },
        {
          "title": "Passing State to Crews",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Mastering Flow State Management",
            "level": 1
          },
          {
            "title": "State Management with Crews",
            "level": 2
          },
          {
            "title": "Passing State to Crews",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Mastering Flow State Management > State Management with Crews > Passing State to Crews"
      },
      "enhanced_content": "Context: Changelog > Mastering Flow State Management > State Management with Crews > Passing State to Crews\n\nfrom crewai.flow.flow import Flow, listen, start\nfrom crewai import Agent, Crew, Process, Task\nfrom pydantic import BaseModel\n\nclass ResearchState(BaseModel):\n    topic: str = \"\"\n    depth: str = \"medium\"\n    results: str = \"\"\n\nclass ResearchFlow(Flow[ResearchState]):\n    @start()\n    def get_parameters(self):\n        # In a real app, this might come from user input\n        self.state.topic = \"Artificial Intelligence Ethics\"\n        self.state.depth = \"deep\"\n        return \"Parameters set\"\n\n    @listen(get_parameters)\n    def execute_research(self, _):\n        # Create agents\n        researcher = Agent(\n            role=\"Research Specialist\",\n            goal=f\"Research {self.state.topic} in {self.state.depth} detail\",\n            backstory=\"You are an expert researcher with a talent for finding accurate information.\"\n        )\n\n        writer = Agent(\n            role=\"Content Writer\",\n            goal=\"Transform research into clear, engaging content\",\n            backstory=\"You excel at communicating complex ideas clearly and concisely.\"\n        )\n\n        # Create tasks\n        research_task = Task(\n            description=f\"Research {self.state.topic} with {self.state.depth} analysis\",\n            expected_output=\"Comprehensive research notes in markdown format\",\n            agent=researcher\n        )\n\n        writing_task = Task(\n            description=f\"Create a summary on {self.state.topic} based on the research\",\n            expected_output=\"Well-written article in markdown format\",\n            agent=writer,\n            context=[research_task]\n        )\n\n        # Create and run crew\n        research_crew = Crew(\n            agents=[researcher, writer],\n            tasks=[research_task, writing_task],\n            process=Process.sequential,\n            verbose=True\n        )\n\n        # Run crew and store result in state\n        result = research_crew.kickoff()\n        self.state.results = result.raw\n\n        return \"Research completed\"\n\n    @listen(execute_research)\n    def summarize_results(self, _):\n        # Access the stored results\n        result_length = len(self.state.results)\n        return f\"Research on {self.state.topic} completed with {result_length} characters of results.\"",
      "formatted_path": "Changelog > Mastering Flow State Management > State Management with Crews > Passing State to Crews",
      "enhanced_text": "Context: Changelog > Mastering Flow State Management > State Management with Crews > Passing State to Crews\n\nfrom crewai.flow.flow import Flow, listen, start\nfrom crewai import Agent, Crew, Process, Task\nfrom pydantic import BaseModel\n\nclass ResearchState(BaseModel):\n    topic: str = \"\"\n    depth: str = \"medium\"\n    results: str = \"\"\n\nclass ResearchFlow(Flow[ResearchState]):\n    @start()\n    def get_parameters(self):\n        # In a real app, this might come from user input\n        self.state.topic = \"Artificial Intelligence Ethics\"\n        self.state.depth = \"deep\"\n        return \"Parameters set\"\n\n    @listen(get_parameters)\n    def execute_research(self, _):\n        # Create agents\n        researcher = Agent(\n            role=\"Research Specialist\",\n            goal=f\"Research {self.state.topic} in {self.state.depth} detail\",\n            backstory=\"You are an expert researcher with a talent for finding accurate information.\"\n        )\n\n        writer = Agent(\n            role=\"Content Writer\",\n            goal=\"Transform research into clear, engaging content\",\n            backstory=\"You excel at communicating complex ideas clearly and concisely.\"\n        )\n\n        # Create tasks\n        research_task = Task(\n            description=f\"Research {self.state.topic} with {self.state.depth} analysis\",\n            expected_output=\"Comprehensive research notes in markdown format\",\n            agent=researcher\n        )\n\n        writing_task = Task(\n            description=f\"Create a summary on {self.state.topic} based on the research\",\n            expected_output=\"Well-written article in markdown format\",\n            agent=writer,\n            context=[research_task]\n        )\n\n        # Create and run crew\n        research_crew = Crew(\n            agents=[researcher, writer],\n            tasks=[research_task, writing_task],\n            process=Process.sequential,\n            verbose=True\n        )\n\n        # Run crew and store result in state\n        result = research_crew.kickoff()\n        self.state.results = result.raw\n\n        return \"Research completed\"\n\n    @listen(execute_research)\n    def summarize_results(self, _):\n        # Access the stored results\n        result_length = len(self.state.results)\n        return f\"Research on {self.state.topic} completed with {result_length} characters of results.\""
    },
    {
      "content": "@listen(execute_crew)\ndef process_crew_results(self, _):\n    # Parse the raw results (assuming JSON output)\n    import json\n    try:\n        results_dict = json.loads(self.state.raw_results)\n        self.state.processed_results = {\n            \"title\": results_dict.get(\"title\", \"\"),\n            \"main_points\": results_dict.get(\"main_points\", []),\n            \"conclusion\": results_dict.get(\"conclusion\", \"\")\n        }\n        return \"Results processed successfully\"\n    except json.JSONDecodeError:\n        self.state.error = \"Failed to parse crew results as JSON\"\n        return \"Error processing results\"",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Mastering Flow State Management",
          "level": 1
        },
        {
          "title": "State Management with Crews",
          "level": 2
        },
        {
          "title": "Handling Crew Outputs in State",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Mastering Flow State Management",
            "level": 1
          },
          {
            "title": "State Management with Crews",
            "level": 2
          },
          {
            "title": "Handling Crew Outputs in State",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Mastering Flow State Management > State Management with Crews > Handling Crew Outputs in State"
      },
      "enhanced_content": "Context: Changelog > Mastering Flow State Management > State Management with Crews > Handling Crew Outputs in State\n\n@listen(execute_crew)\ndef process_crew_results(self, _):\n    # Parse the raw results (assuming JSON output)\n    import json\n    try:\n        results_dict = json.loads(self.state.raw_results)\n        self.state.processed_results = {\n            \"title\": results_dict.get(\"title\", \"\"),\n            \"main_points\": results_dict.get(\"main_points\", []),\n            \"conclusion\": results_dict.get(\"conclusion\", \"\")\n        }\n        return \"Results processed successfully\"\n    except json.JSONDecodeError:\n        self.state.error = \"Failed to parse crew results as JSON\"\n        return \"Error processing results\"",
      "formatted_path": "Changelog > Mastering Flow State Management > State Management with Crews > Handling Crew Outputs in State",
      "enhanced_text": "Context: Changelog > Mastering Flow State Management > State Management with Crews > Handling Crew Outputs in State\n\n@listen(execute_crew)\ndef process_crew_results(self, _):\n    # Parse the raw results (assuming JSON output)\n    import json\n    try:\n        results_dict = json.loads(self.state.raw_results)\n        self.state.processed_results = {\n            \"title\": results_dict.get(\"title\", \"\"),\n            \"main_points\": results_dict.get(\"main_points\", []),\n            \"conclusion\": results_dict.get(\"conclusion\", \"\")\n        }\n        return \"Results processed successfully\"\n    except json.JSONDecodeError:\n        self.state.error = \"Failed to parse crew results as JSON\"\n        return \"Error processing results\""
    },
    {
      "content": "# Too broad\nclass BloatedState(BaseModel):\n    user_data: Dict = {}\n    system_settings: Dict = {}\n    temporary_calculations: List = []\n    debug_info: Dict = {}\n    # ...many more fields\n\n# Better: Focused state\nclass FocusedState(BaseModel):\n    user_id: str\n    preferences: Dict[str, str]\n    completion_status: Dict[str, bool]",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Mastering Flow State Management",
          "level": 1
        },
        {
          "title": "Best Practices for State Management",
          "level": 2
        },
        {
          "title": "1. Keep State Focused",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Mastering Flow State Management",
            "level": 1
          },
          {
            "title": "Best Practices for State Management",
            "level": 2
          },
          {
            "title": "1. Keep State Focused",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Mastering Flow State Management > Best Practices for State Management > 1. Keep State Focused"
      },
      "enhanced_content": "Context: Changelog > Mastering Flow State Management > Best Practices for State Management > 1. Keep State Focused\n\n# Too broad\nclass BloatedState(BaseModel):\n    user_data: Dict = {}\n    system_settings: Dict = {}\n    temporary_calculations: List = []\n    debug_info: Dict = {}\n    # ...many more fields\n\n# Better: Focused state\nclass FocusedState(BaseModel):\n    user_id: str\n    preferences: Dict[str, str]\n    completion_status: Dict[str, bool]",
      "formatted_path": "Changelog > Mastering Flow State Management > Best Practices for State Management > 1. Keep State Focused",
      "enhanced_text": "Context: Changelog > Mastering Flow State Management > Best Practices for State Management > 1. Keep State Focused\n\n# Too broad\nclass BloatedState(BaseModel):\n    user_data: Dict = {}\n    system_settings: Dict = {}\n    temporary_calculations: List = []\n    debug_info: Dict = {}\n    # ...many more fields\n\n# Better: Focused state\nclass FocusedState(BaseModel):\n    user_id: str\n    preferences: Dict[str, str]\n    completion_status: Dict[str, bool]"
    },
    {
      "content": "# Simple flow can use unstructured state\nclass SimpleGreetingFlow(Flow):\n    @start()\n    def greet(self):\n        self.state[\"name\"] = \"World\"\n        return f\"Hello, {self.state['name']}!\"\n\n# Complex flow benefits from structured state\nclass UserRegistrationState(BaseModel):\n    username: str\n    email: str\n    verification_status: bool = False\n    registration_date: datetime = Field(default_factory=datetime.now)\n    last_login: Optional[datetime] = None\n\nclass RegistrationFlow(Flow[UserRegistrationState]):\n    # Methods with strongly-typed state access",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Mastering Flow State Management",
          "level": 1
        },
        {
          "title": "Best Practices for State Management",
          "level": 2
        },
        {
          "title": "2. Use Structured State for Complex Flows",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Mastering Flow State Management",
            "level": 1
          },
          {
            "title": "Best Practices for State Management",
            "level": 2
          },
          {
            "title": "2. Use Structured State for Complex Flows",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Mastering Flow State Management > Best Practices for State Management > 2. Use Structured State for Complex Flows"
      },
      "enhanced_content": "Context: Changelog > Mastering Flow State Management > Best Practices for State Management > 2. Use Structured State for Complex Flows\n\n# Simple flow can use unstructured state\nclass SimpleGreetingFlow(Flow):\n    @start()\n    def greet(self):\n        self.state[\"name\"] = \"World\"\n        return f\"Hello, {self.state['name']}!\"\n\n# Complex flow benefits from structured state\nclass UserRegistrationState(BaseModel):\n    username: str\n    email: str\n    verification_status: bool = False\n    registration_date: datetime = Field(default_factory=datetime.now)\n    last_login: Optional[datetime] = None\n\nclass RegistrationFlow(Flow[UserRegistrationState]):\n    # Methods with strongly-typed state access",
      "formatted_path": "Changelog > Mastering Flow State Management > Best Practices for State Management > 2. Use Structured State for Complex Flows",
      "enhanced_text": "Context: Changelog > Mastering Flow State Management > Best Practices for State Management > 2. Use Structured State for Complex Flows\n\n# Simple flow can use unstructured state\nclass SimpleGreetingFlow(Flow):\n    @start()\n    def greet(self):\n        self.state[\"name\"] = \"World\"\n        return f\"Hello, {self.state['name']}!\"\n\n# Complex flow benefits from structured state\nclass UserRegistrationState(BaseModel):\n    username: str\n    email: str\n    verification_status: bool = False\n    registration_date: datetime = Field(default_factory=datetime.now)\n    last_login: Optional[datetime] = None\n\nclass RegistrationFlow(Flow[UserRegistrationState]):\n    # Methods with strongly-typed state access"
    },
    {
      "content": "@start()\ndef initialize_order(self):\n    \"\"\"\n    Initialize order state with empty values.\n\n    State before: {}\n    State after: {order_id: str, items: [], status: 'new'}\n    \"\"\"\n    self.state.order_id = str(uuid.uuid4())\n    self.state.items = []\n    self.state.status = \"new\"\n    return \"Order initialized\"",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Mastering Flow State Management",
          "level": 1
        },
        {
          "title": "Best Practices for State Management",
          "level": 2
        },
        {
          "title": "3. Document State Transitions",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Mastering Flow State Management",
            "level": 1
          },
          {
            "title": "Best Practices for State Management",
            "level": 2
          },
          {
            "title": "3. Document State Transitions",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Mastering Flow State Management > Best Practices for State Management > 3. Document State Transitions"
      },
      "enhanced_content": "Context: Changelog > Mastering Flow State Management > Best Practices for State Management > 3. Document State Transitions\n\n@start()\ndef initialize_order(self):\n    \"\"\"\n    Initialize order state with empty values.\n\n    State before: {}\n    State after: {order_id: str, items: [], status: 'new'}\n    \"\"\"\n    self.state.order_id = str(uuid.uuid4())\n    self.state.items = []\n    self.state.status = \"new\"\n    return \"Order initialized\"",
      "formatted_path": "Changelog > Mastering Flow State Management > Best Practices for State Management > 3. Document State Transitions",
      "enhanced_text": "Context: Changelog > Mastering Flow State Management > Best Practices for State Management > 3. Document State Transitions\n\n@start()\ndef initialize_order(self):\n    \"\"\"\n    Initialize order state with empty values.\n\n    State before: {}\n    State after: {order_id: str, items: [], status: 'new'}\n    \"\"\"\n    self.state.order_id = str(uuid.uuid4())\n    self.state.items = []\n    self.state.status = \"new\"\n    return \"Order initialized\""
    },
    {
      "content": "@listen(previous_step)\ndef process_data(self, _):\n    try:\n        # Try to access a value that might not exist\n        user_preference = self.state.preferences.get(\"theme\", \"default\")\n    except (AttributeError, KeyError):\n        # Handle the error gracefully\n        self.state.errors = self.state.get(\"errors\", [])\n        self.state.errors.append(\"Failed to access preferences\")\n        user_preference = \"default\"\n\n    return f\"Used preference: {user_preference}\"",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Mastering Flow State Management",
          "level": 1
        },
        {
          "title": "Best Practices for State Management",
          "level": 2
        },
        {
          "title": "4. Handle State Errors Gracefully",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Mastering Flow State Management",
            "level": 1
          },
          {
            "title": "Best Practices for State Management",
            "level": 2
          },
          {
            "title": "4. Handle State Errors Gracefully",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Mastering Flow State Management > Best Practices for State Management > 4. Handle State Errors Gracefully"
      },
      "enhanced_content": "Context: Changelog > Mastering Flow State Management > Best Practices for State Management > 4. Handle State Errors Gracefully\n\n@listen(previous_step)\ndef process_data(self, _):\n    try:\n        # Try to access a value that might not exist\n        user_preference = self.state.preferences.get(\"theme\", \"default\")\n    except (AttributeError, KeyError):\n        # Handle the error gracefully\n        self.state.errors = self.state.get(\"errors\", [])\n        self.state.errors.append(\"Failed to access preferences\")\n        user_preference = \"default\"\n\n    return f\"Used preference: {user_preference}\"",
      "formatted_path": "Changelog > Mastering Flow State Management > Best Practices for State Management > 4. Handle State Errors Gracefully",
      "enhanced_text": "Context: Changelog > Mastering Flow State Management > Best Practices for State Management > 4. Handle State Errors Gracefully\n\n@listen(previous_step)\ndef process_data(self, _):\n    try:\n        # Try to access a value that might not exist\n        user_preference = self.state.preferences.get(\"theme\", \"default\")\n    except (AttributeError, KeyError):\n        # Handle the error gracefully\n        self.state.errors = self.state.get(\"errors\", [])\n        self.state.errors.append(\"Failed to access preferences\")\n        user_preference = \"default\"\n\n    return f\"Used preference: {user_preference}\""
    },
    {
      "content": "class ProgressTrackingFlow(Flow):\n    @start()\n    def initialize(self):\n        self.state[\"total_steps\"] = 3\n        self.state[\"current_step\"] = 0\n        self.state[\"progress\"] = 0.0\n        self.update_progress()\n        return \"Initialized\"\n\n    def update_progress(self):\n        \"\"\"Helper method to calculate and update progress\"\"\"\n        if self.state.get(\"total_steps\", 0) > 0:\n            self.state[\"progress\"] = (self.state.get(\"current_step\", 0) /\n                                    self.state[\"total_steps\"]) * 100\n            print(f\"Progress: {self.state['progress']:.1f}%\")\n\n    @listen(initialize)\n    def step_one(self, _):\n        # Do work...\n        self.state[\"current_step\"] = 1\n        self.update_progress()\n        return \"Step 1 complete\"\n\n    # Additional steps...",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Mastering Flow State Management",
          "level": 1
        },
        {
          "title": "Best Practices for State Management",
          "level": 2
        },
        {
          "title": "5. Use State for Progress Tracking",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Mastering Flow State Management",
            "level": 1
          },
          {
            "title": "Best Practices for State Management",
            "level": 2
          },
          {
            "title": "5. Use State for Progress Tracking",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Mastering Flow State Management > Best Practices for State Management > 5. Use State for Progress Tracking"
      },
      "enhanced_content": "Context: Changelog > Mastering Flow State Management > Best Practices for State Management > 5. Use State for Progress Tracking\n\nclass ProgressTrackingFlow(Flow):\n    @start()\n    def initialize(self):\n        self.state[\"total_steps\"] = 3\n        self.state[\"current_step\"] = 0\n        self.state[\"progress\"] = 0.0\n        self.update_progress()\n        return \"Initialized\"\n\n    def update_progress(self):\n        \"\"\"Helper method to calculate and update progress\"\"\"\n        if self.state.get(\"total_steps\", 0) > 0:\n            self.state[\"progress\"] = (self.state.get(\"current_step\", 0) /\n                                    self.state[\"total_steps\"]) * 100\n            print(f\"Progress: {self.state['progress']:.1f}%\")\n\n    @listen(initialize)\n    def step_one(self, _):\n        # Do work...\n        self.state[\"current_step\"] = 1\n        self.update_progress()\n        return \"Step 1 complete\"\n\n    # Additional steps...",
      "formatted_path": "Changelog > Mastering Flow State Management > Best Practices for State Management > 5. Use State for Progress Tracking",
      "enhanced_text": "Context: Changelog > Mastering Flow State Management > Best Practices for State Management > 5. Use State for Progress Tracking\n\nclass ProgressTrackingFlow(Flow):\n    @start()\n    def initialize(self):\n        self.state[\"total_steps\"] = 3\n        self.state[\"current_step\"] = 0\n        self.state[\"progress\"] = 0.0\n        self.update_progress()\n        return \"Initialized\"\n\n    def update_progress(self):\n        \"\"\"Helper method to calculate and update progress\"\"\"\n        if self.state.get(\"total_steps\", 0) > 0:\n            self.state[\"progress\"] = (self.state.get(\"current_step\", 0) /\n                                    self.state[\"total_steps\"]) * 100\n            print(f\"Progress: {self.state['progress']:.1f}%\")\n\n    @listen(initialize)\n    def step_one(self, _):\n        # Do work...\n        self.state[\"current_step\"] = 1\n        self.update_progress()\n        return \"Step 1 complete\"\n\n    # Additional steps..."
    },
    {
      "content": "# Instead of modifying lists in place:\nself.state.items.append(new_item)  # Mutable operation\n\n# Consider creating new state:\nfrom pydantic import BaseModel\nfrom typing import List\n\nclass ItemState(BaseModel):\n    items: List[str] = []\n\nclass ImmutableFlow(Flow[ItemState]):\n    @start()\n    def add_item(self):\n        # Create new list with the added item\n        self.state.items = [*self.state.items, \"new item\"]\n        return \"Item added\"",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Mastering Flow State Management",
          "level": 1
        },
        {
          "title": "Best Practices for State Management",
          "level": 2
        },
        {
          "title": "6. Use Immutable Operations When Possible",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Mastering Flow State Management",
            "level": 1
          },
          {
            "title": "Best Practices for State Management",
            "level": 2
          },
          {
            "title": "6. Use Immutable Operations When Possible",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Mastering Flow State Management > Best Practices for State Management > 6. Use Immutable Operations When Possible"
      },
      "enhanced_content": "Context: Changelog > Mastering Flow State Management > Best Practices for State Management > 6. Use Immutable Operations When Possible\n\n# Instead of modifying lists in place:\nself.state.items.append(new_item)  # Mutable operation\n\n# Consider creating new state:\nfrom pydantic import BaseModel\nfrom typing import List\n\nclass ItemState(BaseModel):\n    items: List[str] = []\n\nclass ImmutableFlow(Flow[ItemState]):\n    @start()\n    def add_item(self):\n        # Create new list with the added item\n        self.state.items = [*self.state.items, \"new item\"]\n        return \"Item added\"",
      "formatted_path": "Changelog > Mastering Flow State Management > Best Practices for State Management > 6. Use Immutable Operations When Possible",
      "enhanced_text": "Context: Changelog > Mastering Flow State Management > Best Practices for State Management > 6. Use Immutable Operations When Possible\n\n# Instead of modifying lists in place:\nself.state.items.append(new_item)  # Mutable operation\n\n# Consider creating new state:\nfrom pydantic import BaseModel\nfrom typing import List\n\nclass ItemState(BaseModel):\n    items: List[str] = []\n\nclass ImmutableFlow(Flow[ItemState]):\n    @start()\n    def add_item(self):\n        # Create new list with the added item\n        self.state.items = [*self.state.items, \"new item\"]\n        return \"Item added\""
    },
    {
      "content": "import logging\nlogging.basicConfig(level=logging.INFO)\n\nclass LoggingFlow(Flow):\n    def log_state(self, step_name):\n        logging.info(f\"State after {step_name}: {self.state}\")\n\n    @start()\n    def initialize(self):\n        self.state[\"counter\"] = 0\n        self.log_state(\"initialize\")\n        return \"Initialized\"\n\n    @listen(initialize)\n    def increment(self, _):\n        self.state[\"counter\"] += 1\n        self.log_state(\"increment\")\n        return f\"Incremented to {self.state['counter']}\"",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Mastering Flow State Management",
          "level": 1
        },
        {
          "title": "Debugging Flow State",
          "level": 2
        },
        {
          "title": "Logging State Changes",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Mastering Flow State Management",
            "level": 1
          },
          {
            "title": "Debugging Flow State",
            "level": 2
          },
          {
            "title": "Logging State Changes",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Mastering Flow State Management > Debugging Flow State > Logging State Changes"
      },
      "enhanced_content": "Context: Changelog > Mastering Flow State Management > Debugging Flow State > Logging State Changes\n\nimport logging\nlogging.basicConfig(level=logging.INFO)\n\nclass LoggingFlow(Flow):\n    def log_state(self, step_name):\n        logging.info(f\"State after {step_name}: {self.state}\")\n\n    @start()\n    def initialize(self):\n        self.state[\"counter\"] = 0\n        self.log_state(\"initialize\")\n        return \"Initialized\"\n\n    @listen(initialize)\n    def increment(self, _):\n        self.state[\"counter\"] += 1\n        self.log_state(\"increment\")\n        return f\"Incremented to {self.state['counter']}\"",
      "formatted_path": "Changelog > Mastering Flow State Management > Debugging Flow State > Logging State Changes",
      "enhanced_text": "Context: Changelog > Mastering Flow State Management > Debugging Flow State > Logging State Changes\n\nimport logging\nlogging.basicConfig(level=logging.INFO)\n\nclass LoggingFlow(Flow):\n    def log_state(self, step_name):\n        logging.info(f\"State after {step_name}: {self.state}\")\n\n    @start()\n    def initialize(self):\n        self.state[\"counter\"] = 0\n        self.log_state(\"initialize\")\n        return \"Initialized\"\n\n    @listen(initialize)\n    def increment(self, _):\n        self.state[\"counter\"] += 1\n        self.log_state(\"increment\")\n        return f\"Incremented to {self.state['counter']}\""
    },
    {
      "content": "def visualize_state(self):\n    \"\"\"Create a simple visualization of the current state\"\"\"\n    import json\n    from rich.console import Console\n    from rich.panel import Panel\n\n    console = Console()\n\n    if hasattr(self.state, \"model_dump\"):\n        # Pydantic v2\n        state_dict = self.state.model_dump()\n    elif hasattr(self.state, \"dict\"):\n        # Pydantic v1\n        state_dict = self.state.dict()\n    else:\n        # Unstructured state\n        state_dict = dict(self.state)\n\n    # Remove id for cleaner output\n    if \"id\" in state_dict:\n        state_dict.pop(\"id\")\n\n    state_json = json.dumps(state_dict, indent=2, default=str)\n    console.print(Panel(state_json, title=\"Current Flow State\"))",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Mastering Flow State Management",
          "level": 1
        },
        {
          "title": "Debugging Flow State",
          "level": 2
        },
        {
          "title": "State Visualization",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Mastering Flow State Management",
            "level": 1
          },
          {
            "title": "Debugging Flow State",
            "level": 2
          },
          {
            "title": "State Visualization",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Mastering Flow State Management > Debugging Flow State > State Visualization"
      },
      "enhanced_content": "Context: Changelog > Mastering Flow State Management > Debugging Flow State > State Visualization\n\ndef visualize_state(self):\n    \"\"\"Create a simple visualization of the current state\"\"\"\n    import json\n    from rich.console import Console\n    from rich.panel import Panel\n\n    console = Console()\n\n    if hasattr(self.state, \"model_dump\"):\n        # Pydantic v2\n        state_dict = self.state.model_dump()\n    elif hasattr(self.state, \"dict\"):\n        # Pydantic v1\n        state_dict = self.state.dict()\n    else:\n        # Unstructured state\n        state_dict = dict(self.state)\n\n    # Remove id for cleaner output\n    if \"id\" in state_dict:\n        state_dict.pop(\"id\")\n\n    state_json = json.dumps(state_dict, indent=2, default=str)\n    console.print(Panel(state_json, title=\"Current Flow State\"))",
      "formatted_path": "Changelog > Mastering Flow State Management > Debugging Flow State > State Visualization",
      "enhanced_text": "Context: Changelog > Mastering Flow State Management > Debugging Flow State > State Visualization\n\ndef visualize_state(self):\n    \"\"\"Create a simple visualization of the current state\"\"\"\n    import json\n    from rich.console import Console\n    from rich.panel import Panel\n\n    console = Console()\n\n    if hasattr(self.state, \"model_dump\"):\n        # Pydantic v2\n        state_dict = self.state.model_dump()\n    elif hasattr(self.state, \"dict\"):\n        # Pydantic v1\n        state_dict = self.state.dict()\n    else:\n        # Unstructured state\n        state_dict = dict(self.state)\n\n    # Remove id for cleaner output\n    if \"id\" in state_dict:\n        state_dict.pop(\"id\")\n\n    state_json = json.dumps(state_dict, indent=2, default=str)\n    console.print(Panel(state_json, title=\"Current Flow State\"))"
    },
    {
      "content": "Source: https://docs.crewai.com/how-to/agentops-observability Understanding and logging your agent performance with AgentOps.",
      "title": "AgentOps Integration",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "AgentOps Integration",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "AgentOps Integration",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > AgentOps Integration"
      },
      "enhanced_content": "Context: Changelog > AgentOps Integration\n\n# AgentOps Integration\n\nSource: https://docs.crewai.com/how-to/agentops-observability Understanding and logging your agent performance with AgentOps.",
      "formatted_path": "Changelog > AgentOps Integration",
      "enhanced_text": "Context: Changelog > AgentOps Integration\n\n AgentOps Integration\n\nSource: https://docs.crewai.com/how-to/agentops-observability Understanding and logging your agent performance with AgentOps.\n\nRelated sections:\n- \n"
    },
    {
      "content": "[AgentOps](https://agentops.ai/?=crew) provides session replays, metrics, and monitoring for agents. At a high level, AgentOps gives you the ability to monitor cost, token usage, latency, agent failures, session-wide statistics, and more.\nFor more info, check out the [AgentOps Repo](https://github.com/AgentOps-AI/agentops).",
      "title": "AgentOps",
      "type": "link_list",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Introduction",
          "level": 1
        },
        {
          "title": "AgentOps",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Introduction",
            "level": 1
          },
          {
            "title": "AgentOps",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 2,
        "formatted_path": "Changelog > Introduction > AgentOps"
      },
      "enhanced_content": "Context: Changelog > Introduction > AgentOps\n\n## AgentOps\n\n[AgentOps](https://agentops.ai/?=crew) provides session replays, metrics, and monitoring for agents. At a high level, AgentOps gives you the ability to monitor cost, token usage, latency, agent failures, session-wide statistics, and more.\nFor more info, check out the [AgentOps Repo](https://github.com/AgentOps-AI/agentops).",
      "formatted_path": "Changelog > Introduction > AgentOps",
      "enhanced_text": "Context: Changelog > Introduction > AgentOps\n\n AgentOps\n\n[AgentOps](https://agentops.ai/?=crew) provides session replays, metrics, and monitoring for agents. At a high level, AgentOps gives you the ability to monitor cost, token usage, latency, agent failures, session-wide statistics, and more.\nFor more info, check out the [AgentOps Repo](https://github.com/AgentOps-AI/agentops).\n\nRelated sections:\n- \n- \n- \n- \n"
    },
    {
      "content": "Fingerprints in CrewAI provide a way to uniquely identify and track components throughout their lifecycle. Each `Agent`, `Crew`, and `Task` automatically receives a unique fingerprint when created, which cannot be manually overridden. These fingerprints can be used for: Auditing and tracking component usage Ensuring component identity integrity Attaching metadata to components Creating a traceable chain of operations\n\nAgentOps provides monitoring for agents in development and production.\nIt provides a dashboard for tracking agent performance, session replays, and custom reporting. Additionally, AgentOps provides session drilldowns for viewing Crew agent interactions, LLM calls, and tool usage in real-time.\nThis feature is useful for debugging and understanding how agents interact with users as well as other agents. ![Overview of a select series of agent session runs](https://mintlify.s3.us-west-1.amazonaws.com/crewai/images/agentops-overview.png)\n![Overview of session drilldowns for examining agent runs](https://mintlify.s3.us-west-1.amazonaws.com/crewai/images/agentops-session.png)\n![Viewing a step-by-step agent replay execution graph](https://mintlify.s3.us-west-1.amazonaws.com/crewai/images/agentops-replay.png)",
      "title": "Overview",
      "type": "link_list",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Introduction",
          "level": 1
        },
        {
          "title": "AgentOps",
          "level": 2
        },
        {
          "title": "Overview",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Introduction",
            "level": 1
          },
          {
            "title": "AgentOps",
            "level": 2
          },
          {
            "title": "Overview",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 3,
        "formatted_path": "Changelog > Introduction > AgentOps > Overview"
      },
      "enhanced_content": "Context: Changelog > Introduction > AgentOps > Overview\n\n### Overview\n\nFingerprints in CrewAI provide a way to uniquely identify and track components throughout their lifecycle. Each `Agent`, `Crew`, and `Task` automatically receives a unique fingerprint when created, which cannot be manually overridden. These fingerprints can be used for: Auditing and tracking component usage Ensuring component identity integrity Attaching metadata to components Creating a traceable chain of operations\n\nAgentOps provides monitoring for agents in development and production.\nIt provides a dashboard for tracking agent performance, session replays, and custom reporting. Additionally, AgentOps provides session drilldowns for viewing Crew agent interactions, LLM calls, and tool usage in real-time.\nThis feature is useful for debugging and understanding how agents interact with users as well as other agents. ![Overview of a select series of agent session runs](https://mintlify.s3.us-west-1.amazonaws.com/crewai/images/agentops-overview.png)\n![Overview of session drilldowns for examining agent runs](https://mintlify.s3.us-west-1.amazonaws.com/crewai/images/agentops-session.png)\n![Viewing a step-by-step agent replay execution graph](https://mintlify.s3.us-west-1.amazonaws.com/crewai/images/agentops-replay.png)",
      "formatted_path": "Changelog > Introduction > AgentOps > Overview",
      "enhanced_text": "Context: Changelog > Introduction > AgentOps > Overview\n\n Overview\n\nFingerprints in CrewAI provide a way to uniquely identify and track components throughout their lifecycle. Each `Agent`, `Crew`, and `Task` automatically receives a unique fingerprint when created, which cannot be manually overridden. These fingerprints can be used for: Auditing and tracking component usage Ensuring component identity integrity Attaching metadata to components Creating a traceable chain of operations\n\nAgentOps provides monitoring for agents in development and production.\nIt provides a dashboard for tracking agent performance, session replays, and custom reporting. Additionally, AgentOps provides session drilldowns for viewing Crew agent interactions, LLM calls, and tool usage in real-time.\nThis feature is useful for debugging and understanding how agents interact with users as well as other agents. ![Overview of a select series of agent session runs](https://mintlify.s3.us-west-1.amazonaws.com/crewai/images/agentops-overview.png)\n![Overview of session drilldowns for examining agent runs](https://mintlify.s3.us-west-1.amazonaws.com/crewai/images/agentops-session.png)\n![Viewing a step-by-step agent replay execution graph](https://mintlify.s3.us-west-1.amazonaws.com/crewai/images/agentops-replay.png)\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "To get started, create an [AgentOps account](https://agentops.ai/?=crew). For feature requests or bug reports, please reach out to the AgentOps team on the [AgentOps Repo](https://github.com/AgentOps-AI/agentops).",
      "title": "Further Information",
      "type": "link_list",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Introduction",
          "level": 1
        },
        {
          "title": "AgentOps",
          "level": 2
        },
        {
          "title": "Further Information",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Introduction",
            "level": 1
          },
          {
            "title": "AgentOps",
            "level": 2
          },
          {
            "title": "Further Information",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 2,
        "formatted_path": "Changelog > Introduction > AgentOps > Further Information"
      },
      "enhanced_content": "Context: Changelog > Introduction > AgentOps > Further Information\n\n### Further Information\n\nTo get started, create an [AgentOps account](https://agentops.ai/?=crew). For feature requests or bug reports, please reach out to the AgentOps team on the [AgentOps Repo](https://github.com/AgentOps-AI/agentops).",
      "formatted_path": "Changelog > Introduction > AgentOps > Further Information",
      "enhanced_text": "Context: Changelog > Introduction > AgentOps > Further Information\n\n Further Information\n\nTo get started, create an [AgentOps account](https://agentops.ai/?=crew). For feature requests or bug reports, please reach out to the AgentOps team on the [AgentOps Repo](https://github.com/AgentOps-AI/agentops)."
    },
    {
      "content": "<a href=\"https://twitter.com/agentopsai/\">\ud83d\udc26 Twitter</a>\n<span>\u00a0\u00a0\u2022\u00a0\u00a0</span>\n<a href=\"https://discord.gg/JHPt4C7r\">\ud83d\udce2 Discord</a>\n<span>\u00a0\u00a0\u2022\u00a0\u00a0</span>\n<a href=\"https://app.agentops.ai/?=crew\">\ud83d\udd87\ufe0f AgentOps Dashboard</a>\n<span>\u00a0\u00a0\u2022\u00a0\u00a0</span>\n<a href=\"https://docs.agentops.ai/introduction\">\ud83d\udcd9 Documentation</a>",
      "title": "Extra links",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Introduction",
          "level": 1
        },
        {
          "title": "AgentOps",
          "level": 2
        },
        {
          "title": "Further Information",
          "level": 3
        },
        {
          "title": "Extra links",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Introduction",
            "level": 1
          },
          {
            "title": "AgentOps",
            "level": 2
          },
          {
            "title": "Further Information",
            "level": 3
          },
          {
            "title": "Extra links",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Introduction > AgentOps > Further Information > Extra links"
      },
      "enhanced_content": "Context: Changelog > Introduction > AgentOps > Further Information > Extra links\n\n#### Extra links\n\n<a href=\"https://twitter.com/agentopsai/\">\ud83d\udc26 Twitter</a>\n<span>\u00a0\u00a0\u2022\u00a0\u00a0</span>\n<a href=\"https://discord.gg/JHPt4C7r\">\ud83d\udce2 Discord</a>\n<span>\u00a0\u00a0\u2022\u00a0\u00a0</span>\n<a href=\"https://app.agentops.ai/?=crew\">\ud83d\udd87\ufe0f AgentOps Dashboard</a>\n<span>\u00a0\u00a0\u2022\u00a0\u00a0</span>\n<a href=\"https://docs.agentops.ai/introduction\">\ud83d\udcd9 Documentation</a>",
      "formatted_path": "Changelog > Introduction > AgentOps > Further Information > Extra links",
      "enhanced_text": "Context: Changelog > Introduction > AgentOps > Further Information > Extra links\n\n Extra links\n\n<a href=\"https://twitter.com/agentopsai/\">\ud83d\udc26 Twitter</a>\n<span>\u00a0\u00a0\u2022\u00a0\u00a0</span>\n<a href=\"https://discord.gg/JHPt4C7r\">\ud83d\udce2 Discord</a>\n<span>\u00a0\u00a0\u2022\u00a0\u00a0</span>\n<a href=\"https://app.agentops.ai/?=crew\">\ud83d\udd87\ufe0f AgentOps Dashboard</a>\n<span>\u00a0\u00a0\u2022\u00a0\u00a0</span>\n<a href=\"https://docs.agentops.ai/introduction\">\ud83d\udcd9 Documentation</a>"
    },
    {
      "content": "Source: https://docs.crewai.com/how-to/coding-agents Learn how to enable your CrewAI Agents to write and execute code, and explore advanced features for enhanced functionality.",
      "title": "Coding Agents",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Coding Agents",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Coding Agents",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Coding Agents"
      },
      "enhanced_content": "Context: Changelog > Coding Agents\n\n# Coding Agents\n\nSource: https://docs.crewai.com/how-to/coding-agents Learn how to enable your CrewAI Agents to write and execute code, and explore advanced features for enhanced functionality.",
      "formatted_path": "Changelog > Coding Agents",
      "enhanced_text": "Context: Changelog > Coding Agents\n\n Coding Agents\n\nSource: https://docs.crewai.com/how-to/coding-agents Learn how to enable your CrewAI Agents to write and execute code, and explore advanced features for enhanced functionality.\n\nRelated sections:\n- \n"
    },
    {
      "content": "from crewai import Agent\n\ncoding_agent = Agent(\n    role=\"Senior Python Developer\",\n    goal=\"Craft well-designed and thought-out code\",\n    backstory=\"You are a senior Python developer with extensive experience in software architecture and best practices.\",\n    allow_code_execution=True\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Coding Agents",
          "level": 1
        },
        {
          "title": "Enabling Code Execution",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Coding Agents",
            "level": 1
          },
          {
            "title": "Enabling Code Execution",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Coding Agents > Enabling Code Execution"
      },
      "enhanced_content": "Context: Changelog > Coding Agents > Enabling Code Execution\n\nfrom crewai import Agent\n\ncoding_agent = Agent(\n    role=\"Senior Python Developer\",\n    goal=\"Craft well-designed and thought-out code\",\n    backstory=\"You are a senior Python developer with extensive experience in software architecture and best practices.\",\n    allow_code_execution=True\n)",
      "formatted_path": "Changelog > Coding Agents > Enabling Code Execution",
      "enhanced_text": "Context: Changelog > Coding Agents > Enabling Code Execution\n\nfrom crewai import Agent\n\ncoding_agent = Agent(\n    role=\"Senior Python Developer\",\n    goal=\"Craft well-designed and thought-out code\",\n    backstory=\"You are a senior Python developer with extensive experience in software architecture and best practices.\",\n    allow_code_execution=True\n)"
    },
    {
      "content": "**State Types**: Both structured (Pydantic BaseModel) and unstructured (dictionary) states are supported **Automatic ID**: The `id` field is automatically added if not present **State Recovery**: Failed or restarted flows can automatically reload their previous state **Custom Implementation**: You can provide your own FlowPersistence implementation for specialized storage needs",
      "title": "Important Considerations",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Coding Agents",
          "level": 1
        },
        {
          "title": "Important Considerations",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Coding Agents",
            "level": 1
          },
          {
            "title": "Important Considerations",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Coding Agents > Important Considerations"
      },
      "enhanced_content": "Context: Changelog > Coding Agents > Important Considerations\n\n## Important Considerations\n\n**State Types**: Both structured (Pydantic BaseModel) and unstructured (dictionary) states are supported **Automatic ID**: The `id` field is automatically added if not present **State Recovery**: Failed or restarted flows can automatically reload their previous state **Custom Implementation**: You can provide your own FlowPersistence implementation for specialized storage needs",
      "formatted_path": "Changelog > Coding Agents > Important Considerations",
      "enhanced_text": "Context: Changelog > Coding Agents > Important Considerations\n\n Important Considerations\n\n**State Types**: Both structured (Pydantic BaseModel) and unstructured (dictionary) states are supported **Automatic ID**: The `id` field is automatically added if not present **State Recovery**: Failed or restarted flows can automatically reload their previous state **Custom Implementation**: You can provide your own FlowPersistence implementation for specialized storage needs\n\nRelated sections:\n- \n"
    },
    {
      "content": "**Model Selection**: It is strongly recommended to use more capable models like Claude 3.5 Sonnet and GPT-4 when enabling code execution.\nThese models have a better understanding of programming concepts and are more likely to generate correct and efficient code. **Error Handling**: The code execution feature includes error handling. If executed code raises an exception, the agent will receive the error message and can attempt to correct the code or\nprovide alternative solutions. The `max_retry_limit` parameter, which defaults to 2, controls the maximum number of retries for a task. **Dependencies**: To use the code execution feature, you need to install the `crewai_tools` package. If not installed, the agent will log an info message:\n\"Coding tools not available. Install crewai\\_tools.\"",
      "title": "Important Considerations",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Coding Agents",
          "level": 1
        },
        {
          "title": "Important Considerations",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Coding Agents",
            "level": 1
          },
          {
            "title": "Important Considerations",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Coding Agents > Important Considerations"
      },
      "enhanced_content": "Context: Changelog > Coding Agents > Important Considerations\n\n## Important Considerations\n\n**Model Selection**: It is strongly recommended to use more capable models like Claude 3.5 Sonnet and GPT-4 when enabling code execution.\nThese models have a better understanding of programming concepts and are more likely to generate correct and efficient code. **Error Handling**: The code execution feature includes error handling. If executed code raises an exception, the agent will receive the error message and can attempt to correct the code or\nprovide alternative solutions. The `max_retry_limit` parameter, which defaults to 2, controls the maximum number of retries for a task. **Dependencies**: To use the code execution feature, you need to install the `crewai_tools` package. If not installed, the agent will log an info message:\n\"Coding tools not available. Install crewai\\_tools.\"",
      "formatted_path": "Changelog > Coding Agents > Important Considerations",
      "enhanced_text": "Context: Changelog > Coding Agents > Important Considerations\n\n Important Considerations\n\n**Model Selection**: It is strongly recommended to use more capable models like Claude 3.5 Sonnet and GPT-4 when enabling code execution.\nThese models have a better understanding of programming concepts and are more likely to generate correct and efficient code. **Error Handling**: The code execution feature includes error handling. If executed code raises an exception, the agent will receive the error message and can attempt to correct the code or\nprovide alternative solutions. The `max_retry_limit` parameter, which defaults to 2, controls the maximum number of retries for a task. **Dependencies**: To use the code execution feature, you need to install the `crewai_tools` package. If not installed, the agent will log an info message:\n\"Coding tools not available. Install crewai\\_tools.\"\n\nRelated sections:\n- \n"
    },
    {
      "content": "When an agent with code execution enabled encounters a task requiring programming:",
      "title": "Code Execution Process",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Coding Agents",
          "level": 1
        },
        {
          "title": "Code Execution Process",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Coding Agents",
            "level": 1
          },
          {
            "title": "Code Execution Process",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Coding Agents > Code Execution Process"
      },
      "enhanced_content": "Context: Changelog > Coding Agents > Code Execution Process\n\n## Code Execution Process\n\nWhen an agent with code execution enabled encounters a task requiring programming:",
      "formatted_path": "Changelog > Coding Agents > Code Execution Process",
      "enhanced_text": "Context: Changelog > Coding Agents > Code Execution Process\n\n Code Execution Process\n\nWhen an agent with code execution enabled encounters a task requiring programming:\n\nRelated sections:\n- \n"
    },
    {
      "content": "Source: https://docs.crewai.com/how-to/conditional-tasks Learn how to use conditional tasks in a crewAI kickoff",
      "title": "Conditional Tasks",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Conditional Tasks",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Conditional Tasks",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Conditional Tasks"
      },
      "enhanced_content": "Context: Changelog > Conditional Tasks\n\n# Conditional Tasks\n\nSource: https://docs.crewai.com/how-to/conditional-tasks Learn how to use conditional tasks in a crewAI kickoff",
      "formatted_path": "Changelog > Conditional Tasks",
      "enhanced_text": "Context: Changelog > Conditional Tasks\n\n Conditional Tasks\n\nSource: https://docs.crewai.com/how-to/conditional-tasks Learn how to use conditional tasks in a crewAI kickoff\n\nRelated sections:\n- \n"
    },
    {
      "content": "Source: https://docs.crewai.com/how-to/create-custom-tools Comprehensive guide on crafting, using, and managing custom tools within the CrewAI framework, including new functionalities and error handling.",
      "title": "Create Custom Tools",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Create Custom Tools",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Create Custom Tools",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Create Custom Tools"
      },
      "enhanced_content": "Context: Changelog > Create Custom Tools\n\n# Create Custom Tools\n\nSource: https://docs.crewai.com/how-to/create-custom-tools Comprehensive guide on crafting, using, and managing custom tools within the CrewAI framework, including new functionalities and error handling.",
      "formatted_path": "Changelog > Create Custom Tools",
      "enhanced_text": "Context: Changelog > Create Custom Tools\n\n Create Custom Tools\n\nSource: https://docs.crewai.com/how-to/create-custom-tools Comprehensive guide on crafting, using, and managing custom tools within the CrewAI framework, including new functionalities and error handling.\n\nRelated sections:\n- \n"
    },
    {
      "content": "This guide provides detailed instructions on creating custom tools for the CrewAI framework and how to efficiently manage and utilize these tools,\nincorporating the latest functionalities such as tool delegation, error handling, and dynamic tool calling. It also highlights the importance of collaboration tools,\nenabling agents to perform a wide range of actions.",
      "title": "Creating and Utilizing Tools in CrewAI",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Create Custom Tools",
          "level": 1
        },
        {
          "title": "Creating and Utilizing Tools in CrewAI",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Create Custom Tools",
            "level": 1
          },
          {
            "title": "Creating and Utilizing Tools in CrewAI",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Create Custom Tools > Creating and Utilizing Tools in CrewAI"
      },
      "enhanced_content": "Context: Changelog > Create Custom Tools > Creating and Utilizing Tools in CrewAI\n\n## Creating and Utilizing Tools in CrewAI\n\nThis guide provides detailed instructions on creating custom tools for the CrewAI framework and how to efficiently manage and utilize these tools,\nincorporating the latest functionalities such as tool delegation, error handling, and dynamic tool calling. It also highlights the importance of collaboration tools,\nenabling agents to perform a wide range of actions.",
      "formatted_path": "Changelog > Create Custom Tools > Creating and Utilizing Tools in CrewAI",
      "enhanced_text": "Context: Changelog > Create Custom Tools > Creating and Utilizing Tools in CrewAI\n\n Creating and Utilizing Tools in CrewAI\n\nThis guide provides detailed instructions on creating custom tools for the CrewAI framework and how to efficiently manage and utilize these tools,\nincorporating the latest functionalities such as tool delegation, error handling, and dynamic tool calling. It also highlights the importance of collaboration tools,\nenabling agents to perform a wide range of actions.\n\nRelated sections:\n- \n"
    },
    {
      "content": "from crewai.tools import BaseTool\nfrom pydantic import BaseModel, Field\n\nclass MyToolInput(BaseModel):\n    \"\"\"Input schema for MyCustomTool.\"\"\"\n    argument: str = Field(..., description=\"Description of the argument.\")\n\nclass MyCustomTool(BaseTool):\n    name: str = \"Name of my tool\"\n    description: str = \"What this tool does. It's vital for effective utilization.\"\n    args_schema: Type[BaseModel] = MyToolInput\n\n    def _run(self, argument: str) -> str:\n        # Your tool's logic here\n        return \"Tool's result\"",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Create Custom Tools",
          "level": 1
        },
        {
          "title": "Creating and Utilizing Tools in CrewAI",
          "level": 2
        },
        {
          "title": "Subclassing `BaseTool`",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Create Custom Tools",
            "level": 1
          },
          {
            "title": "Creating and Utilizing Tools in CrewAI",
            "level": 2
          },
          {
            "title": "Subclassing `BaseTool`",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Create Custom Tools > Creating and Utilizing Tools in CrewAI > Subclassing `BaseTool`"
      },
      "enhanced_content": "Context: Changelog > Create Custom Tools > Creating and Utilizing Tools in CrewAI > Subclassing `BaseTool`\n\nfrom crewai.tools import BaseTool\nfrom pydantic import BaseModel, Field\n\nclass MyToolInput(BaseModel):\n    \"\"\"Input schema for MyCustomTool.\"\"\"\n    argument: str = Field(..., description=\"Description of the argument.\")\n\nclass MyCustomTool(BaseTool):\n    name: str = \"Name of my tool\"\n    description: str = \"What this tool does. It's vital for effective utilization.\"\n    args_schema: Type[BaseModel] = MyToolInput\n\n    def _run(self, argument: str) -> str:\n        # Your tool's logic here\n        return \"Tool's result\"",
      "formatted_path": "Changelog > Create Custom Tools > Creating and Utilizing Tools in CrewAI > Subclassing `BaseTool`",
      "enhanced_text": "Context: Changelog > Create Custom Tools > Creating and Utilizing Tools in CrewAI > Subclassing `BaseTool`\n\nfrom crewai.tools import BaseTool\nfrom pydantic import BaseModel, Field\n\nclass MyToolInput(BaseModel):\n    \"\"\"Input schema for MyCustomTool.\"\"\"\n    argument: str = Field(..., description=\"Description of the argument.\")\n\nclass MyCustomTool(BaseTool):\n    name: str = \"Name of my tool\"\n    description: str = \"What this tool does. It's vital for effective utilization.\"\n    args_schema: Type[BaseModel] = MyToolInput\n\n    def _run(self, argument: str) -> str:\n        # Your tool's logic here\n        return \"Tool's result\""
    },
    {
      "content": "from typing import Type\nfrom crewai.tools import BaseTool\nfrom pydantic import BaseModel, Field\n\nclass MyToolInput(BaseModel):\n    \"\"\"Input schema for MyCustomTool.\"\"\"\n    argument: str = Field(..., description=\"Description of the argument.\")\n\nclass MyCustomTool(BaseTool):\n    name: str = \"Name of my tool\"\n    description: str = \"What this tool does. It's vital for effective utilization.\"\n    args_schema: Type[BaseModel] = MyToolInput\n\n    def _run(self, argument: str) -> str:\n        # Your tool's logic here\n        return \"Tool's result\"",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Create Custom Tools",
          "level": 1
        },
        {
          "title": "Creating and Utilizing Tools in CrewAI",
          "level": 2
        },
        {
          "title": "Subclassing `BaseTool`",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Create Custom Tools",
            "level": 1
          },
          {
            "title": "Creating and Utilizing Tools in CrewAI",
            "level": 2
          },
          {
            "title": "Subclassing `BaseTool`",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Create Custom Tools > Creating and Utilizing Tools in CrewAI > Subclassing `BaseTool`"
      },
      "enhanced_content": "Context: Changelog > Create Custom Tools > Creating and Utilizing Tools in CrewAI > Subclassing `BaseTool`\n\nfrom typing import Type\nfrom crewai.tools import BaseTool\nfrom pydantic import BaseModel, Field\n\nclass MyToolInput(BaseModel):\n    \"\"\"Input schema for MyCustomTool.\"\"\"\n    argument: str = Field(..., description=\"Description of the argument.\")\n\nclass MyCustomTool(BaseTool):\n    name: str = \"Name of my tool\"\n    description: str = \"What this tool does. It's vital for effective utilization.\"\n    args_schema: Type[BaseModel] = MyToolInput\n\n    def _run(self, argument: str) -> str:\n        # Your tool's logic here\n        return \"Tool's result\"",
      "formatted_path": "Changelog > Create Custom Tools > Creating and Utilizing Tools in CrewAI > Subclassing `BaseTool`",
      "enhanced_text": "Context: Changelog > Create Custom Tools > Creating and Utilizing Tools in CrewAI > Subclassing `BaseTool`\n\nfrom typing import Type\nfrom crewai.tools import BaseTool\nfrom pydantic import BaseModel, Field\n\nclass MyToolInput(BaseModel):\n    \"\"\"Input schema for MyCustomTool.\"\"\"\n    argument: str = Field(..., description=\"Description of the argument.\")\n\nclass MyCustomTool(BaseTool):\n    name: str = \"Name of my tool\"\n    description: str = \"What this tool does. It's vital for effective utilization.\"\n    args_schema: Type[BaseModel] = MyToolInput\n\n    def _run(self, argument: str) -> str:\n        # Your tool's logic here\n        return \"Tool's result\""
    },
    {
      "content": "from crewai.tools import tool\n\n@tool(\"Tool Name\")\ndef my_simple_tool(question: str) -> str:\n    \"\"\"Tool description for clarity.\"\"\"\n    # Tool logic here\n    return \"Tool output\"",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Create Custom Tools",
          "level": 1
        },
        {
          "title": "Creating and Utilizing Tools in CrewAI",
          "level": 2
        },
        {
          "title": "Using the `tool` Decorator",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Create Custom Tools",
            "level": 1
          },
          {
            "title": "Creating and Utilizing Tools in CrewAI",
            "level": 2
          },
          {
            "title": "Using the `tool` Decorator",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Create Custom Tools > Creating and Utilizing Tools in CrewAI > Using the `tool` Decorator"
      },
      "enhanced_content": "Context: Changelog > Create Custom Tools > Creating and Utilizing Tools in CrewAI > Using the `tool` Decorator\n\nfrom crewai.tools import tool\n\n@tool(\"Tool Name\")\ndef my_simple_tool(question: str) -> str:\n    \"\"\"Tool description for clarity.\"\"\"\n    # Tool logic here\n    return \"Tool output\"",
      "formatted_path": "Changelog > Create Custom Tools > Creating and Utilizing Tools in CrewAI > Using the `tool` Decorator",
      "enhanced_text": "Context: Changelog > Create Custom Tools > Creating and Utilizing Tools in CrewAI > Using the `tool` Decorator\n\nfrom crewai.tools import tool\n\n@tool(\"Tool Name\")\ndef my_simple_tool(question: str) -> str:\n    \"\"\"Tool description for clarity.\"\"\"\n    # Tool logic here\n    return \"Tool output\""
    },
    {
      "content": "@tool(\"Tool with Caching\")\ndef cached_tool(argument: str) -> str:\n    \"\"\"Tool functionality description.\"\"\"\n    return \"Cacheable result\"\n\ndef my_cache_strategy(arguments: dict, result: str) -> bool:\n    # Define custom caching logic\n    return True if some_condition else False\n\ncached_tool.cache_function = my_cache_strategy",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Create Custom Tools",
          "level": 1
        },
        {
          "title": "Creating and Utilizing Tools in CrewAI",
          "level": 2
        },
        {
          "title": "Defining a Cache Function for the Tool",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Create Custom Tools",
            "level": 1
          },
          {
            "title": "Creating and Utilizing Tools in CrewAI",
            "level": 2
          },
          {
            "title": "Defining a Cache Function for the Tool",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Create Custom Tools > Creating and Utilizing Tools in CrewAI > Defining a Cache Function for the Tool"
      },
      "enhanced_content": "Context: Changelog > Create Custom Tools > Creating and Utilizing Tools in CrewAI > Defining a Cache Function for the Tool\n\n@tool(\"Tool with Caching\")\ndef cached_tool(argument: str) -> str:\n    \"\"\"Tool functionality description.\"\"\"\n    return \"Cacheable result\"\n\ndef my_cache_strategy(arguments: dict, result: str) -> bool:\n    # Define custom caching logic\n    return True if some_condition else False\n\ncached_tool.cache_function = my_cache_strategy",
      "formatted_path": "Changelog > Create Custom Tools > Creating and Utilizing Tools in CrewAI > Defining a Cache Function for the Tool",
      "enhanced_text": "Context: Changelog > Create Custom Tools > Creating and Utilizing Tools in CrewAI > Defining a Cache Function for the Tool\n\n@tool(\"Tool with Caching\")\ndef cached_tool(argument: str) -> str:\n    \"\"\"Tool functionality description.\"\"\"\n    return \"Cacheable result\"\n\ndef my_cache_strategy(arguments: dict, result: str) -> bool:\n    # Define custom caching logic\n    return True if some_condition else False\n\ncached_tool.cache_function = my_cache_strategy"
    },
    {
      "content": "Source: https://docs.crewai.com/how-to/custom-manager-agent Learn how to set a custom agent as the manager in CrewAI, providing more control over task management and coordination.",
      "title": "Create Your Own Manager Agent",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Create Your Own Manager Agent",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Create Your Own Manager Agent",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Create Your Own Manager Agent"
      },
      "enhanced_content": "Context: Changelog > Create Your Own Manager Agent\n\n# Create Your Own Manager Agent\n\nSource: https://docs.crewai.com/how-to/custom-manager-agent Learn how to set a custom agent as the manager in CrewAI, providing more control over task management and coordination.",
      "formatted_path": "Changelog > Create Your Own Manager Agent",
      "enhanced_text": "Context: Changelog > Create Your Own Manager Agent\n\n Create Your Own Manager Agent\n\nSource: https://docs.crewai.com/how-to/custom-manager-agent Learn how to set a custom agent as the manager in CrewAI, providing more control over task management and coordination."
    },
    {
      "content": "CrewAI allows users to set a specific agent as the manager of the crew, providing more control over the management and coordination of tasks.\nThis feature enables the customization of the managerial role to better fit your project's requirements.",
      "title": "Setting a Specific Agent as Manager in CrewAI",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Setting a Specific Agent as Manager in CrewAI",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Setting a Specific Agent as Manager in CrewAI",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Setting a Specific Agent as Manager in CrewAI"
      },
      "enhanced_content": "Context: Changelog > Setting a Specific Agent as Manager in CrewAI\n\n# Setting a Specific Agent as Manager in CrewAI\n\nCrewAI allows users to set a specific agent as the manager of the crew, providing more control over the management and coordination of tasks.\nThis feature enables the customization of the managerial role to better fit your project's requirements.",
      "formatted_path": "Changelog > Setting a Specific Agent as Manager in CrewAI",
      "enhanced_text": "Context: Changelog > Setting a Specific Agent as Manager in CrewAI\n\n Setting a Specific Agent as Manager in CrewAI\n\nCrewAI allows users to set a specific agent as the manager of the crew, providing more control over the management and coordination of tasks.\nThis feature enables the customization of the managerial role to better fit your project's requirements."
    },
    {
      "content": "The `manager_agent` attribute allows you to define a custom agent to manage the crew. This agent will oversee the entire process, ensuring that tasks are completed efficiently and to the highest standard.",
      "title": "Custom Manager Agent",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Setting a Specific Agent as Manager in CrewAI",
          "level": 1
        },
        {
          "title": "Using the `manager_agent` Attribute",
          "level": 2
        },
        {
          "title": "Custom Manager Agent",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Setting a Specific Agent as Manager in CrewAI",
            "level": 1
          },
          {
            "title": "Using the `manager_agent` Attribute",
            "level": 2
          },
          {
            "title": "Custom Manager Agent",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Setting a Specific Agent as Manager in CrewAI > Using the `manager_agent` Attribute > Custom Manager Agent"
      },
      "enhanced_content": "Context: Changelog > Setting a Specific Agent as Manager in CrewAI > Using the `manager_agent` Attribute > Custom Manager Agent\n\n### Custom Manager Agent\n\nThe `manager_agent` attribute allows you to define a custom agent to manage the crew. This agent will oversee the entire process, ensuring that tasks are completed efficiently and to the highest standard.",
      "formatted_path": "Changelog > Setting a Specific Agent as Manager in CrewAI > Using the `manager_agent` Attribute > Custom Manager Agent",
      "enhanced_text": "Context: Changelog > Setting a Specific Agent as Manager in CrewAI > Using the `manager_agent` Attribute > Custom Manager Agent\n\n Custom Manager Agent\n\nThe `manager_agent` attribute allows you to define a custom agent to manage the crew. This agent will oversee the entire process, ensuring that tasks are completed efficiently and to the highest standard.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "**Enhanced Control**: Tailor the management approach to fit the specific needs of your project. **Improved Coordination**: Ensure efficient task coordination and management by an experienced agent. **Customizable Management**: Define managerial roles and responsibilities that align with your project's goals.",
      "title": "Benefits of a Custom Manager Agent",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Setting a Specific Agent as Manager in CrewAI",
          "level": 1
        },
        {
          "title": "Benefits of a Custom Manager Agent",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Setting a Specific Agent as Manager in CrewAI",
            "level": 1
          },
          {
            "title": "Benefits of a Custom Manager Agent",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Setting a Specific Agent as Manager in CrewAI > Benefits of a Custom Manager Agent"
      },
      "enhanced_content": "Context: Changelog > Setting a Specific Agent as Manager in CrewAI > Benefits of a Custom Manager Agent\n\n## Benefits of a Custom Manager Agent\n\n**Enhanced Control**: Tailor the management approach to fit the specific needs of your project. **Improved Coordination**: Ensure efficient task coordination and management by an experienced agent. **Customizable Management**: Define managerial roles and responsibilities that align with your project's goals.",
      "formatted_path": "Changelog > Setting a Specific Agent as Manager in CrewAI > Benefits of a Custom Manager Agent",
      "enhanced_text": "Context: Changelog > Setting a Specific Agent as Manager in CrewAI > Benefits of a Custom Manager Agent\n\n Benefits of a Custom Manager Agent\n\n**Enhanced Control**: Tailor the management approach to fit the specific needs of your project. **Improved Coordination**: Ensure efficient task coordination and management by an experienced agent. **Customizable Management**: Define managerial roles and responsibilities that align with your project's goals.\n\nRelated sections:\n- \n"
    },
    {
      "content": "from crewai import LLM\n\nmanager_llm = LLM(model=\"gpt-4o\")\n\ncrew = Crew(\n    agents=[researcher, writer],\n    tasks=[task],\n    process=Process.hierarchical,\n    manager_llm=manager_llm\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Setting a Specific Agent as Manager in CrewAI",
          "level": 1
        },
        {
          "title": "Setting a Manager LLM",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Setting a Specific Agent as Manager in CrewAI",
            "level": 1
          },
          {
            "title": "Setting a Manager LLM",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Setting a Specific Agent as Manager in CrewAI > Setting a Manager LLM"
      },
      "enhanced_content": "Context: Changelog > Setting a Specific Agent as Manager in CrewAI > Setting a Manager LLM\n\nfrom crewai import LLM\n\nmanager_llm = LLM(model=\"gpt-4o\")\n\ncrew = Crew(\n    agents=[researcher, writer],\n    tasks=[task],\n    process=Process.hierarchical,\n    manager_llm=manager_llm\n)",
      "formatted_path": "Changelog > Setting a Specific Agent as Manager in CrewAI > Setting a Manager LLM",
      "enhanced_text": "Context: Changelog > Setting a Specific Agent as Manager in CrewAI > Setting a Manager LLM\n\nfrom crewai import LLM\n\nmanager_llm = LLM(model=\"gpt-4o\")\n\ncrew = Crew(\n    agents=[researcher, writer],\n    tasks=[task],\n    process=Process.hierarchical,\n    manager_llm=manager_llm\n)"
    },
    {
      "content": "Source: https://docs.crewai.com/how-to/customizing-agents A comprehensive guide to tailoring agents for specific roles, tasks, and advanced customizations within the CrewAI framework.",
      "title": "Customize Agents",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Customize Agents",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Customize Agents",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Customize Agents"
      },
      "enhanced_content": "Context: Changelog > Customize Agents\n\n# Customize Agents\n\nSource: https://docs.crewai.com/how-to/customizing-agents A comprehensive guide to tailoring agents for specific roles, tasks, and advanced customizations within the CrewAI framework.",
      "formatted_path": "Changelog > Customize Agents",
      "enhanced_text": "Context: Changelog > Customize Agents\n\n Customize Agents\n\nSource: https://docs.crewai.com/how-to/customizing-agents A comprehensive guide to tailoring agents for specific roles, tasks, and advanced customizations within the CrewAI framework.\n\nRelated sections:\n- \n"
    },
    {
      "content": "Crafting an efficient CrewAI team hinges on the ability to dynamically tailor your AI agents to meet the unique requirements of any project. This section covers the foundational attributes you can customize.",
      "title": "Customizable Attributes",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Customize Agents",
          "level": 1
        },
        {
          "title": "Customizable Attributes",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Customize Agents",
            "level": 1
          },
          {
            "title": "Customizable Attributes",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Customize Agents > Customizable Attributes"
      },
      "enhanced_content": "Context: Changelog > Customize Agents > Customizable Attributes\n\n## Customizable Attributes\n\nCrafting an efficient CrewAI team hinges on the ability to dynamically tailor your AI agents to meet the unique requirements of any project. This section covers the foundational attributes you can customize.",
      "formatted_path": "Changelog > Customize Agents > Customizable Attributes",
      "enhanced_text": "Context: Changelog > Customize Agents > Customizable Attributes\n\n Customizable Attributes\n\nCrafting an efficient CrewAI team hinges on the ability to dynamically tailor your AI agents to meet the unique requirements of any project. This section covers the foundational attributes you can customize."
    },
    {
      "content": "| Attribute                           | Description                                                                                                         |\n| :---------------------------------- | :------------------------------------------------------------------------------------------------------------------ |\n| **Role**                            | Specifies the agent's job within the crew, such as 'Analyst' or 'Customer Service Rep'.                             |\n| **Goal**                            | Defines the agent\u2019s objectives, aligned with its role and the crew\u2019s overarching mission.                           |\n| **Backstory**                       | Provides depth to the agent's persona, enhancing motivations and engagements within the crew.                       |\n| **Tools** *(Optional)*              | Represents the capabilities or methods the agent uses for tasks, from simple functions to complex integrations.     |\n| **Cache** *(Optional)*              | Determines if the agent should use a cache for tool usage.                                                          |\n| **Max RPM**                         | Sets the maximum requests per minute (`max_rpm`). Can be set to `None` for unlimited requests to external services. |\n| **Verbose** *(Optional)*            | Enables detailed logging for debugging and optimization, providing insights into execution processes.               |\n| **Allow Delegation** *(Optional)*   | Controls task delegation to other agents, default is `False`.                                                       |\n| **Max Iter** *(Optional)*           | Limits the maximum number of iterations (`max_iter`) for a task to prevent infinite loops, with a default of 25.    |\n| **Max Execution Time** *(Optional)* | Sets the maximum time allowed for an agent to complete a task.                                                      |\n| **System Template** *(Optional)*    | Defines the system format for the agent.                                                                            |\n| **Prompt Template** *(Optional)*    | Defines the prompt format for the agent.                                                                            |\n| **Response Template** *(Optional)*  | Defines the response format for the agent.                                                                          |\n| **Use System Prompt** *(Optional)*  | Controls whether the agent will use a system prompt during task execution.                                          |\n| **Respect Context Window**          | Enables a sliding context window by default, maintaining context size.                                              |\n| **Max Retry Limit**                 | Sets the maximum number of retries (`max_retry_limit`) for an agent in case of errors.                              |",
      "title": "Key Attributes for Customization",
      "type": "descriptive_text_oversized",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Customize Agents",
          "level": 1
        },
        {
          "title": "Customizable Attributes",
          "level": 2
        },
        {
          "title": "Key Attributes for Customization",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Customize Agents",
            "level": 1
          },
          {
            "title": "Customizable Attributes",
            "level": 2
          },
          {
            "title": "Key Attributes for Customization",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Customize Agents > Customizable Attributes > Key Attributes for Customization"
      },
      "enhanced_content": "Context: Changelog > Customize Agents > Customizable Attributes > Key Attributes for Customization\n\n### Key Attributes for Customization\n\n| Attribute                           | Description                                                                                                         |\n| :---------------------------------- | :------------------------------------------------------------------------------------------------------------------ |\n| **Role**                            | Specifies the agent's job within the crew, such as 'Analyst' or 'Customer Service Rep'.                             |\n| **Goal**                            | Defines the agent\u2019s objectives, aligned with its role and the crew\u2019s overarching mission.                           |\n| **Backstory**                       | Provides depth to the agent's persona, enhancing motivations and engagements within the crew.                       |\n| **Tools** *(Optional)*              | Represents the capabilities or methods the agent uses for tasks, from simple functions to complex integrations.     |\n| **Cache** *(Optional)*              | Determines if the agent should use a cache for tool usage.                                                          |\n| **Max RPM**                         | Sets the maximum requests per minute (`max_rpm`). Can be set to `None` for unlimited requests to external services. |\n| **Verbose** *(Optional)*            | Enables detailed logging for debugging and optimization, providing insights into execution processes.               |\n| **Allow Delegation** *(Optional)*   | Controls task delegation to other agents, default is `False`.                                                       |\n| **Max Iter** *(Optional)*           | Limits the maximum number of iterations (`max_iter`) for a task to prevent infinite loops, with a default of 25.    |\n| **Max Execution Time** *(Optional)* | Sets the maximum time allowed for an agent to complete a task.                                                      |\n| **System Template** *(Optional)*    | Defines the system format for the agent.                                                                            |\n| **Prompt Template** *(Optional)*    | Defines the prompt format for the agent.                                                                            |\n| **Response Template** *(Optional)*  | Defines the response format for the agent.                                                                          |\n| **Use System Prompt** *(Optional)*  | Controls whether the agent will use a system prompt during task execution.                                          |\n| **Respect Context Window**          | Enables a sliding context window by default, maintaining context size.                                              |\n| **Max Retry Limit**                 | Sets the maximum number of retries (`max_retry_limit`) for an agent in case of errors.                              |",
      "formatted_path": "Changelog > Customize Agents > Customizable Attributes > Key Attributes for Customization",
      "enhanced_text": "Context: Changelog > Customize Agents > Customizable Attributes > Key Attributes for Customization\n\n Key Attributes for Customization\n\n| Attribute                           | Description                                                                                                         |\n| :---------------------------------- | :------------------------------------------------------------------------------------------------------------------ |\n| **Role**                            | Specifies the agent's job within the crew, such as 'Analyst' or 'Customer Service Rep'.                             |\n| **Goal**                            | Defines the agent\u2019s objectives, aligned with its role and the crew\u2019s overarching mission.                           |\n| **Backstory**                       | Provides depth to the agent's persona, enhancing motivations and engagements within the crew.                       |\n| **Tools** *(Optional)*              | Represents the capabilities or methods the agent uses for tasks, from simple functions to complex integrations.     |\n| **Cache** *(Optional)*              | Determines if the agent should use a cache for tool usage.                                                          |\n| **Max RPM**                         | Sets the maximum requests per minute (`max_rpm`). Can be set to `None` for unlimited requests to external services. |\n| **Verbose** *(Optional)*            | Enables detailed logging for debugging and optimization, providing insights into execution processes.               |\n| **Allow Delegation** *(Optional)*   | Controls task delegation to other agents, default is `False`.                                                       |\n| **Max Iter** *(Optional)*           | Limits the maximum number of iterations (`max_iter`) for a task to prevent infinite loops, with a default of 25.    |\n| **Max Execution Time** *(Optional)* | Sets the maximum time allowed for an agent to complete a task.                                                      |\n| **System Template** *(Optional)*    | Defines the system format for the agent.                                                                            |\n| **Prompt Template** *(Optional)*    | Defines the prompt format for the agent.                                                                            |\n| **Response Template** *(Optional)*  | Defines the response format for the agent.                                                                          |\n| **Use System Prompt** *(Optional)*  | Controls whether the agent will use a system prompt during task execution.                                          |\n| **Respect Context Window**          | Enables a sliding context window by default, maintaining context size.                                              |\n| **Max Retry Limit**                 | Sets the maximum number of retries (`max_retry_limit`) for an agent in case of errors.                              |"
    },
    {
      "content": "Beyond the basic attributes, CrewAI allows for deeper customization to enhance an agent's behavior and capabilities significantly.",
      "title": "Advanced Customization Options",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Customize Agents",
          "level": 1
        },
        {
          "title": "Advanced Customization Options",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Customize Agents",
            "level": 1
          },
          {
            "title": "Advanced Customization Options",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Customize Agents > Advanced Customization Options"
      },
      "enhanced_content": "Context: Changelog > Customize Agents > Advanced Customization Options\n\n## Advanced Customization Options\n\nBeyond the basic attributes, CrewAI allows for deeper customization to enhance an agent's behavior and capabilities significantly.",
      "formatted_path": "Changelog > Customize Agents > Advanced Customization Options",
      "enhanced_text": "Context: Changelog > Customize Agents > Advanced Customization Options\n\n Advanced Customization Options\n\nBeyond the basic attributes, CrewAI allows for deeper customization to enhance an agent's behavior and capabilities significantly.\n\nRelated sections:\n- \n"
    },
    {
      "content": "Agents can be customized with specific language models (`llm`) and function-calling language models (`function_calling_llm`), offering advanced control over their processing and decision-making abilities.\nIt's important to note that setting the `function_calling_llm` allows for overriding the default crew function-calling language model, providing a greater degree of customization.",
      "title": "Language Model Customization",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Customize Agents",
          "level": 1
        },
        {
          "title": "Advanced Customization Options",
          "level": 2
        },
        {
          "title": "Language Model Customization",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Customize Agents",
            "level": 1
          },
          {
            "title": "Advanced Customization Options",
            "level": 2
          },
          {
            "title": "Language Model Customization",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Customize Agents > Advanced Customization Options > Language Model Customization"
      },
      "enhanced_content": "Context: Changelog > Customize Agents > Advanced Customization Options > Language Model Customization\n\n### Language Model Customization\n\nAgents can be customized with specific language models (`llm`) and function-calling language models (`function_calling_llm`), offering advanced control over their processing and decision-making abilities.\nIt's important to note that setting the `function_calling_llm` allows for overriding the default crew function-calling language model, providing a greater degree of customization.",
      "formatted_path": "Changelog > Customize Agents > Advanced Customization Options > Language Model Customization",
      "enhanced_text": "Context: Changelog > Customize Agents > Advanced Customization Options > Language Model Customization\n\n Language Model Customization\n\nAgents can be customized with specific language models (`llm`) and function-calling language models (`function_calling_llm`), offering advanced control over their processing and decision-making abilities.\nIt's important to note that setting the `function_calling_llm` allows for overriding the default crew function-calling language model, providing a greater degree of customization."
    },
    {
      "content": "Adjusting an agent's performance and monitoring its operations are crucial for efficient task execution.",
      "title": "Performance and Debugging Settings",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Customize Agents",
          "level": 1
        },
        {
          "title": "Performance and Debugging Settings",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Customize Agents",
            "level": 1
          },
          {
            "title": "Performance and Debugging Settings",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Customize Agents > Performance and Debugging Settings"
      },
      "enhanced_content": "Context: Changelog > Customize Agents > Performance and Debugging Settings\n\n## Performance and Debugging Settings\n\nAdjusting an agent's performance and monitoring its operations are crucial for efficient task execution.",
      "formatted_path": "Changelog > Customize Agents > Performance and Debugging Settings",
      "enhanced_text": "Context: Changelog > Customize Agents > Performance and Debugging Settings\n\n Performance and Debugging Settings\n\nAdjusting an agent's performance and monitoring its operations are crucial for efficient task execution."
    },
    {
      "content": "**Verbose Mode**: Enables detailed logging of an agent's actions, useful for debugging and optimization. Specifically, it provides insights into agent execution processes, aiding in the optimization of performance. **RPM Limit**: Sets the maximum number of requests per minute (`max_rpm`). This attribute is optional and can be set to `None` for no limit, allowing for unlimited queries to external services if needed.",
      "title": "Verbose Mode and RPM Limit",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Customize Agents",
          "level": 1
        },
        {
          "title": "Performance and Debugging Settings",
          "level": 2
        },
        {
          "title": "Verbose Mode and RPM Limit",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Customize Agents",
            "level": 1
          },
          {
            "title": "Performance and Debugging Settings",
            "level": 2
          },
          {
            "title": "Verbose Mode and RPM Limit",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Customize Agents > Performance and Debugging Settings > Verbose Mode and RPM Limit"
      },
      "enhanced_content": "Context: Changelog > Customize Agents > Performance and Debugging Settings > Verbose Mode and RPM Limit\n\n### Verbose Mode and RPM Limit\n\n**Verbose Mode**: Enables detailed logging of an agent's actions, useful for debugging and optimization. Specifically, it provides insights into agent execution processes, aiding in the optimization of performance. **RPM Limit**: Sets the maximum number of requests per minute (`max_rpm`). This attribute is optional and can be set to `None` for no limit, allowing for unlimited queries to external services if needed.",
      "formatted_path": "Changelog > Customize Agents > Performance and Debugging Settings > Verbose Mode and RPM Limit",
      "enhanced_text": "Context: Changelog > Customize Agents > Performance and Debugging Settings > Verbose Mode and RPM Limit\n\n Verbose Mode and RPM Limit\n\n**Verbose Mode**: Enables detailed logging of an agent's actions, useful for debugging and optimization. Specifically, it provides insights into agent execution processes, aiding in the optimization of performance. **RPM Limit**: Sets the maximum number of requests per minute (`max_rpm`). This attribute is optional and can be set to `None` for no limit, allowing for unlimited queries to external services if needed."
    },
    {
      "content": "The `max_iter` attribute allows users to define the maximum number of iterations an agent can perform for a single task, preventing infinite loops or excessively long executions.\nThe default value is set to 25, providing a balance between thoroughness and efficiency. Once the agent approaches this number, it will try its best to give a good answer.",
      "title": "Maximum Iterations for Task Execution",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Customize Agents",
          "level": 1
        },
        {
          "title": "Performance and Debugging Settings",
          "level": 2
        },
        {
          "title": "Maximum Iterations for Task Execution",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Customize Agents",
            "level": 1
          },
          {
            "title": "Performance and Debugging Settings",
            "level": 2
          },
          {
            "title": "Maximum Iterations for Task Execution",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Customize Agents > Performance and Debugging Settings > Maximum Iterations for Task Execution"
      },
      "enhanced_content": "Context: Changelog > Customize Agents > Performance and Debugging Settings > Maximum Iterations for Task Execution\n\n### Maximum Iterations for Task Execution\n\nThe `max_iter` attribute allows users to define the maximum number of iterations an agent can perform for a single task, preventing infinite loops or excessively long executions.\nThe default value is set to 25, providing a balance between thoroughness and efficiency. Once the agent approaches this number, it will try its best to give a good answer.",
      "formatted_path": "Changelog > Customize Agents > Performance and Debugging Settings > Maximum Iterations for Task Execution",
      "enhanced_text": "Context: Changelog > Customize Agents > Performance and Debugging Settings > Maximum Iterations for Task Execution\n\n Maximum Iterations for Task Execution\n\nThe `max_iter` attribute allows users to define the maximum number of iterations an agent can perform for a single task, preventing infinite loops or excessively long executions.\nThe default value is set to 25, providing a balance between thoroughness and efficiency. Once the agent approaches this number, it will try its best to give a good answer."
    },
    {
      "content": "pip install 'crewai[tools]'",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Customize Agents",
          "level": 1
        },
        {
          "title": "Customizing Agents and Tools",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Customize Agents",
            "level": 1
          },
          {
            "title": "Customizing Agents and Tools",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Customize Agents > Customizing Agents and Tools"
      },
      "enhanced_content": "Context: Changelog > Customize Agents > Customizing Agents and Tools\n\npip install 'crewai[tools]'",
      "formatted_path": "Changelog > Customize Agents > Customizing Agents and Tools",
      "enhanced_text": "Context: Changelog > Customize Agents > Customizing Agents and Tools\n\npip install 'crewai[tools]'"
    },
    {
      "content": "import os\nfrom crewai import Agent\nfrom crewai_tools import SerperDevTool\n\n# Set API keys for tool initialization\nos.environ[\"OPENAI_API_KEY\"] = \"Your Key\"\nos.environ[\"SERPER_API_KEY\"] = \"Your Key\"\n\n# Initialize a search tool\nsearch_tool = SerperDevTool()\n\n# Initialize the agent with advanced options\nagent = Agent(\n  role='Research Analyst',\n  goal='Provide up-to-date market analysis',\n  backstory='An expert analyst with a keen eye for market trends.',\n  tools=[search_tool],\n  memory=True, # Enable memory\n  verbose=True,\n  max_rpm=None, # No limit on requests per minute\n  max_iter=25, # Default value for maximum iterations\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Customize Agents",
          "level": 1
        },
        {
          "title": "Customizing Agents and Tools",
          "level": 2
        },
        {
          "title": "Example: Assigning Tools to an Agent",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Customize Agents",
            "level": 1
          },
          {
            "title": "Customizing Agents and Tools",
            "level": 2
          },
          {
            "title": "Example: Assigning Tools to an Agent",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Customize Agents > Customizing Agents and Tools > Example: Assigning Tools to an Agent"
      },
      "enhanced_content": "Context: Changelog > Customize Agents > Customizing Agents and Tools > Example: Assigning Tools to an Agent\n\nimport os\nfrom crewai import Agent\nfrom crewai_tools import SerperDevTool\n\n# Set API keys for tool initialization\nos.environ[\"OPENAI_API_KEY\"] = \"Your Key\"\nos.environ[\"SERPER_API_KEY\"] = \"Your Key\"\n\n# Initialize a search tool\nsearch_tool = SerperDevTool()\n\n# Initialize the agent with advanced options\nagent = Agent(\n  role='Research Analyst',\n  goal='Provide up-to-date market analysis',\n  backstory='An expert analyst with a keen eye for market trends.',\n  tools=[search_tool],\n  memory=True, # Enable memory\n  verbose=True,\n  max_rpm=None, # No limit on requests per minute\n  max_iter=25, # Default value for maximum iterations\n)",
      "formatted_path": "Changelog > Customize Agents > Customizing Agents and Tools > Example: Assigning Tools to an Agent",
      "enhanced_text": "Context: Changelog > Customize Agents > Customizing Agents and Tools > Example: Assigning Tools to an Agent\n\nimport os\nfrom crewai import Agent\nfrom crewai_tools import SerperDevTool\n\n# Set API keys for tool initialization\nos.environ[\"OPENAI_API_KEY\"] = \"Your Key\"\nos.environ[\"SERPER_API_KEY\"] = \"Your Key\"\n\n# Initialize a search tool\nsearch_tool = SerperDevTool()\n\n# Initialize the agent with advanced options\nagent = Agent(\n  role='Research Analyst',\n  goal='Provide up-to-date market analysis',\n  backstory='An expert analyst with a keen eye for market trends.',\n  tools=[search_tool],\n  memory=True, # Enable memory\n  verbose=True,\n  max_rpm=None, # No limit on requests per minute\n  max_iter=25, # Default value for maximum iterations\n)"
    },
    {
      "content": "Controlling an agent's ability to delegate tasks or ask questions is vital for tailoring its autonomy and collaborative dynamics within the CrewAI framework. By default,\nthe `allow_delegation` attribute is now set to `False`, disabling agents to seek assistance or delegate tasks as needed. This default behavior can be changed to promote collaborative problem-solving and\nefficiency within the CrewAI ecosystem. If needed, delegation can be enabled to suit specific operational requirements.",
      "title": "Delegation and Autonomy",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Customize Agents",
          "level": 1
        },
        {
          "title": "Delegation and Autonomy",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Customize Agents",
            "level": 1
          },
          {
            "title": "Delegation and Autonomy",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Customize Agents > Delegation and Autonomy"
      },
      "enhanced_content": "Context: Changelog > Customize Agents > Delegation and Autonomy\n\n## Delegation and Autonomy\n\nControlling an agent's ability to delegate tasks or ask questions is vital for tailoring its autonomy and collaborative dynamics within the CrewAI framework. By default,\nthe `allow_delegation` attribute is now set to `False`, disabling agents to seek assistance or delegate tasks as needed. This default behavior can be changed to promote collaborative problem-solving and\nefficiency within the CrewAI ecosystem. If needed, delegation can be enabled to suit specific operational requirements.",
      "formatted_path": "Changelog > Customize Agents > Delegation and Autonomy",
      "enhanced_text": "Context: Changelog > Customize Agents > Delegation and Autonomy\n\n Delegation and Autonomy\n\nControlling an agent's ability to delegate tasks or ask questions is vital for tailoring its autonomy and collaborative dynamics within the CrewAI framework. By default,\nthe `allow_delegation` attribute is now set to `False`, disabling agents to seek assistance or delegate tasks as needed. This default behavior can be changed to promote collaborative problem-solving and\nefficiency within the CrewAI ecosystem. If needed, delegation can be enabled to suit specific operational requirements."
    },
    {
      "content": "agent = Agent(\n  role='Content Writer',\n  goal='Write engaging content on market trends',\n  backstory='A seasoned writer with expertise in market analysis.',\n  allow_delegation=True # Enabling delegation\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Customize Agents",
          "level": 1
        },
        {
          "title": "Delegation and Autonomy",
          "level": 2
        },
        {
          "title": "Example: Disabling Delegation for an Agent",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Customize Agents",
            "level": 1
          },
          {
            "title": "Delegation and Autonomy",
            "level": 2
          },
          {
            "title": "Example: Disabling Delegation for an Agent",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Customize Agents > Delegation and Autonomy > Example: Disabling Delegation for an Agent"
      },
      "enhanced_content": "Context: Changelog > Customize Agents > Delegation and Autonomy > Example: Disabling Delegation for an Agent\n\nagent = Agent(\n  role='Content Writer',\n  goal='Write engaging content on market trends',\n  backstory='A seasoned writer with expertise in market analysis.',\n  allow_delegation=True # Enabling delegation\n)",
      "formatted_path": "Changelog > Customize Agents > Delegation and Autonomy > Example: Disabling Delegation for an Agent",
      "enhanced_text": "Context: Changelog > Customize Agents > Delegation and Autonomy > Example: Disabling Delegation for an Agent\n\nagent = Agent(\n  role='Content Writer',\n  goal='Write engaging content on market trends',\n  backstory='A seasoned writer with expertise in market analysis.',\n  allow_delegation=True # Enabling delegation\n)"
    },
    {
      "content": "Source: https://docs.crewai.com/how-to/force-tool-output-as-result Learn how to force tool output as the result in an Agent's task in CrewAI.",
      "title": "Force Tool Output as Result",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Force Tool Output as Result",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Force Tool Output as Result",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Force Tool Output as Result"
      },
      "enhanced_content": "Context: Changelog > Force Tool Output as Result\n\n# Force Tool Output as Result\n\nSource: https://docs.crewai.com/how-to/force-tool-output-as-result Learn how to force tool output as the result in an Agent's task in CrewAI.",
      "formatted_path": "Changelog > Force Tool Output as Result",
      "enhanced_text": "Context: Changelog > Force Tool Output as Result\n\n Force Tool Output as Result\n\nSource: https://docs.crewai.com/how-to/force-tool-output-as-result Learn how to force tool output as the result in an Agent's task in CrewAI."
    },
    {
      "content": "from crewai.agent import Agent\nfrom my_tool import MyCustomTool\n\n# Create a coding agent with the custom tool\ncoding_agent = Agent(\n        role=\"Data Scientist\",\n        goal=\"Produce amazing reports on AI\",\n        backstory=\"You work with data and AI\",\n        tools=[MyCustomTool(result_as_answer=True)],\n    )\n\n# Assuming the tool's execution and result population occurs within the system\ntask_result = coding_agent.execute_task(task)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Force Tool Output as Result",
          "level": 1
        },
        {
          "title": "Forcing Tool Output as Result",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Force Tool Output as Result",
            "level": 1
          },
          {
            "title": "Forcing Tool Output as Result",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Force Tool Output as Result > Forcing Tool Output as Result"
      },
      "enhanced_content": "Context: Changelog > Force Tool Output as Result > Forcing Tool Output as Result\n\nfrom crewai.agent import Agent\nfrom my_tool import MyCustomTool\n\n# Create a coding agent with the custom tool\ncoding_agent = Agent(\n        role=\"Data Scientist\",\n        goal=\"Produce amazing reports on AI\",\n        backstory=\"You work with data and AI\",\n        tools=[MyCustomTool(result_as_answer=True)],\n    )\n\n# Assuming the tool's execution and result population occurs within the system\ntask_result = coding_agent.execute_task(task)",
      "formatted_path": "Changelog > Force Tool Output as Result > Forcing Tool Output as Result",
      "enhanced_text": "Context: Changelog > Force Tool Output as Result > Forcing Tool Output as Result\n\nfrom crewai.agent import Agent\nfrom my_tool import MyCustomTool\n\n# Create a coding agent with the custom tool\ncoding_agent = Agent(\n        role=\"Data Scientist\",\n        goal=\"Produce amazing reports on AI\",\n        backstory=\"You work with data and AI\",\n        tools=[MyCustomTool(result_as_answer=True)],\n    )\n\n# Assuming the tool's execution and result population occurs within the system\ntask_result = coding_agent.execute_task(task)"
    },
    {
      "content": "Emulates a corporate hierarchy, CrewAI allows specifying a custom manager agent or automatically creates one, requiring the specification of a manager language model (`manager_llm`). This agent oversees task execution, including planning, delegation, and validation. Tasks are not pre-assigned; the manager allocates tasks to agents based on their capabilities, reviews outputs, and assesses task completion.\n\nSource: https://docs.crewai.com/how-to/hierarchical-process A comprehensive guide to understanding and applying the hierarchical process within your CrewAI projects, updated to reflect the latest coding practices and functionalities.",
      "title": "Hierarchical Process",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Hierarchical Process",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Hierarchical Process",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Hierarchical Process"
      },
      "enhanced_content": "Context: Changelog > Hierarchical Process\n\n# Hierarchical Process\n\nEmulates a corporate hierarchy, CrewAI allows specifying a custom manager agent or automatically creates one, requiring the specification of a manager language model (`manager_llm`). This agent oversees task execution, including planning, delegation, and validation. Tasks are not pre-assigned; the manager allocates tasks to agents based on their capabilities, reviews outputs, and assesses task completion.\n\nSource: https://docs.crewai.com/how-to/hierarchical-process A comprehensive guide to understanding and applying the hierarchical process within your CrewAI projects, updated to reflect the latest coding practices and functionalities.",
      "formatted_path": "Changelog > Hierarchical Process",
      "enhanced_text": "Context: Changelog > Hierarchical Process\n\n Hierarchical Process\n\nEmulates a corporate hierarchy, CrewAI allows specifying a custom manager agent or automatically creates one, requiring the specification of a manager language model (`manager_llm`). This agent oversees task execution, including planning, delegation, and validation. Tasks are not pre-assigned; the manager allocates tasks to agents based on their capabilities, reviews outputs, and assesses task completion.\n\nSource: https://docs.crewai.com/how-to/hierarchical-process A comprehensive guide to understanding and applying the hierarchical process within your CrewAI projects, updated to reflect the latest coding practices and functionalities.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "By default, tasks in CrewAI are managed through a sequential process. However, adopting a hierarchical approach allows for a clear hierarchy in task management,\nwhere a 'manager' agent coordinates the workflow, delegates tasks, and validates outcomes for streamlined and effective execution. This manager agent can now be either\nautomatically created by CrewAI or explicitly set by the user.",
      "title": "Hierarchical Process Overview",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Hierarchical Process",
          "level": 1
        },
        {
          "title": "Hierarchical Process Overview",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Hierarchical Process",
            "level": 1
          },
          {
            "title": "Hierarchical Process Overview",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Hierarchical Process > Hierarchical Process Overview"
      },
      "enhanced_content": "Context: Changelog > Hierarchical Process > Hierarchical Process Overview\n\n## Hierarchical Process Overview\n\nBy default, tasks in CrewAI are managed through a sequential process. However, adopting a hierarchical approach allows for a clear hierarchy in task management,\nwhere a 'manager' agent coordinates the workflow, delegates tasks, and validates outcomes for streamlined and effective execution. This manager agent can now be either\nautomatically created by CrewAI or explicitly set by the user.",
      "formatted_path": "Changelog > Hierarchical Process > Hierarchical Process Overview",
      "enhanced_text": "Context: Changelog > Hierarchical Process > Hierarchical Process Overview\n\n Hierarchical Process Overview\n\nBy default, tasks in CrewAI are managed through a sequential process. However, adopting a hierarchical approach allows for a clear hierarchy in task management,\nwhere a 'manager' agent coordinates the workflow, delegates tasks, and validates outcomes for streamlined and effective execution. This manager agent can now be either\nautomatically created by CrewAI or explicitly set by the user.\n\nRelated sections:\n- \n- \n- \n- \n"
    },
    {
      "content": "from crewai import Crew, Process, Agent\n\n# Agents are defined with attributes for backstory, cache, and verbose mode\nresearcher = Agent(\n    role='Researcher',\n    goal='Conduct in-depth analysis',\n    backstory='Experienced data analyst with a knack for uncovering hidden trends.',\n)\nwriter = Agent(\n    role='Writer',\n    goal='Create engaging content',\n    backstory='Creative writer passionate about storytelling in technical domains.',\n)\n\n# Establishing the crew with a hierarchical process and additional configurations\nproject_crew = Crew(\n    tasks=[...],  # Tasks to be delegated and executed under the manager's supervision\n    agents=[researcher, writer],\n    manager_llm=\"gpt-4o\",  # Specify which LLM the manager should use\n    process=Process.hierarchical,  \n    planning=True, \n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Hierarchical Process",
          "level": 1
        },
        {
          "title": "Implementing the Hierarchical Process",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Hierarchical Process",
            "level": 1
          },
          {
            "title": "Implementing the Hierarchical Process",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Hierarchical Process > Implementing the Hierarchical Process"
      },
      "enhanced_content": "Context: Changelog > Hierarchical Process > Implementing the Hierarchical Process\n\nfrom crewai import Crew, Process, Agent\n\n# Agents are defined with attributes for backstory, cache, and verbose mode\nresearcher = Agent(\n    role='Researcher',\n    goal='Conduct in-depth analysis',\n    backstory='Experienced data analyst with a knack for uncovering hidden trends.',\n)\nwriter = Agent(\n    role='Writer',\n    goal='Create engaging content',\n    backstory='Creative writer passionate about storytelling in technical domains.',\n)\n\n# Establishing the crew with a hierarchical process and additional configurations\nproject_crew = Crew(\n    tasks=[...],  # Tasks to be delegated and executed under the manager's supervision\n    agents=[researcher, writer],\n    manager_llm=\"gpt-4o\",  # Specify which LLM the manager should use\n    process=Process.hierarchical,  \n    planning=True, \n)",
      "formatted_path": "Changelog > Hierarchical Process > Implementing the Hierarchical Process",
      "enhanced_text": "Context: Changelog > Hierarchical Process > Implementing the Hierarchical Process\n\nfrom crewai import Crew, Process, Agent\n\n# Agents are defined with attributes for backstory, cache, and verbose mode\nresearcher = Agent(\n    role='Researcher',\n    goal='Conduct in-depth analysis',\n    backstory='Experienced data analyst with a knack for uncovering hidden trends.',\n)\nwriter = Agent(\n    role='Writer',\n    goal='Create engaging content',\n    backstory='Creative writer passionate about storytelling in technical domains.',\n)\n\n# Establishing the crew with a hierarchical process and additional configurations\nproject_crew = Crew(\n    tasks=[...],  # Tasks to be delegated and executed under the manager's supervision\n    agents=[researcher, writer],\n    manager_llm=\"gpt-4o\",  # Specify which LLM the manager should use\n    process=Process.hierarchical,  \n    planning=True, \n)"
    },
    {
      "content": "# Define a custom manager agent\nmanager = Agent(\n    role=\"Project Manager\",\n    goal=\"Efficiently manage the crew and ensure high-quality task completion\",\n    backstory=\"You're an experienced project manager, skilled in overseeing complex projects and guiding teams to success.\",\n    allow_delegation=True,\n)\n\n# Use the custom manager in your crew\nproject_crew = Crew(\n    tasks=[...],\n    agents=[researcher, writer],\n    manager_agent=manager,  # Use your custom manager agent\n    process=Process.hierarchical,\n    planning=True,\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Hierarchical Process",
          "level": 1
        },
        {
          "title": "Implementing the Hierarchical Process",
          "level": 2
        },
        {
          "title": "Using a Custom Manager Agent",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Hierarchical Process",
            "level": 1
          },
          {
            "title": "Implementing the Hierarchical Process",
            "level": 2
          },
          {
            "title": "Using a Custom Manager Agent",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Hierarchical Process > Implementing the Hierarchical Process > Using a Custom Manager Agent"
      },
      "enhanced_content": "Context: Changelog > Hierarchical Process > Implementing the Hierarchical Process > Using a Custom Manager Agent\n\n# Define a custom manager agent\nmanager = Agent(\n    role=\"Project Manager\",\n    goal=\"Efficiently manage the crew and ensure high-quality task completion\",\n    backstory=\"You're an experienced project manager, skilled in overseeing complex projects and guiding teams to success.\",\n    allow_delegation=True,\n)\n\n# Use the custom manager in your crew\nproject_crew = Crew(\n    tasks=[...],\n    agents=[researcher, writer],\n    manager_agent=manager,  # Use your custom manager agent\n    process=Process.hierarchical,\n    planning=True,\n)",
      "formatted_path": "Changelog > Hierarchical Process > Implementing the Hierarchical Process > Using a Custom Manager Agent",
      "enhanced_text": "Context: Changelog > Hierarchical Process > Implementing the Hierarchical Process > Using a Custom Manager Agent\n\n# Define a custom manager agent\nmanager = Agent(\n    role=\"Project Manager\",\n    goal=\"Efficiently manage the crew and ensure high-quality task completion\",\n    backstory=\"You're an experienced project manager, skilled in overseeing complex projects and guiding teams to success.\",\n    allow_delegation=True,\n)\n\n# Use the custom manager in your crew\nproject_crew = Crew(\n    tasks=[...],\n    agents=[researcher, writer],\n    manager_agent=manager,  # Use your custom manager agent\n    process=Process.hierarchical,\n    planning=True,\n)"
    },
    {
      "content": "Source: https://docs.crewai.com/how-to/human-input-on-execution Integrating CrewAI with human input during execution in complex decision-making processes and leveraging the full capabilities of the agent's attributes and tools.",
      "title": "Human Input on Execution",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Human Input on Execution",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Human Input on Execution",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Human Input on Execution"
      },
      "enhanced_content": "Context: Changelog > Human Input on Execution\n\n# Human Input on Execution\n\nSource: https://docs.crewai.com/how-to/human-input-on-execution Integrating CrewAI with human input during execution in complex decision-making processes and leveraging the full capabilities of the agent's attributes and tools.",
      "formatted_path": "Changelog > Human Input on Execution",
      "enhanced_text": "Context: Changelog > Human Input on Execution\n\n Human Input on Execution\n\nSource: https://docs.crewai.com/how-to/human-input-on-execution Integrating CrewAI with human input during execution in complex decision-making processes and leveraging the full capabilities of the agent's attributes and tools."
    },
    {
      "content": "Human input is critical in several agent execution scenarios, allowing agents to request additional information or clarification when necessary.\nThis feature is especially useful in complex decision-making processes or when agents require more details to complete a task effectively.",
      "title": "Human input in agent execution",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Human Input on Execution",
          "level": 1
        },
        {
          "title": "Human input in agent execution",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Human Input on Execution",
            "level": 1
          },
          {
            "title": "Human input in agent execution",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Human Input on Execution > Human input in agent execution"
      },
      "enhanced_content": "Context: Changelog > Human Input on Execution > Human input in agent execution\n\n## Human input in agent execution\n\nHuman input is critical in several agent execution scenarios, allowing agents to request additional information or clarification when necessary.\nThis feature is especially useful in complex decision-making processes or when agents require more details to complete a task effectively.",
      "formatted_path": "Changelog > Human Input on Execution > Human input in agent execution",
      "enhanced_text": "Context: Changelog > Human Input on Execution > Human input in agent execution\n\n Human input in agent execution\n\nHuman input is critical in several agent execution scenarios, allowing agents to request additional information or clarification when necessary.\nThis feature is especially useful in complex decision-making processes or when agents require more details to complete a task effectively."
    },
    {
      "content": "To integrate human input into agent execution, set the `human_input` flag in the task definition. When enabled, the agent prompts the user for input before delivering its final answer.\nThis input can provide extra context, clarify ambiguities, or validate the agent's output.",
      "title": "Using human input with CrewAI",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Human Input on Execution",
          "level": 1
        },
        {
          "title": "Using human input with CrewAI",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Human Input on Execution",
            "level": 1
          },
          {
            "title": "Using human input with CrewAI",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Human Input on Execution > Using human input with CrewAI"
      },
      "enhanced_content": "Context: Changelog > Human Input on Execution > Using human input with CrewAI\n\n## Using human input with CrewAI\n\nTo integrate human input into agent execution, set the `human_input` flag in the task definition. When enabled, the agent prompts the user for input before delivering its final answer.\nThis input can provide extra context, clarify ambiguities, or validate the agent's output.",
      "formatted_path": "Changelog > Human Input on Execution > Using human input with CrewAI",
      "enhanced_text": "Context: Changelog > Human Input on Execution > Using human input with CrewAI\n\n Using human input with CrewAI\n\nTo integrate human input into agent execution, set the `human_input` flag in the task definition. When enabled, the agent prompts the user for input before delivering its final answer.\nThis input can provide extra context, clarify ambiguities, or validate the agent's output."
    },
    {
      "content": "from crewai.tools.structured_tool import CrewStructuredTool\nfrom pydantic import BaseModel\n\n# Define the schema for the tool's input using Pydantic\nclass APICallInput(BaseModel):\n    endpoint: str\n    parameters: dict\n\n# Wrapper function to execute the API call\ndef tool_wrapper(*args, **kwargs):\n    # Here, you would typically call the API using the parameters\n    # For demonstration, we'll return a placeholder string\n    return f\"Call the API at {kwargs['endpoint']} with parameters {kwargs['parameters']}\"\n\n# Create and return the structured tool\ndef create_structured_tool():\n    return CrewStructuredTool.from_function(\n        name='Wrapper API',\n        description=\"A tool to wrap API calls with structured input.\",\n        args_schema=APICallInput,\n        func=tool_wrapper,\n    )\n\n# Example usage\nstructured_tool = create_structured_tool()\n\n# Execute the tool with structured input\nresult = structured_tool._run(**{\n    \"endpoint\": \"https://example.com/api\",\n    \"parameters\": {\"key1\": \"value1\", \"key2\": \"value2\"}\n})\nprint(result)  # Output: Call the API at https://example.com/api with parameters {'key1': 'value1', 'key2': 'value2'}",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Human Input on Execution",
          "level": 1
        },
        {
          "title": "Using human input with CrewAI",
          "level": 2
        },
        {
          "title": "Example:",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Human Input on Execution",
            "level": 1
          },
          {
            "title": "Using human input with CrewAI",
            "level": 2
          },
          {
            "title": "Example:",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Human Input on Execution > Using human input with CrewAI > Example:"
      },
      "enhanced_content": "Context: Changelog > Human Input on Execution > Using human input with CrewAI > Example:\n\nfrom crewai.tools.structured_tool import CrewStructuredTool\nfrom pydantic import BaseModel\n\n# Define the schema for the tool's input using Pydantic\nclass APICallInput(BaseModel):\n    endpoint: str\n    parameters: dict\n\n# Wrapper function to execute the API call\ndef tool_wrapper(*args, **kwargs):\n    # Here, you would typically call the API using the parameters\n    # For demonstration, we'll return a placeholder string\n    return f\"Call the API at {kwargs['endpoint']} with parameters {kwargs['parameters']}\"\n\n# Create and return the structured tool\ndef create_structured_tool():\n    return CrewStructuredTool.from_function(\n        name='Wrapper API',\n        description=\"A tool to wrap API calls with structured input.\",\n        args_schema=APICallInput,\n        func=tool_wrapper,\n    )\n\n# Example usage\nstructured_tool = create_structured_tool()\n\n# Execute the tool with structured input\nresult = structured_tool._run(**{\n    \"endpoint\": \"https://example.com/api\",\n    \"parameters\": {\"key1\": \"value1\", \"key2\": \"value2\"}\n})\nprint(result)  # Output: Call the API at https://example.com/api with parameters {'key1': 'value1', 'key2': 'value2'}",
      "formatted_path": "Changelog > Human Input on Execution > Using human input with CrewAI > Example:",
      "enhanced_text": "Context: Changelog > Human Input on Execution > Using human input with CrewAI > Example:\n\nfrom crewai.tools.structured_tool import CrewStructuredTool\nfrom pydantic import BaseModel\n\n# Define the schema for the tool's input using Pydantic\nclass APICallInput(BaseModel):\n    endpoint: str\n    parameters: dict\n\n# Wrapper function to execute the API call\ndef tool_wrapper(*args, **kwargs):\n    # Here, you would typically call the API using the parameters\n    # For demonstration, we'll return a placeholder string\n    return f\"Call the API at {kwargs['endpoint']} with parameters {kwargs['parameters']}\"\n\n# Create and return the structured tool\ndef create_structured_tool():\n    return CrewStructuredTool.from_function(\n        name='Wrapper API',\n        description=\"A tool to wrap API calls with structured input.\",\n        args_schema=APICallInput,\n        func=tool_wrapper,\n    )\n\n# Example usage\nstructured_tool = create_structured_tool()\n\n# Execute the tool with structured input\nresult = structured_tool._run(**{\n    \"endpoint\": \"https://example.com/api\",\n    \"parameters\": {\"key1\": \"value1\", \"key2\": \"value2\"}\n})\nprint(result)  # Output: Call the API at https://example.com/api with parameters {'key1': 'value1', 'key2': 'value2'}"
    },
    {
      "content": "pip install crewai",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Human Input on Execution",
          "level": 1
        },
        {
          "title": "Using human input with CrewAI",
          "level": 2
        },
        {
          "title": "Example:",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Human Input on Execution",
            "level": 1
          },
          {
            "title": "Using human input with CrewAI",
            "level": 2
          },
          {
            "title": "Example:",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Human Input on Execution > Using human input with CrewAI > Example:"
      },
      "enhanced_content": "Context: Changelog > Human Input on Execution > Using human input with CrewAI > Example:\n\npip install crewai",
      "formatted_path": "Changelog > Human Input on Execution > Using human input with CrewAI > Example:",
      "enhanced_text": "Context: Changelog > Human Input on Execution > Using human input with CrewAI > Example:\n\npip install crewai"
    },
    {
      "content": "import os\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import SerperDevTool\n\nos.environ[\"SERPER_API_KEY\"] = \"Your Key\"  # serper.dev API key\nos.environ[\"OPENAI_API_KEY\"] = \"Your Key\"\n\n# Loading Tools\nsearch_tool = SerperDevTool()\n\n# Define your agents with roles, goals, tools, and additional attributes\nresearcher = Agent(\n    role='Senior Research Analyst',\n    goal='Uncover cutting-edge developments in AI and data science',\n    backstory=(\n        \"You are a Senior Research Analyst at a leading tech think tank. \"\n        \"Your expertise lies in identifying emerging trends and technologies in AI and data science. \"\n        \"You have a knack for dissecting complex data and presenting actionable insights.\"\n    ),\n    verbose=True,\n    allow_delegation=False,\n    tools=[search_tool]\n)\nwriter = Agent(\n    role='Tech Content Strategist',\n    goal='Craft compelling content on tech advancements',\n    backstory=(\n        \"You are a renowned Tech Content Strategist, known for your insightful and engaging articles on technology and innovation. \"\n        \"With a deep understanding of the tech industry, you transform complex concepts into compelling narratives.\"\n    ),\n    verbose=True,\n    allow_delegation=True,\n    tools=[search_tool],\n    cache=False,  # Disable cache for this agent\n)\n\n# Create tasks for your agents\ntask1 = Task(\n    description=(\n        \"Conduct a comprehensive analysis of the latest advancements in AI in 2025. \"\n        \"Identify key trends, breakthrough technologies, and potential industry impacts. \"\n        \"Compile your findings in a detailed report. \"\n        \"Make sure to check with a human if the draft is good before finalizing your answer.\"\n    ),\n    expected_output='A comprehensive full report on the latest AI advancements in 2025, leave nothing out',\n    agent=researcher,\n    human_input=True\n)\n\ntask2 = Task(\n    description=(\n        \"Using the insights from the researcher\\'s report, develop an engaging blog post that highlights the most significant AI advancements. \"\n        \"Your post should be informative yet accessible, catering to a tech-savvy audience. \"\n        \"Aim for a narrative that captures the essence of these breakthroughs and their implications for the future.\"\n    ),\n    expected_output='A compelling 3 paragraphs blog post formatted as markdown about the latest AI advancements in 2025',\n    agent=writer,\n    human_input=True\n)\n\n# Instantiate your crew with a sequential process\ncrew = Crew(\n    agents=[researcher, writer],\n    tasks=[task1, task2],\n    verbose=True,\n    memory=True,\n    planning=True  # Enable planning feature for the crew\n)\n\n# Get your crew to work!\nresult = crew.kickoff()\n\nprint(\"######################\")\nprint(result)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Human Input on Execution",
          "level": 1
        },
        {
          "title": "Using human input with CrewAI",
          "level": 2
        },
        {
          "title": "Example:",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Human Input on Execution",
            "level": 1
          },
          {
            "title": "Using human input with CrewAI",
            "level": 2
          },
          {
            "title": "Example:",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Human Input on Execution > Using human input with CrewAI > Example:"
      },
      "enhanced_content": "Context: Changelog > Human Input on Execution > Using human input with CrewAI > Example:\n\nimport os\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import SerperDevTool\n\nos.environ[\"SERPER_API_KEY\"] = \"Your Key\"  # serper.dev API key\nos.environ[\"OPENAI_API_KEY\"] = \"Your Key\"\n\n# Loading Tools\nsearch_tool = SerperDevTool()\n\n# Define your agents with roles, goals, tools, and additional attributes\nresearcher = Agent(\n    role='Senior Research Analyst',\n    goal='Uncover cutting-edge developments in AI and data science',\n    backstory=(\n        \"You are a Senior Research Analyst at a leading tech think tank. \"\n        \"Your expertise lies in identifying emerging trends and technologies in AI and data science. \"\n        \"You have a knack for dissecting complex data and presenting actionable insights.\"\n    ),\n    verbose=True,\n    allow_delegation=False,\n    tools=[search_tool]\n)\nwriter = Agent(\n    role='Tech Content Strategist',\n    goal='Craft compelling content on tech advancements',\n    backstory=(\n        \"You are a renowned Tech Content Strategist, known for your insightful and engaging articles on technology and innovation. \"\n        \"With a deep understanding of the tech industry, you transform complex concepts into compelling narratives.\"\n    ),\n    verbose=True,\n    allow_delegation=True,\n    tools=[search_tool],\n    cache=False,  # Disable cache for this agent\n)\n\n# Create tasks for your agents\ntask1 = Task(\n    description=(\n        \"Conduct a comprehensive analysis of the latest advancements in AI in 2025. \"\n        \"Identify key trends, breakthrough technologies, and potential industry impacts. \"\n        \"Compile your findings in a detailed report. \"\n        \"Make sure to check with a human if the draft is good before finalizing your answer.\"\n    ),\n    expected_output='A comprehensive full report on the latest AI advancements in 2025, leave nothing out',\n    agent=researcher,\n    human_input=True\n)\n\ntask2 = Task(\n    description=(\n        \"Using the insights from the researcher\\'s report, develop an engaging blog post that highlights the most significant AI advancements. \"\n        \"Your post should be informative yet accessible, catering to a tech-savvy audience. \"\n        \"Aim for a narrative that captures the essence of these breakthroughs and their implications for the future.\"\n    ),\n    expected_output='A compelling 3 paragraphs blog post formatted as markdown about the latest AI advancements in 2025',\n    agent=writer,\n    human_input=True\n)\n\n# Instantiate your crew with a sequential process\ncrew = Crew(\n    agents=[researcher, writer],\n    tasks=[task1, task2],\n    verbose=True,\n    memory=True,\n    planning=True  # Enable planning feature for the crew\n)\n\n# Get your crew to work!\nresult = crew.kickoff()\n\nprint(\"######################\")\nprint(result)",
      "formatted_path": "Changelog > Human Input on Execution > Using human input with CrewAI > Example:",
      "enhanced_text": "Context: Changelog > Human Input on Execution > Using human input with CrewAI > Example:\n\nimport os\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import SerperDevTool\n\nos.environ[\"SERPER_API_KEY\"] = \"Your Key\"  # serper.dev API key\nos.environ[\"OPENAI_API_KEY\"] = \"Your Key\"\n\n# Loading Tools\nsearch_tool = SerperDevTool()\n\n# Define your agents with roles, goals, tools, and additional attributes\nresearcher = Agent(\n    role='Senior Research Analyst',\n    goal='Uncover cutting-edge developments in AI and data science',\n    backstory=(\n        \"You are a Senior Research Analyst at a leading tech think tank. \"\n        \"Your expertise lies in identifying emerging trends and technologies in AI and data science. \"\n        \"You have a knack for dissecting complex data and presenting actionable insights.\"\n    ),\n    verbose=True,\n    allow_delegation=False,\n    tools=[search_tool]\n)\nwriter = Agent(\n    role='Tech Content Strategist',\n    goal='Craft compelling content on tech advancements',\n    backstory=(\n        \"You are a renowned Tech Content Strategist, known for your insightful and engaging articles on technology and innovation. \"\n        \"With a deep understanding of the tech industry, you transform complex concepts into compelling narratives.\"\n    ),\n    verbose=True,\n    allow_delegation=True,\n    tools=[search_tool],\n    cache=False,  # Disable cache for this agent\n)\n\n# Create tasks for your agents\ntask1 = Task(\n    description=(\n        \"Conduct a comprehensive analysis of the latest advancements in AI in 2025. \"\n        \"Identify key trends, breakthrough technologies, and potential industry impacts. \"\n        \"Compile your findings in a detailed report. \"\n        \"Make sure to check with a human if the draft is good before finalizing your answer.\"\n    ),\n    expected_output='A comprehensive full report on the latest AI advancements in 2025, leave nothing out',\n    agent=researcher,\n    human_input=True\n)\n\ntask2 = Task(\n    description=(\n        \"Using the insights from the researcher\\'s report, develop an engaging blog post that highlights the most significant AI advancements. \"\n        \"Your post should be informative yet accessible, catering to a tech-savvy audience. \"\n        \"Aim for a narrative that captures the essence of these breakthroughs and their implications for the future.\"\n    ),\n    expected_output='A compelling 3 paragraphs blog post formatted as markdown about the latest AI advancements in 2025',\n    agent=writer,\n    human_input=True\n)\n\n# Instantiate your crew with a sequential process\ncrew = Crew(\n    agents=[researcher, writer],\n    tasks=[task1, task2],\n    verbose=True,\n    memory=True,\n    planning=True  # Enable planning feature for the crew\n)\n\n# Get your crew to work!\nresult = crew.kickoff()\n\nprint(\"######################\")\nprint(result)"
    },
    {
      "content": "Source: https://docs.crewai.com/how-to/kickoff-async Kickoff a Crew Asynchronously",
      "title": "Kickoff Crew Asynchronously",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Kickoff Crew Asynchronously",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Kickoff Crew Asynchronously",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Kickoff Crew Asynchronously"
      },
      "enhanced_content": "Context: Changelog > Kickoff Crew Asynchronously\n\n# Kickoff Crew Asynchronously\n\nSource: https://docs.crewai.com/how-to/kickoff-async Kickoff a Crew Asynchronously",
      "formatted_path": "Changelog > Kickoff Crew Asynchronously",
      "enhanced_text": "Context: Changelog > Kickoff Crew Asynchronously\n\n Kickoff Crew Asynchronously\n\nSource: https://docs.crewai.com/how-to/kickoff-async Kickoff a Crew Asynchronously"
    },
    {
      "content": "To kickoff a crew asynchronously, use the `kickoff_async()` method. This method initiates the crew execution in a separate thread, allowing the main thread to continue executing other tasks.",
      "title": "Asynchronous Crew Execution",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Kickoff Crew Asynchronously",
          "level": 1
        },
        {
          "title": "Asynchronous Crew Execution",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Kickoff Crew Asynchronously",
            "level": 1
          },
          {
            "title": "Asynchronous Crew Execution",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Kickoff Crew Asynchronously > Asynchronous Crew Execution"
      },
      "enhanced_content": "Context: Changelog > Kickoff Crew Asynchronously > Asynchronous Crew Execution\n\n## Asynchronous Crew Execution\n\nTo kickoff a crew asynchronously, use the `kickoff_async()` method. This method initiates the crew execution in a separate thread, allowing the main thread to continue executing other tasks.",
      "formatted_path": "Changelog > Kickoff Crew Asynchronously > Asynchronous Crew Execution",
      "enhanced_text": "Context: Changelog > Kickoff Crew Asynchronously > Asynchronous Crew Execution\n\n Asynchronous Crew Execution\n\nTo kickoff a crew asynchronously, use the `kickoff_async()` method. This method initiates the crew execution in a separate thread, allowing the main thread to continue executing other tasks.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "def kickoff_async(self, inputs: dict) -> CrewOutput:",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Kickoff Crew Asynchronously",
          "level": 1
        },
        {
          "title": "Asynchronous Crew Execution",
          "level": 2
        },
        {
          "title": "Method Signature",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Kickoff Crew Asynchronously",
            "level": 1
          },
          {
            "title": "Asynchronous Crew Execution",
            "level": 2
          },
          {
            "title": "Method Signature",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Kickoff Crew Asynchronously > Asynchronous Crew Execution > Method Signature"
      },
      "enhanced_content": "Context: Changelog > Kickoff Crew Asynchronously > Asynchronous Crew Execution > Method Signature\n\ndef kickoff_async(self, inputs: dict) -> CrewOutput:",
      "formatted_path": "Changelog > Kickoff Crew Asynchronously > Asynchronous Crew Execution > Method Signature",
      "enhanced_text": "Context: Changelog > Kickoff Crew Asynchronously > Asynchronous Crew Execution > Method Signature\n\ndef kickoff_async(self, inputs: dict) -> CrewOutput:"
    },
    {
      "content": "`CrewOutput`: An object representing the result of the crew execution.",
      "title": "Returns",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Kickoff Crew Asynchronously",
          "level": 1
        },
        {
          "title": "Asynchronous Crew Execution",
          "level": 2
        },
        {
          "title": "Returns",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Kickoff Crew Asynchronously",
            "level": 1
          },
          {
            "title": "Asynchronous Crew Execution",
            "level": 2
          },
          {
            "title": "Returns",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Kickoff Crew Asynchronously > Asynchronous Crew Execution > Returns"
      },
      "enhanced_content": "Context: Changelog > Kickoff Crew Asynchronously > Asynchronous Crew Execution > Returns\n\n### Returns\n\n`CrewOutput`: An object representing the result of the crew execution.",
      "formatted_path": "Changelog > Kickoff Crew Asynchronously > Asynchronous Crew Execution > Returns",
      "enhanced_text": "Context: Changelog > Kickoff Crew Asynchronously > Asynchronous Crew Execution > Returns\n\n Returns\n\n`CrewOutput`: An object representing the result of the crew execution."
    },
    {
      "content": "**Parallel Content Generation**: Kickoff multiple independent crews asynchronously, each responsible for generating content on different topics. For example, one crew might research and draft an article on AI trends, while another crew generates social media posts about a new product launch. Each crew operates independently, allowing content production to scale efficiently. **Concurrent Market Research Tasks**: Launch multiple crews asynchronously to conduct market research in parallel. One crew might analyze industry trends, while another examines competitor strategies, and yet another evaluates consumer sentiment. Each crew independently completes its task, enabling faster and more comprehensive insights. **Independent Travel Planning Modules**: Execute separate crews to independently plan different aspects of a trip. One crew might handle flight options, another handles accommodation, and a third plans activities. Each crew works asynchronously, allowing various components of the trip to be planned simultaneously and independently for faster results.",
      "title": "Potential Use Cases",
      "type": "descriptive_text_oversized",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Kickoff Crew Asynchronously",
          "level": 1
        },
        {
          "title": "Potential Use Cases",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Kickoff Crew Asynchronously",
            "level": 1
          },
          {
            "title": "Potential Use Cases",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Kickoff Crew Asynchronously > Potential Use Cases"
      },
      "enhanced_content": "Context: Changelog > Kickoff Crew Asynchronously > Potential Use Cases\n\n## Potential Use Cases\n\n**Parallel Content Generation**: Kickoff multiple independent crews asynchronously, each responsible for generating content on different topics. For example, one crew might research and draft an article on AI trends, while another crew generates social media posts about a new product launch. Each crew operates independently, allowing content production to scale efficiently. **Concurrent Market Research Tasks**: Launch multiple crews asynchronously to conduct market research in parallel. One crew might analyze industry trends, while another examines competitor strategies, and yet another evaluates consumer sentiment. Each crew independently completes its task, enabling faster and more comprehensive insights. **Independent Travel Planning Modules**: Execute separate crews to independently plan different aspects of a trip. One crew might handle flight options, another handles accommodation, and a third plans activities. Each crew works asynchronously, allowing various components of the trip to be planned simultaneously and independently for faster results.",
      "formatted_path": "Changelog > Kickoff Crew Asynchronously > Potential Use Cases",
      "enhanced_text": "Context: Changelog > Kickoff Crew Asynchronously > Potential Use Cases\n\n Potential Use Cases\n\n**Parallel Content Generation**: Kickoff multiple independent crews asynchronously, each responsible for generating content on different topics. For example, one crew might research and draft an article on AI trends, while another crew generates social media posts about a new product launch. Each crew operates independently, allowing content production to scale efficiently. **Concurrent Market Research Tasks**: Launch multiple crews asynchronously to conduct market research in parallel. One crew might analyze industry trends, while another examines competitor strategies, and yet another evaluates consumer sentiment. Each crew independently completes its task, enabling faster and more comprehensive insights. **Independent Travel Planning Modules**: Execute separate crews to independently plan different aspects of a trip. One crew might handle flight options, another handles accommodation, and a third plans activities. Each crew works asynchronously, allowing various components of the trip to be planned simultaneously and independently for faster results.\n\nRelated sections:\n- \n- \n- \n"
    },
    {
      "content": "import asyncio\nfrom crewai import Crew, Agent, Task\n\n# Create an agent with code execution enabled\ncoding_agent = Agent(\n    role=\"Python Data Analyst\",\n    goal=\"Analyze data and provide insights using Python\",\n    backstory=\"You are an experienced data analyst with strong Python skills.\",\n    allow_code_execution=True\n)\n\n# Create a task that requires code execution\ndata_analysis_task = Task(\n    description=\"Analyze the given dataset and calculate the average age of participants. Ages: {ages}\",\n    agent=coding_agent,\n    expected_output=\"The average age of the participants.\"\n)\n\n# Create a crew and add the task\nanalysis_crew = Crew(\n    agents=[coding_agent],\n    tasks=[data_analysis_task]\n)\n\n# Async function to kickoff the crew asynchronously\nasync def async_crew_execution():\n    result = await analysis_crew.kickoff_async(inputs={\"ages\": [25, 30, 35, 40, 45]})\n    print(\"Crew Result:\", result)\n\n# Run the async function\nasyncio.run(async_crew_execution())",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Kickoff Crew Asynchronously",
          "level": 1
        },
        {
          "title": "Example: Single Asynchronous Crew Execution",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Kickoff Crew Asynchronously",
            "level": 1
          },
          {
            "title": "Example: Single Asynchronous Crew Execution",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Kickoff Crew Asynchronously > Example: Single Asynchronous Crew Execution"
      },
      "enhanced_content": "Context: Changelog > Kickoff Crew Asynchronously > Example: Single Asynchronous Crew Execution\n\nimport asyncio\nfrom crewai import Crew, Agent, Task\n\n# Create an agent with code execution enabled\ncoding_agent = Agent(\n    role=\"Python Data Analyst\",\n    goal=\"Analyze data and provide insights using Python\",\n    backstory=\"You are an experienced data analyst with strong Python skills.\",\n    allow_code_execution=True\n)\n\n# Create a task that requires code execution\ndata_analysis_task = Task(\n    description=\"Analyze the given dataset and calculate the average age of participants. Ages: {ages}\",\n    agent=coding_agent,\n    expected_output=\"The average age of the participants.\"\n)\n\n# Create a crew and add the task\nanalysis_crew = Crew(\n    agents=[coding_agent],\n    tasks=[data_analysis_task]\n)\n\n# Async function to kickoff the crew asynchronously\nasync def async_crew_execution():\n    result = await analysis_crew.kickoff_async(inputs={\"ages\": [25, 30, 35, 40, 45]})\n    print(\"Crew Result:\", result)\n\n# Run the async function\nasyncio.run(async_crew_execution())",
      "formatted_path": "Changelog > Kickoff Crew Asynchronously > Example: Single Asynchronous Crew Execution",
      "enhanced_text": "Context: Changelog > Kickoff Crew Asynchronously > Example: Single Asynchronous Crew Execution\n\nimport asyncio\nfrom crewai import Crew, Agent, Task\n\n# Create an agent with code execution enabled\ncoding_agent = Agent(\n    role=\"Python Data Analyst\",\n    goal=\"Analyze data and provide insights using Python\",\n    backstory=\"You are an experienced data analyst with strong Python skills.\",\n    allow_code_execution=True\n)\n\n# Create a task that requires code execution\ndata_analysis_task = Task(\n    description=\"Analyze the given dataset and calculate the average age of participants. Ages: {ages}\",\n    agent=coding_agent,\n    expected_output=\"The average age of the participants.\"\n)\n\n# Create a crew and add the task\nanalysis_crew = Crew(\n    agents=[coding_agent],\n    tasks=[data_analysis_task]\n)\n\n# Async function to kickoff the crew asynchronously\nasync def async_crew_execution():\n    result = await analysis_crew.kickoff_async(inputs={\"ages\": [25, 30, 35, 40, 45]})\n    print(\"Crew Result:\", result)\n\n# Run the async function\nasyncio.run(async_crew_execution())"
    },
    {
      "content": "import asyncio\nfrom crewai import Crew, Agent, Task\n\n# Create an agent with code execution enabled\ncoding_agent = Agent(\n    role=\"Python Data Analyst\",\n    goal=\"Analyze data and provide insights using Python\",\n    backstory=\"You are an experienced data analyst with strong Python skills.\",\n    allow_code_execution=True\n)\n\n# Create tasks that require code execution\ntask_1 = Task(\n    description=\"Analyze the first dataset and calculate the average age of participants. Ages: {ages}\",\n    agent=coding_agent\n)\n\ntask_2 = Task(\n    description=\"Analyze the second dataset and calculate the average age of participants. Ages: {ages}\",\n    agent=coding_agent\n)\n\n# Create two crews and add tasks\ncrew_1 = Crew(agents=[coding_agent], tasks=[task_1])\ncrew_2 = Crew(agents=[coding_agent], tasks=[task_2])\n\n# Async function to kickoff multiple crews asynchronously and wait for all to finish\nasync def async_multiple_crews():\n    result_1 = crew_1.kickoff_async(inputs={\"ages\": [25, 30, 35, 40, 45]})\n    result_2 = crew_2.kickoff_async(inputs={\"ages\": [20, 22, 24, 28, 30]})\n\n    # Wait for both crews to finish\n    results = await asyncio.gather(result_1, result_2)\n\n    for i, result in enumerate(results, 1):\n        print(f\"Crew {i} Result:\", result)\n\n# Run the async function\nasyncio.run(async_multiple_crews())",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Kickoff Crew Asynchronously",
          "level": 1
        },
        {
          "title": "Example: Multiple Asynchronous Crew Executions",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Kickoff Crew Asynchronously",
            "level": 1
          },
          {
            "title": "Example: Multiple Asynchronous Crew Executions",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Kickoff Crew Asynchronously > Example: Multiple Asynchronous Crew Executions"
      },
      "enhanced_content": "Context: Changelog > Kickoff Crew Asynchronously > Example: Multiple Asynchronous Crew Executions\n\nimport asyncio\nfrom crewai import Crew, Agent, Task\n\n# Create an agent with code execution enabled\ncoding_agent = Agent(\n    role=\"Python Data Analyst\",\n    goal=\"Analyze data and provide insights using Python\",\n    backstory=\"You are an experienced data analyst with strong Python skills.\",\n    allow_code_execution=True\n)\n\n# Create tasks that require code execution\ntask_1 = Task(\n    description=\"Analyze the first dataset and calculate the average age of participants. Ages: {ages}\",\n    agent=coding_agent\n)\n\ntask_2 = Task(\n    description=\"Analyze the second dataset and calculate the average age of participants. Ages: {ages}\",\n    agent=coding_agent\n)\n\n# Create two crews and add tasks\ncrew_1 = Crew(agents=[coding_agent], tasks=[task_1])\ncrew_2 = Crew(agents=[coding_agent], tasks=[task_2])\n\n# Async function to kickoff multiple crews asynchronously and wait for all to finish\nasync def async_multiple_crews():\n    result_1 = crew_1.kickoff_async(inputs={\"ages\": [25, 30, 35, 40, 45]})\n    result_2 = crew_2.kickoff_async(inputs={\"ages\": [20, 22, 24, 28, 30]})\n\n    # Wait for both crews to finish\n    results = await asyncio.gather(result_1, result_2)\n\n    for i, result in enumerate(results, 1):\n        print(f\"Crew {i} Result:\", result)\n\n# Run the async function\nasyncio.run(async_multiple_crews())",
      "formatted_path": "Changelog > Kickoff Crew Asynchronously > Example: Multiple Asynchronous Crew Executions",
      "enhanced_text": "Context: Changelog > Kickoff Crew Asynchronously > Example: Multiple Asynchronous Crew Executions\n\nimport asyncio\nfrom crewai import Crew, Agent, Task\n\n# Create an agent with code execution enabled\ncoding_agent = Agent(\n    role=\"Python Data Analyst\",\n    goal=\"Analyze data and provide insights using Python\",\n    backstory=\"You are an experienced data analyst with strong Python skills.\",\n    allow_code_execution=True\n)\n\n# Create tasks that require code execution\ntask_1 = Task(\n    description=\"Analyze the first dataset and calculate the average age of participants. Ages: {ages}\",\n    agent=coding_agent\n)\n\ntask_2 = Task(\n    description=\"Analyze the second dataset and calculate the average age of participants. Ages: {ages}\",\n    agent=coding_agent\n)\n\n# Create two crews and add tasks\ncrew_1 = Crew(agents=[coding_agent], tasks=[task_1])\ncrew_2 = Crew(agents=[coding_agent], tasks=[task_2])\n\n# Async function to kickoff multiple crews asynchronously and wait for all to finish\nasync def async_multiple_crews():\n    result_1 = crew_1.kickoff_async(inputs={\"ages\": [25, 30, 35, 40, 45]})\n    result_2 = crew_2.kickoff_async(inputs={\"ages\": [20, 22, 24, 28, 30]})\n\n    # Wait for both crews to finish\n    results = await asyncio.gather(result_1, result_2)\n\n    for i, result in enumerate(results, 1):\n        print(f\"Crew {i} Result:\", result)\n\n# Run the async function\nasyncio.run(async_multiple_crews())"
    },
    {
      "content": "Source: https://docs.crewai.com/how-to/kickoff-for-each Kickoff Crew for Each Item in a List",
      "title": "Kickoff Crew for Each",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Kickoff Crew for Each",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Kickoff Crew for Each",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Kickoff Crew for Each"
      },
      "enhanced_content": "Context: Changelog > Kickoff Crew for Each\n\n# Kickoff Crew for Each\n\nSource: https://docs.crewai.com/how-to/kickoff-for-each Kickoff Crew for Each Item in a List",
      "formatted_path": "Changelog > Kickoff Crew for Each",
      "enhanced_text": "Context: Changelog > Kickoff Crew for Each\n\n Kickoff Crew for Each\n\nSource: https://docs.crewai.com/how-to/kickoff-for-each Kickoff Crew for Each Item in a List"
    },
    {
      "content": "from crewai import Crew, Agent, Task\n\n# Create an agent with code execution enabled\ncoding_agent = Agent(\n    role=\"Python Data Analyst\",\n    goal=\"Analyze data and provide insights using Python\",\n    backstory=\"You are an experienced data analyst with strong Python skills.\",\n    allow_code_execution=True\n)\n\n# Create a task that requires code execution\ndata_analysis_task = Task(\n    description=\"Analyze the given dataset and calculate the average age of participants. Ages: {ages}\",\n    agent=coding_agent,\n    expected_output=\"The average age calculated from the dataset\"\n)\n\n# Create a crew and add the task\nanalysis_crew = Crew(\n    agents=[coding_agent],\n    tasks=[data_analysis_task],\n    verbose=True,\n    memory=False\n)\n\ndatasets = [\n  { \"ages\": [25, 30, 35, 40, 45] },\n  { \"ages\": [20, 25, 30, 35, 40] },\n  { \"ages\": [30, 35, 40, 45, 50] }\n]\n\n# Execute the crew\nresult = analysis_crew.kickoff_for_each(inputs=datasets)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Kickoff Crew for Each",
          "level": 1
        },
        {
          "title": "Kicking Off a Crew for Each Item",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Kickoff Crew for Each",
            "level": 1
          },
          {
            "title": "Kicking Off a Crew for Each Item",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Kickoff Crew for Each > Kicking Off a Crew for Each Item"
      },
      "enhanced_content": "Context: Changelog > Kickoff Crew for Each > Kicking Off a Crew for Each Item\n\nfrom crewai import Crew, Agent, Task\n\n# Create an agent with code execution enabled\ncoding_agent = Agent(\n    role=\"Python Data Analyst\",\n    goal=\"Analyze data and provide insights using Python\",\n    backstory=\"You are an experienced data analyst with strong Python skills.\",\n    allow_code_execution=True\n)\n\n# Create a task that requires code execution\ndata_analysis_task = Task(\n    description=\"Analyze the given dataset and calculate the average age of participants. Ages: {ages}\",\n    agent=coding_agent,\n    expected_output=\"The average age calculated from the dataset\"\n)\n\n# Create a crew and add the task\nanalysis_crew = Crew(\n    agents=[coding_agent],\n    tasks=[data_analysis_task],\n    verbose=True,\n    memory=False\n)\n\ndatasets = [\n  { \"ages\": [25, 30, 35, 40, 45] },\n  { \"ages\": [20, 25, 30, 35, 40] },\n  { \"ages\": [30, 35, 40, 45, 50] }\n]\n\n# Execute the crew\nresult = analysis_crew.kickoff_for_each(inputs=datasets)",
      "formatted_path": "Changelog > Kickoff Crew for Each > Kicking Off a Crew for Each Item",
      "enhanced_text": "Context: Changelog > Kickoff Crew for Each > Kicking Off a Crew for Each Item\n\nfrom crewai import Crew, Agent, Task\n\n# Create an agent with code execution enabled\ncoding_agent = Agent(\n    role=\"Python Data Analyst\",\n    goal=\"Analyze data and provide insights using Python\",\n    backstory=\"You are an experienced data analyst with strong Python skills.\",\n    allow_code_execution=True\n)\n\n# Create a task that requires code execution\ndata_analysis_task = Task(\n    description=\"Analyze the given dataset and calculate the average age of participants. Ages: {ages}\",\n    agent=coding_agent,\n    expected_output=\"The average age calculated from the dataset\"\n)\n\n# Create a crew and add the task\nanalysis_crew = Crew(\n    agents=[coding_agent],\n    tasks=[data_analysis_task],\n    verbose=True,\n    memory=False\n)\n\ndatasets = [\n  { \"ages\": [25, 30, 35, 40, 45] },\n  { \"ages\": [20, 25, 30, 35, 40] },\n  { \"ages\": [30, 35, 40, 45, 50] }\n]\n\n# Execute the crew\nresult = analysis_crew.kickoff_for_each(inputs=datasets)"
    },
    {
      "content": "Source: https://docs.crewai.com/how-to/langfuse-observability Learn how to integrate Langfuse with CrewAI via OpenTelemetry using OpenLit",
      "title": "Langfuse Integration",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Langfuse Integration",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Langfuse Integration",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Langfuse Integration"
      },
      "enhanced_content": "Context: Changelog > Langfuse Integration\n\n# Langfuse Integration\n\nSource: https://docs.crewai.com/how-to/langfuse-observability Learn how to integrate Langfuse with CrewAI via OpenTelemetry using OpenLit",
      "formatted_path": "Changelog > Langfuse Integration",
      "enhanced_text": "Context: Changelog > Langfuse Integration\n\n Langfuse Integration\n\nSource: https://docs.crewai.com/how-to/langfuse-observability Learn how to integrate Langfuse with CrewAI via OpenTelemetry using OpenLit"
    },
    {
      "content": "This notebook demonstrates how to integrate **Langfuse** with **CrewAI** using OpenTelemetry via the **OpenLit** SDK. By the end of this notebook, you will be able to trace your CrewAI applications with Langfuse for improved observability and debugging. **What is Langfuse?** [Langfuse](https://langfuse.com) is an open-source LLM engineering platform. It provides tracing and monitoring capabilities for LLM applications, helping developers debug, analyze, and optimize their AI systems. Langfuse integrates with various tools and frameworks via native integrations, OpenTelemetry, and APIs/SDKs. [![Langfuse Overview Video](https://github.com/user-attachments/assets/3926b288-ff61-4b95-8aa1-45d041c70866)](https://langfuse.com/watch-demo)",
      "title": "Integrate Langfuse with CrewAI",
      "type": "link_list",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Integrate Langfuse with CrewAI",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Integrate Langfuse with CrewAI",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 2,
        "formatted_path": "Changelog > Integrate Langfuse with CrewAI"
      },
      "enhanced_content": "Context: Changelog > Integrate Langfuse with CrewAI\n\n# Integrate Langfuse with CrewAI\n\nThis notebook demonstrates how to integrate **Langfuse** with **CrewAI** using OpenTelemetry via the **OpenLit** SDK. By the end of this notebook, you will be able to trace your CrewAI applications with Langfuse for improved observability and debugging. **What is Langfuse?** [Langfuse](https://langfuse.com) is an open-source LLM engineering platform. It provides tracing and monitoring capabilities for LLM applications, helping developers debug, analyze, and optimize their AI systems. Langfuse integrates with various tools and frameworks via native integrations, OpenTelemetry, and APIs/SDKs. [![Langfuse Overview Video](https://github.com/user-attachments/assets/3926b288-ff61-4b95-8aa1-45d041c70866)](https://langfuse.com/watch-demo)",
      "formatted_path": "Changelog > Integrate Langfuse with CrewAI",
      "enhanced_text": "Context: Changelog > Integrate Langfuse with CrewAI\n\n Integrate Langfuse with CrewAI\n\nThis notebook demonstrates how to integrate **Langfuse** with **CrewAI** using OpenTelemetry via the **OpenLit** SDK. By the end of this notebook, you will be able to trace your CrewAI applications with Langfuse for improved observability and debugging. **What is Langfuse?** [Langfuse](https://langfuse.com) is an open-source LLM engineering platform. It provides tracing and monitoring capabilities for LLM applications, helping developers debug, analyze, and optimize their AI systems. Langfuse integrates with various tools and frameworks via native integrations, OpenTelemetry, and APIs/SDKs. [![Langfuse Overview Video](https://github.com/user-attachments/assets/3926b288-ff61-4b95-8aa1-45d041c70866)](https://langfuse.com/watch-demo)"
    },
    {
      "content": "We'll walk through a simple example of using CrewAI and integrating it with Langfuse via OpenTelemetry using OpenLit.",
      "title": "Get Started",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Integrate Langfuse with CrewAI",
          "level": 1
        },
        {
          "title": "Get Started",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Integrate Langfuse with CrewAI",
            "level": 1
          },
          {
            "title": "Get Started",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Integrate Langfuse with CrewAI > Get Started"
      },
      "enhanced_content": "Context: Changelog > Integrate Langfuse with CrewAI > Get Started\n\n## Get Started\n\nWe'll walk through a simple example of using CrewAI and integrating it with Langfuse via OpenTelemetry using OpenLit.",
      "formatted_path": "Changelog > Integrate Langfuse with CrewAI > Get Started",
      "enhanced_text": "Context: Changelog > Integrate Langfuse with CrewAI > Get Started\n\n Get Started\n\nWe'll walk through a simple example of using CrewAI and integrating it with Langfuse via OpenTelemetry using OpenLit.\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "%pip install langfuse openlit crewai crewai_tools",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Integrate Langfuse with CrewAI",
          "level": 1
        },
        {
          "title": "Get Started",
          "level": 2
        },
        {
          "title": "Step 1: Install Dependencies",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Integrate Langfuse with CrewAI",
            "level": 1
          },
          {
            "title": "Get Started",
            "level": 2
          },
          {
            "title": "Step 1: Install Dependencies",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Integrate Langfuse with CrewAI > Get Started > Step 1: Install Dependencies"
      },
      "enhanced_content": "Context: Changelog > Integrate Langfuse with CrewAI > Get Started > Step 1: Install Dependencies\n\n%pip install langfuse openlit crewai crewai_tools",
      "formatted_path": "Changelog > Integrate Langfuse with CrewAI > Get Started > Step 1: Install Dependencies",
      "enhanced_text": "Context: Changelog > Integrate Langfuse with CrewAI > Get Started > Step 1: Install Dependencies\n\n%pip install langfuse openlit crewai crewai_tools"
    },
    {
      "content": "import os\nimport base64\n\nLANGFUSE_PUBLIC_KEY=\"pk-lf-...\"\nLANGFUSE_SECRET_KEY=\"sk-lf-...\"\nLANGFUSE_AUTH=base64.b64encode(f\"{LANGFUSE_PUBLIC_KEY}:{LANGFUSE_SECRET_KEY}\".encode()).decode()\n\nos.environ[\"OTEL_EXPORTER_OTLP_ENDPOINT\"] = \"https://cloud.langfuse.com/api/public/otel\" # EU data region\n# os.environ[\"OTEL_EXPORTER_OTLP_ENDPOINT\"] = \"https://us.cloud.langfuse.com/api/public/otel\" # US data region\nos.environ[\"OTEL_EXPORTER_OTLP_HEADERS\"] = f\"Authorization=Basic {LANGFUSE_AUTH}\"\n\n# your openai key\nos.environ[\"OPENAI_API_KEY\"] = \"sk-...\"",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Integrate Langfuse with CrewAI",
          "level": 1
        },
        {
          "title": "Get Started",
          "level": 2
        },
        {
          "title": "Step 2: Set Up Environment Variables",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Integrate Langfuse with CrewAI",
            "level": 1
          },
          {
            "title": "Get Started",
            "level": 2
          },
          {
            "title": "Step 2: Set Up Environment Variables",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Integrate Langfuse with CrewAI > Get Started > Step 2: Set Up Environment Variables"
      },
      "enhanced_content": "Context: Changelog > Integrate Langfuse with CrewAI > Get Started > Step 2: Set Up Environment Variables\n\nimport os\nimport base64\n\nLANGFUSE_PUBLIC_KEY=\"pk-lf-...\"\nLANGFUSE_SECRET_KEY=\"sk-lf-...\"\nLANGFUSE_AUTH=base64.b64encode(f\"{LANGFUSE_PUBLIC_KEY}:{LANGFUSE_SECRET_KEY}\".encode()).decode()\n\nos.environ[\"OTEL_EXPORTER_OTLP_ENDPOINT\"] = \"https://cloud.langfuse.com/api/public/otel\" # EU data region\n# os.environ[\"OTEL_EXPORTER_OTLP_ENDPOINT\"] = \"https://us.cloud.langfuse.com/api/public/otel\" # US data region\nos.environ[\"OTEL_EXPORTER_OTLP_HEADERS\"] = f\"Authorization=Basic {LANGFUSE_AUTH}\"\n\n# your openai key\nos.environ[\"OPENAI_API_KEY\"] = \"sk-...\"",
      "formatted_path": "Changelog > Integrate Langfuse with CrewAI > Get Started > Step 2: Set Up Environment Variables",
      "enhanced_text": "Context: Changelog > Integrate Langfuse with CrewAI > Get Started > Step 2: Set Up Environment Variables\n\nimport os\nimport base64\n\nLANGFUSE_PUBLIC_KEY=\"pk-lf-...\"\nLANGFUSE_SECRET_KEY=\"sk-lf-...\"\nLANGFUSE_AUTH=base64.b64encode(f\"{LANGFUSE_PUBLIC_KEY}:{LANGFUSE_SECRET_KEY}\".encode()).decode()\n\nos.environ[\"OTEL_EXPORTER_OTLP_ENDPOINT\"] = \"https://cloud.langfuse.com/api/public/otel\" # EU data region\n# os.environ[\"OTEL_EXPORTER_OTLP_ENDPOINT\"] = \"https://us.cloud.langfuse.com/api/public/otel\" # US data region\nos.environ[\"OTEL_EXPORTER_OTLP_HEADERS\"] = f\"Authorization=Basic {LANGFUSE_AUTH}\"\n\n# your openai key\nos.environ[\"OPENAI_API_KEY\"] = \"sk-...\""
    },
    {
      "content": "import openlit\n\nopenlit.init()",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Integrate Langfuse with CrewAI",
          "level": 1
        },
        {
          "title": "Get Started",
          "level": 2
        },
        {
          "title": "Step 3: Initialize OpenLit",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Integrate Langfuse with CrewAI",
            "level": 1
          },
          {
            "title": "Get Started",
            "level": 2
          },
          {
            "title": "Step 3: Initialize OpenLit",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Integrate Langfuse with CrewAI > Get Started > Step 3: Initialize OpenLit"
      },
      "enhanced_content": "Context: Changelog > Integrate Langfuse with CrewAI > Get Started > Step 3: Initialize OpenLit\n\nimport openlit\n\nopenlit.init()",
      "formatted_path": "Changelog > Integrate Langfuse with CrewAI > Get Started > Step 3: Initialize OpenLit",
      "enhanced_text": "Context: Changelog > Integrate Langfuse with CrewAI > Get Started > Step 3: Initialize OpenLit\n\nimport openlit\n\nopenlit.init()"
    },
    {
      "content": "from crewai import Agent, Task, Crew\n\nfrom crewai_tools import (\n    WebsiteSearchTool\n)\n\nweb_rag_tool = WebsiteSearchTool()\n\nwriter = Agent(\n        role=\"Writer\",\n        goal=\"You make math engaging and understandable for young children through poetry\",\n        backstory=\"You're an expert in writing haikus but you know nothing of math.\",\n        tools=[web_rag_tool],  \n    )\n\ntask = Task(description=(\"What is {multiplication}?\"),\n            expected_output=(\"Compose a haiku that includes the answer.\"),\n            agent=writer)\n\ncrew = Crew(\n  agents=[writer],\n  tasks=[task],\n  share_crew=False\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Integrate Langfuse with CrewAI",
          "level": 1
        },
        {
          "title": "Get Started",
          "level": 2
        },
        {
          "title": "Step 4: Create a Simple CrewAI Application",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Integrate Langfuse with CrewAI",
            "level": 1
          },
          {
            "title": "Get Started",
            "level": 2
          },
          {
            "title": "Step 4: Create a Simple CrewAI Application",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Integrate Langfuse with CrewAI > Get Started > Step 4: Create a Simple CrewAI Application"
      },
      "enhanced_content": "Context: Changelog > Integrate Langfuse with CrewAI > Get Started > Step 4: Create a Simple CrewAI Application\n\nfrom crewai import Agent, Task, Crew\n\nfrom crewai_tools import (\n    WebsiteSearchTool\n)\n\nweb_rag_tool = WebsiteSearchTool()\n\nwriter = Agent(\n        role=\"Writer\",\n        goal=\"You make math engaging and understandable for young children through poetry\",\n        backstory=\"You're an expert in writing haikus but you know nothing of math.\",\n        tools=[web_rag_tool],  \n    )\n\ntask = Task(description=(\"What is {multiplication}?\"),\n            expected_output=(\"Compose a haiku that includes the answer.\"),\n            agent=writer)\n\ncrew = Crew(\n  agents=[writer],\n  tasks=[task],\n  share_crew=False\n)",
      "formatted_path": "Changelog > Integrate Langfuse with CrewAI > Get Started > Step 4: Create a Simple CrewAI Application",
      "enhanced_text": "Context: Changelog > Integrate Langfuse with CrewAI > Get Started > Step 4: Create a Simple CrewAI Application\n\nfrom crewai import Agent, Task, Crew\n\nfrom crewai_tools import (\n    WebsiteSearchTool\n)\n\nweb_rag_tool = WebsiteSearchTool()\n\nwriter = Agent(\n        role=\"Writer\",\n        goal=\"You make math engaging and understandable for young children through poetry\",\n        backstory=\"You're an expert in writing haikus but you know nothing of math.\",\n        tools=[web_rag_tool],  \n    )\n\ntask = Task(description=(\"What is {multiplication}?\"),\n            expected_output=(\"Compose a haiku that includes the answer.\"),\n            agent=writer)\n\ncrew = Crew(\n  agents=[writer],\n  tasks=[task],\n  share_crew=False\n)"
    },
    {
      "content": "After running the agent, you can view the traces generated by your CrewAI application in [Langfuse](https://cloud.langfuse.com). You should see detailed steps of the LLM interactions, which can help you debug and optimize your AI agent. ![CrewAI example trace in Langfuse](https://langfuse.com/images/cookbook/integration_crewai/crewai-example-trace.png) *[Public example trace in Langfuse](https://cloud.langfuse.com/project/cloramnkj0002jz088vzn1ja4/traces/e2cf380ffc8d47d28da98f136140642b?timestamp=2025-02-05T15%3A12%3A02.717Z\\&observation=3b32338ee6a5d9af)*",
      "title": "Step 5: See Traces in Langfuse",
      "type": "link_list",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Integrate Langfuse with CrewAI",
          "level": 1
        },
        {
          "title": "Get Started",
          "level": 2
        },
        {
          "title": "Step 5: See Traces in Langfuse",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Integrate Langfuse with CrewAI",
            "level": 1
          },
          {
            "title": "Get Started",
            "level": 2
          },
          {
            "title": "Step 5: See Traces in Langfuse",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 3,
        "formatted_path": "Changelog > Integrate Langfuse with CrewAI > Get Started > Step 5: See Traces in Langfuse"
      },
      "enhanced_content": "Context: Changelog > Integrate Langfuse with CrewAI > Get Started > Step 5: See Traces in Langfuse\n\n### Step 5: See Traces in Langfuse\n\nAfter running the agent, you can view the traces generated by your CrewAI application in [Langfuse](https://cloud.langfuse.com). You should see detailed steps of the LLM interactions, which can help you debug and optimize your AI agent. ![CrewAI example trace in Langfuse](https://langfuse.com/images/cookbook/integration_crewai/crewai-example-trace.png) *[Public example trace in Langfuse](https://cloud.langfuse.com/project/cloramnkj0002jz088vzn1ja4/traces/e2cf380ffc8d47d28da98f136140642b?timestamp=2025-02-05T15%3A12%3A02.717Z\\&observation=3b32338ee6a5d9af)*",
      "formatted_path": "Changelog > Integrate Langfuse with CrewAI > Get Started > Step 5: See Traces in Langfuse",
      "enhanced_text": "Context: Changelog > Integrate Langfuse with CrewAI > Get Started > Step 5: See Traces in Langfuse\n\n Step 5: See Traces in Langfuse\n\nAfter running the agent, you can view the traces generated by your CrewAI application in [Langfuse](https://cloud.langfuse.com). You should see detailed steps of the LLM interactions, which can help you debug and optimize your AI agent. ![CrewAI example trace in Langfuse](https://langfuse.com/images/cookbook/integration_crewai/crewai-example-trace.png) *[Public example trace in Langfuse](https://cloud.langfuse.com/project/cloramnkj0002jz088vzn1ja4/traces/e2cf380ffc8d47d28da98f136140642b?timestamp=2025-02-05T15%3A12%3A02.717Z\\&observation=3b32338ee6a5d9af)*"
    },
    {
      "content": "[Langfuse OpenTelemetry Docs](https://langfuse.com/docs/opentelemetry/get-started)",
      "title": "References",
      "type": "link_list",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Integrate Langfuse with CrewAI",
          "level": 1
        },
        {
          "title": "References",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Integrate Langfuse with CrewAI",
            "level": 1
          },
          {
            "title": "References",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 1,
        "formatted_path": "Changelog > Integrate Langfuse with CrewAI > References"
      },
      "enhanced_content": "Context: Changelog > Integrate Langfuse with CrewAI > References\n\n## References\n\n[Langfuse OpenTelemetry Docs](https://langfuse.com/docs/opentelemetry/get-started)",
      "formatted_path": "Changelog > Integrate Langfuse with CrewAI > References",
      "enhanced_text": "Context: Changelog > Integrate Langfuse with CrewAI > References\n\n References\n\n[Langfuse OpenTelemetry Docs](https://langfuse.com/docs/opentelemetry/get-started)\n\nRelated sections:\n- \n"
    },
    {
      "content": "Source: https://docs.crewai.com/how-to/langtrace-observability How to monitor cost, latency, and performance of CrewAI Agents using Langtrace, an external observability tool.",
      "title": "Langtrace Integration",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Langtrace Integration",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Langtrace Integration",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Langtrace Integration"
      },
      "enhanced_content": "Context: Changelog > Langtrace Integration\n\n# Langtrace Integration\n\nSource: https://docs.crewai.com/how-to/langtrace-observability How to monitor cost, latency, and performance of CrewAI Agents using Langtrace, an external observability tool.",
      "formatted_path": "Changelog > Langtrace Integration",
      "enhanced_text": "Context: Changelog > Langtrace Integration\n\n Langtrace Integration\n\nSource: https://docs.crewai.com/how-to/langtrace-observability How to monitor cost, latency, and performance of CrewAI Agents using Langtrace, an external observability tool."
    },
    {
      "content": "Langtrace is an open-source, external tool that helps you set up observability and evaluations for Large Language Models (LLMs), LLM frameworks, and Vector Databases.\nWhile not built directly into CrewAI, Langtrace can be used alongside CrewAI to gain deep visibility into the cost, latency, and performance of your CrewAI Agents.\nThis integration allows you to log hyperparameters, monitor performance regressions, and establish a process for continuous improvement of your Agents. ![Overview of a select series of agent session runs](https://mintlify.s3.us-west-1.amazonaws.com/crewai/images/langtrace1.png)\n![Overview of agent traces](https://mintlify.s3.us-west-1.amazonaws.com/crewai/images/langtrace2.png)\n![Overview of llm traces in details](https://mintlify.s3.us-west-1.amazonaws.com/crewai/images/langtrace3.png)",
      "title": "Langtrace Overview",
      "type": "link_list",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Langtrace Overview",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Langtrace Overview",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 3,
        "formatted_path": "Changelog > Langtrace Overview"
      },
      "enhanced_content": "Context: Changelog > Langtrace Overview\n\n# Langtrace Overview\n\nLangtrace is an open-source, external tool that helps you set up observability and evaluations for Large Language Models (LLMs), LLM frameworks, and Vector Databases.\nWhile not built directly into CrewAI, Langtrace can be used alongside CrewAI to gain deep visibility into the cost, latency, and performance of your CrewAI Agents.\nThis integration allows you to log hyperparameters, monitor performance regressions, and establish a process for continuous improvement of your Agents. ![Overview of a select series of agent session runs](https://mintlify.s3.us-west-1.amazonaws.com/crewai/images/langtrace1.png)\n![Overview of agent traces](https://mintlify.s3.us-west-1.amazonaws.com/crewai/images/langtrace2.png)\n![Overview of llm traces in details](https://mintlify.s3.us-west-1.amazonaws.com/crewai/images/langtrace3.png)",
      "formatted_path": "Changelog > Langtrace Overview",
      "enhanced_text": "Context: Changelog > Langtrace Overview\n\n Langtrace Overview\n\nLangtrace is an open-source, external tool that helps you set up observability and evaluations for Large Language Models (LLMs), LLM frameworks, and Vector Databases.\nWhile not built directly into CrewAI, Langtrace can be used alongside CrewAI to gain deep visibility into the cost, latency, and performance of your CrewAI Agents.\nThis integration allows you to log hyperparameters, monitor performance regressions, and establish a process for continuous improvement of your Agents. ![Overview of a select series of agent session runs](https://mintlify.s3.us-west-1.amazonaws.com/crewai/images/langtrace1.png)\n![Overview of agent traces](https://mintlify.s3.us-west-1.amazonaws.com/crewai/images/langtrace2.png)\n![Overview of llm traces in details](https://mintlify.s3.us-west-1.amazonaws.com/crewai/images/langtrace3.png)\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "**LLM Token and Cost Tracking** Monitor the token usage and associated costs for each CrewAI agent interaction. **Trace Graph for Execution Steps** Visualize the execution flow of your CrewAI tasks, including latency and logs. Useful for identifying bottlenecks in your agent workflows. **Dataset Curation with Manual Annotation** Create datasets from your CrewAI task outputs for future training or evaluation. **Prompt Versioning and Management** Keep track of different versions of prompts used in your CrewAI agents. Useful for A/B testing and optimizing agent performance. **Prompt Playground with Model Comparisons** Test and compare different prompts and models for your CrewAI agents before deployment. **Testing and Evaluations** Set up automated tests for your CrewAI agents and tasks.",
      "title": "Features and Their Application to CrewAI",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Langtrace Overview",
          "level": 1
        },
        {
          "title": "Setup Instructions",
          "level": 2
        },
        {
          "title": "Features and Their Application to CrewAI",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Langtrace Overview",
            "level": 1
          },
          {
            "title": "Setup Instructions",
            "level": 2
          },
          {
            "title": "Features and Their Application to CrewAI",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Langtrace Overview > Setup Instructions > Features and Their Application to CrewAI"
      },
      "enhanced_content": "Context: Changelog > Langtrace Overview > Setup Instructions > Features and Their Application to CrewAI\n\n### Features and Their Application to CrewAI\n\n**LLM Token and Cost Tracking** Monitor the token usage and associated costs for each CrewAI agent interaction. **Trace Graph for Execution Steps** Visualize the execution flow of your CrewAI tasks, including latency and logs. Useful for identifying bottlenecks in your agent workflows. **Dataset Curation with Manual Annotation** Create datasets from your CrewAI task outputs for future training or evaluation. **Prompt Versioning and Management** Keep track of different versions of prompts used in your CrewAI agents. Useful for A/B testing and optimizing agent performance. **Prompt Playground with Model Comparisons** Test and compare different prompts and models for your CrewAI agents before deployment. **Testing and Evaluations** Set up automated tests for your CrewAI agents and tasks.",
      "formatted_path": "Changelog > Langtrace Overview > Setup Instructions > Features and Their Application to CrewAI",
      "enhanced_text": "Context: Changelog > Langtrace Overview > Setup Instructions > Features and Their Application to CrewAI\n\n Features and Their Application to CrewAI\n\n**LLM Token and Cost Tracking** Monitor the token usage and associated costs for each CrewAI agent interaction. **Trace Graph for Execution Steps** Visualize the execution flow of your CrewAI tasks, including latency and logs. Useful for identifying bottlenecks in your agent workflows. **Dataset Curation with Manual Annotation** Create datasets from your CrewAI task outputs for future training or evaluation. **Prompt Versioning and Management** Keep track of different versions of prompts used in your CrewAI agents. Useful for A/B testing and optimizing agent performance. **Prompt Playground with Model Comparisons** Test and compare different prompts and models for your CrewAI agents before deployment. **Testing and Evaluations** Set up automated tests for your CrewAI agents and tasks.\n\nRelated sections:\n- \n- \n- \n- \n"
    },
    {
      "content": "Source: https://docs.crewai.com/how-to/llm-connections Comprehensive guide on integrating CrewAI with various Large Language Models (LLMs) using LiteLLM, including supported providers and configuration options.",
      "title": "Connect to any LLM",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Connect to any LLM",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Connect to any LLM",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Connect to any LLM"
      },
      "enhanced_content": "Context: Changelog > Connect to any LLM\n\n# Connect to any LLM\n\nSource: https://docs.crewai.com/how-to/llm-connections Comprehensive guide on integrating CrewAI with various Large Language Models (LLMs) using LiteLLM, including supported providers and configuration options.",
      "formatted_path": "Changelog > Connect to any LLM",
      "enhanced_text": "Context: Changelog > Connect to any LLM\n\n Connect to any LLM\n\nSource: https://docs.crewai.com/how-to/llm-connections Comprehensive guide on integrating CrewAI with various Large Language Models (LLMs) using LiteLLM, including supported providers and configuration options."
    },
    {
      "content": "CrewAI uses LiteLLM to connect to a wide variety of Language Models (LLMs). This integration provides extensive versatility, allowing you to use models from numerous providers with a simple, unified interface.",
      "title": "Connect CrewAI to LLMs",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Connect to any LLM",
          "level": 1
        },
        {
          "title": "Connect CrewAI to LLMs",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Connect to any LLM",
            "level": 1
          },
          {
            "title": "Connect CrewAI to LLMs",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Connect to any LLM > Connect CrewAI to LLMs"
      },
      "enhanced_content": "Context: Changelog > Connect to any LLM > Connect CrewAI to LLMs\n\n## Connect CrewAI to LLMs\n\nCrewAI uses LiteLLM to connect to a wide variety of Language Models (LLMs). This integration provides extensive versatility, allowing you to use models from numerous providers with a simple, unified interface.",
      "formatted_path": "Changelog > Connect to any LLM > Connect CrewAI to LLMs",
      "enhanced_text": "Context: Changelog > Connect to any LLM > Connect CrewAI to LLMs\n\n Connect CrewAI to LLMs\n\nCrewAI uses LiteLLM to connect to a wide variety of Language Models (LLMs). This integration provides extensive versatility, allowing you to use models from numerous providers with a simple, unified interface.\n\nRelated sections:\n- \n"
    },
    {
      "content": "LiteLLM supports a wide range of providers, including but not limited to: OpenAI Anthropic Google (Vertex AI, Gemini) Azure OpenAI AWS (Bedrock, SageMaker) Cohere VoyageAI Hugging Face Ollama Mistral AI Replicate Together AI AI21 Cloudflare Workers AI DeepInfra Groq SambaNova [NVIDIA NIMs](https://docs.api.nvidia.com/nim/reference/models-1) And many more! For a complete and up-to-date list of supported providers, please refer to the [LiteLLM Providers documentation](https://docs.litellm.ai/docs/providers).",
      "title": "Supported Providers",
      "type": "link_list",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Connect to any LLM",
          "level": 1
        },
        {
          "title": "Supported Providers",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Connect to any LLM",
            "level": 1
          },
          {
            "title": "Supported Providers",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 2,
        "formatted_path": "Changelog > Connect to any LLM > Supported Providers"
      },
      "enhanced_content": "Context: Changelog > Connect to any LLM > Supported Providers\n\n## Supported Providers\n\nLiteLLM supports a wide range of providers, including but not limited to: OpenAI Anthropic Google (Vertex AI, Gemini) Azure OpenAI AWS (Bedrock, SageMaker) Cohere VoyageAI Hugging Face Ollama Mistral AI Replicate Together AI AI21 Cloudflare Workers AI DeepInfra Groq SambaNova [NVIDIA NIMs](https://docs.api.nvidia.com/nim/reference/models-1) And many more! For a complete and up-to-date list of supported providers, please refer to the [LiteLLM Providers documentation](https://docs.litellm.ai/docs/providers).",
      "formatted_path": "Changelog > Connect to any LLM > Supported Providers",
      "enhanced_text": "Context: Changelog > Connect to any LLM > Supported Providers\n\n Supported Providers\n\nLiteLLM supports a wide range of providers, including but not limited to: OpenAI Anthropic Google (Vertex AI, Gemini) Azure OpenAI AWS (Bedrock, SageMaker) Cohere VoyageAI Hugging Face Ollama Mistral AI Replicate Together AI AI21 Cloudflare Workers AI DeepInfra Groq SambaNova [NVIDIA NIMs](https://docs.api.nvidia.com/nim/reference/models-1) And many more! For a complete and up-to-date list of supported providers, please refer to the [LiteLLM Providers documentation](https://docs.litellm.ai/docs/providers)."
    },
    {
      "content": "To use a different LLM with your CrewAI agents, you have several options:",
      "title": "Changing the LLM",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Connect to any LLM",
          "level": 1
        },
        {
          "title": "Changing the LLM",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Connect to any LLM",
            "level": 1
          },
          {
            "title": "Changing the LLM",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Connect to any LLM > Changing the LLM"
      },
      "enhanced_content": "Context: Changelog > Connect to any LLM > Changing the LLM\n\n## Changing the LLM\n\nTo use a different LLM with your CrewAI agents, you have several options:",
      "formatted_path": "Changelog > Connect to any LLM > Changing the LLM",
      "enhanced_text": "Context: Changelog > Connect to any LLM > Changing the LLM\n\n Changing the LLM\n\nTo use a different LLM with your CrewAI agents, you have several options:"
    },
    {
      "content": "You can connect to OpenAI-compatible LLMs using either environment variables or by setting specific attributes on the LLM class:",
      "title": "Connecting to OpenAI-Compatible LLMs",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Connect to any LLM",
          "level": 1
        },
        {
          "title": "Connecting to OpenAI-Compatible LLMs",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Connect to any LLM",
            "level": 1
          },
          {
            "title": "Connecting to OpenAI-Compatible LLMs",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Connect to any LLM > Connecting to OpenAI-Compatible LLMs"
      },
      "enhanced_content": "Context: Changelog > Connect to any LLM > Connecting to OpenAI-Compatible LLMs\n\n## Connecting to OpenAI-Compatible LLMs\n\nYou can connect to OpenAI-compatible LLMs using either environment variables or by setting specific attributes on the LLM class:",
      "formatted_path": "Changelog > Connect to any LLM > Connecting to OpenAI-Compatible LLMs",
      "enhanced_text": "Context: Changelog > Connect to any LLM > Connecting to OpenAI-Compatible LLMs\n\n Connecting to OpenAI-Compatible LLMs\n\nYou can connect to OpenAI-compatible LLMs using either environment variables or by setting specific attributes on the LLM class:\n\nRelated sections:\n- \n"
    },
    {
      "content": "For local models like those provided by Ollama:",
      "title": "Using Local Models with Ollama",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Connect to any LLM",
          "level": 1
        },
        {
          "title": "Using Local Models with Ollama",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Connect to any LLM",
            "level": 1
          },
          {
            "title": "Using Local Models with Ollama",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Connect to any LLM > Using Local Models with Ollama"
      },
      "enhanced_content": "Context: Changelog > Connect to any LLM > Using Local Models with Ollama\n\n## Using Local Models with Ollama\n\nFor local models like those provided by Ollama:",
      "formatted_path": "Changelog > Connect to any LLM > Using Local Models with Ollama",
      "enhanced_text": "Context: Changelog > Connect to any LLM > Using Local Models with Ollama\n\n Using Local Models with Ollama\n\nFor local models like those provided by Ollama:"
    },
    {
      "content": "llm = LLM(\n    model=\"custom-model-name\",\n    base_url=\"https://api.your-provider.com/v1\",\n    api_key=\"your-api-key\"\n)\nagent = Agent(llm=llm, ...)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Connect to any LLM",
          "level": 1
        },
        {
          "title": "Changing the Base API URL",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Connect to any LLM",
            "level": 1
          },
          {
            "title": "Changing the Base API URL",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Connect to any LLM > Changing the Base API URL"
      },
      "enhanced_content": "Context: Changelog > Connect to any LLM > Changing the Base API URL\n\nllm = LLM(\n    model=\"custom-model-name\",\n    base_url=\"https://api.your-provider.com/v1\",\n    api_key=\"your-api-key\"\n)\nagent = Agent(llm=llm, ...)",
      "formatted_path": "Changelog > Connect to any LLM > Changing the Base API URL",
      "enhanced_text": "Context: Changelog > Connect to any LLM > Changing the Base API URL\n\nllm = LLM(\n    model=\"custom-model-name\",\n    base_url=\"https://api.your-provider.com/v1\",\n    api_key=\"your-api-key\"\n)\nagent = Agent(llm=llm, ...)"
    },
    {
      "content": "Source: https://docs.crewai.com/how-to/mlflow-observability Quickly start monitoring your Agents with MLflow.",
      "title": "MLflow Integration",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "MLflow Integration",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "MLflow Integration",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > MLflow Integration"
      },
      "enhanced_content": "Context: Changelog > MLflow Integration\n\n# MLflow Integration\n\nSource: https://docs.crewai.com/how-to/mlflow-observability Quickly start monitoring your Agents with MLflow.",
      "formatted_path": "Changelog > MLflow Integration",
      "enhanced_text": "Context: Changelog > MLflow Integration\n\n MLflow Integration\n\nSource: https://docs.crewai.com/how-to/mlflow-observability Quickly start monitoring your Agents with MLflow."
    },
    {
      "content": "[MLflow](https://mlflow.org/) is an open-source platform to assist machine learning practitioners and teams in handling the complexities of the machine learning process. It provides a tracing feature that enhances LLM observability in your Generative AI applications by capturing detailed information about the execution of your application\u2019s services.\nTracing provides a way to record the inputs, outputs, and metadata associated with each intermediate step of a request, enabling you to easily pinpoint the source of bugs and unexpected behaviors. ![Overview of MLflow crewAI tracing usage](https://mintlify.s3.us-west-1.amazonaws.com/crewai/images/mlflow-tracing.gif)",
      "title": "MLflow Overview",
      "type": "link_list",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "MLflow Overview",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "MLflow Overview",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 2,
        "formatted_path": "Changelog > MLflow Overview"
      },
      "enhanced_content": "Context: Changelog > MLflow Overview\n\n# MLflow Overview\n\n[MLflow](https://mlflow.org/) is an open-source platform to assist machine learning practitioners and teams in handling the complexities of the machine learning process. It provides a tracing feature that enhances LLM observability in your Generative AI applications by capturing detailed information about the execution of your application\u2019s services.\nTracing provides a way to record the inputs, outputs, and metadata associated with each intermediate step of a request, enabling you to easily pinpoint the source of bugs and unexpected behaviors. ![Overview of MLflow crewAI tracing usage](https://mintlify.s3.us-west-1.amazonaws.com/crewai/images/mlflow-tracing.gif)",
      "formatted_path": "Changelog > MLflow Overview",
      "enhanced_text": "Context: Changelog > MLflow Overview\n\n MLflow Overview\n\n[MLflow](https://mlflow.org/) is an open-source platform to assist machine learning practitioners and teams in handling the complexities of the machine learning process. It provides a tracing feature that enhances LLM observability in your Generative AI applications by capturing detailed information about the execution of your application\u2019s services.\nTracing provides a way to record the inputs, outputs, and metadata associated with each intermediate step of a request, enabling you to easily pinpoint the source of bugs and unexpected behaviors. ![Overview of MLflow crewAI tracing usage](https://mintlify.s3.us-west-1.amazonaws.com/crewai/images/mlflow-tracing.gif)\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "Source: https://docs.crewai.com/how-to/multimodal-agents Learn how to enable and use multimodal capabilities in your agents for processing images and other non-text content within the CrewAI framework.\n\nCrewAI supports multimodal agents that can process both text and non-text content like images. This guide will show you how to enable and use multimodal capabilities in your agents.",
      "title": "Using Multimodal Agents",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Using Multimodal Agents",
          "level": 1
        },
        {
          "title": "Using Multimodal Agents",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Using Multimodal Agents",
            "level": 1
          },
          {
            "title": "Using Multimodal Agents",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Using Multimodal Agents > Using Multimodal Agents"
      },
      "enhanced_content": "Context: Changelog > Using Multimodal Agents > Using Multimodal Agents\n\n## Using Multimodal Agents\n\nSource: https://docs.crewai.com/how-to/multimodal-agents Learn how to enable and use multimodal capabilities in your agents for processing images and other non-text content within the CrewAI framework.\n\nCrewAI supports multimodal agents that can process both text and non-text content like images. This guide will show you how to enable and use multimodal capabilities in your agents.",
      "formatted_path": "Changelog > Using Multimodal Agents > Using Multimodal Agents",
      "enhanced_text": "Context: Changelog > Using Multimodal Agents > Using Multimodal Agents\n\n Using Multimodal Agents\n\nSource: https://docs.crewai.com/how-to/multimodal-agents Learn how to enable and use multimodal capabilities in your agents for processing images and other non-text content within the CrewAI framework.\n\nCrewAI supports multimodal agents that can process both text and non-text content like images. This guide will show you how to enable and use multimodal capabilities in your agents.\n\nRelated sections:\n- \n"
    },
    {
      "content": "from crewai import Agent\n\nagent = Agent(\n    role=\"Image Analyst\",\n    goal=\"Analyze and extract insights from images\",\n    backstory=\"An expert in visual content interpretation with years of experience in image analysis\",\n    multimodal=True  # This enables multimodal capabilities\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Using Multimodal Agents",
          "level": 1
        },
        {
          "title": "Using Multimodal Agents",
          "level": 2
        },
        {
          "title": "Enabling Multimodal Capabilities",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Using Multimodal Agents",
            "level": 1
          },
          {
            "title": "Using Multimodal Agents",
            "level": 2
          },
          {
            "title": "Enabling Multimodal Capabilities",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Using Multimodal Agents > Using Multimodal Agents > Enabling Multimodal Capabilities"
      },
      "enhanced_content": "Context: Changelog > Using Multimodal Agents > Using Multimodal Agents > Enabling Multimodal Capabilities\n\nfrom crewai import Agent\n\nagent = Agent(\n    role=\"Image Analyst\",\n    goal=\"Analyze and extract insights from images\",\n    backstory=\"An expert in visual content interpretation with years of experience in image analysis\",\n    multimodal=True  # This enables multimodal capabilities\n)",
      "formatted_path": "Changelog > Using Multimodal Agents > Using Multimodal Agents > Enabling Multimodal Capabilities",
      "enhanced_text": "Context: Changelog > Using Multimodal Agents > Using Multimodal Agents > Enabling Multimodal Capabilities\n\nfrom crewai import Agent\n\nagent = Agent(\n    role=\"Image Analyst\",\n    goal=\"Analyze and extract insights from images\",\n    backstory=\"An expert in visual content interpretation with years of experience in image analysis\",\n    multimodal=True  # This enables multimodal capabilities\n)"
    },
    {
      "content": "from crewai import Agent, Task, Crew\n\n# Create a multimodal agent\nimage_analyst = Agent(\n    role=\"Product Analyst\",\n    goal=\"Analyze product images and provide detailed descriptions\",\n    backstory=\"Expert in visual product analysis with deep knowledge of design and features\",\n    multimodal=True\n)\n\n# Create a task for image analysis\ntask = Task(\n    description=\"Analyze the product image at https://example.com/product.jpg and provide a detailed description\",\n    expected_output=\"A detailed description of the product image\",\n    agent=image_analyst\n)\n\n# Create and run the crew\ncrew = Crew(\n    agents=[image_analyst],\n    tasks=[task]\n)\n\nresult = crew.kickoff()",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Using Multimodal Agents",
          "level": 1
        },
        {
          "title": "Using Multimodal Agents",
          "level": 2
        },
        {
          "title": "Working with Images",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Using Multimodal Agents",
            "level": 1
          },
          {
            "title": "Using Multimodal Agents",
            "level": 2
          },
          {
            "title": "Working with Images",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Using Multimodal Agents > Using Multimodal Agents > Working with Images"
      },
      "enhanced_content": "Context: Changelog > Using Multimodal Agents > Using Multimodal Agents > Working with Images\n\nfrom crewai import Agent, Task, Crew\n\n# Create a multimodal agent\nimage_analyst = Agent(\n    role=\"Product Analyst\",\n    goal=\"Analyze product images and provide detailed descriptions\",\n    backstory=\"Expert in visual product analysis with deep knowledge of design and features\",\n    multimodal=True\n)\n\n# Create a task for image analysis\ntask = Task(\n    description=\"Analyze the product image at https://example.com/product.jpg and provide a detailed description\",\n    expected_output=\"A detailed description of the product image\",\n    agent=image_analyst\n)\n\n# Create and run the crew\ncrew = Crew(\n    agents=[image_analyst],\n    tasks=[task]\n)\n\nresult = crew.kickoff()",
      "formatted_path": "Changelog > Using Multimodal Agents > Using Multimodal Agents > Working with Images",
      "enhanced_text": "Context: Changelog > Using Multimodal Agents > Using Multimodal Agents > Working with Images\n\nfrom crewai import Agent, Task, Crew\n\n# Create a multimodal agent\nimage_analyst = Agent(\n    role=\"Product Analyst\",\n    goal=\"Analyze product images and provide detailed descriptions\",\n    backstory=\"Expert in visual product analysis with deep knowledge of design and features\",\n    multimodal=True\n)\n\n# Create a task for image analysis\ntask = Task(\n    description=\"Analyze the product image at https://example.com/product.jpg and provide a detailed description\",\n    expected_output=\"A detailed description of the product image\",\n    agent=image_analyst\n)\n\n# Create and run the crew\ncrew = Crew(\n    agents=[image_analyst],\n    tasks=[task]\n)\n\nresult = crew.kickoff()"
    },
    {
      "content": "from crewai import Agent, Task, Crew\n\n# Create a multimodal agent for detailed analysis\nexpert_analyst = Agent(\n    role=\"Visual Quality Inspector\",\n    goal=\"Perform detailed quality analysis of product images\",\n    backstory=\"Senior quality control expert with expertise in visual inspection\",\n    multimodal=True  # AddImageTool is automatically included\n)\n\n# Create a task with specific analysis requirements\ninspection_task = Task(\n    description=\"\"\"\n    Analyze the product image at https://example.com/product.jpg with focus on:\n    1. Quality of materials\n    2. Manufacturing defects\n    3. Compliance with standards\n    Provide a detailed report highlighting any issues found.\n    \"\"\",\n    expected_output=\"A detailed report highlighting any issues found\",\n    agent=expert_analyst\n)\n\n# Create and run the crew\ncrew = Crew(\n    agents=[expert_analyst],\n    tasks=[inspection_task]\n)\n\nresult = crew.kickoff()",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Using Multimodal Agents",
          "level": 1
        },
        {
          "title": "Using Multimodal Agents",
          "level": 2
        },
        {
          "title": "Advanced Usage with Context",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Using Multimodal Agents",
            "level": 1
          },
          {
            "title": "Using Multimodal Agents",
            "level": 2
          },
          {
            "title": "Advanced Usage with Context",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Using Multimodal Agents > Using Multimodal Agents > Advanced Usage with Context"
      },
      "enhanced_content": "Context: Changelog > Using Multimodal Agents > Using Multimodal Agents > Advanced Usage with Context\n\nfrom crewai import Agent, Task, Crew\n\n# Create a multimodal agent for detailed analysis\nexpert_analyst = Agent(\n    role=\"Visual Quality Inspector\",\n    goal=\"Perform detailed quality analysis of product images\",\n    backstory=\"Senior quality control expert with expertise in visual inspection\",\n    multimodal=True  # AddImageTool is automatically included\n)\n\n# Create a task with specific analysis requirements\ninspection_task = Task(\n    description=\"\"\"\n    Analyze the product image at https://example.com/product.jpg with focus on:\n    1. Quality of materials\n    2. Manufacturing defects\n    3. Compliance with standards\n    Provide a detailed report highlighting any issues found.\n    \"\"\",\n    expected_output=\"A detailed report highlighting any issues found\",\n    agent=expert_analyst\n)\n\n# Create and run the crew\ncrew = Crew(\n    agents=[expert_analyst],\n    tasks=[inspection_task]\n)\n\nresult = crew.kickoff()",
      "formatted_path": "Changelog > Using Multimodal Agents > Using Multimodal Agents > Advanced Usage with Context",
      "enhanced_text": "Context: Changelog > Using Multimodal Agents > Using Multimodal Agents > Advanced Usage with Context\n\nfrom crewai import Agent, Task, Crew\n\n# Create a multimodal agent for detailed analysis\nexpert_analyst = Agent(\n    role=\"Visual Quality Inspector\",\n    goal=\"Perform detailed quality analysis of product images\",\n    backstory=\"Senior quality control expert with expertise in visual inspection\",\n    multimodal=True  # AddImageTool is automatically included\n)\n\n# Create a task with specific analysis requirements\ninspection_task = Task(\n    description=\"\"\"\n    Analyze the product image at https://example.com/product.jpg with focus on:\n    1. Quality of materials\n    2. Manufacturing defects\n    3. Compliance with standards\n    Provide a detailed report highlighting any issues found.\n    \"\"\",\n    expected_output=\"A detailed report highlighting any issues found\",\n    agent=expert_analyst\n)\n\n# Create and run the crew\ncrew = Crew(\n    agents=[expert_analyst],\n    tasks=[inspection_task]\n)\n\nresult = crew.kickoff()"
    },
    {
      "content": "class AddImageToolSchema:\n    image_url: str  # Required: The URL or path of the image to process\n    action: Optional[str] = None  # Optional: Additional context or specific questions about the image",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Using Multimodal Agents",
          "level": 1
        },
        {
          "title": "Using Multimodal Agents",
          "level": 2
        },
        {
          "title": "Tool Details",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Using Multimodal Agents",
            "level": 1
          },
          {
            "title": "Using Multimodal Agents",
            "level": 2
          },
          {
            "title": "Tool Details",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Using Multimodal Agents > Using Multimodal Agents > Tool Details"
      },
      "enhanced_content": "Context: Changelog > Using Multimodal Agents > Using Multimodal Agents > Tool Details\n\nclass AddImageToolSchema:\n    image_url: str  # Required: The URL or path of the image to process\n    action: Optional[str] = None  # Optional: Additional context or specific questions about the image",
      "formatted_path": "Changelog > Using Multimodal Agents > Using Multimodal Agents > Tool Details",
      "enhanced_text": "Context: Changelog > Using Multimodal Agents > Using Multimodal Agents > Tool Details\n\nclass AddImageToolSchema:\n    image_url: str  # Required: The URL or path of the image to process\n    action: Optional[str] = None  # Optional: Additional context or specific questions about the image"
    },
    {
      "content": "**Keep Handlers Light**: Event handlers should be lightweight and avoid blocking operations **Error Handling**: Include proper error handling in your event handlers to prevent exceptions from affecting the main execution **Cleanup**: If your listener allocates resources, ensure they're properly cleaned up **Selective Listening**: Only listen for events you actually need to handle **Testing**: Test your event listeners in isolation to ensure they behave as expected By leveraging CrewAI's event system, you can extend its functionality and integrate it seamlessly with your existing infrastructure.",
      "title": "Best Practices",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Using Multimodal Agents",
          "level": 1
        },
        {
          "title": "Using Multimodal Agents",
          "level": 2
        },
        {
          "title": "Best Practices",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Using Multimodal Agents",
            "level": 1
          },
          {
            "title": "Using Multimodal Agents",
            "level": 2
          },
          {
            "title": "Best Practices",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Using Multimodal Agents > Using Multimodal Agents > Best Practices"
      },
      "enhanced_content": "Context: Changelog > Using Multimodal Agents > Using Multimodal Agents > Best Practices\n\n### Best Practices\n\n**Keep Handlers Light**: Event handlers should be lightweight and avoid blocking operations **Error Handling**: Include proper error handling in your event handlers to prevent exceptions from affecting the main execution **Cleanup**: If your listener allocates resources, ensure they're properly cleaned up **Selective Listening**: Only listen for events you actually need to handle **Testing**: Test your event listeners in isolation to ensure they behave as expected By leveraging CrewAI's event system, you can extend its functionality and integrate it seamlessly with your existing infrastructure.",
      "formatted_path": "Changelog > Using Multimodal Agents > Using Multimodal Agents > Best Practices",
      "enhanced_text": "Context: Changelog > Using Multimodal Agents > Using Multimodal Agents > Best Practices\n\n Best Practices\n\n**Keep Handlers Light**: Event handlers should be lightweight and avoid blocking operations **Error Handling**: Include proper error handling in your event handlers to prevent exceptions from affecting the main execution **Cleanup**: If your listener allocates resources, ensure they're properly cleaned up **Selective Listening**: Only listen for events you actually need to handle **Testing**: Test your event listeners in isolation to ensure they behave as expected By leveraging CrewAI's event system, you can extend its functionality and integrate it seamlessly with your existing infrastructure.\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "When working with multimodal agents, keep these best practices in mind: **Image Access** Ensure your images are accessible via URLs that the agent can reach For local images, consider hosting them temporarily or using absolute file paths Verify that image URLs are valid and accessible before running tasks **Task Description** Be specific about what aspects of the image you want the agent to analyze Include clear questions or requirements in the task description Consider using the optional `action` parameter for focused analysis **Resource Management** Image processing may require more computational resources than text-only tasks Some language models may require base64 encoding for image data Consider batch processing for multiple images to optimize performance **Environment Setup** Verify that your environment has the necessary dependencies for image processing Ensure your language model supports multimodal capabilities Test with small images first to validate your setup **Error Handling** Implement proper error handling for image loading failures Have fallback strategies for when image processing fails Monitor and log image processing operations for debugging",
      "title": "Best Practices",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Using Multimodal Agents",
          "level": 1
        },
        {
          "title": "Using Multimodal Agents",
          "level": 2
        },
        {
          "title": "Best Practices",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Using Multimodal Agents",
            "level": 1
          },
          {
            "title": "Using Multimodal Agents",
            "level": 2
          },
          {
            "title": "Best Practices",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Using Multimodal Agents > Using Multimodal Agents > Best Practices"
      },
      "enhanced_content": "Context: Changelog > Using Multimodal Agents > Using Multimodal Agents > Best Practices\n\n### Best Practices\n\nWhen working with multimodal agents, keep these best practices in mind: **Image Access** Ensure your images are accessible via URLs that the agent can reach For local images, consider hosting them temporarily or using absolute file paths Verify that image URLs are valid and accessible before running tasks **Task Description** Be specific about what aspects of the image you want the agent to analyze Include clear questions or requirements in the task description Consider using the optional `action` parameter for focused analysis **Resource Management** Image processing may require more computational resources than text-only tasks Some language models may require base64 encoding for image data Consider batch processing for multiple images to optimize performance **Environment Setup** Verify that your environment has the necessary dependencies for image processing Ensure your language model supports multimodal capabilities Test with small images first to validate your setup **Error Handling** Implement proper error handling for image loading failures Have fallback strategies for when image processing fails Monitor and log image processing operations for debugging",
      "formatted_path": "Changelog > Using Multimodal Agents > Using Multimodal Agents > Best Practices",
      "enhanced_text": "Context: Changelog > Using Multimodal Agents > Using Multimodal Agents > Best Practices\n\n Best Practices\n\nWhen working with multimodal agents, keep these best practices in mind: **Image Access** Ensure your images are accessible via URLs that the agent can reach For local images, consider hosting them temporarily or using absolute file paths Verify that image URLs are valid and accessible before running tasks **Task Description** Be specific about what aspects of the image you want the agent to analyze Include clear questions or requirements in the task description Consider using the optional `action` parameter for focused analysis **Resource Management** Image processing may require more computational resources than text-only tasks Some language models may require base64 encoding for image data Consider batch processing for multiple images to optimize performance **Environment Setup** Verify that your environment has the necessary dependencies for image processing Ensure your language model supports multimodal capabilities Test with small images first to validate your setup **Error Handling** Implement proper error handling for image loading failures Have fallback strategies for when image processing fails Monitor and log image processing operations for debugging\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "Source: https://docs.crewai.com/how-to/openlit-observability Quickly start monitoring your Agents in just a single line of code with OpenTelemetry.",
      "title": "OpenLIT Integration",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "OpenLIT Integration",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "OpenLIT Integration",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > OpenLIT Integration"
      },
      "enhanced_content": "Context: Changelog > OpenLIT Integration\n\n# OpenLIT Integration\n\nSource: https://docs.crewai.com/how-to/openlit-observability Quickly start monitoring your Agents in just a single line of code with OpenTelemetry.",
      "formatted_path": "Changelog > OpenLIT Integration",
      "enhanced_text": "Context: Changelog > OpenLIT Integration\n\n OpenLIT Integration\n\nSource: https://docs.crewai.com/how-to/openlit-observability Quickly start monitoring your Agents in just a single line of code with OpenTelemetry."
    },
    {
      "content": "[OpenLIT](https://github.com/openlit/openlit?src=crewai-docs) is an open-source tool that makes it simple to monitor the performance of AI agents, LLMs, VectorDBs, and GPUs with just **one** line of code. It provides OpenTelemetry-native tracing and metrics to track important parameters like cost, latency, interactions and task sequences.\nThis setup enables you to track hyperparameters and monitor for performance issues, helping you find ways to enhance and fine-tune your agents over time.",
      "title": "OpenLIT Overview",
      "type": "link_list",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "OpenLIT Overview",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "OpenLIT Overview",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 1,
        "formatted_path": "Changelog > OpenLIT Overview"
      },
      "enhanced_content": "Context: Changelog > OpenLIT Overview\n\n# OpenLIT Overview\n\n[OpenLIT](https://github.com/openlit/openlit?src=crewai-docs) is an open-source tool that makes it simple to monitor the performance of AI agents, LLMs, VectorDBs, and GPUs with just **one** line of code. It provides OpenTelemetry-native tracing and metrics to track important parameters like cost, latency, interactions and task sequences.\nThis setup enables you to track hyperparameters and monitor for performance issues, helping you find ways to enhance and fine-tune your agents over time.",
      "formatted_path": "Changelog > OpenLIT Overview",
      "enhanced_text": "Context: Changelog > OpenLIT Overview\n\n OpenLIT Overview\n\n[OpenLIT](https://github.com/openlit/openlit?src=crewai-docs) is an open-source tool that makes it simple to monitor the performance of AI agents, LLMs, VectorDBs, and GPUs with just **one** line of code. It provides OpenTelemetry-native tracing and metrics to track important parameters like cost, latency, interactions and task sequences.\nThis setup enables you to track hyperparameters and monitor for performance issues, helping you find ways to enhance and fine-tune your agents over time.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "Source: https://docs.crewai.com/how-to/opik-observability Learn how to use Comet Opik to debug, evaluate, and monitor your CrewAI applications with comprehensive tracing, automated evaluations, and production-ready dashboards.",
      "title": "Opik Integration",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Opik Integration",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Opik Integration",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Opik Integration"
      },
      "enhanced_content": "Context: Changelog > Opik Integration\n\n# Opik Integration\n\nSource: https://docs.crewai.com/how-to/opik-observability Learn how to use Comet Opik to debug, evaluate, and monitor your CrewAI applications with comprehensive tracing, automated evaluations, and production-ready dashboards.",
      "formatted_path": "Changelog > Opik Integration",
      "enhanced_text": "Context: Changelog > Opik Integration\n\n Opik Integration\n\nSource: https://docs.crewai.com/how-to/opik-observability Learn how to use Comet Opik to debug, evaluate, and monitor your CrewAI applications with comprehensive tracing, automated evaluations, and production-ready dashboards."
    },
    {
      "content": "With [Comet Opik](https://www.comet.com/docs/opik/), debug, evaluate, and monitor your LLM applications, RAG systems, and agentic workflows with comprehensive tracing, automated evaluations, and production-ready dashboards. Opik provides comprehensive support for every stage of your CrewAI application development: **Log Traces and Spans**: Automatically track LLM calls and application logic to debug and analyze development and production systems. Manually or programmatically annotate, view, and compare responses across projects. **Evaluate Your LLM Application's Performance**: Evaluate against a custom test set and run built-in evaluation metrics or define your own metrics in the SDK or UI. **Test Within Your CI/CD Pipeline**: Establish reliable performance baselines with Opik's LLM unit tests, built on PyTest. Run online evaluations for continuous monitoring in production. **Monitor & Analyze Production Data**: Understand your models' performance on unseen data in production and generate datasets for new dev iterations.",
      "title": "Opik Overview",
      "type": "link_list",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Opik Overview",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Opik Overview",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 1,
        "formatted_path": "Changelog > Opik Overview"
      },
      "enhanced_content": "Context: Changelog > Opik Overview\n\n# Opik Overview\n\nWith [Comet Opik](https://www.comet.com/docs/opik/), debug, evaluate, and monitor your LLM applications, RAG systems, and agentic workflows with comprehensive tracing, automated evaluations, and production-ready dashboards. Opik provides comprehensive support for every stage of your CrewAI application development: **Log Traces and Spans**: Automatically track LLM calls and application logic to debug and analyze development and production systems. Manually or programmatically annotate, view, and compare responses across projects. **Evaluate Your LLM Application's Performance**: Evaluate against a custom test set and run built-in evaluation metrics or define your own metrics in the SDK or UI. **Test Within Your CI/CD Pipeline**: Establish reliable performance baselines with Opik's LLM unit tests, built on PyTest. Run online evaluations for continuous monitoring in production. **Monitor & Analyze Production Data**: Understand your models' performance on unseen data in production and generate datasets for new dev iterations.",
      "formatted_path": "Changelog > Opik Overview",
      "enhanced_text": "Context: Changelog > Opik Overview\n\n Opik Overview\n\nWith [Comet Opik](https://www.comet.com/docs/opik/), debug, evaluate, and monitor your LLM applications, RAG systems, and agentic workflows with comprehensive tracing, automated evaluations, and production-ready dashboards. Opik provides comprehensive support for every stage of your CrewAI application development: **Log Traces and Spans**: Automatically track LLM calls and application logic to debug and analyze development and production systems. Manually or programmatically annotate, view, and compare responses across projects. **Evaluate Your LLM Application's Performance**: Evaluate against a custom test set and run built-in evaluation metrics or define your own metrics in the SDK or UI. **Test Within Your CI/CD Pipeline**: Establish reliable performance baselines with Opik's LLM unit tests, built on PyTest. Run online evaluations for continuous monitoring in production. **Monitor & Analyze Production Data**: Understand your models' performance on unseen data in production and generate datasets for new dev iterations.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "Comet provides a hosted version of the Opik platform, or you can run the platform locally. To use the hosted version, simply [create a free Comet account](https://www.comet.com/signup?utm_medium=github\\&utm_source=crewai_docs) and grab you API Key. To run the Opik platform locally, see our [installation guide](https://www.comet.com/docs/opik/self-host/overview/) for more information. For this guide we will use CrewAI\u2019s quickstart example.",
      "title": "Setup",
      "type": "link_list",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Opik Overview",
          "level": 1
        },
        {
          "title": "Setup",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Opik Overview",
            "level": 1
          },
          {
            "title": "Setup",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 2,
        "formatted_path": "Changelog > Opik Overview > Setup"
      },
      "enhanced_content": "Context: Changelog > Opik Overview > Setup\n\n## Setup\n\nComet provides a hosted version of the Opik platform, or you can run the platform locally. To use the hosted version, simply [create a free Comet account](https://www.comet.com/signup?utm_medium=github\\&utm_source=crewai_docs) and grab you API Key. To run the Opik platform locally, see our [installation guide](https://www.comet.com/docs/opik/self-host/overview/) for more information. For this guide we will use CrewAI\u2019s quickstart example.",
      "formatted_path": "Changelog > Opik Overview > Setup",
      "enhanced_text": "Context: Changelog > Opik Overview > Setup\n\n Setup\n\nComet provides a hosted version of the Opik platform, or you can run the platform locally. To use the hosted version, simply [create a free Comet account](https://www.comet.com/signup?utm_medium=github\\&utm_source=crewai_docs) and grab you API Key. To run the Opik platform locally, see our [installation guide](https://www.comet.com/docs/opik/self-host/overview/) for more information. For this guide we will use CrewAI\u2019s quickstart example.\n\nRelated sections:\n- \n- \n- \n- \n"
    },
    {
      "content": "Source: https://docs.crewai.com/how-to/portkey-observability How to use Portkey with CrewAI [Portkey](https://portkey.ai/?utm_source=crewai\\&utm_medium=crewai\\&utm_campaign=crewai) is a 2-line upgrade to make your CrewAI agents reliable, cost-efficient, and fast. Portkey adds 4 core production capabilities to any CrewAI agent: Routing to **200+ LLMs** Making each LLM call more robust Full-stack tracing & cost, performance analytics Real-time guardrails to enforce behavior",
      "title": "Portkey Integration",
      "type": "link_list",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Portkey Integration",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Portkey Integration",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 1,
        "formatted_path": "Changelog > Portkey Integration"
      },
      "enhanced_content": "Context: Changelog > Portkey Integration\n\n# Portkey Integration\n\nSource: https://docs.crewai.com/how-to/portkey-observability How to use Portkey with CrewAI [Portkey](https://portkey.ai/?utm_source=crewai\\&utm_medium=crewai\\&utm_campaign=crewai) is a 2-line upgrade to make your CrewAI agents reliable, cost-efficient, and fast. Portkey adds 4 core production capabilities to any CrewAI agent: Routing to **200+ LLMs** Making each LLM call more robust Full-stack tracing & cost, performance analytics Real-time guardrails to enforce behavior",
      "formatted_path": "Changelog > Portkey Integration",
      "enhanced_text": "Context: Changelog > Portkey Integration\n\n Portkey Integration\n\nSource: https://docs.crewai.com/how-to/portkey-observability How to use Portkey with CrewAI [Portkey](https://portkey.ai/?utm_source=crewai\\&utm_medium=crewai\\&utm_campaign=crewai) is a 2-line upgrade to make your CrewAI agents reliable, cost-efficient, and fast. Portkey adds 4 core production capabilities to any CrewAI agent: Routing to **200+ LLMs** Making each LLM call more robust Full-stack tracing & cost, performance analytics Real-time guardrails to enforce behavior"
    },
    {
      "content": "from crewai.flow.flow import Flow, listen, start\nfrom dotenv import load_dotenv\nfrom litellm import completion\n\n\nclass ExampleFlow(Flow):\n    model = \"gpt-4o-mini\"\n\n    @start()\n    def generate_city(self):\n        print(\"Starting flow\")\n        # Each flow state automatically gets a unique ID\n        print(f\"Flow State ID: {self.state['id']}\")\n\n        response = completion(\n            model=self.model,\n            messages=[\n                {\n                    \"role\": \"user\",\n                    \"content\": \"Return the name of a random city in the world.\",\n                },\n            ],\n        )\n\n        random_city = response[\"choices\"][0][\"message\"][\"content\"]\n        # Store the city in our state\n        self.state[\"city\"] = random_city\n        print(f\"Random City: {random_city}\")\n\n        return random_city\n\n    @listen(generate_city)\n    def generate_fun_fact(self, random_city):\n        response = completion(\n            model=self.model,\n            messages=[\n                {\n                    \"role\": \"user\",\n                    \"content\": f\"Tell me a fun fact about {random_city}\",\n                },\n            ],\n        )\n\n        fun_fact = response[\"choices\"][0][\"message\"][\"content\"]\n        # Store the fun fact in our state\n        self.state[\"fun_fact\"] = fun_fact\n        return fun_fact\n\n\n\nflow = ExampleFlow()\nresult = flow.kickoff()\n\nprint(f\"Generated fun fact: {result}\")",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Portkey Integration",
          "level": 1
        },
        {
          "title": "Getting Started",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Portkey Integration",
            "level": 1
          },
          {
            "title": "Getting Started",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Portkey Integration > Getting Started"
      },
      "enhanced_content": "Context: Changelog > Portkey Integration > Getting Started\n\nfrom crewai.flow.flow import Flow, listen, start\nfrom dotenv import load_dotenv\nfrom litellm import completion\n\n\nclass ExampleFlow(Flow):\n    model = \"gpt-4o-mini\"\n\n    @start()\n    def generate_city(self):\n        print(\"Starting flow\")\n        # Each flow state automatically gets a unique ID\n        print(f\"Flow State ID: {self.state['id']}\")\n\n        response = completion(\n            model=self.model,\n            messages=[\n                {\n                    \"role\": \"user\",\n                    \"content\": \"Return the name of a random city in the world.\",\n                },\n            ],\n        )\n\n        random_city = response[\"choices\"][0][\"message\"][\"content\"]\n        # Store the city in our state\n        self.state[\"city\"] = random_city\n        print(f\"Random City: {random_city}\")\n\n        return random_city\n\n    @listen(generate_city)\n    def generate_fun_fact(self, random_city):\n        response = completion(\n            model=self.model,\n            messages=[\n                {\n                    \"role\": \"user\",\n                    \"content\": f\"Tell me a fun fact about {random_city}\",\n                },\n            ],\n        )\n\n        fun_fact = response[\"choices\"][0][\"message\"][\"content\"]\n        # Store the fun fact in our state\n        self.state[\"fun_fact\"] = fun_fact\n        return fun_fact\n\n\n\nflow = ExampleFlow()\nresult = flow.kickoff()\n\nprint(f\"Generated fun fact: {result}\")",
      "formatted_path": "Changelog > Portkey Integration > Getting Started",
      "enhanced_text": "Context: Changelog > Portkey Integration > Getting Started\n\nfrom crewai.flow.flow import Flow, listen, start\nfrom dotenv import load_dotenv\nfrom litellm import completion\n\n\nclass ExampleFlow(Flow):\n    model = \"gpt-4o-mini\"\n\n    @start()\n    def generate_city(self):\n        print(\"Starting flow\")\n        # Each flow state automatically gets a unique ID\n        print(f\"Flow State ID: {self.state['id']}\")\n\n        response = completion(\n            model=self.model,\n            messages=[\n                {\n                    \"role\": \"user\",\n                    \"content\": \"Return the name of a random city in the world.\",\n                },\n            ],\n        )\n\n        random_city = response[\"choices\"][0][\"message\"][\"content\"]\n        # Store the city in our state\n        self.state[\"city\"] = random_city\n        print(f\"Random City: {random_city}\")\n\n        return random_city\n\n    @listen(generate_city)\n    def generate_fun_fact(self, random_city):\n        response = completion(\n            model=self.model,\n            messages=[\n                {\n                    \"role\": \"user\",\n                    \"content\": f\"Tell me a fun fact about {random_city}\",\n                },\n            ],\n        )\n\n        fun_fact = response[\"choices\"][0][\"message\"][\"content\"]\n        # Store the fun fact in our state\n        self.state[\"fun_fact\"] = fun_fact\n        return fun_fact\n\n\n\nflow = ExampleFlow()\nresult = flow.kickoff()\n\nprint(f\"Generated fun fact: {result}\")"
    },
    {
      "content": "All features mentioned below are through Portkey's Config system. Portkey's Config system allows you to define routing strategies using simple JSON objects in your LLM API calls. You can create and manage Configs directly in your code or through the Portkey Dashboard. Each Config has a unique ID for easy reference.",
      "title": "Production Features with Portkey Configs",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Portkey Integration",
          "level": 1
        },
        {
          "title": "Production Features with Portkey Configs",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Portkey Integration",
            "level": 1
          },
          {
            "title": "Production Features with Portkey Configs",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Portkey Integration > Production Features with Portkey Configs"
      },
      "enhanced_content": "Context: Changelog > Portkey Integration > Production Features with Portkey Configs\n\n## Production Features with Portkey Configs\n\nAll features mentioned below are through Portkey's Config system. Portkey's Config system allows you to define routing strategies using simple JSON objects in your LLM API calls. You can create and manage Configs directly in your code or through the Portkey Dashboard. Each Config has a unique ID for easy reference.",
      "formatted_path": "Changelog > Portkey Integration > Production Features with Portkey Configs",
      "enhanced_text": "Context: Changelog > Portkey Integration > Production Features with Portkey Configs\n\n Production Features with Portkey Configs\n\nAll features mentioned below are through Portkey's Config system. Portkey's Config system allows you to define routing strategies using simple JSON objects in your LLM API calls. You can create and manage Configs directly in your code or through the Portkey Dashboard. Each Config has a unique ID for easy reference.\n\nRelated sections:\n- \n- \n- \n- \n"
    },
    {
      "content": "# Anthropic Configuration\nanthropic_llm = LLM(\n    model=\"claude-3-5-sonnet-latest\",\n    base_url=PORTKEY_GATEWAY_URL,\n    api_key=\"dummy\",\n    extra_headers=createHeaders(\n        api_key=\"YOUR_PORTKEY_API_KEY\",\n        virtual_key=\"YOUR_ANTHROPIC_VIRTUAL_KEY\", #You don't need provider when using Virtual keys\n        trace_id=\"anthropic_agent\"\n    )\n)\n\n# Azure OpenAI Configuration\nazure_llm = LLM(\n    model=\"gpt-4\",\n    base_url=PORTKEY_GATEWAY_URL,\n    api_key=\"dummy\",\n    extra_headers=createHeaders(\n        api_key=\"YOUR_PORTKEY_API_KEY\",\n        virtual_key=\"YOUR_AZURE_VIRTUAL_KEY\", #You don't need provider when using Virtual keys\n        trace_id=\"azure_agent\"\n    )\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Portkey Integration",
          "level": 1
        },
        {
          "title": "Production Features with Portkey Configs",
          "level": 2
        },
        {
          "title": "1. Use 250+ LLMs",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Portkey Integration",
            "level": 1
          },
          {
            "title": "Production Features with Portkey Configs",
            "level": 2
          },
          {
            "title": "1. Use 250+ LLMs",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Portkey Integration > Production Features with Portkey Configs > 1. Use 250+ LLMs"
      },
      "enhanced_content": "Context: Changelog > Portkey Integration > Production Features with Portkey Configs > 1. Use 250+ LLMs\n\n# Anthropic Configuration\nanthropic_llm = LLM(\n    model=\"claude-3-5-sonnet-latest\",\n    base_url=PORTKEY_GATEWAY_URL,\n    api_key=\"dummy\",\n    extra_headers=createHeaders(\n        api_key=\"YOUR_PORTKEY_API_KEY\",\n        virtual_key=\"YOUR_ANTHROPIC_VIRTUAL_KEY\", #You don't need provider when using Virtual keys\n        trace_id=\"anthropic_agent\"\n    )\n)\n\n# Azure OpenAI Configuration\nazure_llm = LLM(\n    model=\"gpt-4\",\n    base_url=PORTKEY_GATEWAY_URL,\n    api_key=\"dummy\",\n    extra_headers=createHeaders(\n        api_key=\"YOUR_PORTKEY_API_KEY\",\n        virtual_key=\"YOUR_AZURE_VIRTUAL_KEY\", #You don't need provider when using Virtual keys\n        trace_id=\"azure_agent\"\n    )\n)",
      "formatted_path": "Changelog > Portkey Integration > Production Features with Portkey Configs > 1. Use 250+ LLMs",
      "enhanced_text": "Context: Changelog > Portkey Integration > Production Features with Portkey Configs > 1. Use 250+ LLMs\n\n# Anthropic Configuration\nanthropic_llm = LLM(\n    model=\"claude-3-5-sonnet-latest\",\n    base_url=PORTKEY_GATEWAY_URL,\n    api_key=\"dummy\",\n    extra_headers=createHeaders(\n        api_key=\"YOUR_PORTKEY_API_KEY\",\n        virtual_key=\"YOUR_ANTHROPIC_VIRTUAL_KEY\", #You don't need provider when using Virtual keys\n        trace_id=\"anthropic_agent\"\n    )\n)\n\n# Azure OpenAI Configuration\nazure_llm = LLM(\n    model=\"gpt-4\",\n    base_url=PORTKEY_GATEWAY_URL,\n    api_key=\"dummy\",\n    extra_headers=createHeaders(\n        api_key=\"YOUR_PORTKEY_API_KEY\",\n        virtual_key=\"YOUR_AZURE_VIRTUAL_KEY\", #You don't need provider when using Virtual keys\n        trace_id=\"azure_agent\"\n    )\n)"
    },
    {
      "content": "config = {\n    \"cache\": {\n        \"mode\": \"semantic\",  # or \"simple\" for exact matching\n    }\n}",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Portkey Integration",
          "level": 1
        },
        {
          "title": "Production Features with Portkey Configs",
          "level": 2
        },
        {
          "title": "2. Caching",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Portkey Integration",
            "level": 1
          },
          {
            "title": "Production Features with Portkey Configs",
            "level": 2
          },
          {
            "title": "2. Caching",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Portkey Integration > Production Features with Portkey Configs > 2. Caching"
      },
      "enhanced_content": "Context: Changelog > Portkey Integration > Production Features with Portkey Configs > 2. Caching\n\nconfig = {\n    \"cache\": {\n        \"mode\": \"semantic\",  # or \"simple\" for exact matching\n    }\n}",
      "formatted_path": "Changelog > Portkey Integration > Production Features with Portkey Configs > 2. Caching",
      "enhanced_text": "Context: Changelog > Portkey Integration > Production Features with Portkey Configs > 2. Caching\n\nconfig = {\n    \"cache\": {\n        \"mode\": \"semantic\",  # or \"simple\" for exact matching\n    }\n}"
    },
    {
      "content": "Portkey provides comprehensive reliability features: **Automatic Retries**: Handle temporary failures gracefully **Request Timeouts**: Prevent hanging operations **Conditional Routing**: Route requests based on specific conditions **Fallbacks**: Set up automatic provider failovers **Load Balancing**: Distribute requests efficiently [Learn more about Reliability Features](https://portkey.ai/docs/product/ai-gateway/)",
      "title": "3. Production Reliability",
      "type": "link_list",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Portkey Integration",
          "level": 1
        },
        {
          "title": "Production Features with Portkey Configs",
          "level": 2
        },
        {
          "title": "3. Production Reliability",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Portkey Integration",
            "level": 1
          },
          {
            "title": "Production Features with Portkey Configs",
            "level": 2
          },
          {
            "title": "3. Production Reliability",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 1,
        "formatted_path": "Changelog > Portkey Integration > Production Features with Portkey Configs > 3. Production Reliability"
      },
      "enhanced_content": "Context: Changelog > Portkey Integration > Production Features with Portkey Configs > 3. Production Reliability\n\n### 3. Production Reliability\n\nPortkey provides comprehensive reliability features: **Automatic Retries**: Handle temporary failures gracefully **Request Timeouts**: Prevent hanging operations **Conditional Routing**: Route requests based on specific conditions **Fallbacks**: Set up automatic provider failovers **Load Balancing**: Distribute requests efficiently [Learn more about Reliability Features](https://portkey.ai/docs/product/ai-gateway/)",
      "formatted_path": "Changelog > Portkey Integration > Production Features with Portkey Configs > 3. Production Reliability",
      "enhanced_text": "Context: Changelog > Portkey Integration > Production Features with Portkey Configs > 3. Production Reliability\n\n 3. Production Reliability\n\nPortkey provides comprehensive reliability features: **Automatic Retries**: Handle temporary failures gracefully **Request Timeouts**: Prevent hanging operations **Conditional Routing**: Route requests based on specific conditions **Fallbacks**: Set up automatic provider failovers **Load Balancing**: Distribute requests efficiently [Learn more about Reliability Features](https://portkey.ai/docs/product/ai-gateway/)"
    },
    {
      "content": "Agent runs are complex. Portkey automatically logs **40+ comprehensive metrics** for your AI agents, including cost, tokens used, latency, etc. Whether you need a broad overview or granular insights into your agent runs, Portkey's customizable filters provide the metrics you need. Cost per agent interaction Response times and latency Token usage and efficiency Success/failure rates Cache hit rates",
      "title": "4. Metrics",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Portkey Integration",
          "level": 1
        },
        {
          "title": "Production Features with Portkey Configs",
          "level": 2
        },
        {
          "title": "4. Metrics",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Portkey Integration",
            "level": 1
          },
          {
            "title": "Production Features with Portkey Configs",
            "level": 2
          },
          {
            "title": "4. Metrics",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Portkey Integration > Production Features with Portkey Configs > 4. Metrics"
      },
      "enhanced_content": "Context: Changelog > Portkey Integration > Production Features with Portkey Configs > 4. Metrics\n\n### 4. Metrics\n\nAgent runs are complex. Portkey automatically logs **40+ comprehensive metrics** for your AI agents, including cost, tokens used, latency, etc. Whether you need a broad overview or granular insights into your agent runs, Portkey's customizable filters provide the metrics you need. Cost per agent interaction Response times and latency Token usage and efficiency Success/failure rates Cache hit rates",
      "formatted_path": "Changelog > Portkey Integration > Production Features with Portkey Configs > 4. Metrics",
      "enhanced_text": "Context: Changelog > Portkey Integration > Production Features with Portkey Configs > 4. Metrics\n\n 4. Metrics\n\nAgent runs are complex. Portkey automatically logs **40+ comprehensive metrics** for your AI agents, including cost, tokens used, latency, etc. Whether you need a broad overview or granular insights into your agent runs, Portkey's customizable filters provide the metrics you need. Cost per agent interaction Response times and latency Token usage and efficiency Success/failure rates Cache hit rates"
    },
    {
      "content": "Logs are essential for understanding agent behavior, diagnosing issues, and improving performance. They provide a detailed record of agent activities and tool use, which is crucial for debugging and optimizing processes. Access a dedicated section to view records of agent executions, including parameters, outcomes, function calls, and errors. Filter logs based on multiple parameters such as trace ID, model, tokens used, and metadata.",
      "title": "5. Detailed Logging",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Portkey Integration",
          "level": 1
        },
        {
          "title": "Production Features with Portkey Configs",
          "level": 2
        },
        {
          "title": "5. Detailed Logging",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Portkey Integration",
            "level": 1
          },
          {
            "title": "Production Features with Portkey Configs",
            "level": 2
          },
          {
            "title": "5. Detailed Logging",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Portkey Integration > Production Features with Portkey Configs > 5. Detailed Logging"
      },
      "enhanced_content": "Context: Changelog > Portkey Integration > Production Features with Portkey Configs > 5. Detailed Logging\n\n### 5. Detailed Logging\n\nLogs are essential for understanding agent behavior, diagnosing issues, and improving performance. They provide a detailed record of agent activities and tool use, which is crucial for debugging and optimizing processes. Access a dedicated section to view records of agent executions, including parameters, outcomes, function calls, and errors. Filter logs based on multiple parameters such as trace ID, model, tokens used, and metadata.",
      "formatted_path": "Changelog > Portkey Integration > Production Features with Portkey Configs > 5. Detailed Logging",
      "enhanced_text": "Context: Changelog > Portkey Integration > Production Features with Portkey Configs > 5. Detailed Logging\n\n 5. Detailed Logging\n\nLogs are essential for understanding agent behavior, diagnosing issues, and improving performance. They provide a detailed record of agent activities and tool use, which is crucial for debugging and optimizing processes. Access a dedicated section to view records of agent executions, including parameters, outcomes, function calls, and errors. Filter logs based on multiple parameters such as trace ID, model, tokens used, and metadata."
    },
    {
      "content": "Set budget limit and rate limts per Virtual Key (disposable API keys) Implement role-based access control Track system changes with audit logs Configure data retention policies For detailed information on creating and managing Configs, visit the [Portkey documentation](https://docs.portkey.ai/product/ai-gateway/configs).",
      "title": "6. Enterprise Security Features",
      "type": "link_list",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Portkey Integration",
          "level": 1
        },
        {
          "title": "Production Features with Portkey Configs",
          "level": 2
        },
        {
          "title": "6. Enterprise Security Features",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Portkey Integration",
            "level": 1
          },
          {
            "title": "Production Features with Portkey Configs",
            "level": 2
          },
          {
            "title": "6. Enterprise Security Features",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 1,
        "formatted_path": "Changelog > Portkey Integration > Production Features with Portkey Configs > 6. Enterprise Security Features"
      },
      "enhanced_content": "Context: Changelog > Portkey Integration > Production Features with Portkey Configs > 6. Enterprise Security Features\n\n### 6. Enterprise Security Features\n\nSet budget limit and rate limts per Virtual Key (disposable API keys) Implement role-based access control Track system changes with audit logs Configure data retention policies For detailed information on creating and managing Configs, visit the [Portkey documentation](https://docs.portkey.ai/product/ai-gateway/configs).",
      "formatted_path": "Changelog > Portkey Integration > Production Features with Portkey Configs > 6. Enterprise Security Features",
      "enhanced_text": "Context: Changelog > Portkey Integration > Production Features with Portkey Configs > 6. Enterprise Security Features\n\n 6. Enterprise Security Features\n\nSet budget limit and rate limts per Virtual Key (disposable API keys) Implement role-based access control Track system changes with audit logs Configure data retention policies For detailed information on creating and managing Configs, visit the [Portkey documentation](https://docs.portkey.ai/product/ai-gateway/configs).\n\nRelated sections:\n- \n- \n- \n- \n"
    },
    {
      "content": "Source: https://docs.crewai.com/how-to/replay-tasks-from-latest-crew-kickoff Replay tasks from the latest crew.kickoff(...)",
      "title": "Replay Tasks from Latest Crew Kickoff",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Replay Tasks from Latest Crew Kickoff",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Replay Tasks from Latest Crew Kickoff",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Replay Tasks from Latest Crew Kickoff"
      },
      "enhanced_content": "Context: Changelog > Replay Tasks from Latest Crew Kickoff\n\n# Replay Tasks from Latest Crew Kickoff\n\nSource: https://docs.crewai.com/how-to/replay-tasks-from-latest-crew-kickoff Replay tasks from the latest crew.kickoff(...)",
      "formatted_path": "Changelog > Replay Tasks from Latest Crew Kickoff",
      "enhanced_text": "Context: Changelog > Replay Tasks from Latest Crew Kickoff\n\n Replay Tasks from Latest Crew Kickoff\n\nSource: https://docs.crewai.com/how-to/replay-tasks-from-latest-crew-kickoff Replay tasks from the latest crew.kickoff(...)\n\nRelated sections:\n- \n"
    },
    {
      "content": "To use the replay feature, follow these steps:",
      "title": "Replaying from Specific Task Using the CLI",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Replay Tasks from Latest Crew Kickoff",
          "level": 1
        },
        {
          "title": "Introduction",
          "level": 2
        },
        {
          "title": "Replaying from Specific Task Using the CLI",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Replay Tasks from Latest Crew Kickoff",
            "level": 1
          },
          {
            "title": "Introduction",
            "level": 2
          },
          {
            "title": "Replaying from Specific Task Using the CLI",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Replay Tasks from Latest Crew Kickoff > Introduction > Replaying from Specific Task Using the CLI"
      },
      "enhanced_content": "Context: Changelog > Replay Tasks from Latest Crew Kickoff > Introduction > Replaying from Specific Task Using the CLI\n\n### Replaying from Specific Task Using the CLI\n\nTo use the replay feature, follow these steps:",
      "formatted_path": "Changelog > Replay Tasks from Latest Crew Kickoff > Introduction > Replaying from Specific Task Using the CLI",
      "enhanced_text": "Context: Changelog > Replay Tasks from Latest Crew Kickoff > Introduction > Replaying from Specific Task Using the CLI\n\n Replaying from Specific Task Using the CLI\n\nTo use the replay feature, follow these steps:\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "To replay from a task programmatically, use the following steps:",
      "title": "Replaying from a Task Programmatically",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Replay Tasks from Latest Crew Kickoff",
          "level": 1
        },
        {
          "title": "Introduction",
          "level": 2
        },
        {
          "title": "Replaying from a Task Programmatically",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Replay Tasks from Latest Crew Kickoff",
            "level": 1
          },
          {
            "title": "Introduction",
            "level": 2
          },
          {
            "title": "Replaying from a Task Programmatically",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Replay Tasks from Latest Crew Kickoff > Introduction > Replaying from a Task Programmatically"
      },
      "enhanced_content": "Context: Changelog > Replay Tasks from Latest Crew Kickoff > Introduction > Replaying from a Task Programmatically\n\n### Replaying from a Task Programmatically\n\nTo replay from a task programmatically, use the following steps:",
      "formatted_path": "Changelog > Replay Tasks from Latest Crew Kickoff > Introduction > Replaying from a Task Programmatically",
      "enhanced_text": "Context: Changelog > Replay Tasks from Latest Crew Kickoff > Introduction > Replaying from a Task Programmatically\n\n Replaying from a Task Programmatically\n\nTo replay from a task programmatically, use the following steps:"
    },
    {
      "content": "Source: https://docs.crewai.com/how-to/sequential-process A comprehensive guide to utilizing the sequential processes for task execution in CrewAI projects.",
      "title": "Sequential Processes",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Sequential Processes",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Sequential Processes",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Sequential Processes"
      },
      "enhanced_content": "Context: Changelog > Sequential Processes\n\n# Sequential Processes\n\nSource: https://docs.crewai.com/how-to/sequential-process A comprehensive guide to utilizing the sequential processes for task execution in CrewAI projects.",
      "formatted_path": "Changelog > Sequential Processes",
      "enhanced_text": "Context: Changelog > Sequential Processes\n\n Sequential Processes\n\nSource: https://docs.crewai.com/how-to/sequential-process A comprehensive guide to utilizing the sequential processes for task execution in CrewAI projects.\n\nRelated sections:\n- \n- \n- \n"
    },
    {
      "content": "The sequential process ensures tasks are executed one after the other, following a linear progression.\nThis approach is ideal for projects requiring tasks to be completed in a specific order.",
      "title": "Sequential Process Overview",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Sequential Processes",
          "level": 1
        },
        {
          "title": "Sequential Process Overview",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Sequential Processes",
            "level": 1
          },
          {
            "title": "Sequential Process Overview",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Sequential Processes > Sequential Process Overview"
      },
      "enhanced_content": "Context: Changelog > Sequential Processes > Sequential Process Overview\n\n## Sequential Process Overview\n\nThe sequential process ensures tasks are executed one after the other, following a linear progression.\nThis approach is ideal for projects requiring tasks to be completed in a specific order.",
      "formatted_path": "Changelog > Sequential Processes > Sequential Process Overview",
      "enhanced_text": "Context: Changelog > Sequential Processes > Sequential Process Overview\n\n Sequential Process Overview\n\nThe sequential process ensures tasks are executed one after the other, following a linear progression.\nThis approach is ideal for projects requiring tasks to be completed in a specific order.\n\nRelated sections:\n- \n- \n- \n"
    },
    {
      "content": "from crewai import Crew, Process, Agent, Task, TaskOutput, CrewOutput\n\n# Define your agents\nresearcher = Agent(\n  role='Researcher',\n  goal='Conduct foundational research',\n  backstory='An experienced researcher with a passion for uncovering insights'\n)\nanalyst = Agent(\n  role='Data Analyst',\n  goal='Analyze research findings',\n  backstory='A meticulous analyst with a knack for uncovering patterns'\n)\nwriter = Agent(\n  role='Writer',\n  goal='Draft the final report',\n  backstory='A skilled writer with a talent for crafting compelling narratives'\n)\n\n# Define your tasks\nresearch_task = Task(\n  description='Gather relevant data...', \n  agent=researcher, \n  expected_output='Raw Data'\n)\nanalysis_task = Task(\n  description='Analyze the data...', \n  agent=analyst, \n  expected_output='Data Insights'\n)\nwriting_task = Task(\n  description='Compose the report...', \n  agent=writer, \n  expected_output='Final Report'\n)\n\n# Form the crew with a sequential process\nreport_crew = Crew(\n  agents=[researcher, analyst, writer],\n  tasks=[research_task, analysis_task, writing_task],\n  process=Process.sequential\n)\n\n# Execute the crew\nresult = report_crew.kickoff()\n\n# Accessing the type-safe output\ntask_output: TaskOutput = result.tasks[0].output\ncrew_output: CrewOutput = result.output",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Sequential Processes",
          "level": 1
        },
        {
          "title": "Implementing the Sequential Process",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Sequential Processes",
            "level": 1
          },
          {
            "title": "Implementing the Sequential Process",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Sequential Processes > Implementing the Sequential Process"
      },
      "enhanced_content": "Context: Changelog > Sequential Processes > Implementing the Sequential Process\n\nfrom crewai import Crew, Process, Agent, Task, TaskOutput, CrewOutput\n\n# Define your agents\nresearcher = Agent(\n  role='Researcher',\n  goal='Conduct foundational research',\n  backstory='An experienced researcher with a passion for uncovering insights'\n)\nanalyst = Agent(\n  role='Data Analyst',\n  goal='Analyze research findings',\n  backstory='A meticulous analyst with a knack for uncovering patterns'\n)\nwriter = Agent(\n  role='Writer',\n  goal='Draft the final report',\n  backstory='A skilled writer with a talent for crafting compelling narratives'\n)\n\n# Define your tasks\nresearch_task = Task(\n  description='Gather relevant data...', \n  agent=researcher, \n  expected_output='Raw Data'\n)\nanalysis_task = Task(\n  description='Analyze the data...', \n  agent=analyst, \n  expected_output='Data Insights'\n)\nwriting_task = Task(\n  description='Compose the report...', \n  agent=writer, \n  expected_output='Final Report'\n)\n\n# Form the crew with a sequential process\nreport_crew = Crew(\n  agents=[researcher, analyst, writer],\n  tasks=[research_task, analysis_task, writing_task],\n  process=Process.sequential\n)\n\n# Execute the crew\nresult = report_crew.kickoff()\n\n# Accessing the type-safe output\ntask_output: TaskOutput = result.tasks[0].output\ncrew_output: CrewOutput = result.output",
      "formatted_path": "Changelog > Sequential Processes > Implementing the Sequential Process",
      "enhanced_text": "Context: Changelog > Sequential Processes > Implementing the Sequential Process\n\nfrom crewai import Crew, Process, Agent, Task, TaskOutput, CrewOutput\n\n# Define your agents\nresearcher = Agent(\n  role='Researcher',\n  goal='Conduct foundational research',\n  backstory='An experienced researcher with a passion for uncovering insights'\n)\nanalyst = Agent(\n  role='Data Analyst',\n  goal='Analyze research findings',\n  backstory='A meticulous analyst with a knack for uncovering patterns'\n)\nwriter = Agent(\n  role='Writer',\n  goal='Draft the final report',\n  backstory='A skilled writer with a talent for crafting compelling narratives'\n)\n\n# Define your tasks\nresearch_task = Task(\n  description='Gather relevant data...', \n  agent=researcher, \n  expected_output='Raw Data'\n)\nanalysis_task = Task(\n  description='Analyze the data...', \n  agent=analyst, \n  expected_output='Data Insights'\n)\nwriting_task = Task(\n  description='Compose the report...', \n  agent=writer, \n  expected_output='Final Report'\n)\n\n# Form the crew with a sequential process\nreport_crew = Crew(\n  agents=[researcher, analyst, writer],\n  tasks=[research_task, analysis_task, writing_task],\n  process=Process.sequential\n)\n\n# Execute the crew\nresult = report_crew.kickoff()\n\n# Accessing the type-safe output\ntask_output: TaskOutput = result.tasks[0].output\ncrew_output: CrewOutput = result.output"
    },
    {
      "content": "Each task in a sequential process **must** have an agent assigned. Ensure that every `Task` includes an `agent` parameter.",
      "title": "Note:",
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Sequential Processes",
          "level": 1
        },
        {
          "title": "Implementing the Sequential Process",
          "level": 2
        },
        {
          "title": "Note:",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Sequential Processes",
            "level": 1
          },
          {
            "title": "Implementing the Sequential Process",
            "level": 2
          },
          {
            "title": "Note:",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Sequential Processes > Implementing the Sequential Process > Note:"
      },
      "enhanced_content": "Context: Changelog > Sequential Processes > Implementing the Sequential Process > Note:\n\n### Note:\n\nEach task in a sequential process **must** have an agent assigned. Ensure that every `Task` includes an `agent` parameter.",
      "formatted_path": "Changelog > Sequential Processes > Implementing the Sequential Process > Note:",
      "enhanced_text": "Context: Changelog > Sequential Processes > Implementing the Sequential Process > Note:\n\n Note:\n\nEach task in a sequential process **must** have an agent assigned. Ensure that every `Task` includes an `agent` parameter."
    },
    {
      "content": "**Task Assignment**: The manager assigns tasks strategically, considering each agent's capabilities and available tools. **Execution and Review**: Agents complete their tasks with the option for asynchronous execution and callback functions for streamlined workflows. **Sequential Task Progression**: Despite being a hierarchical process, tasks follow a logical order for smooth progression, facilitated by the manager's oversight.\n\n**Initial Task**: In a sequential process, the first agent completes their task and signals completion. **Subsequent Tasks**: Agents pick up their tasks based on the process type, with outcomes of preceding tasks or directives guiding their execution. **Completion**: The process concludes once the final task is executed, leading to project completion.",
      "title": "Workflow in Action",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Sequential Processes",
          "level": 1
        },
        {
          "title": "Implementing the Sequential Process",
          "level": 2
        },
        {
          "title": "Workflow in Action",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Sequential Processes",
            "level": 1
          },
          {
            "title": "Implementing the Sequential Process",
            "level": 2
          },
          {
            "title": "Workflow in Action",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Sequential Processes > Implementing the Sequential Process > Workflow in Action"
      },
      "enhanced_content": "Context: Changelog > Sequential Processes > Implementing the Sequential Process > Workflow in Action\n\n### Workflow in Action\n\n**Task Assignment**: The manager assigns tasks strategically, considering each agent's capabilities and available tools. **Execution and Review**: Agents complete their tasks with the option for asynchronous execution and callback functions for streamlined workflows. **Sequential Task Progression**: Despite being a hierarchical process, tasks follow a logical order for smooth progression, facilitated by the manager's oversight.\n\n**Initial Task**: In a sequential process, the first agent completes their task and signals completion. **Subsequent Tasks**: Agents pick up their tasks based on the process type, with outcomes of preceding tasks or directives guiding their execution. **Completion**: The process concludes once the final task is executed, leading to project completion.",
      "formatted_path": "Changelog > Sequential Processes > Implementing the Sequential Process > Workflow in Action",
      "enhanced_text": "Context: Changelog > Sequential Processes > Implementing the Sequential Process > Workflow in Action\n\n Workflow in Action\n\n**Task Assignment**: The manager assigns tasks strategically, considering each agent's capabilities and available tools. **Execution and Review**: Agents complete their tasks with the option for asynchronous execution and callback functions for streamlined workflows. **Sequential Task Progression**: Despite being a hierarchical process, tasks follow a logical order for smooth progression, facilitated by the manager's oversight.\n\n**Initial Task**: In a sequential process, the first agent completes their task and signals completion. **Subsequent Tasks**: Agents pick up their tasks based on the process type, with outcomes of preceding tasks or directives guiding their execution. **Completion**: The process concludes once the final task is executed, leading to project completion."
    },
    {
      "content": "In sequential processes, if an agent has `allow_delegation` set to `True`, they can delegate tasks to other agents in the crew.\nThis feature is automatically set up when there are multiple agents in the crew.",
      "title": "Task Delegation",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Sequential Processes",
          "level": 1
        },
        {
          "title": "Advanced Features",
          "level": 2
        },
        {
          "title": "Task Delegation",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Sequential Processes",
            "level": 1
          },
          {
            "title": "Advanced Features",
            "level": 2
          },
          {
            "title": "Task Delegation",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Sequential Processes > Advanced Features > Task Delegation"
      },
      "enhanced_content": "Context: Changelog > Sequential Processes > Advanced Features > Task Delegation\n\n### Task Delegation\n\nIn sequential processes, if an agent has `allow_delegation` set to `True`, they can delegate tasks to other agents in the crew.\nThis feature is automatically set up when there are multiple agents in the crew.",
      "formatted_path": "Changelog > Sequential Processes > Advanced Features > Task Delegation",
      "enhanced_text": "Context: Changelog > Sequential Processes > Advanced Features > Task Delegation\n\n Task Delegation\n\nIn sequential processes, if an agent has `allow_delegation` set to `True`, they can delegate tasks to other agents in the crew.\nThis feature is automatically set up when there are multiple agents in the crew."
    },
    {
      "content": "#...\n\nlist_ideas = Task(\n    description=\"List of 5 interesting ideas to explore for an article about AI.\",\n    expected_output=\"Bullet point list of 5 ideas for an article.\",\n    agent=researcher,\n    async_execution=True # Will be executed asynchronously\n)\n\nlist_important_history = Task(\n    description=\"Research the history of AI and give me the 5 most important events.\",\n    expected_output=\"Bullet point list of 5 important events.\",\n    agent=researcher,\n    async_execution=True # Will be executed asynchronously\n)\n\nwrite_article = Task(\n    description=\"Write an article about AI, its history, and interesting ideas.\",\n    expected_output=\"A 4 paragraph article about AI.\",\n    agent=writer,\n    context=[list_ideas, list_important_history] # Will wait for the output of the two tasks to be completed\n)\n\n#...",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Sequential Processes",
          "level": 1
        },
        {
          "title": "Advanced Features",
          "level": 2
        },
        {
          "title": "Asynchronous Execution",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Sequential Processes",
            "level": 1
          },
          {
            "title": "Advanced Features",
            "level": 2
          },
          {
            "title": "Asynchronous Execution",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Sequential Processes > Advanced Features > Asynchronous Execution"
      },
      "enhanced_content": "Context: Changelog > Sequential Processes > Advanced Features > Asynchronous Execution\n\n#...\n\nlist_ideas = Task(\n    description=\"List of 5 interesting ideas to explore for an article about AI.\",\n    expected_output=\"Bullet point list of 5 ideas for an article.\",\n    agent=researcher,\n    async_execution=True # Will be executed asynchronously\n)\n\nlist_important_history = Task(\n    description=\"Research the history of AI and give me the 5 most important events.\",\n    expected_output=\"Bullet point list of 5 important events.\",\n    agent=researcher,\n    async_execution=True # Will be executed asynchronously\n)\n\nwrite_article = Task(\n    description=\"Write an article about AI, its history, and interesting ideas.\",\n    expected_output=\"A 4 paragraph article about AI.\",\n    agent=writer,\n    context=[list_ideas, list_important_history] # Will wait for the output of the two tasks to be completed\n)\n\n#...",
      "formatted_path": "Changelog > Sequential Processes > Advanced Features > Asynchronous Execution",
      "enhanced_text": "Context: Changelog > Sequential Processes > Advanced Features > Asynchronous Execution\n\n#...\n\nlist_ideas = Task(\n    description=\"List of 5 interesting ideas to explore for an article about AI.\",\n    expected_output=\"Bullet point list of 5 ideas for an article.\",\n    agent=researcher,\n    async_execution=True # Will be executed asynchronously\n)\n\nlist_important_history = Task(\n    description=\"Research the history of AI and give me the 5 most important events.\",\n    expected_output=\"Bullet point list of 5 important events.\",\n    agent=researcher,\n    async_execution=True # Will be executed asynchronously\n)\n\nwrite_article = Task(\n    description=\"Write an article about AI, its history, and interesting ideas.\",\n    expected_output=\"A 4 paragraph article about AI.\",\n    agent=writer,\n    context=[list_ideas, list_important_history] # Will wait for the output of the two tasks to be completed\n)\n\n#..."
    },
    {
      "content": "CrewAI supports both memory and caching features: **Memory**: Enable by setting `memory=True` when creating the Crew. This allows agents to retain information across tasks. **Caching**: By default, caching is enabled. Set `cache=False` to disable it.",
      "title": "Memory and Caching",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Sequential Processes",
          "level": 1
        },
        {
          "title": "Advanced Features",
          "level": 2
        },
        {
          "title": "Memory and Caching",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Sequential Processes",
            "level": 1
          },
          {
            "title": "Advanced Features",
            "level": 2
          },
          {
            "title": "Memory and Caching",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Sequential Processes > Advanced Features > Memory and Caching"
      },
      "enhanced_content": "Context: Changelog > Sequential Processes > Advanced Features > Memory and Caching\n\n### Memory and Caching\n\nCrewAI supports both memory and caching features: **Memory**: Enable by setting `memory=True` when creating the Crew. This allows agents to retain information across tasks. **Caching**: By default, caching is enabled. Set `cache=False` to disable it.",
      "formatted_path": "Changelog > Sequential Processes > Advanced Features > Memory and Caching",
      "enhanced_text": "Context: Changelog > Sequential Processes > Advanced Features > Memory and Caching\n\n Memory and Caching\n\nCrewAI supports both memory and caching features: **Memory**: Enable by setting `memory=True` when creating the Crew. This allows agents to retain information across tasks. **Caching**: By default, caching is enabled. Set `cache=False` to disable it.\n\nRelated sections:\n- \n"
    },
    {
      "content": "You can set callbacks at both the task and step level: `task_callback`: Executed after each task completion. `step_callback`: Executed after each step in an agent's execution.",
      "title": "Callbacks",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Sequential Processes",
          "level": 1
        },
        {
          "title": "Advanced Features",
          "level": 2
        },
        {
          "title": "Callbacks",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Sequential Processes",
            "level": 1
          },
          {
            "title": "Advanced Features",
            "level": 2
          },
          {
            "title": "Callbacks",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Sequential Processes > Advanced Features > Callbacks"
      },
      "enhanced_content": "Context: Changelog > Sequential Processes > Advanced Features > Callbacks\n\n### Callbacks\n\nYou can set callbacks at both the task and step level: `task_callback`: Executed after each task completion. `step_callback`: Executed after each step in an agent's execution.",
      "formatted_path": "Changelog > Sequential Processes > Advanced Features > Callbacks",
      "enhanced_text": "Context: Changelog > Sequential Processes > Advanced Features > Callbacks\n\n Callbacks\n\nYou can set callbacks at both the task and step level: `task_callback`: Executed after each task completion. `step_callback`: Executed after each step in an agent's execution."
    },
    {
      "content": "CrewAI tracks token usage across all tasks and agents. You can access these metrics after execution.",
      "title": "Usage Metrics",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Sequential Processes",
          "level": 1
        },
        {
          "title": "Advanced Features",
          "level": 2
        },
        {
          "title": "Usage Metrics",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Sequential Processes",
            "level": 1
          },
          {
            "title": "Advanced Features",
            "level": 2
          },
          {
            "title": "Usage Metrics",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Sequential Processes > Advanced Features > Usage Metrics"
      },
      "enhanced_content": "Context: Changelog > Sequential Processes > Advanced Features > Usage Metrics\n\n### Usage Metrics\n\nCrewAI tracks token usage across all tasks and agents. You can access these metrics after execution.",
      "formatted_path": "Changelog > Sequential Processes > Advanced Features > Usage Metrics",
      "enhanced_text": "Context: Changelog > Sequential Processes > Advanced Features > Usage Metrics\n\n Usage Metrics\n\nCrewAI tracks token usage across all tasks and agents. You can access these metrics after execution.\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "**Order Matters**: Arrange tasks in a logical sequence where each task builds upon the previous one. **Clear Task Descriptions**: Provide detailed descriptions for each task to guide the agents effectively. **Appropriate Agent Selection**: Match agents' skills and roles to the requirements of each task. **Use Context**: Leverage the context from previous tasks to inform subsequent ones. This updated documentation ensures that details accurately reflect the latest changes in the codebase and clearly describes how to leverage new features and configurations.\nThe content is kept simple and direct to ensure easy understanding.",
      "title": "Best Practices for Sequential Processes",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Sequential Processes",
          "level": 1
        },
        {
          "title": "Best Practices for Sequential Processes",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Sequential Processes",
            "level": 1
          },
          {
            "title": "Best Practices for Sequential Processes",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Sequential Processes > Best Practices for Sequential Processes"
      },
      "enhanced_content": "Context: Changelog > Sequential Processes > Best Practices for Sequential Processes\n\n## Best Practices for Sequential Processes\n\n**Order Matters**: Arrange tasks in a logical sequence where each task builds upon the previous one. **Clear Task Descriptions**: Provide detailed descriptions for each task to guide the agents effectively. **Appropriate Agent Selection**: Match agents' skills and roles to the requirements of each task. **Use Context**: Leverage the context from previous tasks to inform subsequent ones. This updated documentation ensures that details accurately reflect the latest changes in the codebase and clearly describes how to leverage new features and configurations.\nThe content is kept simple and direct to ensure easy understanding.",
      "formatted_path": "Changelog > Sequential Processes > Best Practices for Sequential Processes",
      "enhanced_text": "Context: Changelog > Sequential Processes > Best Practices for Sequential Processes\n\n Best Practices for Sequential Processes\n\n**Order Matters**: Arrange tasks in a logical sequence where each task builds upon the previous one. **Clear Task Descriptions**: Provide detailed descriptions for each task to guide the agents effectively. **Appropriate Agent Selection**: Match agents' skills and roles to the requirements of each task. **Use Context**: Leverage the context from previous tasks to inform subsequent ones. This updated documentation ensures that details accurately reflect the latest changes in the codebase and clearly describes how to leverage new features and configurations.\nThe content is kept simple and direct to ensure easy understanding.\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "Source: https://docs.crewai.com/how-to/weave-integration Learn how to use Weights & Biases (W&B) Weave to track, experiment with, evaluate, and improve your CrewAI applications.",
      "title": "Weave Integration",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Weave Integration",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Weave Integration",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Weave Integration"
      },
      "enhanced_content": "Context: Changelog > Weave Integration\n\n# Weave Integration\n\nSource: https://docs.crewai.com/how-to/weave-integration Learn how to use Weights & Biases (W&B) Weave to track, experiment with, evaluate, and improve your CrewAI applications.",
      "formatted_path": "Changelog > Weave Integration",
      "enhanced_text": "Context: Changelog > Weave Integration\n\n Weave Integration\n\nSource: https://docs.crewai.com/how-to/weave-integration Learn how to use Weights & Biases (W&B) Weave to track, experiment with, evaluate, and improve your CrewAI applications."
    },
    {
      "content": "[Weights & Biases (W\\&B) Weave](https://weave-docs.wandb.ai/) is a framework for tracking, experimenting with, evaluating, deploying, and improving LLM-based applications. ![Overview of W\\&B Weave CrewAI tracing usage](https://mintlify.s3.us-west-1.amazonaws.com/crewai/images/weave-tracing.gif) Weave provides comprehensive support for every stage of your CrewAI application development: **Tracing & Monitoring**: Automatically track LLM calls and application logic to debug and analyze production systems **Systematic Iteration**: Refine and iterate on prompts, datasets, and models **Evaluation**: Use custom or pre-built scorers to systematically assess and enhance agent performance **Guardrails**: Protect your agents with pre- and post-safeguards for content moderation and prompt safety Weave automatically captures traces for your CrewAI applications, enabling you to monitor and analyze your agents' performance, interactions, and execution flow. This helps you build better evaluation datasets and optimize your agent workflows.",
      "title": "Weave Overview",
      "type": "link_list",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Weave Overview",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Weave Overview",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 2,
        "formatted_path": "Changelog > Weave Overview"
      },
      "enhanced_content": "Context: Changelog > Weave Overview\n\n# Weave Overview\n\n[Weights & Biases (W\\&B) Weave](https://weave-docs.wandb.ai/) is a framework for tracking, experimenting with, evaluating, deploying, and improving LLM-based applications. ![Overview of W\\&B Weave CrewAI tracing usage](https://mintlify.s3.us-west-1.amazonaws.com/crewai/images/weave-tracing.gif) Weave provides comprehensive support for every stage of your CrewAI application development: **Tracing & Monitoring**: Automatically track LLM calls and application logic to debug and analyze production systems **Systematic Iteration**: Refine and iterate on prompts, datasets, and models **Evaluation**: Use custom or pre-built scorers to systematically assess and enhance agent performance **Guardrails**: Protect your agents with pre- and post-safeguards for content moderation and prompt safety Weave automatically captures traces for your CrewAI applications, enabling you to monitor and analyze your agents' performance, interactions, and execution flow. This helps you build better evaluation datasets and optimize your agent workflows.",
      "formatted_path": "Changelog > Weave Overview",
      "enhanced_text": "Context: Changelog > Weave Overview\n\n Weave Overview\n\n[Weights & Biases (W\\&B) Weave](https://weave-docs.wandb.ai/) is a framework for tracking, experimenting with, evaluating, deploying, and improving LLM-based applications. ![Overview of W\\&B Weave CrewAI tracing usage](https://mintlify.s3.us-west-1.amazonaws.com/crewai/images/weave-tracing.gif) Weave provides comprehensive support for every stage of your CrewAI application development: **Tracing & Monitoring**: Automatically track LLM calls and application logic to debug and analyze production systems **Systematic Iteration**: Refine and iterate on prompts, datasets, and models **Evaluation**: Use custom or pre-built scorers to systematically assess and enhance agent performance **Guardrails**: Protect your agents with pre- and post-safeguards for content moderation and prompt safety Weave automatically captures traces for your CrewAI applications, enabling you to monitor and analyze your agents' performance, interactions, and execution flow. This helps you build better evaluation datasets and optimize your agent workflows.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "**LLM Cost Management and Tracking**: Track spend with foundation model providers. **Replay Analytics**: Watch step-by-step agent execution graphs. **Recursive Thought Detection**: Identify when agents fall into infinite loops. **Custom Reporting**: Create custom analytics on agent performance. **Analytics Dashboard**: Monitor high-level statistics about agents in development and production. **Public Model Testing**: Test your agents against benchmarks and leaderboards. **Custom Tests**: Run your agents against domain-specific tests. **Time Travel Debugging**: Restart your sessions from checkpoints. **Compliance and Security**: Create audit logs and detect potential threats such as profanity and PII leaks. **Prompt Injection Detection**: Identify potential code injection and secret leaks.",
      "title": "Features",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Weave Overview",
          "level": 1
        },
        {
          "title": "Features",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Weave Overview",
            "level": 1
          },
          {
            "title": "Features",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Weave Overview > Features"
      },
      "enhanced_content": "Context: Changelog > Weave Overview > Features\n\n## Features\n\n**LLM Cost Management and Tracking**: Track spend with foundation model providers. **Replay Analytics**: Watch step-by-step agent execution graphs. **Recursive Thought Detection**: Identify when agents fall into infinite loops. **Custom Reporting**: Create custom analytics on agent performance. **Analytics Dashboard**: Monitor high-level statistics about agents in development and production. **Public Model Testing**: Test your agents against benchmarks and leaderboards. **Custom Tests**: Run your agents against domain-specific tests. **Time Travel Debugging**: Restart your sessions from checkpoints. **Compliance and Security**: Create audit logs and detect potential threats such as profanity and PII leaks. **Prompt Injection Detection**: Identify potential code injection and secret leaks.",
      "formatted_path": "Changelog > Weave Overview > Features",
      "enhanced_text": "Context: Changelog > Weave Overview > Features\n\n Features\n\n**LLM Cost Management and Tracking**: Track spend with foundation model providers. **Replay Analytics**: Watch step-by-step agent execution graphs. **Recursive Thought Detection**: Identify when agents fall into infinite loops. **Custom Reporting**: Create custom analytics on agent performance. **Analytics Dashboard**: Monitor high-level statistics about agents in development and production. **Public Model Testing**: Test your agents against benchmarks and leaderboards. **Custom Tests**: Run your agents against domain-specific tests. **Time Travel Debugging**: Restart your sessions from checkpoints. **Compliance and Security**: Create audit logs and detect potential threats such as profanity and PII leaks. **Prompt Injection Detection**: Identify potential code injection and secret leaks.\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "**Tracing Dashboard**: Monitor activities of your crewAI agents with detailed dashboards that include inputs, outputs and metadata of spans. **Automated Tracing**: A fully automated integration with crewAI, which can be enabled by running `mlflow.crewai.autolog()`. **Manual Trace Instrumentation with minor efforts**: Customize trace instrumentation through MLflow's high-level fluent APIs such as decorators, function wrappers and context managers. **OpenTelemetry Compatibility**: MLflow Tracing supports exporting traces to an OpenTelemetry Collector, which can then be used to export traces to various backends such as Jaeger, Zipkin, and AWS X-Ray. **Package and Deploy Agents**: Package and deploy your crewAI agents to an inference server with a variety of deployment targets. **Securely Host LLMs**: Host multiple LLM from various providers in one unified endpoint through MFflow gateway. **Evaluation**: Evaluate your crewAI agents with a wide range of metrics using a convenient API `mlflow.evaluate()`.",
      "title": "Features",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Weave Overview",
          "level": 1
        },
        {
          "title": "Features",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Weave Overview",
            "level": 1
          },
          {
            "title": "Features",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Weave Overview > Features"
      },
      "enhanced_content": "Context: Changelog > Weave Overview > Features\n\n## Features\n\n**Tracing Dashboard**: Monitor activities of your crewAI agents with detailed dashboards that include inputs, outputs and metadata of spans. **Automated Tracing**: A fully automated integration with crewAI, which can be enabled by running `mlflow.crewai.autolog()`. **Manual Trace Instrumentation with minor efforts**: Customize trace instrumentation through MLflow's high-level fluent APIs such as decorators, function wrappers and context managers. **OpenTelemetry Compatibility**: MLflow Tracing supports exporting traces to an OpenTelemetry Collector, which can then be used to export traces to various backends such as Jaeger, Zipkin, and AWS X-Ray. **Package and Deploy Agents**: Package and deploy your crewAI agents to an inference server with a variety of deployment targets. **Securely Host LLMs**: Host multiple LLM from various providers in one unified endpoint through MFflow gateway. **Evaluation**: Evaluate your crewAI agents with a wide range of metrics using a convenient API `mlflow.evaluate()`.",
      "formatted_path": "Changelog > Weave Overview > Features",
      "enhanced_text": "Context: Changelog > Weave Overview > Features\n\n Features\n\n**Tracing Dashboard**: Monitor activities of your crewAI agents with detailed dashboards that include inputs, outputs and metadata of spans. **Automated Tracing**: A fully automated integration with crewAI, which can be enabled by running `mlflow.crewai.autolog()`. **Manual Trace Instrumentation with minor efforts**: Customize trace instrumentation through MLflow's high-level fluent APIs such as decorators, function wrappers and context managers. **OpenTelemetry Compatibility**: MLflow Tracing supports exporting traces to an OpenTelemetry Collector, which can then be used to export traces to various backends such as Jaeger, Zipkin, and AWS X-Ray. **Package and Deploy Agents**: Package and deploy your crewAI agents to an inference server with a variety of deployment targets. **Securely Host LLMs**: Host multiple LLM from various providers in one unified endpoint through MFflow gateway. **Evaluation**: Evaluate your crewAI agents with a wide range of metrics using a convenient API `mlflow.evaluate()`.\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "**Analytics Dashboard**: Monitor your Agents health and performance with detailed dashboards that track metrics, costs, and user interactions. **OpenTelemetry-native Observability SDK**: Vendor-neutral SDKs to send traces and metrics to your existing observability tools like Grafana, DataDog and more. **Cost Tracking for Custom and Fine-Tuned Models**: Tailor cost estimations for specific models using custom pricing files for precise budgeting. **Exceptions Monitoring Dashboard**: Quickly spot and resolve issues by tracking common exceptions and errors with a monitoring dashboard. **Compliance and Security**: Detect potential threats such as profanity and PII leaks. **Prompt Injection Detection**: Identify potential code injection and secret leaks. **API Keys and Secrets Management**: Securely handle your LLM API keys and secrets centrally, avoiding insecure practices. **Prompt Management**: Manage and version Agent prompts using PromptHub for consistent and easy access across Agents. **Model Playground** Test and compare different models for your CrewAI agents before deployment.",
      "title": "Features",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Weave Overview",
          "level": 1
        },
        {
          "title": "Features",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Weave Overview",
            "level": 1
          },
          {
            "title": "Features",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Weave Overview > Features"
      },
      "enhanced_content": "Context: Changelog > Weave Overview > Features\n\n## Features\n\n**Analytics Dashboard**: Monitor your Agents health and performance with detailed dashboards that track metrics, costs, and user interactions. **OpenTelemetry-native Observability SDK**: Vendor-neutral SDKs to send traces and metrics to your existing observability tools like Grafana, DataDog and more. **Cost Tracking for Custom and Fine-Tuned Models**: Tailor cost estimations for specific models using custom pricing files for precise budgeting. **Exceptions Monitoring Dashboard**: Quickly spot and resolve issues by tracking common exceptions and errors with a monitoring dashboard. **Compliance and Security**: Detect potential threats such as profanity and PII leaks. **Prompt Injection Detection**: Identify potential code injection and secret leaks. **API Keys and Secrets Management**: Securely handle your LLM API keys and secrets centrally, avoiding insecure practices. **Prompt Management**: Manage and version Agent prompts using PromptHub for consistent and easy access across Agents. **Model Playground** Test and compare different models for your CrewAI agents before deployment.",
      "formatted_path": "Changelog > Weave Overview > Features",
      "enhanced_text": "Context: Changelog > Weave Overview > Features\n\n Features\n\n**Analytics Dashboard**: Monitor your Agents health and performance with detailed dashboards that track metrics, costs, and user interactions. **OpenTelemetry-native Observability SDK**: Vendor-neutral SDKs to send traces and metrics to your existing observability tools like Grafana, DataDog and more. **Cost Tracking for Custom and Fine-Tuned Models**: Tailor cost estimations for specific models using custom pricing files for precise budgeting. **Exceptions Monitoring Dashboard**: Quickly spot and resolve issues by tracking common exceptions and errors with a monitoring dashboard. **Compliance and Security**: Detect potential threats such as profanity and PII leaks. **Prompt Injection Detection**: Identify potential code injection and secret leaks. **API Keys and Secrets Management**: Securely handle your LLM API keys and secrets centrally, avoiding insecure practices. **Prompt Management**: Manage and version Agent prompts using PromptHub for consistent and easy access across Agents. **Model Playground** Test and compare different models for your CrewAI agents before deployment.\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "Weave automatically captures all CrewAI operations: agent interactions and task executions; LLM calls with metadata and token usage; tool usage and results. The integration supports all CrewAI execution methods: `kickoff()`, `kickoff_for_each()`, `kickoff_async()`, and `kickoff_for_each_async()`. Automatic tracing of all [crewAI-tools](https://github.com/crewAIInc/crewAI-tools). Flow feature support with decorator patching (`@start`, `@listen`, `@router`, `@or_`, `@and_`). Track custom guardrails passed to CrewAI `Task` with `@weave.op()`. For detailed information on what's supported, visit the [Weave CrewAI documentation](https://weave-docs.wandb.ai/guides/integrations/crewai/#getting-started-with-flow).",
      "title": "Features",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Weave Overview",
          "level": 1
        },
        {
          "title": "Features",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Weave Overview",
            "level": 1
          },
          {
            "title": "Features",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 2,
        "formatted_path": "Changelog > Weave Overview > Features"
      },
      "enhanced_content": "Context: Changelog > Weave Overview > Features\n\n## Features\n\nWeave automatically captures all CrewAI operations: agent interactions and task executions; LLM calls with metadata and token usage; tool usage and results. The integration supports all CrewAI execution methods: `kickoff()`, `kickoff_for_each()`, `kickoff_async()`, and `kickoff_for_each_async()`. Automatic tracing of all [crewAI-tools](https://github.com/crewAIInc/crewAI-tools). Flow feature support with decorator patching (`@start`, `@listen`, `@router`, `@or_`, `@and_`). Track custom guardrails passed to CrewAI `Task` with `@weave.op()`. For detailed information on what's supported, visit the [Weave CrewAI documentation](https://weave-docs.wandb.ai/guides/integrations/crewai/#getting-started-with-flow).",
      "formatted_path": "Changelog > Weave Overview > Features",
      "enhanced_text": "Context: Changelog > Weave Overview > Features\n\n Features\n\nWeave automatically captures all CrewAI operations: agent interactions and task executions; LLM calls with metadata and token usage; tool usage and results. The integration supports all CrewAI execution methods: `kickoff()`, `kickoff_for_each()`, `kickoff_async()`, and `kickoff_for_each_async()`. Automatic tracing of all [crewAI-tools](https://github.com/crewAIInc/crewAI-tools). Flow feature support with decorator patching (`@start`, `@listen`, `@router`, `@or_`, `@and_`). Track custom guardrails passed to CrewAI `Task` with `@weave.op()`. For detailed information on what's supported, visit the [Weave CrewAI documentation](https://weave-docs.wandb.ai/guides/integrations/crewai/#getting-started-with-flow).\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "We recommend using the `YAML` template scaffolding for a structured approach to defining agents and tasks. Here's how to get started:",
      "title": "Creating a CrewAI Project",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Creating a CrewAI Project",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Creating a CrewAI Project",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Creating a CrewAI Project"
      },
      "enhanced_content": "Context: Changelog > Creating a CrewAI Project\n\n# Creating a CrewAI Project\n\nWe recommend using the `YAML` template scaffolding for a structured approach to defining agents and tasks. Here's how to get started:",
      "formatted_path": "Changelog > Creating a CrewAI Project",
      "enhanced_text": "Context: Changelog > Creating a CrewAI Project\n\n Creating a CrewAI Project\n\nWe recommend using the `YAML` template scaffolding for a structured approach to defining agents and tasks. Here's how to get started:"
    },
    {
      "content": "If you're interested in exploring additional examples of flows, we have a variety of recommendations in our examples repository. Here are four specific flow examples, each showcasing unique use cases to help you match your current problem type to a specific example: **Email Auto Responder Flow**: This example demonstrates an infinite loop where a background job continually runs to automate email responses. It's a great use case for tasks that need to be performed repeatedly without manual intervention. [View Example](https://github.com/crewAIInc/crewAI-examples/tree/main/email_auto_responder_flow) **Lead Score Flow**: This flow showcases adding human-in-the-loop feedback and handling different conditional branches using the router. It's an excellent example of how to incorporate dynamic decision-making and human oversight into your workflows. [View Example](https://github.com/crewAIInc/crewAI-examples/tree/main/lead-score-flow) **Write a Book Flow**: This example excels at chaining multiple crews together, where the output of one crew is used by another. Specifically, one crew outlines an entire book, and another crew generates chapters based on the outline. Eventually, everything is connected to produce a complete book. This flow is perfect for complex, multi-step processes that require coordination between different tasks. [View Example](https://github.com/crewAIInc/crewAI-examples/tree/main/write_a_book_with_flows) **Meeting Assistant Flow**: This flow demonstrates how to broadcast one event to trigger multiple follow-up actions. For instance, after a meeting is completed, the flow can update a Trello board, send a Slack message, and save the results. It's a great example of handling multiple outcomes from a single event, making it ideal for comprehensive task management and notification systems. [View Example](https://github.com/crewAIInc/crewAI-examples/tree/main/meeting_assistant_flow) By exploring these examples, you can gain insights into how to leverage CrewAI Flows for various use cases, from automating repetitive tasks to managing complex, multi-step processes with dynamic decision-making and human feedback. Also, check out our YouTube video on how to use flows in CrewAI below!",
      "title": "Next Steps",
      "type": "descriptive_text_oversized",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Creating a CrewAI Project",
          "level": 1
        },
        {
          "title": "Next Steps",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Creating a CrewAI Project",
            "level": 1
          },
          {
            "title": "Next Steps",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 4,
        "formatted_path": "Changelog > Creating a CrewAI Project > Next Steps"
      },
      "enhanced_content": "Context: Changelog > Creating a CrewAI Project > Next Steps\n\n## Next Steps\n\nIf you're interested in exploring additional examples of flows, we have a variety of recommendations in our examples repository. Here are four specific flow examples, each showcasing unique use cases to help you match your current problem type to a specific example: **Email Auto Responder Flow**: This example demonstrates an infinite loop where a background job continually runs to automate email responses. It's a great use case for tasks that need to be performed repeatedly without manual intervention. [View Example](https://github.com/crewAIInc/crewAI-examples/tree/main/email_auto_responder_flow) **Lead Score Flow**: This flow showcases adding human-in-the-loop feedback and handling different conditional branches using the router. It's an excellent example of how to incorporate dynamic decision-making and human oversight into your workflows. [View Example](https://github.com/crewAIInc/crewAI-examples/tree/main/lead-score-flow) **Write a Book Flow**: This example excels at chaining multiple crews together, where the output of one crew is used by another. Specifically, one crew outlines an entire book, and another crew generates chapters based on the outline. Eventually, everything is connected to produce a complete book. This flow is perfect for complex, multi-step processes that require coordination between different tasks. [View Example](https://github.com/crewAIInc/crewAI-examples/tree/main/write_a_book_with_flows) **Meeting Assistant Flow**: This flow demonstrates how to broadcast one event to trigger multiple follow-up actions. For instance, after a meeting is completed, the flow can update a Trello board, send a Slack message, and save the results. It's a great example of handling multiple outcomes from a single event, making it ideal for comprehensive task management and notification systems. [View Example](https://github.com/crewAIInc/crewAI-examples/tree/main/meeting_assistant_flow) By exploring these examples, you can gain insights into how to leverage CrewAI Flows for various use cases, from automating repetitive tasks to managing complex, multi-step processes with dynamic decision-making and human feedback. Also, check out our YouTube video on how to use flows in CrewAI below!",
      "formatted_path": "Changelog > Creating a CrewAI Project > Next Steps",
      "enhanced_text": "Context: Changelog > Creating a CrewAI Project > Next Steps\n\n Next Steps\n\nIf you're interested in exploring additional examples of flows, we have a variety of recommendations in our examples repository. Here are four specific flow examples, each showcasing unique use cases to help you match your current problem type to a specific example: **Email Auto Responder Flow**: This example demonstrates an infinite loop where a background job continually runs to automate email responses. It's a great use case for tasks that need to be performed repeatedly without manual intervention. [View Example](https://github.com/crewAIInc/crewAI-examples/tree/main/email_auto_responder_flow) **Lead Score Flow**: This flow showcases adding human-in-the-loop feedback and handling different conditional branches using the router. It's an excellent example of how to incorporate dynamic decision-making and human oversight into your workflows. [View Example](https://github.com/crewAIInc/crewAI-examples/tree/main/lead-score-flow) **Write a Book Flow**: This example excels at chaining multiple crews together, where the output of one crew is used by another. Specifically, one crew outlines an entire book, and another crew generates chapters based on the outline. Eventually, everything is connected to produce a complete book. This flow is perfect for complex, multi-step processes that require coordination between different tasks. [View Example](https://github.com/crewAIInc/crewAI-examples/tree/main/write_a_book_with_flows) **Meeting Assistant Flow**: This flow demonstrates how to broadcast one event to trigger multiple follow-up actions. For instance, after a meeting is completed, the flow can update a Trello board, send a Slack message, and save the results. It's a great example of handling multiple outcomes from a single event, making it ideal for comprehensive task management and notification systems. [View Example](https://github.com/crewAIInc/crewAI-examples/tree/main/meeting_assistant_flow) By exploring these examples, you can gain insights into how to leverage CrewAI Flows for various use cases, from automating repetitive tasks to managing complex, multi-step processes with dynamic decision-making and human feedback. Also, check out our YouTube video on how to use flows in CrewAI below!"
    },
    {
      "content": "Experiment with different agent configurations for your specific use case Learn about [building your first crew](/guides/crews/first-crew) to see how agents work together Explore [CrewAI Flows](/guides/flows/first-flow) for more advanced orchestration\n\nLearn more about [crafting effective agents](/guides/agents/crafting-effective-agents) Explore [building your first crew](/guides/crews/first-crew) Dive into [mastering flow state management](/guides/flows/mastering-flow-state) Check out the [core concepts](/concepts/agents) for deeper understanding\n\nNow that you've built your first crew, you can: Experiment with different agent configurations and personalities Try more complex task structures and workflows Implement custom tools to give your agents new capabilities Apply your crew to different topics or problem domains Explore [CrewAI Flows](/guides/flows/first-flow) for more advanced workflows with procedural programming",
      "title": "Next Steps",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Creating a CrewAI Project",
          "level": 1
        },
        {
          "title": "Next Steps",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Creating a CrewAI Project",
            "level": 1
          },
          {
            "title": "Next Steps",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 7,
        "formatted_path": "Changelog > Creating a CrewAI Project > Next Steps"
      },
      "enhanced_content": "Context: Changelog > Creating a CrewAI Project > Next Steps\n\n## Next Steps\n\nExperiment with different agent configurations for your specific use case Learn about [building your first crew](/guides/crews/first-crew) to see how agents work together Explore [CrewAI Flows](/guides/flows/first-flow) for more advanced orchestration\n\nLearn more about [crafting effective agents](/guides/agents/crafting-effective-agents) Explore [building your first crew](/guides/crews/first-crew) Dive into [mastering flow state management](/guides/flows/mastering-flow-state) Check out the [core concepts](/concepts/agents) for deeper understanding\n\nNow that you've built your first crew, you can: Experiment with different agent configurations and personalities Try more complex task structures and workflows Implement custom tools to give your agents new capabilities Apply your crew to different topics or problem domains Explore [CrewAI Flows](/guides/flows/first-flow) for more advanced workflows with procedural programming",
      "formatted_path": "Changelog > Creating a CrewAI Project > Next Steps",
      "enhanced_text": "Context: Changelog > Creating a CrewAI Project > Next Steps\n\n Next Steps\n\nExperiment with different agent configurations for your specific use case Learn about [building your first crew](/guides/crews/first-crew) to see how agents work together Explore [CrewAI Flows](/guides/flows/first-flow) for more advanced orchestration\n\nLearn more about [crafting effective agents](/guides/agents/crafting-effective-agents) Explore [building your first crew](/guides/crews/first-crew) Dive into [mastering flow state management](/guides/flows/mastering-flow-state) Check out the [core concepts](/concepts/agents) for deeper understanding\n\nNow that you've built your first crew, you can: Experiment with different agent configurations and personalities Try more complex task structures and workflows Implement custom tools to give your agents new capabilities Apply your crew to different topics or problem domains Explore [CrewAI Flows](/guides/flows/first-flow) for more advanced workflows with procedural programming"
    },
    {
      "content": "Now that you've built your first flow, you can: Experiment with more complex flow structures and patterns Try using `@router()` to create conditional branches in your flows Explore the `and_` and `or_` functions for more complex parallel execution Connect your flow to external APIs, databases, or user interfaces Combine multiple specialized crews in a single flow\n\nExperiment with both structured and unstructured state in your flows Try implementing state persistence for long-running workflows Explore [building your first crew](/guides/crews/first-crew) to see how crews and flows can work together Check out the [Flow reference documentation](/concepts/flows) for more advanced features",
      "title": "Next Steps",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Creating a CrewAI Project",
          "level": 1
        },
        {
          "title": "Next Steps",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Creating a CrewAI Project",
            "level": 1
          },
          {
            "title": "Next Steps",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 2,
        "formatted_path": "Changelog > Creating a CrewAI Project > Next Steps"
      },
      "enhanced_content": "Context: Changelog > Creating a CrewAI Project > Next Steps\n\n## Next Steps\n\nNow that you've built your first flow, you can: Experiment with more complex flow structures and patterns Try using `@router()` to create conditional branches in your flows Explore the `and_` and `or_` functions for more complex parallel execution Connect your flow to external APIs, databases, or user interfaces Combine multiple specialized crews in a single flow\n\nExperiment with both structured and unstructured state in your flows Try implementing state persistence for long-running workflows Explore [building your first crew](/guides/crews/first-crew) to see how crews and flows can work together Check out the [Flow reference documentation](/concepts/flows) for more advanced features",
      "formatted_path": "Changelog > Creating a CrewAI Project > Next Steps",
      "enhanced_text": "Context: Changelog > Creating a CrewAI Project > Next Steps\n\n Next Steps\n\nNow that you've built your first flow, you can: Experiment with more complex flow structures and patterns Try using `@router()` to create conditional branches in your flows Explore the `and_` and `or_` functions for more complex parallel execution Connect your flow to external APIs, databases, or user interfaces Combine multiple specialized crews in a single flow\n\nExperiment with both structured and unstructured state in your flows Try implementing state persistence for long-running workflows Explore [building your first crew](/guides/crews/first-crew) to see how crews and flows can work together Check out the [Flow reference documentation](/concepts/flows) for more advanced features"
    },
    {
      "content": "CrewAI Flows is a powerful feature designed to streamline the creation and management of AI workflows. Flows allow developers to combine and coordinate coding tasks and Crews efficiently, providing a robust framework for building sophisticated AI automations. Flows allow you to create structured, event-driven workflows. They provide a seamless way to connect multiple tasks, manage state, and control the flow of execution in your AI applications. With Flows, you can easily design and implement multi-step processes that leverage the full potential of CrewAI's capabilities. **Simplified Workflow Creation**: Easily chain together multiple Crews and tasks to create complex AI workflows. **State Management**: Flows make it super easy to manage and share state between different tasks in your workflow. **Event-Driven Architecture**: Built on an event-driven model, allowing for dynamic and responsive workflows. **Flexible Control Flow**: Implement conditional logic, loops, and branching within your workflows.",
      "title": "Introduction",
      "type": "descriptive_text_oversized",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Introduction",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Introduction",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Introduction"
      },
      "enhanced_content": "Context: Changelog > Introduction\n\n# Introduction\n\nCrewAI Flows is a powerful feature designed to streamline the creation and management of AI workflows. Flows allow developers to combine and coordinate coding tasks and Crews efficiently, providing a robust framework for building sophisticated AI automations. Flows allow you to create structured, event-driven workflows. They provide a seamless way to connect multiple tasks, manage state, and control the flow of execution in your AI applications. With Flows, you can easily design and implement multi-step processes that leverage the full potential of CrewAI's capabilities. **Simplified Workflow Creation**: Easily chain together multiple Crews and tasks to create complex AI workflows. **State Management**: Flows make it super easy to manage and share state between different tasks in your workflow. **Event-Driven Architecture**: Built on an event-driven model, allowing for dynamic and responsive workflows. **Flexible Control Flow**: Implement conditional logic, loops, and branching within your workflows.",
      "formatted_path": "Changelog > Introduction",
      "enhanced_text": "Context: Changelog > Introduction\n\n Introduction\n\nCrewAI Flows is a powerful feature designed to streamline the creation and management of AI workflows. Flows allow developers to combine and coordinate coding tasks and Crews efficiently, providing a robust framework for building sophisticated AI automations. Flows allow you to create structured, event-driven workflows. They provide a seamless way to connect multiple tasks, manage state, and control the flow of execution in your AI applications. With Flows, you can easily design and implement multi-step processes that leverage the full potential of CrewAI's capabilities. **Simplified Workflow Creation**: Easily chain together multiple Crews and tasks to create complex AI workflows. **State Management**: Flows make it super easy to manage and share state between different tasks in your workflow. **Event-Driven Architecture**: Built on an event-driven model, allowing for dynamic and responsive workflows. **Flexible Control Flow**: Implement conditional logic, loops, and branching within your workflows.\n\nRelated sections:\n- \n"
    },
    {
      "content": "The planning feature in CrewAI allows you to add planning capability to your crew. When enabled, before each Crew iteration,\nall Crew information is sent to an AgentPlanner that will plan the tasks step by step, and this plan will be added to each task description.\n\nTesting is a crucial part of the development process, and it is essential to ensure that your crew is performing as expected. With crewAI, you can easily test your crew and evaluate its performance using the built-in testing capabilities.\n\nCrewAI tools empower agents with capabilities ranging from web searching and data analysis to collaboration and delegating tasks among coworkers.\nThis documentation outlines how to create, integrate, and leverage these tools within the CrewAI framework, including a new focus on collaboration tools.",
      "title": "Introduction",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Introduction",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Introduction",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Introduction"
      },
      "enhanced_content": "Context: Changelog > Introduction\n\n# Introduction\n\nThe planning feature in CrewAI allows you to add planning capability to your crew. When enabled, before each Crew iteration,\nall Crew information is sent to an AgentPlanner that will plan the tasks step by step, and this plan will be added to each task description.\n\nTesting is a crucial part of the development process, and it is essential to ensure that your crew is performing as expected. With crewAI, you can easily test your crew and evaluate its performance using the built-in testing capabilities.\n\nCrewAI tools empower agents with capabilities ranging from web searching and data analysis to collaboration and delegating tasks among coworkers.\nThis documentation outlines how to create, integrate, and leverage these tools within the CrewAI framework, including a new focus on collaboration tools.",
      "formatted_path": "Changelog > Introduction",
      "enhanced_text": "Context: Changelog > Introduction\n\n Introduction\n\nThe planning feature in CrewAI allows you to add planning capability to your crew. When enabled, before each Crew iteration,\nall Crew information is sent to an AgentPlanner that will plan the tasks step by step, and this plan will be added to each task description.\n\nTesting is a crucial part of the development process, and it is essential to ensure that your crew is performing as expected. With crewAI, you can easily test your crew and evaluate its performance using the built-in testing capabilities.\n\nCrewAI tools empower agents with capabilities ranging from web searching and data analysis to collaboration and delegating tasks among coworkers.\nThis documentation outlines how to create, integrate, and leverage these tools within the CrewAI framework, including a new focus on collaboration tools.\n\nRelated sections:\n- \n"
    },
    {
      "content": "The training feature in CrewAI allows you to train your AI agents using the command-line interface (CLI).\nBy running the command `crewai train -n <n_iterations>`, you can specify the number of iterations for the training process. During training, CrewAI utilizes techniques to optimize the performance of your agents along with human feedback.\nThis helps the agents improve their understanding, decision-making, and problem-solving abilities.\n\nObservability is a key aspect of developing and deploying conversational AI agents. It allows developers to understand how their agents are performing,\nhow their agents are interacting with users, and how their agents use external tools and APIs.\nAgentOps is a product independent of CrewAI that provides a comprehensive observability solution for agents.",
      "title": "Introduction",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Introduction",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Introduction",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Introduction"
      },
      "enhanced_content": "Context: Changelog > Introduction\n\n# Introduction\n\nThe training feature in CrewAI allows you to train your AI agents using the command-line interface (CLI).\nBy running the command `crewai train -n <n_iterations>`, you can specify the number of iterations for the training process. During training, CrewAI utilizes techniques to optimize the performance of your agents along with human feedback.\nThis helps the agents improve their understanding, decision-making, and problem-solving abilities.\n\nObservability is a key aspect of developing and deploying conversational AI agents. It allows developers to understand how their agents are performing,\nhow their agents are interacting with users, and how their agents use external tools and APIs.\nAgentOps is a product independent of CrewAI that provides a comprehensive observability solution for agents.",
      "formatted_path": "Changelog > Introduction",
      "enhanced_text": "Context: Changelog > Introduction\n\n Introduction\n\nThe training feature in CrewAI allows you to train your AI agents using the command-line interface (CLI).\nBy running the command `crewai train -n <n_iterations>`, you can specify the number of iterations for the training process. During training, CrewAI utilizes techniques to optimize the performance of your agents along with human feedback.\nThis helps the agents improve their understanding, decision-making, and problem-solving abilities.\n\nObservability is a key aspect of developing and deploying conversational AI agents. It allows developers to understand how their agents are performing,\nhow their agents are interacting with users, and how their agents use external tools and APIs.\nAgentOps is a product independent of CrewAI that provides a comprehensive observability solution for agents.\n\nRelated sections:\n- \n"
    },
    {
      "content": "CrewAI Agents now have the powerful ability to write and execute code, significantly enhancing their problem-solving capabilities. This feature is particularly useful for tasks that require computational or programmatic solutions.\n\nConditional Tasks in crewAI allow for dynamic workflow adaptation based on the outcomes of previous tasks.\nThis powerful feature enables crews to make decisions and execute tasks selectively, enhancing the flexibility and efficiency of your AI-driven processes.\n\nIn CrewAI, you can force the output of a tool as the result of an agent's task.\nThis feature is useful when you want to ensure that the tool output is captured and returned as the task result, avoiding any agent modification during the task execution.",
      "title": "Introduction",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Introduction",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Introduction",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Introduction"
      },
      "enhanced_content": "Context: Changelog > Introduction\n\n# Introduction\n\nCrewAI Agents now have the powerful ability to write and execute code, significantly enhancing their problem-solving capabilities. This feature is particularly useful for tasks that require computational or programmatic solutions.\n\nConditional Tasks in crewAI allow for dynamic workflow adaptation based on the outcomes of previous tasks.\nThis powerful feature enables crews to make decisions and execute tasks selectively, enhancing the flexibility and efficiency of your AI-driven processes.\n\nIn CrewAI, you can force the output of a tool as the result of an agent's task.\nThis feature is useful when you want to ensure that the tool output is captured and returned as the task result, avoiding any agent modification during the task execution.",
      "formatted_path": "Changelog > Introduction",
      "enhanced_text": "Context: Changelog > Introduction\n\n Introduction\n\nCrewAI Agents now have the powerful ability to write and execute code, significantly enhancing their problem-solving capabilities. This feature is particularly useful for tasks that require computational or programmatic solutions.\n\nConditional Tasks in crewAI allow for dynamic workflow adaptation based on the outcomes of previous tasks.\nThis powerful feature enables crews to make decisions and execute tasks selectively, enhancing the flexibility and efficiency of your AI-driven processes.\n\nIn CrewAI, you can force the output of a tool as the result of an agent's task.\nThis feature is useful when you want to ensure that the tool output is captured and returned as the task result, avoiding any agent modification during the task execution.\n\nRelated sections:\n- \n"
    },
    {
      "content": "The hierarchical process in CrewAI introduces a structured approach to task management, simulating traditional organizational hierarchies for efficient task delegation and execution.\nThis systematic workflow enhances project outcomes by ensuring tasks are handled with optimal efficiency and accuracy.\n\nCrewAI provides the ability to kickoff a crew asynchronously, allowing you to start the crew execution in a non-blocking manner.\nThis feature is particularly useful when you want to run multiple crews concurrently or when you need to perform other tasks while the crew is executing.\n\nCrewAI provides the ability to kickoff a crew for each item in a list, allowing you to execute the crew for each item in the list.\nThis feature is particularly useful when you need to perform the same set of tasks for multiple items.",
      "title": "Introduction",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Introduction",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Introduction",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Introduction"
      },
      "enhanced_content": "Context: Changelog > Introduction\n\n# Introduction\n\nThe hierarchical process in CrewAI introduces a structured approach to task management, simulating traditional organizational hierarchies for efficient task delegation and execution.\nThis systematic workflow enhances project outcomes by ensuring tasks are handled with optimal efficiency and accuracy.\n\nCrewAI provides the ability to kickoff a crew asynchronously, allowing you to start the crew execution in a non-blocking manner.\nThis feature is particularly useful when you want to run multiple crews concurrently or when you need to perform other tasks while the crew is executing.\n\nCrewAI provides the ability to kickoff a crew for each item in a list, allowing you to execute the crew for each item in the list.\nThis feature is particularly useful when you need to perform the same set of tasks for multiple items.",
      "formatted_path": "Changelog > Introduction",
      "enhanced_text": "Context: Changelog > Introduction\n\n Introduction\n\nThe hierarchical process in CrewAI introduces a structured approach to task management, simulating traditional organizational hierarchies for efficient task delegation and execution.\nThis systematic workflow enhances project outcomes by ensuring tasks are handled with optimal efficiency and accuracy.\n\nCrewAI provides the ability to kickoff a crew asynchronously, allowing you to start the crew execution in a non-blocking manner.\nThis feature is particularly useful when you want to run multiple crews concurrently or when you need to perform other tasks while the crew is executing.\n\nCrewAI provides the ability to kickoff a crew for each item in a list, allowing you to execute the crew for each item in the list.\nThis feature is particularly useful when you need to perform the same set of tasks for multiple items.\n\nRelated sections:\n- \n"
    },
    {
      "content": "CrewAI provides the ability to replay from a task specified from the latest crew kickoff. This feature is particularly useful when you've finished a kickoff and may want to retry certain tasks or don't need to refetch data over and your agents already have the context saved from the kickoff execution so you just need to replay the tasks you want to. Here's an example of how to replay from a task:\n\nCrewAI offers a flexible framework for executing tasks in a structured manner, supporting both sequential and hierarchical processes.\nThis guide outlines how to effectively implement these processes to ensure efficient task execution and project completion.\n\nSource: https://docs.crewai.com/introduction Build AI agent teams that work together to tackle complex tasks",
      "title": "Introduction",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Introduction",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Introduction",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Introduction"
      },
      "enhanced_content": "Context: Changelog > Introduction\n\n# Introduction\n\nCrewAI provides the ability to replay from a task specified from the latest crew kickoff. This feature is particularly useful when you've finished a kickoff and may want to retry certain tasks or don't need to refetch data over and your agents already have the context saved from the kickoff execution so you just need to replay the tasks you want to. Here's an example of how to replay from a task:\n\nCrewAI offers a flexible framework for executing tasks in a structured manner, supporting both sequential and hierarchical processes.\nThis guide outlines how to effectively implement these processes to ensure efficient task execution and project completion.\n\nSource: https://docs.crewai.com/introduction Build AI agent teams that work together to tackle complex tasks",
      "formatted_path": "Changelog > Introduction",
      "enhanced_text": "Context: Changelog > Introduction\n\n Introduction\n\nCrewAI provides the ability to replay from a task specified from the latest crew kickoff. This feature is particularly useful when you've finished a kickoff and may want to retry certain tasks or don't need to refetch data over and your agents already have the context saved from the kickoff execution so you just need to replay the tasks you want to. Here's an example of how to replay from a task:\n\nCrewAI offers a flexible framework for executing tasks in a structured manner, supporting both sequential and hierarchical processes.\nThis guide outlines how to effectively implement these processes to ensure efficient task execution and project completion.\n\nSource: https://docs.crewai.com/introduction Build AI agent teams that work together to tackle complex tasks\n\nRelated sections:\n- \n"
    },
    {
      "content": "**CrewAI is a lean, lightning-fast Python framework built entirely from scratch\u2014completely independent of LangChain or other agent frameworks.** CrewAI empowers developers with both high-level simplicity and precise low-level control, ideal for creating autonomous AI agents tailored to any scenario: **[CrewAI Crews](/guides/crews/first-crew)**: Optimize for autonomy and collaborative intelligence, enabling you to create AI teams where each agent has specific roles, tools, and goals. **[CrewAI Flows](/guides/flows/first-flow)**: Enable granular, event-driven control, single LLM calls for precise task orchestration and supports Crews natively. With over 100,000 developers certified through our community courses, CrewAI is rapidly becoming the standard for enterprise-ready AI automation.",
      "title": "What is CrewAI?",
      "type": "link_list",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "What is CrewAI?",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "What is CrewAI?",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 2,
        "formatted_path": "Changelog > What is CrewAI?"
      },
      "enhanced_content": "Context: Changelog > What is CrewAI?\n\n# What is CrewAI?\n\n**CrewAI is a lean, lightning-fast Python framework built entirely from scratch\u2014completely independent of LangChain or other agent frameworks.** CrewAI empowers developers with both high-level simplicity and precise low-level control, ideal for creating autonomous AI agents tailored to any scenario: **[CrewAI Crews](/guides/crews/first-crew)**: Optimize for autonomy and collaborative intelligence, enabling you to create AI teams where each agent has specific roles, tools, and goals. **[CrewAI Flows](/guides/flows/first-flow)**: Enable granular, event-driven control, single LLM calls for precise task orchestration and supports Crews natively. With over 100,000 developers certified through our community courses, CrewAI is rapidly becoming the standard for enterprise-ready AI automation.",
      "formatted_path": "Changelog > What is CrewAI?",
      "enhanced_text": "Context: Changelog > What is CrewAI?\n\n What is CrewAI?\n\n**CrewAI is a lean, lightning-fast Python framework built entirely from scratch\u2014completely independent of LangChain or other agent frameworks.** CrewAI empowers developers with both high-level simplicity and precise low-level control, ideal for creating autonomous AI agents tailored to any scenario: **[CrewAI Crews](/guides/crews/first-crew)**: Optimize for autonomy and collaborative intelligence, enabling you to create AI teams where each agent has specific roles, tools, and goals. **[CrewAI Flows](/guides/flows/first-flow)**: Enable granular, event-driven control, single LLM calls for precise task orchestration and supports Crews natively. With over 100,000 developers certified through our community courses, CrewAI is rapidly becoming the standard for enterprise-ready AI automation."
    },
    {
      "content": "| Component     |         Description        | Key Features                                                                                                                      |\n| :------------ | :------------------------: | :-------------------------------------------------------------------------------------------------------------------------------- |\n| **Crew**      | The top-level organization | \u2022 Manages AI agent teams<br />\u2022 Oversees workflows<br />\u2022 Ensures collaboration<br />\u2022 Delivers outcomes                          |\n| **AI Agents** |  Specialized team members  | \u2022 Have specific roles (researcher, writer)<br />\u2022 Use designated tools<br />\u2022 Can delegate tasks<br />\u2022 Make autonomous decisions |\n| **Process**   | Workflow management system | \u2022 Defines collaboration patterns<br />\u2022 Controls task assignments<br />\u2022 Manages interactions<br />\u2022 Ensures efficient execution  |\n| **Tasks**     |   Individual assignments   | \u2022 Have clear objectives<br />\u2022 Use specific tools<br />\u2022 Feed into larger process<br />\u2022 Produce actionable results               |",
      "title": "How Crews Work",
      "type": "descriptive_text_oversized",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "What is CrewAI?",
          "level": 1
        },
        {
          "title": "How Crews Work",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "What is CrewAI?",
            "level": 1
          },
          {
            "title": "How Crews Work",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > What is CrewAI? > How Crews Work"
      },
      "enhanced_content": "Context: Changelog > What is CrewAI? > How Crews Work\n\n## How Crews Work\n\n| Component     |         Description        | Key Features                                                                                                                      |\n| :------------ | :------------------------: | :-------------------------------------------------------------------------------------------------------------------------------- |\n| **Crew**      | The top-level organization | \u2022 Manages AI agent teams<br />\u2022 Oversees workflows<br />\u2022 Ensures collaboration<br />\u2022 Delivers outcomes                          |\n| **AI Agents** |  Specialized team members  | \u2022 Have specific roles (researcher, writer)<br />\u2022 Use designated tools<br />\u2022 Can delegate tasks<br />\u2022 Make autonomous decisions |\n| **Process**   | Workflow management system | \u2022 Defines collaboration patterns<br />\u2022 Controls task assignments<br />\u2022 Manages interactions<br />\u2022 Ensures efficient execution  |\n| **Tasks**     |   Individual assignments   | \u2022 Have clear objectives<br />\u2022 Use specific tools<br />\u2022 Feed into larger process<br />\u2022 Produce actionable results               |",
      "formatted_path": "Changelog > What is CrewAI? > How Crews Work",
      "enhanced_text": "Context: Changelog > What is CrewAI? > How Crews Work\n\n How Crews Work\n\n| Component     |         Description        | Key Features                                                                                                                      |\n| :------------ | :------------------------: | :-------------------------------------------------------------------------------------------------------------------------------- |\n| **Crew**      | The top-level organization | \u2022 Manages AI agent teams<br />\u2022 Oversees workflows<br />\u2022 Ensures collaboration<br />\u2022 Delivers outcomes                          |\n| **AI Agents** |  Specialized team members  | \u2022 Have specific roles (researcher, writer)<br />\u2022 Use designated tools<br />\u2022 Can delegate tasks<br />\u2022 Make autonomous decisions |\n| **Process**   | Workflow management system | \u2022 Defines collaboration patterns<br />\u2022 Controls task assignments<br />\u2022 Manages interactions<br />\u2022 Ensures efficient execution  |\n| **Tasks**     |   Individual assignments   | \u2022 Have clear objectives<br />\u2022 Use specific tools<br />\u2022 Feed into larger process<br />\u2022 Produce actionable results               |\n\nRelated sections:\n- \n"
    },
    {
      "content": "The **Crew** organizes the overall operation **AI Agents** work on their specialized tasks The **Process** ensures smooth collaboration **Tasks** get completed to achieve the goal",
      "title": "How It All Works Together",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "What is CrewAI?",
          "level": 1
        },
        {
          "title": "How Crews Work",
          "level": 2
        },
        {
          "title": "How It All Works Together",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "What is CrewAI?",
            "level": 1
          },
          {
            "title": "How Crews Work",
            "level": 2
          },
          {
            "title": "How It All Works Together",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > What is CrewAI? > How Crews Work > How It All Works Together"
      },
      "enhanced_content": "Context: Changelog > What is CrewAI? > How Crews Work > How It All Works Together\n\n### How It All Works Together\n\nThe **Crew** organizes the overall operation **AI Agents** work on their specialized tasks The **Process** ensures smooth collaboration **Tasks** get completed to achieve the goal",
      "formatted_path": "Changelog > What is CrewAI? > How Crews Work > How It All Works Together",
      "enhanced_text": "Context: Changelog > What is CrewAI? > How Crews Work > How It All Works Together\n\n How It All Works Together\n\nThe **Crew** organizes the overall operation **AI Agents** work on their specialized tasks The **Process** ensures smooth collaboration **Tasks** get completed to achieve the goal"
    },
    {
      "content": "**Task Delegation**: A manager agent allocates tasks among crew members based on their roles and capabilities. **Result Validation**: The manager evaluates outcomes to ensure they meet the required standards. **Efficient Workflow**: Emulates corporate structures, providing an organized approach to task management. **System Prompt Handling**: Optionally specify whether the system should use predefined prompts. **Stop Words Control**: Optionally specify whether stop words should be used, supporting various models including the o1 models. **Context Window Respect**: Prioritize important context by enabling respect of the context window, which is now the default behavior. **Delegation Control**: Delegation is now disabled by default to give users explicit control. **Max Requests Per Minute**: Configurable option to set the maximum number of requests per minute. **Max Iterations**: Limit the maximum number of iterations for obtaining a final answer.",
      "title": "Key Features",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "What is CrewAI?",
          "level": 1
        },
        {
          "title": "Key Features",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "What is CrewAI?",
            "level": 1
          },
          {
            "title": "Key Features",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > What is CrewAI? > Key Features"
      },
      "enhanced_content": "Context: Changelog > What is CrewAI? > Key Features\n\n## Key Features\n\n**Task Delegation**: A manager agent allocates tasks among crew members based on their roles and capabilities. **Result Validation**: The manager evaluates outcomes to ensure they meet the required standards. **Efficient Workflow**: Emulates corporate structures, providing an organized approach to task management. **System Prompt Handling**: Optionally specify whether the system should use predefined prompts. **Stop Words Control**: Optionally specify whether stop words should be used, supporting various models including the o1 models. **Context Window Respect**: Prioritize important context by enabling respect of the context window, which is now the default behavior. **Delegation Control**: Delegation is now disabled by default to give users explicit control. **Max Requests Per Minute**: Configurable option to set the maximum number of requests per minute. **Max Iterations**: Limit the maximum number of iterations for obtaining a final answer.",
      "formatted_path": "Changelog > What is CrewAI? > Key Features",
      "enhanced_text": "Context: Changelog > What is CrewAI? > Key Features\n\n Key Features\n\n**Task Delegation**: A manager agent allocates tasks among crew members based on their roles and capabilities. **Result Validation**: The manager evaluates outcomes to ensure they meet the required standards. **Efficient Workflow**: Emulates corporate structures, providing an organized approach to task management. **System Prompt Handling**: Optionally specify whether the system should use predefined prompts. **Stop Words Control**: Optionally specify whether stop words should be used, supporting various models including the o1 models. **Context Window Respect**: Prioritize important context by enabling respect of the context window, which is now the default behavior. **Delegation Control**: Delegation is now disabled by default to give users explicit control. **Max Requests Per Minute**: Configurable option to set the maximum number of requests per minute. **Max Iterations**: Limit the maximum number of iterations for obtaining a final answer.\n\nRelated sections:\n- \n- \n- \n- \n- \n"
    },
    {
      "content": "| Feature                    | Description                                                                             |\n| :------------------------- | :-------------------------------------------------------------------------------------- |\n| \ud83c\udf10 Multi-LLM Support       | Access OpenAI, Anthropic, Gemini, Azure, and 250+ providers through a unified interface |\n| \ud83d\udee1\ufe0f Production Reliability | Implement retries, timeouts, load balancing, and fallbacks                              |\n| \ud83d\udcca Advanced Observability  | Track 40+ metrics including costs, tokens, latency, and custom metadata                 |\n| \ud83d\udd0d Comprehensive Logging   | Debug with detailed execution traces and function call logs                             |\n| \ud83d\udea7 Security Controls       | Set budget limits and implement role-based access control                               |\n| \ud83d\udd04 Performance Analytics   | Capture and analyze feedback for continuous improvement                                 |\n| \ud83d\udcbe Intelligent Caching     | Reduce costs and latency with semantic or simple caching                                |",
      "title": "Key Features",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "What is CrewAI?",
          "level": 1
        },
        {
          "title": "Key Features",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "What is CrewAI?",
            "level": 1
          },
          {
            "title": "Key Features",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > What is CrewAI? > Key Features"
      },
      "enhanced_content": "Context: Changelog > What is CrewAI? > Key Features\n\n## Key Features\n\n| Feature                    | Description                                                                             |\n| :------------------------- | :-------------------------------------------------------------------------------------- |\n| \ud83c\udf10 Multi-LLM Support       | Access OpenAI, Anthropic, Gemini, Azure, and 250+ providers through a unified interface |\n| \ud83d\udee1\ufe0f Production Reliability | Implement retries, timeouts, load balancing, and fallbacks                              |\n| \ud83d\udcca Advanced Observability  | Track 40+ metrics including costs, tokens, latency, and custom metadata                 |\n| \ud83d\udd0d Comprehensive Logging   | Debug with detailed execution traces and function call logs                             |\n| \ud83d\udea7 Security Controls       | Set budget limits and implement role-based access control                               |\n| \ud83d\udd04 Performance Analytics   | Capture and analyze feedback for continuous improvement                                 |\n| \ud83d\udcbe Intelligent Caching     | Reduce costs and latency with semantic or simple caching                                |",
      "formatted_path": "Changelog > What is CrewAI? > Key Features",
      "enhanced_text": "Context: Changelog > What is CrewAI? > Key Features\n\n Key Features\n\n| Feature                    | Description                                                                             |\n| :------------------------- | :-------------------------------------------------------------------------------------- |\n| \ud83c\udf10 Multi-LLM Support       | Access OpenAI, Anthropic, Gemini, Azure, and 250+ providers through a unified interface |\n| \ud83d\udee1\ufe0f Production Reliability | Implement retries, timeouts, load balancing, and fallbacks                              |\n| \ud83d\udcca Advanced Observability  | Track 40+ metrics including costs, tokens, latency, and custom metadata                 |\n| \ud83d\udd0d Comprehensive Logging   | Debug with detailed execution traces and function call logs                             |\n| \ud83d\udea7 Security Controls       | Set budget limits and implement role-based access control                               |\n| \ud83d\udd04 Performance Analytics   | Capture and analyze feedback for continuous improvement                                 |\n| \ud83d\udcbe Intelligent Caching     | Reduce costs and latency with semantic or simple caching                                |\n\nRelated sections:\n- \n- \n- \n- \n- \n"
    },
    {
      "content": "**Linear Task Flow**: Ensures orderly progression by handling tasks in a predetermined sequence. **Simplicity**: Best suited for projects with clear, step-by-step tasks. **Easy Monitoring**: Facilitates easy tracking of task completion and project progress.",
      "title": "Key Features",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "What is CrewAI?",
          "level": 1
        },
        {
          "title": "Key Features",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "What is CrewAI?",
            "level": 1
          },
          {
            "title": "Key Features",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > What is CrewAI? > Key Features"
      },
      "enhanced_content": "Context: Changelog > What is CrewAI? > Key Features\n\n## Key Features\n\n**Linear Task Flow**: Ensures orderly progression by handling tasks in a predetermined sequence. **Simplicity**: Best suited for projects with clear, step-by-step tasks. **Easy Monitoring**: Facilitates easy tracking of task completion and project progress.",
      "formatted_path": "Changelog > What is CrewAI? > Key Features",
      "enhanced_text": "Context: Changelog > What is CrewAI? > Key Features\n\n Key Features\n\n**Linear Task Flow**: Ensures orderly progression by handling tasks in a predetermined sequence. **Simplicity**: Best suited for projects with clear, step-by-step tasks. **Easy Monitoring**: Facilitates easy tracking of task completion and project progress.\n\nRelated sections:\n- \n- \n- \n- \n- \n"
    },
    {
      "content": "| Component        |            Description            | Key Features                                                                                                                                                         |\n| :--------------- | :-------------------------------: | :------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Flow**         | Structured workflow orchestration | \u2022 Manages execution paths<br />\u2022 Handles state transitions<br />\u2022 Controls task sequencing<br />\u2022 Ensures reliable execution                                         |\n| **Events**       |   Triggers for workflow actions   | \u2022 Initiate specific processes<br />\u2022 Enable dynamic responses<br />\u2022 Support conditional branching<br />\u2022 Allow for real-time adaptation                             |\n| **States**       |    Workflow execution contexts    | \u2022 Maintain execution data<br />\u2022 Enable persistence<br />\u2022 Support resumability<br />\u2022 Ensure execution integrity                                                    |\n| **Crew Support** |    Enhances workflow automation   | \u2022 Injects pockets of agency when needed<br />\u2022 Complements structured workflows<br />\u2022 Balances automation with intelligence<br />\u2022 Enables adaptive decision-making |",
      "title": "How Flows Work",
      "type": "descriptive_text_oversized",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "What is CrewAI?",
          "level": 1
        },
        {
          "title": "How Flows Work",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "What is CrewAI?",
            "level": 1
          },
          {
            "title": "How Flows Work",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > What is CrewAI? > How Flows Work"
      },
      "enhanced_content": "Context: Changelog > What is CrewAI? > How Flows Work\n\n## How Flows Work\n\n| Component        |            Description            | Key Features                                                                                                                                                         |\n| :--------------- | :-------------------------------: | :------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Flow**         | Structured workflow orchestration | \u2022 Manages execution paths<br />\u2022 Handles state transitions<br />\u2022 Controls task sequencing<br />\u2022 Ensures reliable execution                                         |\n| **Events**       |   Triggers for workflow actions   | \u2022 Initiate specific processes<br />\u2022 Enable dynamic responses<br />\u2022 Support conditional branching<br />\u2022 Allow for real-time adaptation                             |\n| **States**       |    Workflow execution contexts    | \u2022 Maintain execution data<br />\u2022 Enable persistence<br />\u2022 Support resumability<br />\u2022 Ensure execution integrity                                                    |\n| **Crew Support** |    Enhances workflow automation   | \u2022 Injects pockets of agency when needed<br />\u2022 Complements structured workflows<br />\u2022 Balances automation with intelligence<br />\u2022 Enables adaptive decision-making |",
      "formatted_path": "Changelog > What is CrewAI? > How Flows Work",
      "enhanced_text": "Context: Changelog > What is CrewAI? > How Flows Work\n\n How Flows Work\n\n| Component        |            Description            | Key Features                                                                                                                                                         |\n| :--------------- | :-------------------------------: | :------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Flow**         | Structured workflow orchestration | \u2022 Manages execution paths<br />\u2022 Handles state transitions<br />\u2022 Controls task sequencing<br />\u2022 Ensures reliable execution                                         |\n| **Events**       |   Triggers for workflow actions   | \u2022 Initiate specific processes<br />\u2022 Enable dynamic responses<br />\u2022 Support conditional branching<br />\u2022 Allow for real-time adaptation                             |\n| **States**       |    Workflow execution contexts    | \u2022 Maintain execution data<br />\u2022 Enable persistence<br />\u2022 Support resumability<br />\u2022 Ensure execution integrity                                                    |\n| **Crew Support** |    Enhances workflow automation   | \u2022 Injects pockets of agency when needed<br />\u2022 Complements structured workflows<br />\u2022 Balances automation with intelligence<br />\u2022 Enables adaptive decision-making |\n\nRelated sections:\n- \n"
    },
    {
      "content": "| Use Case                | Recommended Approach              | Why?                                                                                                                                  |\n| :---------------------- | :-------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------ |\n| **Open-ended research** | [Crews](/guides/crews/first-crew) | When tasks require creative thinking, exploration, and adaptation                                                                     |\n| **Content generation**  | [Crews](/guides/crews/first-crew) | For collaborative creation of articles, reports, or marketing materials                                                               |\n| **Decision workflows**  | [Flows](/guides/flows/first-flow) | When you need predictable, auditable decision paths with precise control                                                              |\n| **API orchestration**   | [Flows](/guides/flows/first-flow) | For reliable integration with multiple external services in a specific sequence                                                       |\n| **Hybrid applications** | Combined approach                 | Use [Flows](/guides/flows/first-flow) to orchestrate overall process with [Crews](/guides/crews/first-crew) handling complex subtasks |",
      "title": "When to Use Crews vs. Flows",
      "type": "descriptive_text_oversized",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "What is CrewAI?",
          "level": 1
        },
        {
          "title": "When to Use Crews vs. Flows",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "What is CrewAI?",
            "level": 1
          },
          {
            "title": "When to Use Crews vs. Flows",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 6,
        "formatted_path": "Changelog > What is CrewAI? > When to Use Crews vs. Flows"
      },
      "enhanced_content": "Context: Changelog > What is CrewAI? > When to Use Crews vs. Flows\n\n## When to Use Crews vs. Flows\n\n| Use Case                | Recommended Approach              | Why?                                                                                                                                  |\n| :---------------------- | :-------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------ |\n| **Open-ended research** | [Crews](/guides/crews/first-crew) | When tasks require creative thinking, exploration, and adaptation                                                                     |\n| **Content generation**  | [Crews](/guides/crews/first-crew) | For collaborative creation of articles, reports, or marketing materials                                                               |\n| **Decision workflows**  | [Flows](/guides/flows/first-flow) | When you need predictable, auditable decision paths with precise control                                                              |\n| **API orchestration**   | [Flows](/guides/flows/first-flow) | For reliable integration with multiple external services in a specific sequence                                                       |\n| **Hybrid applications** | Combined approach                 | Use [Flows](/guides/flows/first-flow) to orchestrate overall process with [Crews](/guides/crews/first-crew) handling complex subtasks |",
      "formatted_path": "Changelog > What is CrewAI? > When to Use Crews vs. Flows",
      "enhanced_text": "Context: Changelog > What is CrewAI? > When to Use Crews vs. Flows\n\n When to Use Crews vs. Flows\n\n| Use Case                | Recommended Approach              | Why?                                                                                                                                  |\n| :---------------------- | :-------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------ |\n| **Open-ended research** | [Crews](/guides/crews/first-crew) | When tasks require creative thinking, exploration, and adaptation                                                                     |\n| **Content generation**  | [Crews](/guides/crews/first-crew) | For collaborative creation of articles, reports, or marketing materials                                                               |\n| **Decision workflows**  | [Flows](/guides/flows/first-flow) | When you need predictable, auditable decision paths with precise control                                                              |\n| **API orchestration**   | [Flows](/guides/flows/first-flow) | For reliable integration with multiple external services in a specific sequence                                                       |\n| **Hybrid applications** | Combined approach                 | Use [Flows](/guides/flows/first-flow) to orchestrate overall process with [Crews](/guides/crews/first-crew) handling complex subtasks |\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "**Choose [Crews](/guides/crews/first-crew) when:** You need autonomous problem-solving, creative collaboration, or exploratory tasks **Choose [Flows](/guides/flows/first-flow) when:** You require deterministic outcomes, auditability, or precise control over execution **Combine both when:** Your application needs both structured processes and pockets of autonomous intelligence",
      "title": "Decision Framework",
      "type": "link_list",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "What is CrewAI?",
          "level": 1
        },
        {
          "title": "When to Use Crews vs. Flows",
          "level": 2
        },
        {
          "title": "Decision Framework",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "What is CrewAI?",
            "level": 1
          },
          {
            "title": "When to Use Crews vs. Flows",
            "level": 2
          },
          {
            "title": "Decision Framework",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 2,
        "formatted_path": "Changelog > What is CrewAI? > When to Use Crews vs. Flows > Decision Framework"
      },
      "enhanced_content": "Context: Changelog > What is CrewAI? > When to Use Crews vs. Flows > Decision Framework\n\n### Decision Framework\n\n**Choose [Crews](/guides/crews/first-crew) when:** You need autonomous problem-solving, creative collaboration, or exploratory tasks **Choose [Flows](/guides/flows/first-flow) when:** You require deterministic outcomes, auditability, or precise control over execution **Combine both when:** Your application needs both structured processes and pockets of autonomous intelligence",
      "formatted_path": "Changelog > What is CrewAI? > When to Use Crews vs. Flows > Decision Framework",
      "enhanced_text": "Context: Changelog > What is CrewAI? > When to Use Crews vs. Flows > Decision Framework\n\n Decision Framework\n\n**Choose [Crews](/guides/crews/first-crew) when:** You need autonomous problem-solving, creative collaboration, or exploratory tasks **Choose [Flows](/guides/flows/first-flow) when:** You require deterministic outcomes, auditability, or precise control over execution **Combine both when:** Your application needs both structured processes and pockets of autonomous intelligence\n\nRelated sections:\n- \n"
    },
    {
      "content": "\ud83e\udde0 **Autonomous Operation**: Agents make intelligent decisions based on their roles and available tools \ud83d\udcdd **Natural Interaction**: Agents communicate and collaborate like human team members \ud83d\udee0\ufe0f **Extensible Design**: Easy to add new tools, roles, and capabilities \ud83d\ude80 **Production Ready**: Built for reliability and scalability in real-world applications \ud83d\udd12 **Security-Focused**: Designed with enterprise security requirements in mind \ud83d\udcb0 **Cost-Efficient**: Optimized to minimize token usage and API calls",
      "title": "Why Choose CrewAI?",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "What is CrewAI?",
          "level": 1
        },
        {
          "title": "Why Choose CrewAI?",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "What is CrewAI?",
            "level": 1
          },
          {
            "title": "Why Choose CrewAI?",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > What is CrewAI? > Why Choose CrewAI?"
      },
      "enhanced_content": "Context: Changelog > What is CrewAI? > Why Choose CrewAI?\n\n## Why Choose CrewAI?\n\n\ud83e\udde0 **Autonomous Operation**: Agents make intelligent decisions based on their roles and available tools \ud83d\udcdd **Natural Interaction**: Agents communicate and collaborate like human team members \ud83d\udee0\ufe0f **Extensible Design**: Easy to add new tools, roles, and capabilities \ud83d\ude80 **Production Ready**: Built for reliability and scalability in real-world applications \ud83d\udd12 **Security-Focused**: Designed with enterprise security requirements in mind \ud83d\udcb0 **Cost-Efficient**: Optimized to minimize token usage and API calls",
      "formatted_path": "Changelog > What is CrewAI? > Why Choose CrewAI?",
      "enhanced_text": "Context: Changelog > What is CrewAI? > Why Choose CrewAI?\n\n Why Choose CrewAI?\n\n\ud83e\udde0 **Autonomous Operation**: Agents make intelligent decisions based on their roles and available tools \ud83d\udcdd **Natural Interaction**: Agents communicate and collaborate like human team members \ud83d\udee0\ufe0f **Extensible Design**: Easy to add new tools, roles, and capabilities \ud83d\ude80 **Production Ready**: Built for reliability and scalability in real-world applications \ud83d\udd12 **Security-Focused**: Designed with enterprise security requirements in mind \ud83d\udcb0 **Cost-Efficient**: Optimized to minimize token usage and API calls"
    },
    {
      "content": "Source: https://docs.crewai.com/quickstart Build your first AI agent with CrewAI in under 5 minutes.",
      "title": "Quickstart",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Quickstart",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Quickstart",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Quickstart"
      },
      "enhanced_content": "Context: Changelog > Quickstart\n\n# Quickstart\n\nSource: https://docs.crewai.com/quickstart Build your first AI agent with CrewAI in under 5 minutes.",
      "formatted_path": "Changelog > Quickstart",
      "enhanced_text": "Context: Changelog > Quickstart\n\n Quickstart\n\nSource: https://docs.crewai.com/quickstart Build your first AI agent with CrewAI in under 5 minutes.\n\nRelated sections:\n- \n"
    },
    {
      "content": "Let's create a simple crew that will help us `research` and `report` on the `latest AI developments` for a given topic or subject. Before we proceed, make sure you have finished installing CrewAI.\nIf you haven't installed them yet, you can do so by following the [installation guide](/installation). Follow the steps below to get Crewing! \ud83d\udea3\u200d\u2642\ufe0f You have successfully set up your crew project and are ready to start building your own agentic workflows!\n</Check>",
      "title": "Build your first CrewAI Agent",
      "type": "link_list",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Quickstart",
          "level": 1
        },
        {
          "title": "Build your first CrewAI Agent",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Quickstart",
            "level": 1
          },
          {
            "title": "Build your first CrewAI Agent",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 1,
        "formatted_path": "Changelog > Quickstart > Build your first CrewAI Agent"
      },
      "enhanced_content": "Context: Changelog > Quickstart > Build your first CrewAI Agent\n\n## Build your first CrewAI Agent\n\nLet's create a simple crew that will help us `research` and `report` on the `latest AI developments` for a given topic or subject. Before we proceed, make sure you have finished installing CrewAI.\nIf you haven't installed them yet, you can do so by following the [installation guide](/installation). Follow the steps below to get Crewing! \ud83d\udea3\u200d\u2642\ufe0f You have successfully set up your crew project and are ready to start building your own agentic workflows!\n</Check>",
      "formatted_path": "Changelog > Quickstart > Build your first CrewAI Agent",
      "enhanced_text": "Context: Changelog > Quickstart > Build your first CrewAI Agent\n\n Build your first CrewAI Agent\n\nLet's create a simple crew that will help us `research` and `report` on the `latest AI developments` for a given topic or subject. Before we proceed, make sure you have finished installing CrewAI.\nIf you haven't installed them yet, you can do so by following the [installation guide](/installation). Follow the steps below to get Crewing! \ud83d\udea3\u200d\u2642\ufe0f You have successfully set up your crew project and are ready to start building your own agentic workflows!\n</Check>"
    },
    {
      "content": "The names you use in your YAML files (`agents.yaml` and `tasks.yaml`) should match the method names in your Python code.\nFor example, you can reference the agent for specific tasks from `tasks.yaml` file.\nThis naming consistency allows CrewAI to automatically link your configurations with your code; otherwise, your task won't recognize the reference properly.",
      "title": "Note on Consistency in Naming",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Quickstart",
          "level": 1
        },
        {
          "title": "Build your first CrewAI Agent",
          "level": 2
        },
        {
          "title": "Note on Consistency in Naming",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Quickstart",
            "level": 1
          },
          {
            "title": "Build your first CrewAI Agent",
            "level": 2
          },
          {
            "title": "Note on Consistency in Naming",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Quickstart > Build your first CrewAI Agent > Note on Consistency in Naming"
      },
      "enhanced_content": "Context: Changelog > Quickstart > Build your first CrewAI Agent > Note on Consistency in Naming\n\n### Note on Consistency in Naming\n\nThe names you use in your YAML files (`agents.yaml` and `tasks.yaml`) should match the method names in your Python code.\nFor example, you can reference the agent for specific tasks from `tasks.yaml` file.\nThis naming consistency allows CrewAI to automatically link your configurations with your code; otherwise, your task won't recognize the reference properly.",
      "formatted_path": "Changelog > Quickstart > Build your first CrewAI Agent > Note on Consistency in Naming",
      "enhanced_text": "Context: Changelog > Quickstart > Build your first CrewAI Agent > Note on Consistency in Naming\n\n Note on Consistency in Naming\n\nThe names you use in your YAML files (`agents.yaml` and `tasks.yaml`) should match the method names in your Python code.\nFor example, you can reference the agent for specific tasks from `tasks.yaml` file.\nThis naming consistency allows CrewAI to automatically link your configurations with your code; otherwise, your task won't recognize the reference properly."
    },
    {
      "content": "email_summarizer:\n    role: >\n      Email Summarizer\n    goal: >\n      Summarize emails into a concise and clear summary\n    backstory: >\n      You will create a 5 bullet point summary of the report\n    llm: openai/gpt-4o",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Quickstart",
          "level": 1
        },
        {
          "title": "Build your first CrewAI Agent",
          "level": 2
        },
        {
          "title": "Note on Consistency in Naming",
          "level": 3
        },
        {
          "title": "Example References",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Quickstart",
            "level": 1
          },
          {
            "title": "Build your first CrewAI Agent",
            "level": 2
          },
          {
            "title": "Note on Consistency in Naming",
            "level": 3
          },
          {
            "title": "Example References",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Quickstart > Build your first CrewAI Agent > Note on Consistency in Naming > Example References"
      },
      "enhanced_content": "Context: Changelog > Quickstart > Build your first CrewAI Agent > Note on Consistency in Naming > Example References\n\nemail_summarizer:\n    role: >\n      Email Summarizer\n    goal: >\n      Summarize emails into a concise and clear summary\n    backstory: >\n      You will create a 5 bullet point summary of the report\n    llm: openai/gpt-4o",
      "formatted_path": "Changelog > Quickstart > Build your first CrewAI Agent > Note on Consistency in Naming > Example References",
      "enhanced_text": "Context: Changelog > Quickstart > Build your first CrewAI Agent > Note on Consistency in Naming > Example References\n\nemail_summarizer:\n    role: >\n      Email Summarizer\n    goal: >\n      Summarize emails into a concise and clear summary\n    backstory: >\n      You will create a 5 bullet point summary of the report\n    llm: openai/gpt-4o"
    },
    {
      "content": "email_summarizer_task:\n    description: >\n      Summarize the email into a 5 bullet point summary\n    expected_output: >\n      A 5 bullet point summary of the email\n    agent: email_summarizer\n    context:\n      - reporting_task\n      - research_task",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Quickstart",
          "level": 1
        },
        {
          "title": "Build your first CrewAI Agent",
          "level": 2
        },
        {
          "title": "Note on Consistency in Naming",
          "level": 3
        },
        {
          "title": "Example References",
          "level": 4
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Quickstart",
            "level": 1
          },
          {
            "title": "Build your first CrewAI Agent",
            "level": 2
          },
          {
            "title": "Note on Consistency in Naming",
            "level": 3
          },
          {
            "title": "Example References",
            "level": 4
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Quickstart > Build your first CrewAI Agent > Note on Consistency in Naming > Example References"
      },
      "enhanced_content": "Context: Changelog > Quickstart > Build your first CrewAI Agent > Note on Consistency in Naming > Example References\n\nemail_summarizer_task:\n    description: >\n      Summarize the email into a 5 bullet point summary\n    expected_output: >\n      A 5 bullet point summary of the email\n    agent: email_summarizer\n    context:\n      - reporting_task\n      - research_task",
      "formatted_path": "Changelog > Quickstart > Build your first CrewAI Agent > Note on Consistency in Naming > Example References",
      "enhanced_text": "Context: Changelog > Quickstart > Build your first CrewAI Agent > Note on Consistency in Naming > Example References\n\nemail_summarizer_task:\n    description: >\n      Summarize the email into a 5 bullet point summary\n    expected_output: >\n      A 5 bullet point summary of the email\n    agent: email_summarizer\n    context:\n      - reporting_task\n      - research_task"
    },
    {
      "content": "The easiest way to deploy your crew is through [CrewAI Enterprise](http://app.crewai.com), where you can deploy your crew in a few clicks.",
      "title": "Deploying Your Project",
      "type": "link_list",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Quickstart",
          "level": 1
        },
        {
          "title": "Deploying Your Project",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Quickstart",
            "level": 1
          },
          {
            "title": "Deploying Your Project",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 1,
        "formatted_path": "Changelog > Quickstart > Deploying Your Project"
      },
      "enhanced_content": "Context: Changelog > Quickstart > Deploying Your Project\n\n## Deploying Your Project\n\nThe easiest way to deploy your crew is through [CrewAI Enterprise](http://app.crewai.com), where you can deploy your crew in a few clicks.",
      "formatted_path": "Changelog > Quickstart > Deploying Your Project",
      "enhanced_text": "Context: Changelog > Quickstart > Deploying Your Project\n\n Deploying Your Project\n\nThe easiest way to deploy your crew is through [CrewAI Enterprise](http://app.crewai.com), where you can deploy your crew in a few clicks."
    },
    {
      "content": "Source: https://docs.crewai.com/telemetry Understanding the telemetry data collected by CrewAI and how it contributes to the enhancement of the library.",
      "title": "Telemetry",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Telemetry",
          "level": 1
        },
        {
          "title": "Telemetry",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Telemetry",
            "level": 1
          },
          {
            "title": "Telemetry",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Telemetry > Telemetry"
      },
      "enhanced_content": "Context: Changelog > Telemetry > Telemetry\n\n## Telemetry\n\nSource: https://docs.crewai.com/telemetry Understanding the telemetry data collected by CrewAI and how it contributes to the enhancement of the library.",
      "formatted_path": "Changelog > Telemetry > Telemetry",
      "enhanced_text": "Context: Changelog > Telemetry > Telemetry\n\n Telemetry\n\nSource: https://docs.crewai.com/telemetry Understanding the telemetry data collected by CrewAI and how it contributes to the enhancement of the library.\n\nRelated sections:\n- \n"
    },
    {
      "content": "CrewAI utilizes anonymous telemetry to gather usage statistics with the primary goal of enhancing the library.\nOur focus is on improving and developing the features, integrations, and tools most utilized by our users. It's pivotal to understand that by default, **NO personal data is collected** concerning prompts, task descriptions, agents' backstories or goals,\nusage of tools, API calls, responses, any data processed by the agents, or secrets and environment variables.\nWhen the `share_crew` feature is enabled, detailed data including task descriptions, agents' backstories or goals, and other specific attributes are collected\nto provide deeper insights. This expanded data collection may include personal information if users have incorporated it into their crews or tasks.\nUsers should carefully consider the content of their crews and tasks before enabling `share_crew`.\nUsers can disable telemetry by setting the environment variable `OTEL_SDK_DISABLED` to `true`.",
      "title": "Telemetry",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Telemetry",
          "level": 1
        },
        {
          "title": "Telemetry",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Telemetry",
            "level": 1
          },
          {
            "title": "Telemetry",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Telemetry > Telemetry"
      },
      "enhanced_content": "Context: Changelog > Telemetry > Telemetry\n\n## Telemetry\n\nCrewAI utilizes anonymous telemetry to gather usage statistics with the primary goal of enhancing the library.\nOur focus is on improving and developing the features, integrations, and tools most utilized by our users. It's pivotal to understand that by default, **NO personal data is collected** concerning prompts, task descriptions, agents' backstories or goals,\nusage of tools, API calls, responses, any data processed by the agents, or secrets and environment variables.\nWhen the `share_crew` feature is enabled, detailed data including task descriptions, agents' backstories or goals, and other specific attributes are collected\nto provide deeper insights. This expanded data collection may include personal information if users have incorporated it into their crews or tasks.\nUsers should carefully consider the content of their crews and tasks before enabling `share_crew`.\nUsers can disable telemetry by setting the environment variable `OTEL_SDK_DISABLED` to `true`.",
      "formatted_path": "Changelog > Telemetry > Telemetry",
      "enhanced_text": "Context: Changelog > Telemetry > Telemetry\n\n Telemetry\n\nCrewAI utilizes anonymous telemetry to gather usage statistics with the primary goal of enhancing the library.\nOur focus is on improving and developing the features, integrations, and tools most utilized by our users. It's pivotal to understand that by default, **NO personal data is collected** concerning prompts, task descriptions, agents' backstories or goals,\nusage of tools, API calls, responses, any data processed by the agents, or secrets and environment variables.\nWhen the `share_crew` feature is enabled, detailed data including task descriptions, agents' backstories or goals, and other specific attributes are collected\nto provide deeper insights. This expanded data collection may include personal information if users have incorporated it into their crews or tasks.\nUsers should carefully consider the content of their crews and tasks before enabling `share_crew`.\nUsers can disable telemetry by setting the environment variable `OTEL_SDK_DISABLED` to `true`.\n\nRelated sections:\n- \n"
    },
    {
      "content": "| Defaulted | Data                                     | Reason and Specifics                                                                                                                                                                                                                                                                                             |\n| --------- | ---------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Yes       | CrewAI and Python Version                | Tracks software versions. Example: CrewAI v1.2.3, Python 3.8.10. No personal data.                                                                                                                                                                                                                               |\n| Yes       | Crew Metadata                            | Includes: randomly generated key and ID, process type (e.g., 'sequential', 'parallel'), boolean flag for memory usage (true/false), count of tasks, count of agents. All non-personal.                                                                                                                           |\n| Yes       | Agent Data                               | Includes: randomly generated key and ID, role name (should not include personal info), boolean settings (verbose, delegation enabled, code execution allowed), max iterations, max RPM, max retry limit, LLM info (see LLM Attributes), list of tool names (should not include personal info). No personal data. |\n| Yes       | Task Metadata                            | Includes: randomly generated key and ID, boolean execution settings (async\\_execution, human\\_input), associated agent's role and key, list of tool names. All non-personal.                                                                                                                                     |\n| Yes       | Tool Usage Statistics                    | Includes: tool name (should not include personal info), number of usage attempts (integer), LLM attributes used. No personal data.                                                                                                                                                                               |\n| Yes       | Test Execution Data                      | Includes: crew's randomly generated key and ID, number of iterations, model name used, quality score (float), execution time (in seconds). All non-personal.                                                                                                                                                     |\n| Yes       | Task Lifecycle Data                      | Includes: creation and execution start/end times, crew and task identifiers. Stored as spans with timestamps. No personal data.                                                                                                                                                                                  |\n| Yes       | LLM Attributes                           | Includes: name, model\\_name, model, top\\_k, temperature, and class name of the LLM. All technical, non-personal data.                                                                                                                                                                                            |\n| Yes       | Crew Deployment attempt using crewAI CLI | Includes: The fact a deploy is being made and crew id, and if it's trying to pull logs, no other data.                                                                                                                                                                                                           |\n| No        | Agent's Expanded Data                    | Includes: goal description, backstory text, i18n prompt file identifier. Users should ensure no personal info is included in text fields.                                                                                                                                                                        |\n| No        | Detailed Task Information                | Includes: task description, expected output description, context references. Users should ensure no personal info is included in these fields.                                                                                                                                                                   |\n| No        | Environment Information                  | Includes: platform, release, system, version, and CPU count. Example: 'Windows 10', 'x86\\_64'. No personal data.                                                                                                                                                                                                 |\n| No        | Crew and Task Inputs and Outputs         | Includes: input parameters and output results as non-identifiable data. Users should ensure no personal info is included.                                                                                                                                                                                        |\n| No        | Comprehensive Crew Execution Data        | Includes: detailed logs of crew operations, all agents and tasks data, final output. All non-personal and technical in nature.                                                                                                                                                                                   |",
      "title": "Data Explanation:",
      "type": "descriptive_text_oversized",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Telemetry",
          "level": 1
        },
        {
          "title": "Telemetry",
          "level": 2
        },
        {
          "title": "Data Explanation:",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Telemetry",
            "level": 1
          },
          {
            "title": "Telemetry",
            "level": 2
          },
          {
            "title": "Data Explanation:",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Telemetry > Telemetry > Data Explanation:"
      },
      "enhanced_content": "Context: Changelog > Telemetry > Telemetry > Data Explanation:\n\n### Data Explanation:\n\n| Defaulted | Data                                     | Reason and Specifics                                                                                                                                                                                                                                                                                             |\n| --------- | ---------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Yes       | CrewAI and Python Version                | Tracks software versions. Example: CrewAI v1.2.3, Python 3.8.10. No personal data.                                                                                                                                                                                                                               |\n| Yes       | Crew Metadata                            | Includes: randomly generated key and ID, process type (e.g., 'sequential', 'parallel'), boolean flag for memory usage (true/false), count of tasks, count of agents. All non-personal.                                                                                                                           |\n| Yes       | Agent Data                               | Includes: randomly generated key and ID, role name (should not include personal info), boolean settings (verbose, delegation enabled, code execution allowed), max iterations, max RPM, max retry limit, LLM info (see LLM Attributes), list of tool names (should not include personal info). No personal data. |\n| Yes       | Task Metadata                            | Includes: randomly generated key and ID, boolean execution settings (async\\_execution, human\\_input), associated agent's role and key, list of tool names. All non-personal.                                                                                                                                     |\n| Yes       | Tool Usage Statistics                    | Includes: tool name (should not include personal info), number of usage attempts (integer), LLM attributes used. No personal data.                                                                                                                                                                               |\n| Yes       | Test Execution Data                      | Includes: crew's randomly generated key and ID, number of iterations, model name used, quality score (float), execution time (in seconds). All non-personal.                                                                                                                                                     |\n| Yes       | Task Lifecycle Data                      | Includes: creation and execution start/end times, crew and task identifiers. Stored as spans with timestamps. No personal data.                                                                                                                                                                                  |\n| Yes       | LLM Attributes                           | Includes: name, model\\_name, model, top\\_k, temperature, and class name of the LLM. All technical, non-personal data.                                                                                                                                                                                            |\n| Yes       | Crew Deployment attempt using crewAI CLI | Includes: The fact a deploy is being made and crew id, and if it's trying to pull logs, no other data.                                                                                                                                                                                                           |\n| No        | Agent's Expanded Data                    | Includes: goal description, backstory text, i18n prompt file identifier. Users should ensure no personal info is included in text fields.                                                                                                                                                                        |\n| No        | Detailed Task Information                | Includes: task description, expected output description, context references. Users should ensure no personal info is included in these fields.                                                                                                                                                                   |\n| No        | Environment Information                  | Includes: platform, release, system, version, and CPU count. Example: 'Windows 10', 'x86\\_64'. No personal data.                                                                                                                                                                                                 |\n| No        | Crew and Task Inputs and Outputs         | Includes: input parameters and output results as non-identifiable data. Users should ensure no personal info is included.                                                                                                                                                                                        |\n| No        | Comprehensive Crew Execution Data        | Includes: detailed logs of crew operations, all agents and tasks data, final output. All non-personal and technical in nature.                                                                                                                                                                                   |",
      "formatted_path": "Changelog > Telemetry > Telemetry > Data Explanation:",
      "enhanced_text": "Context: Changelog > Telemetry > Telemetry > Data Explanation:\n\n Data Explanation:\n\n| Defaulted | Data                                     | Reason and Specifics                                                                                                                                                                                                                                                                                             |\n| --------- | ---------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Yes       | CrewAI and Python Version                | Tracks software versions. Example: CrewAI v1.2.3, Python 3.8.10. No personal data.                                                                                                                                                                                                                               |\n| Yes       | Crew Metadata                            | Includes: randomly generated key and ID, process type (e.g., 'sequential', 'parallel'), boolean flag for memory usage (true/false), count of tasks, count of agents. All non-personal.                                                                                                                           |\n| Yes       | Agent Data                               | Includes: randomly generated key and ID, role name (should not include personal info), boolean settings (verbose, delegation enabled, code execution allowed), max iterations, max RPM, max retry limit, LLM info (see LLM Attributes), list of tool names (should not include personal info). No personal data. |\n| Yes       | Task Metadata                            | Includes: randomly generated key and ID, boolean execution settings (async\\_execution, human\\_input), associated agent's role and key, list of tool names. All non-personal.                                                                                                                                     |\n| Yes       | Tool Usage Statistics                    | Includes: tool name (should not include personal info), number of usage attempts (integer), LLM attributes used. No personal data.                                                                                                                                                                               |\n| Yes       | Test Execution Data                      | Includes: crew's randomly generated key and ID, number of iterations, model name used, quality score (float), execution time (in seconds). All non-personal.                                                                                                                                                     |\n| Yes       | Task Lifecycle Data                      | Includes: creation and execution start/end times, crew and task identifiers. Stored as spans with timestamps. No personal data.                                                                                                                                                                                  |\n| Yes       | LLM Attributes                           | Includes: name, model\\_name, model, top\\_k, temperature, and class name of the LLM. All technical, non-personal data.                                                                                                                                                                                            |\n| Yes       | Crew Deployment attempt using crewAI CLI | Includes: The fact a deploy is being made and crew id, and if it's trying to pull logs, no other data.                                                                                                                                                                                                           |\n| No        | Agent's Expanded Data                    | Includes: goal description, backstory text, i18n prompt file identifier. Users should ensure no personal info is included in text fields.                                                                                                                                                                        |\n| No        | Detailed Task Information                | Includes: task description, expected output description, context references. Users should ensure no personal info is included in these fields.                                                                                                                                                                   |\n| No        | Environment Information                  | Includes: platform, release, system, version, and CPU count. Example: 'Windows 10', 'x86\\_64'. No personal data.                                                                                                                                                                                                 |\n| No        | Crew and Task Inputs and Outputs         | Includes: input parameters and output results as non-identifiable data. Users should ensure no personal info is included.                                                                                                                                                                                        |\n| No        | Comprehensive Crew Execution Data        | Includes: detailed logs of crew operations, all agents and tasks data, final output. All non-personal and technical in nature.                                                                                                                                                                                   |"
    },
    {
      "content": "Users can choose to share their complete telemetry data by enabling the `share_crew` attribute to `True` in their crew configurations.\nEnabling `share_crew` results in the collection of detailed crew and task execution data, including `goal`, `backstory`, `context`, and `output` of tasks.\nThis enables a deeper insight into usage patterns.",
      "title": "Opt-In Further Telemetry Sharing",
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Telemetry",
          "level": 1
        },
        {
          "title": "Telemetry",
          "level": 2
        },
        {
          "title": "Opt-In Further Telemetry Sharing",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Telemetry",
            "level": 1
          },
          {
            "title": "Telemetry",
            "level": 2
          },
          {
            "title": "Opt-In Further Telemetry Sharing",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Telemetry > Telemetry > Opt-In Further Telemetry Sharing"
      },
      "enhanced_content": "Context: Changelog > Telemetry > Telemetry > Opt-In Further Telemetry Sharing\n\n### Opt-In Further Telemetry Sharing\n\nUsers can choose to share their complete telemetry data by enabling the `share_crew` attribute to `True` in their crew configurations.\nEnabling `share_crew` results in the collection of detailed crew and task execution data, including `goal`, `backstory`, `context`, and `output` of tasks.\nThis enables a deeper insight into usage patterns.",
      "formatted_path": "Changelog > Telemetry > Telemetry > Opt-In Further Telemetry Sharing",
      "enhanced_text": "Context: Changelog > Telemetry > Telemetry > Opt-In Further Telemetry Sharing\n\n Opt-In Further Telemetry Sharing\n\nUsers can choose to share their complete telemetry data by enabling the `share_crew` attribute to `True` in their crew configurations.\nEnabling `share_crew` results in the collection of detailed crew and task execution data, including `goal`, `backstory`, `context`, and `output` of tasks.\nThis enables a deeper insight into usage patterns.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "Source: https://docs.crewai.com/tools/aimindtool The `AIMindTool` is designed to query data sources in natural language.",
      "title": "AI Mind Tool",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "AI Mind Tool",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "AI Mind Tool",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > AI Mind Tool"
      },
      "enhanced_content": "Context: Changelog > AI Mind Tool\n\n# AI Mind Tool\n\nSource: https://docs.crewai.com/tools/aimindtool The `AIMindTool` is designed to query data sources in natural language.",
      "formatted_path": "Changelog > AI Mind Tool",
      "enhanced_text": "Context: Changelog > AI Mind Tool\n\n AI Mind Tool\n\nSource: https://docs.crewai.com/tools/aimindtool The `AIMindTool` is designed to query data sources in natural language."
    },
    {
      "content": "Source: https://docs.crewai.com/tools/apifyactorstool `ApifyActorsTool` lets you call Apify Actors to provide your CrewAI workflows with web scraping, crawling, data extraction, and web automation capabilities.",
      "title": "Apify Actors",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Apify Actors",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Apify Actors",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Apify Actors"
      },
      "enhanced_content": "Context: Changelog > Apify Actors\n\n# Apify Actors\n\nSource: https://docs.crewai.com/tools/apifyactorstool `ApifyActorsTool` lets you call Apify Actors to provide your CrewAI workflows with web scraping, crawling, data extraction, and web automation capabilities.",
      "formatted_path": "Changelog > Apify Actors",
      "enhanced_text": "Context: Changelog > Apify Actors\n\n Apify Actors\n\nSource: https://docs.crewai.com/tools/apifyactorstool `ApifyActorsTool` lets you call Apify Actors to provide your CrewAI workflows with web scraping, crawling, data extraction, and web automation capabilities."
    },
    {
      "content": "Integrate [Apify Actors](https://apify.com/actors) into your CrewAI workflows.",
      "title": "`ApifyActorsTool`",
      "type": "link_list",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`ApifyActorsTool`",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`ApifyActorsTool`",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 1,
        "formatted_path": "Changelog > `ApifyActorsTool`"
      },
      "enhanced_content": "Context: Changelog > `ApifyActorsTool`\n\n# `ApifyActorsTool`\n\nIntegrate [Apify Actors](https://apify.com/actors) into your CrewAI workflows.",
      "formatted_path": "Changelog > `ApifyActorsTool`",
      "enhanced_text": "Context: Changelog > `ApifyActorsTool`\n\n `ApifyActorsTool`\n\nIntegrate [Apify Actors](https://apify.com/actors) into your CrewAI workflows."
    },
    {
      "content": "from crewai_tools import ApifyActorsTool\n\n# Initialize the tool with an Apify Actor\ntool = ApifyActorsTool(actor_name=\"apify/rag-web-browser\")\n\n# Run the tool with input parameters\nresults = tool.run(run_input={\"query\": \"What is CrewAI?\", \"maxResults\": 5})\n\n# Process the results\nfor result in results:\n    print(f\"URL: {result['metadata']['url']}\")\n    print(f\"Content: {result.get('markdown', 'N/A')[:100]}...\")",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`ApifyActorsTool`",
          "level": 1
        },
        {
          "title": "Usage example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`ApifyActorsTool`",
            "level": 1
          },
          {
            "title": "Usage example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `ApifyActorsTool` > Usage example"
      },
      "enhanced_content": "Context: Changelog > `ApifyActorsTool` > Usage example\n\nfrom crewai_tools import ApifyActorsTool\n\n# Initialize the tool with an Apify Actor\ntool = ApifyActorsTool(actor_name=\"apify/rag-web-browser\")\n\n# Run the tool with input parameters\nresults = tool.run(run_input={\"query\": \"What is CrewAI?\", \"maxResults\": 5})\n\n# Process the results\nfor result in results:\n    print(f\"URL: {result['metadata']['url']}\")\n    print(f\"Content: {result.get('markdown', 'N/A')[:100]}...\")",
      "formatted_path": "Changelog > `ApifyActorsTool` > Usage example",
      "enhanced_text": "Context: Changelog > `ApifyActorsTool` > Usage example\n\nfrom crewai_tools import ApifyActorsTool\n\n# Initialize the tool with an Apify Actor\ntool = ApifyActorsTool(actor_name=\"apify/rag-web-browser\")\n\n# Run the tool with input parameters\nresults = tool.run(run_input={\"query\": \"What is CrewAI?\", \"maxResults\": 5})\n\n# Process the results\nfor result in results:\n    print(f\"URL: {result['metadata']['url']}\")\n    print(f\"Content: {result.get('markdown', 'N/A')[:100]}...\")"
    },
    {
      "content": "URL: https://www.example.com/crewai-intro\nContent: CrewAI is a framework for building AI-powered workflows...\nURL: https://docs.crewai.com/\nContent: Official documentation for CrewAI...",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`ApifyActorsTool`",
          "level": 1
        },
        {
          "title": "Usage example",
          "level": 2
        },
        {
          "title": "Expected output",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`ApifyActorsTool`",
            "level": 1
          },
          {
            "title": "Usage example",
            "level": 2
          },
          {
            "title": "Expected output",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `ApifyActorsTool` > Usage example > Expected output"
      },
      "enhanced_content": "Context: Changelog > `ApifyActorsTool` > Usage example > Expected output\n\nURL: https://www.example.com/crewai-intro\nContent: CrewAI is a framework for building AI-powered workflows...\nURL: https://docs.crewai.com/\nContent: Official documentation for CrewAI...",
      "formatted_path": "Changelog > `ApifyActorsTool` > Usage example > Expected output",
      "enhanced_text": "Context: Changelog > `ApifyActorsTool` > Usage example > Expected output\n\nURL: https://www.example.com/crewai-intro\nContent: CrewAI is a framework for building AI-powered workflows...\nURL: https://docs.crewai.com/\nContent: Official documentation for CrewAI..."
    },
    {
      "content": "from crewai import Agent\nfrom crewai_tools import ApifyActorsTool\n\nrag_browser = ApifyActorsTool(actor_name=\"apify/rag-web-browser\")\n\nagent = Agent(\n    role=\"Research Analyst\",\n    goal=\"Find and summarize information about specific topics\",\n    backstory=\"You are an experienced researcher with attention to detail\",\n    tools=[rag_browser],\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`ApifyActorsTool`",
          "level": 1
        },
        {
          "title": "Usage example",
          "level": 2
        },
        {
          "title": "Expected output",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`ApifyActorsTool`",
            "level": 1
          },
          {
            "title": "Usage example",
            "level": 2
          },
          {
            "title": "Expected output",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `ApifyActorsTool` > Usage example > Expected output"
      },
      "enhanced_content": "Context: Changelog > `ApifyActorsTool` > Usage example > Expected output\n\nfrom crewai import Agent\nfrom crewai_tools import ApifyActorsTool\n\nrag_browser = ApifyActorsTool(actor_name=\"apify/rag-web-browser\")\n\nagent = Agent(\n    role=\"Research Analyst\",\n    goal=\"Find and summarize information about specific topics\",\n    backstory=\"You are an experienced researcher with attention to detail\",\n    tools=[rag_browser],\n)",
      "formatted_path": "Changelog > `ApifyActorsTool` > Usage example > Expected output",
      "enhanced_text": "Context: Changelog > `ApifyActorsTool` > Usage example > Expected output\n\nfrom crewai import Agent\nfrom crewai_tools import ApifyActorsTool\n\nrag_browser = ApifyActorsTool(actor_name=\"apify/rag-web-browser\")\n\nagent = Agent(\n    role=\"Research Analyst\",\n    goal=\"Find and summarize information about specific topics\",\n    backstory=\"You are an experienced researcher with attention to detail\",\n    tools=[rag_browser],\n)"
    },
    {
      "content": "The `ApifyActorsTool` requires these inputs to work: **`actor_name`**\nThe ID of the Apify Actor to run, e.g., `\"apify/rag-web-browser\"`. Browse all Actors on [Apify Store](https://apify.com/store). **`run_input`**\nA dictionary of input parameters for the Actor when running the tool manually. For example, for the `apify/rag-web-browser` Actor: `{\"query\": \"search term\", \"maxResults\": 5}` See the Actor's [input schema](https://apify.com/apify/rag-web-browser/input-schema) for the list of input parameters.",
      "title": "Configuration",
      "type": "link_list",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`ApifyActorsTool`",
          "level": 1
        },
        {
          "title": "Configuration",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`ApifyActorsTool`",
            "level": 1
          },
          {
            "title": "Configuration",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 2,
        "formatted_path": "Changelog > `ApifyActorsTool` > Configuration"
      },
      "enhanced_content": "Context: Changelog > `ApifyActorsTool` > Configuration\n\n## Configuration\n\nThe `ApifyActorsTool` requires these inputs to work: **`actor_name`**\nThe ID of the Apify Actor to run, e.g., `\"apify/rag-web-browser\"`. Browse all Actors on [Apify Store](https://apify.com/store). **`run_input`**\nA dictionary of input parameters for the Actor when running the tool manually. For example, for the `apify/rag-web-browser` Actor: `{\"query\": \"search term\", \"maxResults\": 5}` See the Actor's [input schema](https://apify.com/apify/rag-web-browser/input-schema) for the list of input parameters.",
      "formatted_path": "Changelog > `ApifyActorsTool` > Configuration",
      "enhanced_text": "Context: Changelog > `ApifyActorsTool` > Configuration\n\n Configuration\n\nThe `ApifyActorsTool` requires these inputs to work: **`actor_name`**\nThe ID of the Apify Actor to run, e.g., `\"apify/rag-web-browser\"`. Browse all Actors on [Apify Store](https://apify.com/store). **`run_input`**\nA dictionary of input parameters for the Actor when running the tool manually. For example, for the `apify/rag-web-browser` Actor: `{\"query\": \"search term\", \"maxResults\": 5}` See the Actor's [input schema](https://apify.com/apify/rag-web-browser/input-schema) for the list of input parameters.\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "[\ud83e\udd89 Opik Documentation](https://www.comet.com/docs/opik/) [\ud83d\udc49 Opik + CrewAI Colab](https://colab.research.google.com/github/comet-ml/opik/blob/main/apps/opik-documentation/documentation/docs/cookbook/crewai.ipynb) [\ud83d\udc26 X](https://x.com/cometml) [\ud83d\udcac Slack](https://slack.comet.com/)\n\n[\ud83d\udcd8 Portkey Documentation](https://docs.portkey.ai) [\ud83d\udcca Portkey Dashboard](https://app.portkey.ai/?utm_source=crewai\\&utm_medium=crewai\\&utm_campaign=crewai) [\ud83d\udc26 Twitter](https://twitter.com/portkeyai) [\ud83d\udcac Discord Community](https://discord.gg/DD7vgKK299)\n\n[\ud83d\udcd8 Weave Documentation](https://weave-docs.wandb.ai) [\ud83d\udcca Example Weave x CrewAI dashboard](https://wandb.ai/ayut/crewai_demo/weave/traces?cols=%7B%22wb_run_id%22%3Afalse%2C%22attributes.weave.client_version%22%3Afalse%2C%22attributes.weave.os_name%22%3Afalse%2C%22attributes.weave.os_release%22%3Afalse%2C%22attributes.weave.os_version%22%3Afalse%2C%22attributes.weave.source%22%3Afalse%2C%22attributes.weave.sys_version%22%3Afalse%7D\\&peekPath=%2Fayut%2Fcrewai_demo%2Fcalls%2F0195c838-38cb-71a2-8a15-651ecddf9d89) [\ud83d\udc26 X](https://x.com/weave_wb)\n\n**[Apify](https://apify.com/)**: Explore the Apify platform. **[How to build an AI agent on Apify](https://blog.apify.com/how-to-build-an-ai-agent/)** - A complete step-by-step guide to creating, publishing, and monetizing AI agents on the Apify platform. **[RAG Web Browser Actor](https://apify.com/apify/rag-web-browser)**: A popular Actor for web search for LLMs. **[CrewAI Integration Guide](https://docs.apify.com/platform/integrations/crewai)**: Follow the official guide for integrating Apify and CrewAI.",
      "title": "Resources",
      "type": "link_list",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`ApifyActorsTool`",
          "level": 1
        },
        {
          "title": "Resources",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`ApifyActorsTool`",
            "level": 1
          },
          {
            "title": "Resources",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 15,
        "formatted_path": "Changelog > `ApifyActorsTool` > Resources"
      },
      "enhanced_content": "Context: Changelog > `ApifyActorsTool` > Resources\n\n## Resources\n\n[\ud83e\udd89 Opik Documentation](https://www.comet.com/docs/opik/) [\ud83d\udc49 Opik + CrewAI Colab](https://colab.research.google.com/github/comet-ml/opik/blob/main/apps/opik-documentation/documentation/docs/cookbook/crewai.ipynb) [\ud83d\udc26 X](https://x.com/cometml) [\ud83d\udcac Slack](https://slack.comet.com/)\n\n[\ud83d\udcd8 Portkey Documentation](https://docs.portkey.ai) [\ud83d\udcca Portkey Dashboard](https://app.portkey.ai/?utm_source=crewai\\&utm_medium=crewai\\&utm_campaign=crewai) [\ud83d\udc26 Twitter](https://twitter.com/portkeyai) [\ud83d\udcac Discord Community](https://discord.gg/DD7vgKK299)\n\n[\ud83d\udcd8 Weave Documentation](https://weave-docs.wandb.ai) [\ud83d\udcca Example Weave x CrewAI dashboard](https://wandb.ai/ayut/crewai_demo/weave/traces?cols=%7B%22wb_run_id%22%3Afalse%2C%22attributes.weave.client_version%22%3Afalse%2C%22attributes.weave.os_name%22%3Afalse%2C%22attributes.weave.os_release%22%3Afalse%2C%22attributes.weave.os_version%22%3Afalse%2C%22attributes.weave.source%22%3Afalse%2C%22attributes.weave.sys_version%22%3Afalse%7D\\&peekPath=%2Fayut%2Fcrewai_demo%2Fcalls%2F0195c838-38cb-71a2-8a15-651ecddf9d89) [\ud83d\udc26 X](https://x.com/weave_wb)\n\n**[Apify](https://apify.com/)**: Explore the Apify platform. **[How to build an AI agent on Apify](https://blog.apify.com/how-to-build-an-ai-agent/)** - A complete step-by-step guide to creating, publishing, and monetizing AI agents on the Apify platform. **[RAG Web Browser Actor](https://apify.com/apify/rag-web-browser)**: A popular Actor for web search for LLMs. **[CrewAI Integration Guide](https://docs.apify.com/platform/integrations/crewai)**: Follow the official guide for integrating Apify and CrewAI.",
      "formatted_path": "Changelog > `ApifyActorsTool` > Resources",
      "enhanced_text": "Context: Changelog > `ApifyActorsTool` > Resources\n\n Resources\n\n[\ud83e\udd89 Opik Documentation](https://www.comet.com/docs/opik/) [\ud83d\udc49 Opik + CrewAI Colab](https://colab.research.google.com/github/comet-ml/opik/blob/main/apps/opik-documentation/documentation/docs/cookbook/crewai.ipynb) [\ud83d\udc26 X](https://x.com/cometml) [\ud83d\udcac Slack](https://slack.comet.com/)\n\n[\ud83d\udcd8 Portkey Documentation](https://docs.portkey.ai) [\ud83d\udcca Portkey Dashboard](https://app.portkey.ai/?utm_source=crewai\\&utm_medium=crewai\\&utm_campaign=crewai) [\ud83d\udc26 Twitter](https://twitter.com/portkeyai) [\ud83d\udcac Discord Community](https://discord.gg/DD7vgKK299)\n\n[\ud83d\udcd8 Weave Documentation](https://weave-docs.wandb.ai) [\ud83d\udcca Example Weave x CrewAI dashboard](https://wandb.ai/ayut/crewai_demo/weave/traces?cols=%7B%22wb_run_id%22%3Afalse%2C%22attributes.weave.client_version%22%3Afalse%2C%22attributes.weave.os_name%22%3Afalse%2C%22attributes.weave.os_release%22%3Afalse%2C%22attributes.weave.os_version%22%3Afalse%2C%22attributes.weave.source%22%3Afalse%2C%22attributes.weave.sys_version%22%3Afalse%7D\\&peekPath=%2Fayut%2Fcrewai_demo%2Fcalls%2F0195c838-38cb-71a2-8a15-651ecddf9d89) [\ud83d\udc26 X](https://x.com/weave_wb)\n\n**[Apify](https://apify.com/)**: Explore the Apify platform. **[How to build an AI agent on Apify](https://blog.apify.com/how-to-build-an-ai-agent/)** - A complete step-by-step guide to creating, publishing, and monetizing AI agents on the Apify platform. **[RAG Web Browser Actor](https://apify.com/apify/rag-web-browser)**: A popular Actor for web search for LLMs. **[CrewAI Integration Guide](https://docs.apify.com/platform/integrations/crewai)**: Follow the official guide for integrating Apify and CrewAI."
    },
    {
      "content": "Source: https://docs.crewai.com/tools/bedrockinvokeagenttool Enables CrewAI agents to invoke Amazon Bedrock Agents and leverage their capabilities within your workflows",
      "title": "Bedrock Invoke Agent Tool",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Bedrock Invoke Agent Tool",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Bedrock Invoke Agent Tool",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Bedrock Invoke Agent Tool"
      },
      "enhanced_content": "Context: Changelog > Bedrock Invoke Agent Tool\n\n# Bedrock Invoke Agent Tool\n\nSource: https://docs.crewai.com/tools/bedrockinvokeagenttool Enables CrewAI agents to invoke Amazon Bedrock Agents and leverage their capabilities within your workflows",
      "formatted_path": "Changelog > Bedrock Invoke Agent Tool",
      "enhanced_text": "Context: Changelog > Bedrock Invoke Agent Tool\n\n Bedrock Invoke Agent Tool\n\nSource: https://docs.crewai.com/tools/bedrockinvokeagenttool Enables CrewAI agents to invoke Amazon Bedrock Agents and leverage their capabilities within your workflows"
    },
    {
      "content": "The `BedrockInvokeAgentTool` enables CrewAI agents to invoke Amazon Bedrock Agents and leverage their capabilities within your workflows.",
      "title": "`BedrockInvokeAgentTool`",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`BedrockInvokeAgentTool`",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`BedrockInvokeAgentTool`",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `BedrockInvokeAgentTool`"
      },
      "enhanced_content": "Context: Changelog > `BedrockInvokeAgentTool`\n\n# `BedrockInvokeAgentTool`\n\nThe `BedrockInvokeAgentTool` enables CrewAI agents to invoke Amazon Bedrock Agents and leverage their capabilities within your workflows.",
      "formatted_path": "Changelog > `BedrockInvokeAgentTool`",
      "enhanced_text": "Context: Changelog > `BedrockInvokeAgentTool`\n\n `BedrockInvokeAgentTool`\n\nThe `BedrockInvokeAgentTool` enables CrewAI agents to invoke Amazon Bedrock Agents and leverage their capabilities within your workflows."
    },
    {
      "content": "from crewai import Agent, Task, Crew, Process\nfrom crewai_tools.aws.bedrock.agents.invoke_agent_tool import BedrockInvokeAgentTool\n\n# Initialize tools with session management\ninitial_tool = BedrockInvokeAgentTool(\n    agent_id=\"your-agent-id\",\n    agent_alias_id=\"your-agent-alias-id\",\n    session_id=\"custom-session-id\"\n)\n\nfollowup_tool = BedrockInvokeAgentTool(\n    agent_id=\"your-agent-id\",\n    agent_alias_id=\"your-agent-alias-id\",\n    session_id=\"custom-session-id\"\n)\n\nfinal_tool = BedrockInvokeAgentTool(\n    agent_id=\"your-agent-id\",\n    agent_alias_id=\"your-agent-alias-id\",\n    session_id=\"custom-session-id\",\n    end_session=True\n)\n\n# Create agents for different stages\nresearcher = Agent(\n    role='AWS Service Researcher',\n    goal='Gather information about AWS services',\n    backstory='I am specialized in finding detailed AWS service information.',\n    tools=[initial_tool]\n)\n\nanalyst = Agent(\n    role='Service Compatibility Analyst',\n    goal='Analyze service compatibility and requirements',\n    backstory='I analyze AWS services for compatibility and integration possibilities.',\n    tools=[followup_tool]\n)\n\nsummarizer = Agent(\n    role='Technical Documentation Writer',\n    goal='Create clear technical summaries',\n    backstory='I specialize in creating clear, concise technical documentation.',\n    tools=[final_tool]\n)\n\n# Create tasks\nresearch_task = Task(\n    description=\"Find all available AWS services in us-west-2 region.\",\n    agent=researcher\n)\n\nanalysis_task = Task(\n    description=\"Analyze which services support IPv6 and their implementation requirements.\",\n    agent=analyst\n)\n\nsummary_task = Task(\n    description=\"Create a summary of IPv6-compatible services and their key features.\",\n    agent=summarizer\n)\n\n# Create a crew with the agents and tasks\ncrew = Crew(\n    agents=[researcher, analyst, summarizer],\n    tasks=[research_task, analysis_task, summary_task],\n    process=Process.sequential,\n    verbose=2\n)\n\n# Run the crew\nresult = crew.kickoff()",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`BedrockInvokeAgentTool`",
          "level": 1
        },
        {
          "title": "Advanced Usage",
          "level": 2
        },
        {
          "title": "Multi-Agent Workflow with Session Management",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`BedrockInvokeAgentTool`",
            "level": 1
          },
          {
            "title": "Advanced Usage",
            "level": 2
          },
          {
            "title": "Multi-Agent Workflow with Session Management",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `BedrockInvokeAgentTool` > Advanced Usage > Multi-Agent Workflow with Session Management"
      },
      "enhanced_content": "Context: Changelog > `BedrockInvokeAgentTool` > Advanced Usage > Multi-Agent Workflow with Session Management\n\nfrom crewai import Agent, Task, Crew, Process\nfrom crewai_tools.aws.bedrock.agents.invoke_agent_tool import BedrockInvokeAgentTool\n\n# Initialize tools with session management\ninitial_tool = BedrockInvokeAgentTool(\n    agent_id=\"your-agent-id\",\n    agent_alias_id=\"your-agent-alias-id\",\n    session_id=\"custom-session-id\"\n)\n\nfollowup_tool = BedrockInvokeAgentTool(\n    agent_id=\"your-agent-id\",\n    agent_alias_id=\"your-agent-alias-id\",\n    session_id=\"custom-session-id\"\n)\n\nfinal_tool = BedrockInvokeAgentTool(\n    agent_id=\"your-agent-id\",\n    agent_alias_id=\"your-agent-alias-id\",\n    session_id=\"custom-session-id\",\n    end_session=True\n)\n\n# Create agents for different stages\nresearcher = Agent(\n    role='AWS Service Researcher',\n    goal='Gather information about AWS services',\n    backstory='I am specialized in finding detailed AWS service information.',\n    tools=[initial_tool]\n)\n\nanalyst = Agent(\n    role='Service Compatibility Analyst',\n    goal='Analyze service compatibility and requirements',\n    backstory='I analyze AWS services for compatibility and integration possibilities.',\n    tools=[followup_tool]\n)\n\nsummarizer = Agent(\n    role='Technical Documentation Writer',\n    goal='Create clear technical summaries',\n    backstory='I specialize in creating clear, concise technical documentation.',\n    tools=[final_tool]\n)\n\n# Create tasks\nresearch_task = Task(\n    description=\"Find all available AWS services in us-west-2 region.\",\n    agent=researcher\n)\n\nanalysis_task = Task(\n    description=\"Analyze which services support IPv6 and their implementation requirements.\",\n    agent=analyst\n)\n\nsummary_task = Task(\n    description=\"Create a summary of IPv6-compatible services and their key features.\",\n    agent=summarizer\n)\n\n# Create a crew with the agents and tasks\ncrew = Crew(\n    agents=[researcher, analyst, summarizer],\n    tasks=[research_task, analysis_task, summary_task],\n    process=Process.sequential,\n    verbose=2\n)\n\n# Run the crew\nresult = crew.kickoff()",
      "formatted_path": "Changelog > `BedrockInvokeAgentTool` > Advanced Usage > Multi-Agent Workflow with Session Management",
      "enhanced_text": "Context: Changelog > `BedrockInvokeAgentTool` > Advanced Usage > Multi-Agent Workflow with Session Management\n\nfrom crewai import Agent, Task, Crew, Process\nfrom crewai_tools.aws.bedrock.agents.invoke_agent_tool import BedrockInvokeAgentTool\n\n# Initialize tools with session management\ninitial_tool = BedrockInvokeAgentTool(\n    agent_id=\"your-agent-id\",\n    agent_alias_id=\"your-agent-alias-id\",\n    session_id=\"custom-session-id\"\n)\n\nfollowup_tool = BedrockInvokeAgentTool(\n    agent_id=\"your-agent-id\",\n    agent_alias_id=\"your-agent-alias-id\",\n    session_id=\"custom-session-id\"\n)\n\nfinal_tool = BedrockInvokeAgentTool(\n    agent_id=\"your-agent-id\",\n    agent_alias_id=\"your-agent-alias-id\",\n    session_id=\"custom-session-id\",\n    end_session=True\n)\n\n# Create agents for different stages\nresearcher = Agent(\n    role='AWS Service Researcher',\n    goal='Gather information about AWS services',\n    backstory='I am specialized in finding detailed AWS service information.',\n    tools=[initial_tool]\n)\n\nanalyst = Agent(\n    role='Service Compatibility Analyst',\n    goal='Analyze service compatibility and requirements',\n    backstory='I analyze AWS services for compatibility and integration possibilities.',\n    tools=[followup_tool]\n)\n\nsummarizer = Agent(\n    role='Technical Documentation Writer',\n    goal='Create clear technical summaries',\n    backstory='I specialize in creating clear, concise technical documentation.',\n    tools=[final_tool]\n)\n\n# Create tasks\nresearch_task = Task(\n    description=\"Find all available AWS services in us-west-2 region.\",\n    agent=researcher\n)\n\nanalysis_task = Task(\n    description=\"Analyze which services support IPv6 and their implementation requirements.\",\n    agent=analyst\n)\n\nsummary_task = Task(\n    description=\"Create a summary of IPv6-compatible services and their key features.\",\n    agent=summarizer\n)\n\n# Create a crew with the agents and tasks\ncrew = Crew(\n    agents=[researcher, analyst, summarizer],\n    tasks=[research_task, analysis_task, summary_task],\n    process=Process.sequential,\n    verbose=2\n)\n\n# Run the crew\nresult = crew.kickoff()"
    },
    {
      "content": "Create workflows where CrewAI agents collaborate with managed Bedrock agents running as services in AWS Enable scenarios where sensitive data processing happens within your AWS environment while other agents operate externally Bridge on-premises CrewAI agents with cloud-based Bedrock agents for distributed intelligence workflows",
      "title": "Hybrid Multi-Agent Collaborations",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`BedrockInvokeAgentTool`",
          "level": 1
        },
        {
          "title": "Use Cases",
          "level": 2
        },
        {
          "title": "Hybrid Multi-Agent Collaborations",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`BedrockInvokeAgentTool`",
            "level": 1
          },
          {
            "title": "Use Cases",
            "level": 2
          },
          {
            "title": "Hybrid Multi-Agent Collaborations",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `BedrockInvokeAgentTool` > Use Cases > Hybrid Multi-Agent Collaborations"
      },
      "enhanced_content": "Context: Changelog > `BedrockInvokeAgentTool` > Use Cases > Hybrid Multi-Agent Collaborations\n\n### Hybrid Multi-Agent Collaborations\n\nCreate workflows where CrewAI agents collaborate with managed Bedrock agents running as services in AWS Enable scenarios where sensitive data processing happens within your AWS environment while other agents operate externally Bridge on-premises CrewAI agents with cloud-based Bedrock agents for distributed intelligence workflows",
      "formatted_path": "Changelog > `BedrockInvokeAgentTool` > Use Cases > Hybrid Multi-Agent Collaborations",
      "enhanced_text": "Context: Changelog > `BedrockInvokeAgentTool` > Use Cases > Hybrid Multi-Agent Collaborations\n\n Hybrid Multi-Agent Collaborations\n\nCreate workflows where CrewAI agents collaborate with managed Bedrock agents running as services in AWS Enable scenarios where sensitive data processing happens within your AWS environment while other agents operate externally Bridge on-premises CrewAI agents with cloud-based Bedrock agents for distributed intelligence workflows\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "Keep data-sensitive agentic workflows within your AWS environment while allowing external CrewAI agents to orchestrate tasks Maintain compliance with data residency requirements by processing sensitive information only within your AWS account Enable secure multi-agent collaborations where some agents cannot access your organization's private data",
      "title": "Data Sovereignty and Compliance",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`BedrockInvokeAgentTool`",
          "level": 1
        },
        {
          "title": "Use Cases",
          "level": 2
        },
        {
          "title": "Data Sovereignty and Compliance",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`BedrockInvokeAgentTool`",
            "level": 1
          },
          {
            "title": "Use Cases",
            "level": 2
          },
          {
            "title": "Data Sovereignty and Compliance",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `BedrockInvokeAgentTool` > Use Cases > Data Sovereignty and Compliance"
      },
      "enhanced_content": "Context: Changelog > `BedrockInvokeAgentTool` > Use Cases > Data Sovereignty and Compliance\n\n### Data Sovereignty and Compliance\n\nKeep data-sensitive agentic workflows within your AWS environment while allowing external CrewAI agents to orchestrate tasks Maintain compliance with data residency requirements by processing sensitive information only within your AWS account Enable secure multi-agent collaborations where some agents cannot access your organization's private data",
      "formatted_path": "Changelog > `BedrockInvokeAgentTool` > Use Cases > Data Sovereignty and Compliance",
      "enhanced_text": "Context: Changelog > `BedrockInvokeAgentTool` > Use Cases > Data Sovereignty and Compliance\n\n Data Sovereignty and Compliance\n\nKeep data-sensitive agentic workflows within your AWS environment while allowing external CrewAI agents to orchestrate tasks Maintain compliance with data residency requirements by processing sensitive information only within your AWS account Enable secure multi-agent collaborations where some agents cannot access your organization's private data"
    },
    {
      "content": "Access any AWS service through Amazon Bedrock Actions without writing complex integration code Enable CrewAI agents to interact with AWS services through natural language requests Leverage pre-built Bedrock agent capabilities to interact with AWS services like Bedrock Knowledge Bases, Lambda, and more",
      "title": "Seamless AWS Service Integration",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`BedrockInvokeAgentTool`",
          "level": 1
        },
        {
          "title": "Use Cases",
          "level": 2
        },
        {
          "title": "Seamless AWS Service Integration",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`BedrockInvokeAgentTool`",
            "level": 1
          },
          {
            "title": "Use Cases",
            "level": 2
          },
          {
            "title": "Seamless AWS Service Integration",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `BedrockInvokeAgentTool` > Use Cases > Seamless AWS Service Integration"
      },
      "enhanced_content": "Context: Changelog > `BedrockInvokeAgentTool` > Use Cases > Seamless AWS Service Integration\n\n### Seamless AWS Service Integration\n\nAccess any AWS service through Amazon Bedrock Actions without writing complex integration code Enable CrewAI agents to interact with AWS services through natural language requests Leverage pre-built Bedrock agent capabilities to interact with AWS services like Bedrock Knowledge Bases, Lambda, and more",
      "formatted_path": "Changelog > `BedrockInvokeAgentTool` > Use Cases > Seamless AWS Service Integration",
      "enhanced_text": "Context: Changelog > `BedrockInvokeAgentTool` > Use Cases > Seamless AWS Service Integration\n\n Seamless AWS Service Integration\n\nAccess any AWS service through Amazon Bedrock Actions without writing complex integration code Enable CrewAI agents to interact with AWS services through natural language requests Leverage pre-built Bedrock agent capabilities to interact with AWS services like Bedrock Knowledge Bases, Lambda, and more"
    },
    {
      "content": "Offload computationally intensive tasks to managed Bedrock agents while lightweight tasks run in CrewAI Scale agent processing by distributing workloads between local CrewAI agents and cloud-based Bedrock agents",
      "title": "Scalable Hybrid Agent Architectures",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`BedrockInvokeAgentTool`",
          "level": 1
        },
        {
          "title": "Use Cases",
          "level": 2
        },
        {
          "title": "Scalable Hybrid Agent Architectures",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`BedrockInvokeAgentTool`",
            "level": 1
          },
          {
            "title": "Use Cases",
            "level": 2
          },
          {
            "title": "Scalable Hybrid Agent Architectures",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `BedrockInvokeAgentTool` > Use Cases > Scalable Hybrid Agent Architectures"
      },
      "enhanced_content": "Context: Changelog > `BedrockInvokeAgentTool` > Use Cases > Scalable Hybrid Agent Architectures\n\n### Scalable Hybrid Agent Architectures\n\nOffload computationally intensive tasks to managed Bedrock agents while lightweight tasks run in CrewAI Scale agent processing by distributing workloads between local CrewAI agents and cloud-based Bedrock agents",
      "formatted_path": "Changelog > `BedrockInvokeAgentTool` > Use Cases > Scalable Hybrid Agent Architectures",
      "enhanced_text": "Context: Changelog > `BedrockInvokeAgentTool` > Use Cases > Scalable Hybrid Agent Architectures\n\n Scalable Hybrid Agent Architectures\n\nOffload computationally intensive tasks to managed Bedrock agents while lightweight tasks run in CrewAI Scale agent processing by distributing workloads between local CrewAI agents and cloud-based Bedrock agents"
    },
    {
      "content": "Enable secure collaboration between your organization's CrewAI agents and partner organizations' Bedrock agents Create workflows where external expertise from Bedrock agents can be incorporated without exposing sensitive data Build agent ecosystems that span organizational boundaries while maintaining security and data control",
      "title": "Cross-Organizational Agent Collaboration",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`BedrockInvokeAgentTool`",
          "level": 1
        },
        {
          "title": "Use Cases",
          "level": 2
        },
        {
          "title": "Cross-Organizational Agent Collaboration",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`BedrockInvokeAgentTool`",
            "level": 1
          },
          {
            "title": "Use Cases",
            "level": 2
          },
          {
            "title": "Cross-Organizational Agent Collaboration",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `BedrockInvokeAgentTool` > Use Cases > Cross-Organizational Agent Collaboration"
      },
      "enhanced_content": "Context: Changelog > `BedrockInvokeAgentTool` > Use Cases > Cross-Organizational Agent Collaboration\n\n### Cross-Organizational Agent Collaboration\n\nEnable secure collaboration between your organization's CrewAI agents and partner organizations' Bedrock agents Create workflows where external expertise from Bedrock agents can be incorporated without exposing sensitive data Build agent ecosystems that span organizational boundaries while maintaining security and data control",
      "formatted_path": "Changelog > `BedrockInvokeAgentTool` > Use Cases > Cross-Organizational Agent Collaboration",
      "enhanced_text": "Context: Changelog > `BedrockInvokeAgentTool` > Use Cases > Cross-Organizational Agent Collaboration\n\n Cross-Organizational Agent Collaboration\n\nEnable secure collaboration between your organization's CrewAI agents and partner organizations' Bedrock agents Create workflows where external expertise from Bedrock agents can be incorporated without exposing sensitive data Build agent ecosystems that span organizational boundaries while maintaining security and data control\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "Source: https://docs.crewai.com/tools/bedrockkbretriever Retrieve information from Amazon Bedrock Knowledge Bases using natural language queries",
      "title": "Bedrock Knowledge Base Retriever",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Bedrock Knowledge Base Retriever",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Bedrock Knowledge Base Retriever",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Bedrock Knowledge Base Retriever"
      },
      "enhanced_content": "Context: Changelog > Bedrock Knowledge Base Retriever\n\n# Bedrock Knowledge Base Retriever\n\nSource: https://docs.crewai.com/tools/bedrockkbretriever Retrieve information from Amazon Bedrock Knowledge Bases using natural language queries",
      "formatted_path": "Changelog > Bedrock Knowledge Base Retriever",
      "enhanced_text": "Context: Changelog > Bedrock Knowledge Base Retriever\n\n Bedrock Knowledge Base Retriever\n\nSource: https://docs.crewai.com/tools/bedrockkbretriever Retrieve information from Amazon Bedrock Knowledge Bases using natural language queries\n\nRelated sections:\n- \n"
    },
    {
      "content": "The `BedrockKBRetrieverTool` enables CrewAI agents to retrieve information from Amazon Bedrock Knowledge Bases using natural language queries.",
      "title": "`BedrockKBRetrieverTool`",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`BedrockKBRetrieverTool`",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`BedrockKBRetrieverTool`",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `BedrockKBRetrieverTool`"
      },
      "enhanced_content": "Context: Changelog > `BedrockKBRetrieverTool`\n\n# `BedrockKBRetrieverTool`\n\nThe `BedrockKBRetrieverTool` enables CrewAI agents to retrieve information from Amazon Bedrock Knowledge Bases using natural language queries.",
      "formatted_path": "Changelog > `BedrockKBRetrieverTool`",
      "enhanced_text": "Context: Changelog > `BedrockKBRetrieverTool`\n\n `BedrockKBRetrieverTool`\n\nThe `BedrockKBRetrieverTool` enables CrewAI agents to retrieve information from Amazon Bedrock Knowledge Bases using natural language queries."
    },
    {
      "content": "| Argument             | Type   | Required | Default   | Description                                 |\n| :------------------- | :----- | :------- | :-------- | :------------------------------------------ |\n| **agent\\_id**        | `str`  | Yes      | None      | The unique identifier of the Bedrock agent  |\n| **agent\\_alias\\_id** | `str`  | Yes      | None      | The unique identifier of the agent alias    |\n| **session\\_id**      | `str`  | No       | timestamp | The unique identifier of the session        |\n| **enable\\_trace**    | `bool` | No       | False     | Whether to enable trace for debugging       |\n| **end\\_session**     | `bool` | No       | False     | Whether to end the session after invocation |\n| **description**      | `str`  | No       | None      | Custom description for the tool             |",
      "title": "Tool Arguments",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`BedrockKBRetrieverTool`",
          "level": 1
        },
        {
          "title": "Tool Arguments",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`BedrockKBRetrieverTool`",
            "level": 1
          },
          {
            "title": "Tool Arguments",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `BedrockKBRetrieverTool` > Tool Arguments"
      },
      "enhanced_content": "Context: Changelog > `BedrockKBRetrieverTool` > Tool Arguments\n\n## Tool Arguments\n\n| Argument             | Type   | Required | Default   | Description                                 |\n| :------------------- | :----- | :------- | :-------- | :------------------------------------------ |\n| **agent\\_id**        | `str`  | Yes      | None      | The unique identifier of the Bedrock agent  |\n| **agent\\_alias\\_id** | `str`  | Yes      | None      | The unique identifier of the agent alias    |\n| **session\\_id**      | `str`  | No       | timestamp | The unique identifier of the session        |\n| **enable\\_trace**    | `bool` | No       | False     | Whether to enable trace for debugging       |\n| **end\\_session**     | `bool` | No       | False     | Whether to end the session after invocation |\n| **description**      | `str`  | No       | None      | Custom description for the tool             |",
      "formatted_path": "Changelog > `BedrockKBRetrieverTool` > Tool Arguments",
      "enhanced_text": "Context: Changelog > `BedrockKBRetrieverTool` > Tool Arguments\n\n Tool Arguments\n\n| Argument             | Type   | Required | Default   | Description                                 |\n| :------------------- | :----- | :------- | :-------- | :------------------------------------------ |\n| **agent\\_id**        | `str`  | Yes      | None      | The unique identifier of the Bedrock agent  |\n| **agent\\_alias\\_id** | `str`  | Yes      | None      | The unique identifier of the agent alias    |\n| **session\\_id**      | `str`  | No       | timestamp | The unique identifier of the session        |\n| **enable\\_trace**    | `bool` | No       | False     | Whether to enable trace for debugging       |\n| **end\\_session**     | `bool` | No       | False     | Whether to end the session after invocation |\n| **description**      | `str`  | No       | None      | Custom description for the tool             |\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "| Argument                     | Type   | Required | Default | Description                                                                |\n| :--------------------------- | :----- | :------- | :------ | :------------------------------------------------------------------------- |\n| **knowledge\\_base\\_id**      | `str`  | Yes      | None    | The unique identifier of the knowledge base (0-10 alphanumeric characters) |\n| **number\\_of\\_results**      | `int`  | No       | 5       | Maximum number of results to return                                        |\n| **retrieval\\_configuration** | `dict` | No       | None    | Custom configurations for the knowledge base query                         |\n| **guardrail\\_configuration** | `dict` | No       | None    | Content filtering settings                                                 |\n| **next\\_token**              | `str`  | No       | None    | Token for pagination                                                       |",
      "title": "Tool Arguments",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`BedrockKBRetrieverTool`",
          "level": 1
        },
        {
          "title": "Tool Arguments",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`BedrockKBRetrieverTool`",
            "level": 1
          },
          {
            "title": "Tool Arguments",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `BedrockKBRetrieverTool` > Tool Arguments"
      },
      "enhanced_content": "Context: Changelog > `BedrockKBRetrieverTool` > Tool Arguments\n\n## Tool Arguments\n\n| Argument                     | Type   | Required | Default | Description                                                                |\n| :--------------------------- | :----- | :------- | :------ | :------------------------------------------------------------------------- |\n| **knowledge\\_base\\_id**      | `str`  | Yes      | None    | The unique identifier of the knowledge base (0-10 alphanumeric characters) |\n| **number\\_of\\_results**      | `int`  | No       | 5       | Maximum number of results to return                                        |\n| **retrieval\\_configuration** | `dict` | No       | None    | Custom configurations for the knowledge base query                         |\n| **guardrail\\_configuration** | `dict` | No       | None    | Content filtering settings                                                 |\n| **next\\_token**              | `str`  | No       | None    | Token for pagination                                                       |",
      "formatted_path": "Changelog > `BedrockKBRetrieverTool` > Tool Arguments",
      "enhanced_text": "Context: Changelog > `BedrockKBRetrieverTool` > Tool Arguments\n\n Tool Arguments\n\n| Argument                     | Type   | Required | Default | Description                                                                |\n| :--------------------------- | :----- | :------- | :------ | :------------------------------------------------------------------------- |\n| **knowledge\\_base\\_id**      | `str`  | Yes      | None    | The unique identifier of the knowledge base (0-10 alphanumeric characters) |\n| **number\\_of\\_results**      | `int`  | No       | 5       | Maximum number of results to return                                        |\n| **retrieval\\_configuration** | `dict` | No       | None    | Custom configurations for the knowledge base query                         |\n| **guardrail\\_configuration** | `dict` | No       | None    | Content filtering settings                                                 |\n| **next\\_token**              | `str`  | No       | None    | Token for pagination                                                       |\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "{\n  \"results\": [\n    {\n      \"content\": \"Retrieved text content\",\n      \"content_type\": \"text\",\n      \"source_type\": \"S3\",\n      \"source_uri\": \"s3://bucket/document.pdf\",\n      \"score\": 0.95,\n      \"metadata\": {\n        \"additional\": \"metadata\"\n      }\n    }\n  ],\n  \"nextToken\": \"pagination-token\",\n  \"guardrailAction\": \"NONE\"\n}",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`BedrockKBRetrieverTool`",
          "level": 1
        },
        {
          "title": "Response Format",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`BedrockKBRetrieverTool`",
            "level": 1
          },
          {
            "title": "Response Format",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `BedrockKBRetrieverTool` > Response Format"
      },
      "enhanced_content": "Context: Changelog > `BedrockKBRetrieverTool` > Response Format\n\n{\n  \"results\": [\n    {\n      \"content\": \"Retrieved text content\",\n      \"content_type\": \"text\",\n      \"source_type\": \"S3\",\n      \"source_uri\": \"s3://bucket/document.pdf\",\n      \"score\": 0.95,\n      \"metadata\": {\n        \"additional\": \"metadata\"\n      }\n    }\n  ],\n  \"nextToken\": \"pagination-token\",\n  \"guardrailAction\": \"NONE\"\n}",
      "formatted_path": "Changelog > `BedrockKBRetrieverTool` > Response Format",
      "enhanced_text": "Context: Changelog > `BedrockKBRetrieverTool` > Response Format\n\n{\n  \"results\": [\n    {\n      \"content\": \"Retrieved text content\",\n      \"content_type\": \"text\",\n      \"source_type\": \"S3\",\n      \"source_uri\": \"s3://bucket/document.pdf\",\n      \"score\": 0.95,\n      \"metadata\": {\n        \"additional\": \"metadata\"\n      }\n    }\n  ],\n  \"nextToken\": \"pagination-token\",\n  \"guardrailAction\": \"NONE\"\n}"
    },
    {
      "content": "kb_tool = BedrockKBRetrieverTool(\n    knowledge_base_id=\"your-kb-id\",\n    retrieval_configuration={\n        \"vectorSearchConfiguration\": {\n            \"numberOfResults\": 10,\n            \"overrideSearchType\": \"HYBRID\"\n        }\n    }\n)\n\npolicy_expert = Agent(\n    role='Policy Expert',\n    goal='Analyze company policies in detail',\n    backstory='I am an expert in corporate policy analysis with deep knowledge of regulatory requirements.',\n    tools=[kb_tool]\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`BedrockKBRetrieverTool`",
          "level": 1
        },
        {
          "title": "Advanced Usage",
          "level": 2
        },
        {
          "title": "Custom Retrieval Configuration",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`BedrockKBRetrieverTool`",
            "level": 1
          },
          {
            "title": "Advanced Usage",
            "level": 2
          },
          {
            "title": "Custom Retrieval Configuration",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `BedrockKBRetrieverTool` > Advanced Usage > Custom Retrieval Configuration"
      },
      "enhanced_content": "Context: Changelog > `BedrockKBRetrieverTool` > Advanced Usage > Custom Retrieval Configuration\n\nkb_tool = BedrockKBRetrieverTool(\n    knowledge_base_id=\"your-kb-id\",\n    retrieval_configuration={\n        \"vectorSearchConfiguration\": {\n            \"numberOfResults\": 10,\n            \"overrideSearchType\": \"HYBRID\"\n        }\n    }\n)\n\npolicy_expert = Agent(\n    role='Policy Expert',\n    goal='Analyze company policies in detail',\n    backstory='I am an expert in corporate policy analysis with deep knowledge of regulatory requirements.',\n    tools=[kb_tool]\n)",
      "formatted_path": "Changelog > `BedrockKBRetrieverTool` > Advanced Usage > Custom Retrieval Configuration",
      "enhanced_text": "Context: Changelog > `BedrockKBRetrieverTool` > Advanced Usage > Custom Retrieval Configuration\n\nkb_tool = BedrockKBRetrieverTool(\n    knowledge_base_id=\"your-kb-id\",\n    retrieval_configuration={\n        \"vectorSearchConfiguration\": {\n            \"numberOfResults\": 10,\n            \"overrideSearchType\": \"HYBRID\"\n        }\n    }\n)\n\npolicy_expert = Agent(\n    role='Policy Expert',\n    goal='Analyze company policies in detail',\n    backstory='I am an expert in corporate policy analysis with deep knowledge of regulatory requirements.',\n    tools=[kb_tool]\n)"
    },
    {
      "content": "Event listeners can be used for a variety of purposes: **Logging and Monitoring**: Track the execution of your Crew and log important events **Analytics**: Collect data about your Crew's performance and behavior **Debugging**: Set up temporary listeners to debug specific issues **Integration**: Connect CrewAI with external systems like monitoring platforms, databases, or notification services **Custom Behavior**: Trigger custom actions based on specific events",
      "title": "Use Cases",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`BedrockKBRetrieverTool`",
          "level": 1
        },
        {
          "title": "Use Cases",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`BedrockKBRetrieverTool`",
            "level": 1
          },
          {
            "title": "Use Cases",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `BedrockKBRetrieverTool` > Use Cases"
      },
      "enhanced_content": "Context: Changelog > `BedrockKBRetrieverTool` > Use Cases\n\n## Use Cases\n\nEvent listeners can be used for a variety of purposes: **Logging and Monitoring**: Track the execution of your Crew and log important events **Analytics**: Collect data about your Crew's performance and behavior **Debugging**: Set up temporary listeners to debug specific issues **Integration**: Connect CrewAI with external systems like monitoring platforms, databases, or notification services **Custom Behavior**: Trigger custom actions based on specific events",
      "formatted_path": "Changelog > `BedrockKBRetrieverTool` > Use Cases",
      "enhanced_text": "Context: Changelog > `BedrockKBRetrieverTool` > Use Cases\n\n Use Cases\n\nEvent listeners can be used for a variety of purposes: **Logging and Monitoring**: Track the execution of your Crew and log important events **Analytics**: Collect data about your Crew's performance and behavior **Debugging**: Set up temporary listeners to debug specific issues **Integration**: Connect CrewAI with external systems like monitoring platforms, databases, or notification services **Custom Behavior**: Trigger custom actions based on specific events\n\nRelated sections:\n- \n- \n- \n- \n"
    },
    {
      "content": "Enable CrewAI agents to access your organization's proprietary knowledge without exposing sensitive data Allow agents to make decisions based on your company's specific policies, procedures, and documentation Create agents that can answer questions based on your internal documentation while maintaining data security",
      "title": "Enterprise Knowledge Integration",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`BedrockKBRetrieverTool`",
          "level": 1
        },
        {
          "title": "Use Cases",
          "level": 2
        },
        {
          "title": "Enterprise Knowledge Integration",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`BedrockKBRetrieverTool`",
            "level": 1
          },
          {
            "title": "Use Cases",
            "level": 2
          },
          {
            "title": "Enterprise Knowledge Integration",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `BedrockKBRetrieverTool` > Use Cases > Enterprise Knowledge Integration"
      },
      "enhanced_content": "Context: Changelog > `BedrockKBRetrieverTool` > Use Cases > Enterprise Knowledge Integration\n\n### Enterprise Knowledge Integration\n\nEnable CrewAI agents to access your organization's proprietary knowledge without exposing sensitive data Allow agents to make decisions based on your company's specific policies, procedures, and documentation Create agents that can answer questions based on your internal documentation while maintaining data security",
      "formatted_path": "Changelog > `BedrockKBRetrieverTool` > Use Cases > Enterprise Knowledge Integration",
      "enhanced_text": "Context: Changelog > `BedrockKBRetrieverTool` > Use Cases > Enterprise Knowledge Integration\n\n Enterprise Knowledge Integration\n\nEnable CrewAI agents to access your organization's proprietary knowledge without exposing sensitive data Allow agents to make decisions based on your company's specific policies, procedures, and documentation Create agents that can answer questions based on your internal documentation while maintaining data security\n\nRelated sections:\n- \n"
    },
    {
      "content": "Connect CrewAI agents to domain-specific knowledge bases (legal, medical, technical) without retraining models Leverage existing knowledge repositories that are already maintained in your AWS environment Combine CrewAI's reasoning with domain-specific information from your knowledge bases",
      "title": "Specialized Domain Knowledge",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`BedrockKBRetrieverTool`",
          "level": 1
        },
        {
          "title": "Use Cases",
          "level": 2
        },
        {
          "title": "Specialized Domain Knowledge",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`BedrockKBRetrieverTool`",
            "level": 1
          },
          {
            "title": "Use Cases",
            "level": 2
          },
          {
            "title": "Specialized Domain Knowledge",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `BedrockKBRetrieverTool` > Use Cases > Specialized Domain Knowledge"
      },
      "enhanced_content": "Context: Changelog > `BedrockKBRetrieverTool` > Use Cases > Specialized Domain Knowledge\n\n### Specialized Domain Knowledge\n\nConnect CrewAI agents to domain-specific knowledge bases (legal, medical, technical) without retraining models Leverage existing knowledge repositories that are already maintained in your AWS environment Combine CrewAI's reasoning with domain-specific information from your knowledge bases",
      "formatted_path": "Changelog > `BedrockKBRetrieverTool` > Use Cases > Specialized Domain Knowledge",
      "enhanced_text": "Context: Changelog > `BedrockKBRetrieverTool` > Use Cases > Specialized Domain Knowledge\n\n Specialized Domain Knowledge\n\nConnect CrewAI agents to domain-specific knowledge bases (legal, medical, technical) without retraining models Leverage existing knowledge repositories that are already maintained in your AWS environment Combine CrewAI's reasoning with domain-specific information from your knowledge bases\n\nRelated sections:\n- \n"
    },
    {
      "content": "Ground CrewAI agent responses in your actual company data rather than general knowledge Ensure agents provide recommendations based on your specific business context and documentation Reduce hallucinations by retrieving factual information from your knowledge bases",
      "title": "Data-Driven Decision Making",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`BedrockKBRetrieverTool`",
          "level": 1
        },
        {
          "title": "Use Cases",
          "level": 2
        },
        {
          "title": "Data-Driven Decision Making",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`BedrockKBRetrieverTool`",
            "level": 1
          },
          {
            "title": "Use Cases",
            "level": 2
          },
          {
            "title": "Data-Driven Decision Making",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `BedrockKBRetrieverTool` > Use Cases > Data-Driven Decision Making"
      },
      "enhanced_content": "Context: Changelog > `BedrockKBRetrieverTool` > Use Cases > Data-Driven Decision Making\n\n### Data-Driven Decision Making\n\nGround CrewAI agent responses in your actual company data rather than general knowledge Ensure agents provide recommendations based on your specific business context and documentation Reduce hallucinations by retrieving factual information from your knowledge bases",
      "formatted_path": "Changelog > `BedrockKBRetrieverTool` > Use Cases > Data-Driven Decision Making",
      "enhanced_text": "Context: Changelog > `BedrockKBRetrieverTool` > Use Cases > Data-Driven Decision Making\n\n Data-Driven Decision Making\n\nGround CrewAI agent responses in your actual company data rather than general knowledge Ensure agents provide recommendations based on your specific business context and documentation Reduce hallucinations by retrieving factual information from your knowledge bases"
    },
    {
      "content": "Access terabytes of organizational knowledge without embedding it all into your models Dynamically query only the relevant information needed for specific tasks Leverage AWS's scalable infrastructure to handle large knowledge bases efficiently",
      "title": "Scalable Information Access",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`BedrockKBRetrieverTool`",
          "level": 1
        },
        {
          "title": "Use Cases",
          "level": 2
        },
        {
          "title": "Scalable Information Access",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`BedrockKBRetrieverTool`",
            "level": 1
          },
          {
            "title": "Use Cases",
            "level": 2
          },
          {
            "title": "Scalable Information Access",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `BedrockKBRetrieverTool` > Use Cases > Scalable Information Access"
      },
      "enhanced_content": "Context: Changelog > `BedrockKBRetrieverTool` > Use Cases > Scalable Information Access\n\n### Scalable Information Access\n\nAccess terabytes of organizational knowledge without embedding it all into your models Dynamically query only the relevant information needed for specific tasks Leverage AWS's scalable infrastructure to handle large knowledge bases efficiently",
      "formatted_path": "Changelog > `BedrockKBRetrieverTool` > Use Cases > Scalable Information Access",
      "enhanced_text": "Context: Changelog > `BedrockKBRetrieverTool` > Use Cases > Scalable Information Access\n\n Scalable Information Access\n\nAccess terabytes of organizational knowledge without embedding it all into your models Dynamically query only the relevant information needed for specific tasks Leverage AWS's scalable infrastructure to handle large knowledge bases efficiently"
    },
    {
      "content": "Ensure CrewAI agents provide responses that align with your company's approved documentation Create auditable trails of information sources used by your agents Maintain control over what information sources your agents can access",
      "title": "Compliance and Governance",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`BedrockKBRetrieverTool`",
          "level": 1
        },
        {
          "title": "Use Cases",
          "level": 2
        },
        {
          "title": "Compliance and Governance",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`BedrockKBRetrieverTool`",
            "level": 1
          },
          {
            "title": "Use Cases",
            "level": 2
          },
          {
            "title": "Compliance and Governance",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `BedrockKBRetrieverTool` > Use Cases > Compliance and Governance"
      },
      "enhanced_content": "Context: Changelog > `BedrockKBRetrieverTool` > Use Cases > Compliance and Governance\n\n### Compliance and Governance\n\nEnsure CrewAI agents provide responses that align with your company's approved documentation Create auditable trails of information sources used by your agents Maintain control over what information sources your agents can access",
      "formatted_path": "Changelog > `BedrockKBRetrieverTool` > Use Cases > Compliance and Governance",
      "enhanced_text": "Context: Changelog > `BedrockKBRetrieverTool` > Use Cases > Compliance and Governance\n\n Compliance and Governance\n\nEnsure CrewAI agents provide responses that align with your company's approved documentation Create auditable trails of information sources used by your agents Maintain control over what information sources your agents can access"
    },
    {
      "content": "Source: https://docs.crewai.com/tools/bravesearchtool The `BraveSearchTool` is designed to search the internet using the Brave Search API.",
      "title": "Brave Search",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Brave Search",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Brave Search",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Brave Search"
      },
      "enhanced_content": "Context: Changelog > Brave Search\n\n# Brave Search\n\nSource: https://docs.crewai.com/tools/bravesearchtool The `BraveSearchTool` is designed to search the internet using the Brave Search API.",
      "formatted_path": "Changelog > Brave Search",
      "enhanced_text": "Context: Changelog > Brave Search\n\n Brave Search\n\nSource: https://docs.crewai.com/tools/bravesearchtool The `BraveSearchTool` is designed to search the internet using the Brave Search API."
    },
    {
      "content": "Source: https://docs.crewai.com/tools/browserbaseloadtool Browserbase is a developer platform to reliably run, manage, and monitor headless browsers.",
      "title": "Browserbase Web Loader",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Browserbase Web Loader",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Browserbase Web Loader",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Browserbase Web Loader"
      },
      "enhanced_content": "Context: Changelog > Browserbase Web Loader\n\n# Browserbase Web Loader\n\nSource: https://docs.crewai.com/tools/browserbaseloadtool Browserbase is a developer platform to reliably run, manage, and monitor headless browsers.",
      "formatted_path": "Changelog > Browserbase Web Loader",
      "enhanced_text": "Context: Changelog > Browserbase Web Loader\n\n Browserbase Web Loader\n\nSource: https://docs.crewai.com/tools/browserbaseloadtool Browserbase is a developer platform to reliably run, manage, and monitor headless browsers."
    },
    {
      "content": "Source: https://docs.crewai.com/tools/codedocssearchtool The `CodeDocsSearchTool` is a powerful RAG (Retrieval-Augmented Generation) tool designed for semantic searches within code documentation.",
      "title": "Code Docs RAG Search",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Code Docs RAG Search",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Code Docs RAG Search",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Code Docs RAG Search"
      },
      "enhanced_content": "Context: Changelog > Code Docs RAG Search\n\n# Code Docs RAG Search\n\nSource: https://docs.crewai.com/tools/codedocssearchtool The `CodeDocsSearchTool` is a powerful RAG (Retrieval-Augmented Generation) tool designed for semantic searches within code documentation.",
      "formatted_path": "Changelog > Code Docs RAG Search",
      "enhanced_text": "Context: Changelog > Code Docs RAG Search\n\n Code Docs RAG Search\n\nSource: https://docs.crewai.com/tools/codedocssearchtool The `CodeDocsSearchTool` is a powerful RAG (Retrieval-Augmented Generation) tool designed for semantic searches within code documentation."
    },
    {
      "content": "Source: https://docs.crewai.com/tools/codeinterpretertool The `CodeInterpreterTool` is a powerful tool designed for executing Python 3 code within a secure, isolated environment.",
      "title": "Code Interpreter",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Code Interpreter",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Code Interpreter",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Code Interpreter"
      },
      "enhanced_content": "Context: Changelog > Code Interpreter\n\n# Code Interpreter\n\nSource: https://docs.crewai.com/tools/codeinterpretertool The `CodeInterpreterTool` is a powerful tool designed for executing Python 3 code within a secure, isolated environment.",
      "formatted_path": "Changelog > Code Interpreter",
      "enhanced_text": "Context: Changelog > Code Interpreter\n\n Code Interpreter\n\nSource: https://docs.crewai.com/tools/codeinterpretertool The `CodeInterpreterTool` is a powerful tool designed for executing Python 3 code within a secure, isolated environment."
    },
    {
      "content": "import os\nfrom crewai import Crew\nfrom crewai.memory import LongTermMemory\nfrom crewai.memory.storage.ltm_sqlite_storage import LTMSQLiteStorage\n\n# Configure storage path using environment variable\nstorage_path = os.getenv(\"CREWAI_STORAGE_DIR\", \"./storage\")\ncrew = Crew(\n    memory=True,\n    long_term_memory=LongTermMemory(\n        storage=LTMSQLiteStorage(\n            db_path=\"{storage_path}/memory.db\".format(storage_path=storage_path)\n        )\n    )\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`CodeInterpreterTool`",
          "level": 1
        },
        {
          "title": "Security Considerations",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`CodeInterpreterTool`",
            "level": 1
          },
          {
            "title": "Security Considerations",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `CodeInterpreterTool` > Security Considerations"
      },
      "enhanced_content": "Context: Changelog > `CodeInterpreterTool` > Security Considerations\n\nimport os\nfrom crewai import Crew\nfrom crewai.memory import LongTermMemory\nfrom crewai.memory.storage.ltm_sqlite_storage import LTMSQLiteStorage\n\n# Configure storage path using environment variable\nstorage_path = os.getenv(\"CREWAI_STORAGE_DIR\", \"./storage\")\ncrew = Crew(\n    memory=True,\n    long_term_memory=LongTermMemory(\n        storage=LTMSQLiteStorage(\n            db_path=\"{storage_path}/memory.db\".format(storage_path=storage_path)\n        )\n    )\n)",
      "formatted_path": "Changelog > `CodeInterpreterTool` > Security Considerations",
      "enhanced_text": "Context: Changelog > `CodeInterpreterTool` > Security Considerations\n\nimport os\nfrom crewai import Crew\nfrom crewai.memory import LongTermMemory\nfrom crewai.memory.storage.ltm_sqlite_storage import LTMSQLiteStorage\n\n# Configure storage path using environment variable\nstorage_path = os.getenv(\"CREWAI_STORAGE_DIR\", \"./storage\")\ncrew = Crew(\n    memory=True,\n    long_term_memory=LongTermMemory(\n        storage=LTMSQLiteStorage(\n            db_path=\"{storage_path}/memory.db\".format(storage_path=storage_path)\n        )\n    )\n)"
    },
    {
      "content": "Source: https://docs.crewai.com/tools/composiotool Composio provides 250+ production-ready tools for AI agents with flexible authentication management.",
      "title": "Composio Tool",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Composio Tool",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Composio Tool",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Composio Tool"
      },
      "enhanced_content": "Context: Changelog > Composio Tool\n\n# Composio Tool\n\nSource: https://docs.crewai.com/tools/composiotool Composio provides 250+ production-ready tools for AI agents with flexible authentication management.",
      "formatted_path": "Changelog > Composio Tool",
      "enhanced_text": "Context: Changelog > Composio Tool\n\n Composio Tool\n\nSource: https://docs.crewai.com/tools/composiotool Composio provides 250+ production-ready tools for AI agents with flexible authentication management."
    },
    {
      "content": "Source: https://docs.crewai.com/tools/csvsearchtool The `CSVSearchTool` is a powerful RAG (Retrieval-Augmented Generation) tool designed for semantic searches within a CSV file's content.",
      "title": "CSV RAG Search",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "CSV RAG Search",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "CSV RAG Search",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > CSV RAG Search"
      },
      "enhanced_content": "Context: Changelog > CSV RAG Search\n\n# CSV RAG Search\n\nSource: https://docs.crewai.com/tools/csvsearchtool The `CSVSearchTool` is a powerful RAG (Retrieval-Augmented Generation) tool designed for semantic searches within a CSV file's content.",
      "formatted_path": "Changelog > CSV RAG Search",
      "enhanced_text": "Context: Changelog > CSV RAG Search\n\n CSV RAG Search\n\nSource: https://docs.crewai.com/tools/csvsearchtool The `CSVSearchTool` is a powerful RAG (Retrieval-Augmented Generation) tool designed for semantic searches within a CSV file's content."
    },
    {
      "content": "Source: https://docs.crewai.com/tools/dalletool The `DallETool` is a powerful tool designed for generating images from textual descriptions.",
      "title": "DALL-E Tool",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "DALL-E Tool",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "DALL-E Tool",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > DALL-E Tool"
      },
      "enhanced_content": "Context: Changelog > DALL-E Tool\n\n# DALL-E Tool\n\nSource: https://docs.crewai.com/tools/dalletool The `DallETool` is a powerful tool designed for generating images from textual descriptions.",
      "formatted_path": "Changelog > DALL-E Tool",
      "enhanced_text": "Context: Changelog > DALL-E Tool\n\n DALL-E Tool\n\nSource: https://docs.crewai.com/tools/dalletool The `DallETool` is a powerful tool designed for generating images from textual descriptions."
    },
    {
      "content": "Source: https://docs.crewai.com/tools/directoryreadtool The `DirectoryReadTool` is a powerful utility designed to provide a comprehensive listing of directory contents.",
      "title": "Directory Read",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Directory Read",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Directory Read",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Directory Read"
      },
      "enhanced_content": "Context: Changelog > Directory Read\n\n# Directory Read\n\nSource: https://docs.crewai.com/tools/directoryreadtool The `DirectoryReadTool` is a powerful utility designed to provide a comprehensive listing of directory contents.",
      "formatted_path": "Changelog > Directory Read",
      "enhanced_text": "Context: Changelog > Directory Read\n\n Directory Read\n\nSource: https://docs.crewai.com/tools/directoryreadtool The `DirectoryReadTool` is a powerful utility designed to provide a comprehensive listing of directory contents."
    },
    {
      "content": "Source: https://docs.crewai.com/tools/directorysearchtool The `DirectorySearchTool` is a powerful RAG (Retrieval-Augmented Generation) tool designed for semantic searches within a directory's content.",
      "title": "Directory RAG Search",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Directory RAG Search",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Directory RAG Search",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Directory RAG Search"
      },
      "enhanced_content": "Context: Changelog > Directory RAG Search\n\n# Directory RAG Search\n\nSource: https://docs.crewai.com/tools/directorysearchtool The `DirectorySearchTool` is a powerful RAG (Retrieval-Augmented Generation) tool designed for semantic searches within a directory's content.",
      "formatted_path": "Changelog > Directory RAG Search",
      "enhanced_text": "Context: Changelog > Directory RAG Search\n\n Directory RAG Search\n\nSource: https://docs.crewai.com/tools/directorysearchtool The `DirectorySearchTool` is a powerful RAG (Retrieval-Augmented Generation) tool designed for semantic searches within a directory's content."
    },
    {
      "content": "from crewai_tools import DirectorySearchTool\n\n# For dynamic directory specification at runtime\ntool = DirectorySearchTool()\n\n# For fixed directory searches\ntool = DirectorySearchTool(directory='/path/to/directory')",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`DirectorySearchTool`",
          "level": 1
        },
        {
          "title": "Initialization and Usage",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`DirectorySearchTool`",
            "level": 1
          },
          {
            "title": "Initialization and Usage",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `DirectorySearchTool` > Initialization and Usage"
      },
      "enhanced_content": "Context: Changelog > `DirectorySearchTool` > Initialization and Usage\n\nfrom crewai_tools import DirectorySearchTool\n\n# For dynamic directory specification at runtime\ntool = DirectorySearchTool()\n\n# For fixed directory searches\ntool = DirectorySearchTool(directory='/path/to/directory')",
      "formatted_path": "Changelog > `DirectorySearchTool` > Initialization and Usage",
      "enhanced_text": "Context: Changelog > `DirectorySearchTool` > Initialization and Usage\n\nfrom crewai_tools import DirectorySearchTool\n\n# For dynamic directory specification at runtime\ntool = DirectorySearchTool()\n\n# For fixed directory searches\ntool = DirectorySearchTool(directory='/path/to/directory')"
    },
    {
      "content": "Source: https://docs.crewai.com/tools/docxsearchtool The `DOCXSearchTool` is a RAG tool designed for semantic searching within DOCX documents.",
      "title": "DOCX RAG Search",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "DOCX RAG Search",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "DOCX RAG Search",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > DOCX RAG Search"
      },
      "enhanced_content": "Context: Changelog > DOCX RAG Search\n\n# DOCX RAG Search\n\nSource: https://docs.crewai.com/tools/docxsearchtool The `DOCXSearchTool` is a RAG tool designed for semantic searching within DOCX documents.",
      "formatted_path": "Changelog > DOCX RAG Search",
      "enhanced_text": "Context: Changelog > DOCX RAG Search\n\n DOCX RAG Search\n\nSource: https://docs.crewai.com/tools/docxsearchtool The `DOCXSearchTool` is a RAG tool designed for semantic searching within DOCX documents."
    },
    {
      "content": "Source: https://docs.crewai.com/tools/exasearchtool The `EXASearchTool` is designed to perform a semantic search for a specified query from a text's content across the internet.",
      "title": "EXA Search Web Loader",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "EXA Search Web Loader",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "EXA Search Web Loader",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > EXA Search Web Loader"
      },
      "enhanced_content": "Context: Changelog > EXA Search Web Loader\n\n# EXA Search Web Loader\n\nSource: https://docs.crewai.com/tools/exasearchtool The `EXASearchTool` is designed to perform a semantic search for a specified query from a text's content across the internet.",
      "formatted_path": "Changelog > EXA Search Web Loader",
      "enhanced_text": "Context: Changelog > EXA Search Web Loader\n\n EXA Search Web Loader\n\nSource: https://docs.crewai.com/tools/exasearchtool The `EXASearchTool` is designed to perform a semantic search for a specified query from a text's content across the internet."
    },
    {
      "content": "Source: https://docs.crewai.com/tools/filereadtool The `FileReadTool` is designed to read files from the local file system.",
      "title": "File Read",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "File Read",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "File Read",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > File Read"
      },
      "enhanced_content": "Context: Changelog > File Read\n\n# File Read\n\nSource: https://docs.crewai.com/tools/filereadtool The `FileReadTool` is designed to read files from the local file system.",
      "formatted_path": "Changelog > File Read",
      "enhanced_text": "Context: Changelog > File Read\n\n File Read\n\nSource: https://docs.crewai.com/tools/filereadtool The `FileReadTool` is designed to read files from the local file system."
    },
    {
      "content": "Source: https://docs.crewai.com/tools/filewritetool The `FileWriterTool` is designed to write content to files.",
      "title": "File Write",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "File Write",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "File Write",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > File Write"
      },
      "enhanced_content": "Context: Changelog > File Write\n\n# File Write\n\nSource: https://docs.crewai.com/tools/filewritetool The `FileWriterTool` is designed to write content to files.",
      "formatted_path": "Changelog > File Write",
      "enhanced_text": "Context: Changelog > File Write\n\n File Write\n\nSource: https://docs.crewai.com/tools/filewritetool The `FileWriterTool` is designed to write content to files."
    },
    {
      "content": "Source: https://docs.crewai.com/tools/firecrawlcrawlwebsitetool The `FirecrawlCrawlWebsiteTool` is designed to crawl and convert websites into clean markdown or structured data.",
      "title": "Firecrawl Crawl Website",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Firecrawl Crawl Website",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Firecrawl Crawl Website",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Firecrawl Crawl Website"
      },
      "enhanced_content": "Context: Changelog > Firecrawl Crawl Website\n\n# Firecrawl Crawl Website\n\nSource: https://docs.crewai.com/tools/firecrawlcrawlwebsitetool The `FirecrawlCrawlWebsiteTool` is designed to crawl and convert websites into clean markdown or structured data.",
      "formatted_path": "Changelog > Firecrawl Crawl Website",
      "enhanced_text": "Context: Changelog > Firecrawl Crawl Website\n\n Firecrawl Crawl Website\n\nSource: https://docs.crewai.com/tools/firecrawlcrawlwebsitetool The `FirecrawlCrawlWebsiteTool` is designed to crawl and convert websites into clean markdown or structured data."
    },
    {
      "content": "Source: https://docs.crewai.com/tools/firecrawlscrapewebsitetool The `FirecrawlScrapeWebsiteTool` is designed to scrape websites and convert them into clean markdown or structured data.",
      "title": "Firecrawl Scrape Website",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Firecrawl Scrape Website",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Firecrawl Scrape Website",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Firecrawl Scrape Website"
      },
      "enhanced_content": "Context: Changelog > Firecrawl Scrape Website\n\n# Firecrawl Scrape Website\n\nSource: https://docs.crewai.com/tools/firecrawlscrapewebsitetool The `FirecrawlScrapeWebsiteTool` is designed to scrape websites and convert them into clean markdown or structured data.",
      "formatted_path": "Changelog > Firecrawl Scrape Website",
      "enhanced_text": "Context: Changelog > Firecrawl Scrape Website\n\n Firecrawl Scrape Website\n\nSource: https://docs.crewai.com/tools/firecrawlscrapewebsitetool The `FirecrawlScrapeWebsiteTool` is designed to scrape websites and convert them into clean markdown or structured data.\n\nRelated sections:\n- \n"
    },
    {
      "content": "Source: https://docs.crewai.com/tools/firecrawlsearchtool The `FirecrawlSearchTool` is designed to search websites and convert them into clean markdown or structured data.",
      "title": "Firecrawl Search",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Firecrawl Search",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Firecrawl Search",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Firecrawl Search"
      },
      "enhanced_content": "Context: Changelog > Firecrawl Search\n\n# Firecrawl Search\n\nSource: https://docs.crewai.com/tools/firecrawlsearchtool The `FirecrawlSearchTool` is designed to search websites and convert them into clean markdown or structured data.",
      "formatted_path": "Changelog > Firecrawl Search",
      "enhanced_text": "Context: Changelog > Firecrawl Search\n\n Firecrawl Search\n\nSource: https://docs.crewai.com/tools/firecrawlsearchtool The `FirecrawlSearchTool` is designed to search websites and convert them into clean markdown or structured data."
    },
    {
      "content": "Source: https://docs.crewai.com/tools/githubsearchtool The `GithubSearchTool` is designed to search websites and convert them into clean markdown or structured data.",
      "title": "Github Search",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Github Search",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Github Search",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Github Search"
      },
      "enhanced_content": "Context: Changelog > Github Search\n\n# Github Search\n\nSource: https://docs.crewai.com/tools/githubsearchtool The `GithubSearchTool` is designed to search websites and convert them into clean markdown or structured data.",
      "formatted_path": "Changelog > Github Search",
      "enhanced_text": "Context: Changelog > Github Search\n\n Github Search\n\nSource: https://docs.crewai.com/tools/githubsearchtool The `GithubSearchTool` is designed to search websites and convert them into clean markdown or structured data."
    },
    {
      "content": "Source: https://docs.crewai.com/tools/hyperbrowserloadtool The `HyperbrowserLoadTool` enables web scraping and crawling using Hyperbrowser.",
      "title": "Hyperbrowser Load Tool",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Hyperbrowser Load Tool",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Hyperbrowser Load Tool",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Hyperbrowser Load Tool"
      },
      "enhanced_content": "Context: Changelog > Hyperbrowser Load Tool\n\n# Hyperbrowser Load Tool\n\nSource: https://docs.crewai.com/tools/hyperbrowserloadtool The `HyperbrowserLoadTool` enables web scraping and crawling using Hyperbrowser.",
      "formatted_path": "Changelog > Hyperbrowser Load Tool",
      "enhanced_text": "Context: Changelog > Hyperbrowser Load Tool\n\n Hyperbrowser Load Tool\n\nSource: https://docs.crewai.com/tools/hyperbrowserloadtool The `HyperbrowserLoadTool` enables web scraping and crawling using Hyperbrowser."
    },
    {
      "content": "For detailed information on all supported parameters, visit: [Scrape Parameters](https://docs.hyperbrowser.ai/reference/sdks/python/scrape#start-scrape-job-and-wait) [Crawl Parameters](https://docs.hyperbrowser.ai/reference/sdks/python/crawl#start-crawl-job-and-wait)",
      "title": "Supported Parameters",
      "type": "link_list",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`HyperbrowserLoadTool`",
          "level": 1
        },
        {
          "title": "Supported Parameters",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`HyperbrowserLoadTool`",
            "level": 1
          },
          {
            "title": "Supported Parameters",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 2,
        "formatted_path": "Changelog > `HyperbrowserLoadTool` > Supported Parameters"
      },
      "enhanced_content": "Context: Changelog > `HyperbrowserLoadTool` > Supported Parameters\n\n## Supported Parameters\n\nFor detailed information on all supported parameters, visit: [Scrape Parameters](https://docs.hyperbrowser.ai/reference/sdks/python/scrape#start-scrape-job-and-wait) [Crawl Parameters](https://docs.hyperbrowser.ai/reference/sdks/python/crawl#start-crawl-job-and-wait)",
      "formatted_path": "Changelog > `HyperbrowserLoadTool` > Supported Parameters",
      "enhanced_text": "Context: Changelog > `HyperbrowserLoadTool` > Supported Parameters\n\n Supported Parameters\n\nFor detailed information on all supported parameters, visit: [Scrape Parameters](https://docs.hyperbrowser.ai/reference/sdks/python/scrape#start-scrape-job-and-wait) [Crawl Parameters](https://docs.hyperbrowser.ai/reference/sdks/python/crawl#start-crawl-job-and-wait)\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "Source: https://docs.crewai.com/tools/jsonsearchtool The `JSONSearchTool` is designed to search JSON files and return the most relevant results.",
      "title": "JSON RAG Search",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "JSON RAG Search",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "JSON RAG Search",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > JSON RAG Search"
      },
      "enhanced_content": "Context: Changelog > JSON RAG Search\n\n# JSON RAG Search\n\nSource: https://docs.crewai.com/tools/jsonsearchtool The `JSONSearchTool` is designed to search JSON files and return the most relevant results.",
      "formatted_path": "Changelog > JSON RAG Search",
      "enhanced_text": "Context: Changelog > JSON RAG Search\n\n JSON RAG Search\n\nSource: https://docs.crewai.com/tools/jsonsearchtool The `JSONSearchTool` is designed to search JSON files and return the most relevant results."
    },
    {
      "content": "from crewai.json_tools import JSONSearchTool  # Updated import path\n\n# General JSON content search\n# This approach is suitable when the JSON path is either known beforehand or can be dynamically identified.\ntool = JSONSearchTool()\n\n# Restricting search to a specific JSON file\n# Use this initialization method when you want to limit the search scope to a specific JSON file.\ntool = JSONSearchTool(json_path='./path/to/your/file.json')",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`JSONSearchTool`",
          "level": 1
        },
        {
          "title": "Usage Examples",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`JSONSearchTool`",
            "level": 1
          },
          {
            "title": "Usage Examples",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `JSONSearchTool` > Usage Examples"
      },
      "enhanced_content": "Context: Changelog > `JSONSearchTool` > Usage Examples\n\nfrom crewai.json_tools import JSONSearchTool  # Updated import path\n\n# General JSON content search\n# This approach is suitable when the JSON path is either known beforehand or can be dynamically identified.\ntool = JSONSearchTool()\n\n# Restricting search to a specific JSON file\n# Use this initialization method when you want to limit the search scope to a specific JSON file.\ntool = JSONSearchTool(json_path='./path/to/your/file.json')",
      "formatted_path": "Changelog > `JSONSearchTool` > Usage Examples",
      "enhanced_text": "Context: Changelog > `JSONSearchTool` > Usage Examples\n\nfrom crewai.json_tools import JSONSearchTool  # Updated import path\n\n# General JSON content search\n# This approach is suitable when the JSON path is either known beforehand or can be dynamically identified.\ntool = JSONSearchTool()\n\n# Restricting search to a specific JSON file\n# Use this initialization method when you want to limit the search scope to a specific JSON file.\ntool = JSONSearchTool(json_path='./path/to/your/file.json')"
    },
    {
      "content": "tool = JSONSearchTool(\n    config={\n        \"llm\": {\n            \"provider\": \"ollama\",  # Other options include google, openai, anthropic, llama2, etc.\n            \"config\": {\n                \"model\": \"llama2\",\n                # Additional optional configurations can be specified here.\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            },\n        },\n        \"embedding_model\": {\n            \"provider\": \"google\", # or openai, ollama, ...\n            \"config\": {\n                \"model\": \"models/embedding-001\",\n                \"task_type\": \"retrieval_document\",\n                # Further customization options can be added here.\n            },\n        },\n    }\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`JSONSearchTool`",
          "level": 1
        },
        {
          "title": "Configuration Options",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`JSONSearchTool`",
            "level": 1
          },
          {
            "title": "Configuration Options",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `JSONSearchTool` > Configuration Options"
      },
      "enhanced_content": "Context: Changelog > `JSONSearchTool` > Configuration Options\n\ntool = JSONSearchTool(\n    config={\n        \"llm\": {\n            \"provider\": \"ollama\",  # Other options include google, openai, anthropic, llama2, etc.\n            \"config\": {\n                \"model\": \"llama2\",\n                # Additional optional configurations can be specified here.\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            },\n        },\n        \"embedding_model\": {\n            \"provider\": \"google\", # or openai, ollama, ...\n            \"config\": {\n                \"model\": \"models/embedding-001\",\n                \"task_type\": \"retrieval_document\",\n                # Further customization options can be added here.\n            },\n        },\n    }\n)",
      "formatted_path": "Changelog > `JSONSearchTool` > Configuration Options",
      "enhanced_text": "Context: Changelog > `JSONSearchTool` > Configuration Options\n\ntool = JSONSearchTool(\n    config={\n        \"llm\": {\n            \"provider\": \"ollama\",  # Other options include google, openai, anthropic, llama2, etc.\n            \"config\": {\n                \"model\": \"llama2\",\n                # Additional optional configurations can be specified here.\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            },\n        },\n        \"embedding_model\": {\n            \"provider\": \"google\", # or openai, ollama, ...\n            \"config\": {\n                \"model\": \"models/embedding-001\",\n                \"task_type\": \"retrieval_document\",\n                # Further customization options can be added here.\n            },\n        },\n    }\n)"
    },
    {
      "content": "Source: https://docs.crewai.com/tools/linkupsearchtool The `LinkupSearchTool` enables querying the Linkup API for contextual information.",
      "title": "Linkup Search Tool",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Linkup Search Tool",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Linkup Search Tool",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Linkup Search Tool"
      },
      "enhanced_content": "Context: Changelog > Linkup Search Tool\n\n# Linkup Search Tool\n\nSource: https://docs.crewai.com/tools/linkupsearchtool The `LinkupSearchTool` enables querying the Linkup API for contextual information.",
      "formatted_path": "Changelog > Linkup Search Tool",
      "enhanced_text": "Context: Changelog > Linkup Search Tool\n\n Linkup Search Tool\n\nSource: https://docs.crewai.com/tools/linkupsearchtool The `LinkupSearchTool` enables querying the Linkup API for contextual information."
    },
    {
      "content": "**api\\_key**: Optional. Your Hyperbrowser API key. If not provided, it will be read from the `HYPERBROWSER_API_KEY` environment variable.\n\n**api\\_key**: Required. Your Linkup API key.",
      "title": "Constructor Parameters",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`LinkupSearchTool`",
          "level": 1
        },
        {
          "title": "Parameters",
          "level": 2
        },
        {
          "title": "Constructor Parameters",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`LinkupSearchTool`",
            "level": 1
          },
          {
            "title": "Parameters",
            "level": 2
          },
          {
            "title": "Constructor Parameters",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `LinkupSearchTool` > Parameters > Constructor Parameters"
      },
      "enhanced_content": "Context: Changelog > `LinkupSearchTool` > Parameters > Constructor Parameters\n\n### Constructor Parameters\n\n**api\\_key**: Optional. Your Hyperbrowser API key. If not provided, it will be read from the `HYPERBROWSER_API_KEY` environment variable.\n\n**api\\_key**: Required. Your Linkup API key.",
      "formatted_path": "Changelog > `LinkupSearchTool` > Parameters > Constructor Parameters",
      "enhanced_text": "Context: Changelog > `LinkupSearchTool` > Parameters > Constructor Parameters\n\n Constructor Parameters\n\n**api\\_key**: Optional. Your Hyperbrowser API key. If not provided, it will be read from the `HYPERBROWSER_API_KEY` environment variable.\n\n**api\\_key**: Required. Your Linkup API key.\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "# Perform a search with custom parameters\nresults = linkup_tool.run(\n    query=\"Women Nobel Prize Physics\",\n    depth=\"deep\",\n    output_type=\"searchResults\"\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`LinkupSearchTool`",
          "level": 1
        },
        {
          "title": "Advanced Usage",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`LinkupSearchTool`",
            "level": 1
          },
          {
            "title": "Advanced Usage",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `LinkupSearchTool` > Advanced Usage"
      },
      "enhanced_content": "Context: Changelog > `LinkupSearchTool` > Advanced Usage\n\n# Perform a search with custom parameters\nresults = linkup_tool.run(\n    query=\"Women Nobel Prize Physics\",\n    depth=\"deep\",\n    output_type=\"searchResults\"\n)",
      "formatted_path": "Changelog > `LinkupSearchTool` > Advanced Usage",
      "enhanced_text": "Context: Changelog > `LinkupSearchTool` > Advanced Usage\n\n# Perform a search with custom parameters\nresults = linkup_tool.run(\n    query=\"Women Nobel Prize Physics\",\n    depth=\"deep\",\n    output_type=\"searchResults\"\n)"
    },
    {
      "content": "Source: https://docs.crewai.com/tools/llamaindextool The `LlamaIndexTool` is a wrapper for LlamaIndex tools and query engines.",
      "title": "LlamaIndex Tool",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "LlamaIndex Tool",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "LlamaIndex Tool",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > LlamaIndex Tool"
      },
      "enhanced_content": "Context: Changelog > LlamaIndex Tool\n\n# LlamaIndex Tool\n\nSource: https://docs.crewai.com/tools/llamaindextool The `LlamaIndexTool` is a wrapper for LlamaIndex tools and query engines.",
      "formatted_path": "Changelog > LlamaIndex Tool",
      "enhanced_text": "Context: Changelog > LlamaIndex Tool\n\n LlamaIndex Tool\n\nSource: https://docs.crewai.com/tools/llamaindextool The `LlamaIndexTool` is a wrapper for LlamaIndex tools and query engines.\n\nRelated sections:\n- \n- \n- \n"
    },
    {
      "content": "from crewai_tools import LlamaIndexTool\nfrom crewai import Agent\nfrom llama_index.core.tools import FunctionTool\n\n# Example 1: Initialize from FunctionTool\ndef search_data(query: str) -> str:\n    \"\"\"Search for information in the data.\"\"\"\n    # Your implementation here\n    return f\"Results for: {query}\"\n\n# Create a LlamaIndex FunctionTool\nog_tool = FunctionTool.from_defaults(\n    search_data, \n    name=\"DataSearchTool\",\n    description=\"Search for information in the data\"\n)\n\n# Wrap it with LlamaIndexTool\ntool = LlamaIndexTool.from_tool(og_tool)\n\n# Define an agent that uses the tool\n@agent\ndef researcher(self) -> Agent:\n    '''\n    This agent uses the LlamaIndexTool to search for information.\n    '''\n    return Agent(\n        config=self.agents_config[\"researcher\"],\n        tools=[tool]\n    )",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`LlamaIndexTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        },
        {
          "title": "From a LlamaIndex Tool",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`LlamaIndexTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          },
          {
            "title": "From a LlamaIndex Tool",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `LlamaIndexTool` > Example > From a LlamaIndex Tool"
      },
      "enhanced_content": "Context: Changelog > `LlamaIndexTool` > Example > From a LlamaIndex Tool\n\nfrom crewai_tools import LlamaIndexTool\nfrom crewai import Agent\nfrom llama_index.core.tools import FunctionTool\n\n# Example 1: Initialize from FunctionTool\ndef search_data(query: str) -> str:\n    \"\"\"Search for information in the data.\"\"\"\n    # Your implementation here\n    return f\"Results for: {query}\"\n\n# Create a LlamaIndex FunctionTool\nog_tool = FunctionTool.from_defaults(\n    search_data, \n    name=\"DataSearchTool\",\n    description=\"Search for information in the data\"\n)\n\n# Wrap it with LlamaIndexTool\ntool = LlamaIndexTool.from_tool(og_tool)\n\n# Define an agent that uses the tool\n@agent\ndef researcher(self) -> Agent:\n    '''\n    This agent uses the LlamaIndexTool to search for information.\n    '''\n    return Agent(\n        config=self.agents_config[\"researcher\"],\n        tools=[tool]\n    )",
      "formatted_path": "Changelog > `LlamaIndexTool` > Example > From a LlamaIndex Tool",
      "enhanced_text": "Context: Changelog > `LlamaIndexTool` > Example > From a LlamaIndex Tool\n\nfrom crewai_tools import LlamaIndexTool\nfrom crewai import Agent\nfrom llama_index.core.tools import FunctionTool\n\n# Example 1: Initialize from FunctionTool\ndef search_data(query: str) -> str:\n    \"\"\"Search for information in the data.\"\"\"\n    # Your implementation here\n    return f\"Results for: {query}\"\n\n# Create a LlamaIndex FunctionTool\nog_tool = FunctionTool.from_defaults(\n    search_data, \n    name=\"DataSearchTool\",\n    description=\"Search for information in the data\"\n)\n\n# Wrap it with LlamaIndexTool\ntool = LlamaIndexTool.from_tool(og_tool)\n\n# Define an agent that uses the tool\n@agent\ndef researcher(self) -> Agent:\n    '''\n    This agent uses the LlamaIndexTool to search for information.\n    '''\n    return Agent(\n        config=self.agents_config[\"researcher\"],\n        tools=[tool]\n    )"
    },
    {
      "content": "from crewai_tools import LlamaIndexTool\nfrom llama_index.tools.wolfram_alpha import WolframAlphaToolSpec\n\n# Initialize from LlamaHub Tools\nwolfram_spec = WolframAlphaToolSpec(app_id=\"your_app_id\")\nwolfram_tools = wolfram_spec.to_tool_list()\ntools = [LlamaIndexTool.from_tool(t) for t in wolfram_tools]",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`LlamaIndexTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        },
        {
          "title": "From LlamaHub Tools",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`LlamaIndexTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          },
          {
            "title": "From LlamaHub Tools",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `LlamaIndexTool` > Example > From LlamaHub Tools"
      },
      "enhanced_content": "Context: Changelog > `LlamaIndexTool` > Example > From LlamaHub Tools\n\nfrom crewai_tools import LlamaIndexTool\nfrom llama_index.tools.wolfram_alpha import WolframAlphaToolSpec\n\n# Initialize from LlamaHub Tools\nwolfram_spec = WolframAlphaToolSpec(app_id=\"your_app_id\")\nwolfram_tools = wolfram_spec.to_tool_list()\ntools = [LlamaIndexTool.from_tool(t) for t in wolfram_tools]",
      "formatted_path": "Changelog > `LlamaIndexTool` > Example > From LlamaHub Tools",
      "enhanced_text": "Context: Changelog > `LlamaIndexTool` > Example > From LlamaHub Tools\n\nfrom crewai_tools import LlamaIndexTool\nfrom llama_index.tools.wolfram_alpha import WolframAlphaToolSpec\n\n# Initialize from LlamaHub Tools\nwolfram_spec = WolframAlphaToolSpec(app_id=\"your_app_id\")\nwolfram_tools = wolfram_spec.to_tool_list()\ntools = [LlamaIndexTool.from_tool(t) for t in wolfram_tools]"
    },
    {
      "content": "from crewai_tools import LlamaIndexTool\nfrom llama_index.core import VectorStoreIndex\nfrom llama_index.core.readers import SimpleDirectoryReader\n\n# Load documents\ndocuments = SimpleDirectoryReader(\"./data\").load_data()\n\n# Create an index\nindex = VectorStoreIndex.from_documents(documents)\n\n# Create a query engine\nquery_engine = index.as_query_engine()\n\n# Create a LlamaIndexTool from the query engine\nquery_tool = LlamaIndexTool.from_query_engine(\n    query_engine,\n    name=\"Company Data Query Tool\",\n    description=\"Use this tool to lookup information in company documents\"\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`LlamaIndexTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        },
        {
          "title": "From a LlamaIndex Query Engine",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`LlamaIndexTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          },
          {
            "title": "From a LlamaIndex Query Engine",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `LlamaIndexTool` > Example > From a LlamaIndex Query Engine"
      },
      "enhanced_content": "Context: Changelog > `LlamaIndexTool` > Example > From a LlamaIndex Query Engine\n\nfrom crewai_tools import LlamaIndexTool\nfrom llama_index.core import VectorStoreIndex\nfrom llama_index.core.readers import SimpleDirectoryReader\n\n# Load documents\ndocuments = SimpleDirectoryReader(\"./data\").load_data()\n\n# Create an index\nindex = VectorStoreIndex.from_documents(documents)\n\n# Create a query engine\nquery_engine = index.as_query_engine()\n\n# Create a LlamaIndexTool from the query engine\nquery_tool = LlamaIndexTool.from_query_engine(\n    query_engine,\n    name=\"Company Data Query Tool\",\n    description=\"Use this tool to lookup information in company documents\"\n)",
      "formatted_path": "Changelog > `LlamaIndexTool` > Example > From a LlamaIndex Query Engine",
      "enhanced_text": "Context: Changelog > `LlamaIndexTool` > Example > From a LlamaIndex Query Engine\n\nfrom crewai_tools import LlamaIndexTool\nfrom llama_index.core import VectorStoreIndex\nfrom llama_index.core.readers import SimpleDirectoryReader\n\n# Load documents\ndocuments = SimpleDirectoryReader(\"./data\").load_data()\n\n# Create an index\nindex = VectorStoreIndex.from_documents(documents)\n\n# Create a query engine\nquery_engine = index.as_query_engine()\n\n# Create a LlamaIndexTool from the query engine\nquery_tool = LlamaIndexTool.from_query_engine(\n    query_engine,\n    name=\"Company Data Query Tool\",\n    description=\"Use this tool to lookup information in company documents\"\n)"
    },
    {
      "content": "The `LlamaIndexTool` provides two main class methods for creating instances:",
      "title": "Class Methods",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`LlamaIndexTool`",
          "level": 1
        },
        {
          "title": "Class Methods",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`LlamaIndexTool`",
            "level": 1
          },
          {
            "title": "Class Methods",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `LlamaIndexTool` > Class Methods"
      },
      "enhanced_content": "Context: Changelog > `LlamaIndexTool` > Class Methods\n\n## Class Methods\n\nThe `LlamaIndexTool` provides two main class methods for creating instances:",
      "formatted_path": "Changelog > `LlamaIndexTool` > Class Methods",
      "enhanced_text": "Context: Changelog > `LlamaIndexTool` > Class Methods\n\n Class Methods\n\nThe `LlamaIndexTool` provides two main class methods for creating instances:"
    },
    {
      "content": "@classmethod\ndef from_tool(cls, tool: Any, **kwargs: Any) -> \"LlamaIndexTool\":\n    # Implementation details",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`LlamaIndexTool`",
          "level": 1
        },
        {
          "title": "Class Methods",
          "level": 2
        },
        {
          "title": "from\\_tool",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`LlamaIndexTool`",
            "level": 1
          },
          {
            "title": "Class Methods",
            "level": 2
          },
          {
            "title": "from\\_tool",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `LlamaIndexTool` > Class Methods > from\\_tool"
      },
      "enhanced_content": "Context: Changelog > `LlamaIndexTool` > Class Methods > from\\_tool\n\n@classmethod\ndef from_tool(cls, tool: Any, **kwargs: Any) -> \"LlamaIndexTool\":\n    # Implementation details",
      "formatted_path": "Changelog > `LlamaIndexTool` > Class Methods > from\\_tool",
      "enhanced_text": "Context: Changelog > `LlamaIndexTool` > Class Methods > from\\_tool\n\n@classmethod\ndef from_tool(cls, tool: Any, **kwargs: Any) -> \"LlamaIndexTool\":\n    # Implementation details"
    },
    {
      "content": "@classmethod\ndef from_query_engine(\n    cls,\n    query_engine: Any,\n    name: Optional[str] = None,\n    description: Optional[str] = None,\n    return_direct: bool = False,\n    **kwargs: Any,\n) -> \"LlamaIndexTool\":\n    # Implementation details",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`LlamaIndexTool`",
          "level": 1
        },
        {
          "title": "Class Methods",
          "level": 2
        },
        {
          "title": "from\\_query\\_engine",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`LlamaIndexTool`",
            "level": 1
          },
          {
            "title": "Class Methods",
            "level": 2
          },
          {
            "title": "from\\_query\\_engine",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `LlamaIndexTool` > Class Methods > from\\_query\\_engine"
      },
      "enhanced_content": "Context: Changelog > `LlamaIndexTool` > Class Methods > from\\_query\\_engine\n\n@classmethod\ndef from_query_engine(\n    cls,\n    query_engine: Any,\n    name: Optional[str] = None,\n    description: Optional[str] = None,\n    return_direct: bool = False,\n    **kwargs: Any,\n) -> \"LlamaIndexTool\":\n    # Implementation details",
      "formatted_path": "Changelog > `LlamaIndexTool` > Class Methods > from\\_query\\_engine",
      "enhanced_text": "Context: Changelog > `LlamaIndexTool` > Class Methods > from\\_query\\_engine\n\n@classmethod\ndef from_query_engine(\n    cls,\n    query_engine: Any,\n    name: Optional[str] = None,\n    description: Optional[str] = None,\n    return_direct: bool = False,\n    **kwargs: Any,\n) -> \"LlamaIndexTool\":\n    # Implementation details"
    },
    {
      "content": "Source: https://docs.crewai.com/tools/mdxsearchtool The `MDXSearchTool` is designed to search MDX files and return the most relevant results.",
      "title": "MDX RAG Search",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "MDX RAG Search",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "MDX RAG Search",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > MDX RAG Search"
      },
      "enhanced_content": "Context: Changelog > MDX RAG Search\n\n# MDX RAG Search\n\nSource: https://docs.crewai.com/tools/mdxsearchtool The `MDXSearchTool` is designed to search MDX files and return the most relevant results.",
      "formatted_path": "Changelog > MDX RAG Search",
      "enhanced_text": "Context: Changelog > MDX RAG Search\n\n MDX RAG Search\n\nSource: https://docs.crewai.com/tools/mdxsearchtool The `MDXSearchTool` is designed to search MDX files and return the most relevant results."
    },
    {
      "content": "from crewai_tools import FileReadTool\n\n# Initialize the tool to read any files the agents knows or lean the path for\nfile_read_tool = FileReadTool()\n\n# OR\n\n# Initialize the tool with a specific file path, so the agent can only read the content of the specified file\nfile_read_tool = FileReadTool(file_path='path/to/your/file.txt')",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`MDXSearchTool`",
          "level": 1
        },
        {
          "title": "Usage Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`MDXSearchTool`",
            "level": 1
          },
          {
            "title": "Usage Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `MDXSearchTool` > Usage Example"
      },
      "enhanced_content": "Context: Changelog > `MDXSearchTool` > Usage Example\n\nfrom crewai_tools import FileReadTool\n\n# Initialize the tool to read any files the agents knows or lean the path for\nfile_read_tool = FileReadTool()\n\n# OR\n\n# Initialize the tool with a specific file path, so the agent can only read the content of the specified file\nfile_read_tool = FileReadTool(file_path='path/to/your/file.txt')",
      "formatted_path": "Changelog > `MDXSearchTool` > Usage Example",
      "enhanced_text": "Context: Changelog > `MDXSearchTool` > Usage Example\n\nfrom crewai_tools import FileReadTool\n\n# Initialize the tool to read any files the agents knows or lean the path for\nfile_read_tool = FileReadTool()\n\n# OR\n\n# Initialize the tool with a specific file path, so the agent can only read the content of the specified file\nfile_read_tool = FileReadTool(file_path='path/to/your/file.txt')"
    },
    {
      "content": "from crewai_tools import MDXSearchTool\n\n# Initialize the tool to search any MDX content it learns about during execution\ntool = MDXSearchTool()\n\n# OR\n\n# Initialize the tool with a specific MDX file path for an exclusive search within that document\ntool = MDXSearchTool(mdx='path/to/your/document.mdx')",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`MDXSearchTool`",
          "level": 1
        },
        {
          "title": "Usage Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`MDXSearchTool`",
            "level": 1
          },
          {
            "title": "Usage Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `MDXSearchTool` > Usage Example"
      },
      "enhanced_content": "Context: Changelog > `MDXSearchTool` > Usage Example\n\nfrom crewai_tools import MDXSearchTool\n\n# Initialize the tool to search any MDX content it learns about during execution\ntool = MDXSearchTool()\n\n# OR\n\n# Initialize the tool with a specific MDX file path for an exclusive search within that document\ntool = MDXSearchTool(mdx='path/to/your/document.mdx')",
      "formatted_path": "Changelog > `MDXSearchTool` > Usage Example",
      "enhanced_text": "Context: Changelog > `MDXSearchTool` > Usage Example\n\nfrom crewai_tools import MDXSearchTool\n\n# Initialize the tool to search any MDX content it learns about during execution\ntool = MDXSearchTool()\n\n# OR\n\n# Initialize the tool with a specific MDX file path for an exclusive search within that document\ntool = MDXSearchTool(mdx='path/to/your/document.mdx')"
    },
    {
      "content": "tool = MDXSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # Options include google, openai, anthropic, llama2, etc.\n            config=dict(\n                model=\"llama2\",\n                # Optional parameters can be included here.\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # Optional title for the embeddings can be added here.\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`MDXSearchTool`",
          "level": 1
        },
        {
          "title": "Customization of Model and Embeddings",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`MDXSearchTool`",
            "level": 1
          },
          {
            "title": "Customization of Model and Embeddings",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `MDXSearchTool` > Customization of Model and Embeddings"
      },
      "enhanced_content": "Context: Changelog > `MDXSearchTool` > Customization of Model and Embeddings\n\ntool = MDXSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # Options include google, openai, anthropic, llama2, etc.\n            config=dict(\n                model=\"llama2\",\n                # Optional parameters can be included here.\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # Optional title for the embeddings can be added here.\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)",
      "formatted_path": "Changelog > `MDXSearchTool` > Customization of Model and Embeddings",
      "enhanced_text": "Context: Changelog > `MDXSearchTool` > Customization of Model and Embeddings\n\ntool = MDXSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # Options include google, openai, anthropic, llama2, etc.\n            config=dict(\n                model=\"llama2\",\n                # Optional parameters can be included here.\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # Optional title for the embeddings can be added here.\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)"
    },
    {
      "content": "Source: https://docs.crewai.com/tools/multiontool The `MultiOnTool` empowers CrewAI agents with the capability to navigate and interact with the web through natural language instructions.",
      "title": "MultiOn Tool",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "MultiOn Tool",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "MultiOn Tool",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > MultiOn Tool"
      },
      "enhanced_content": "Context: Changelog > MultiOn Tool\n\n# MultiOn Tool\n\nSource: https://docs.crewai.com/tools/multiontool The `MultiOnTool` empowers CrewAI agents with the capability to navigate and interact with the web through natural language instructions.",
      "formatted_path": "Changelog > MultiOn Tool",
      "enhanced_text": "Context: Changelog > MultiOn Tool\n\n MultiOn Tool\n\nSource: https://docs.crewai.com/tools/multiontool The `MultiOnTool` empowers CrewAI agents with the capability to navigate and interact with the web through natural language instructions."
    },
    {
      "content": "Source: https://docs.crewai.com/tools/mysqltool The `MySQLSearchTool` is designed to search MySQL databases and return the most relevant results.",
      "title": "MySQL RAG Search",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "MySQL RAG Search",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "MySQL RAG Search",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > MySQL RAG Search"
      },
      "enhanced_content": "Context: Changelog > MySQL RAG Search\n\n# MySQL RAG Search\n\nSource: https://docs.crewai.com/tools/mysqltool The `MySQLSearchTool` is designed to search MySQL databases and return the most relevant results.",
      "formatted_path": "Changelog > MySQL RAG Search",
      "enhanced_text": "Context: Changelog > MySQL RAG Search\n\n MySQL RAG Search\n\nSource: https://docs.crewai.com/tools/mysqltool The `MySQLSearchTool` is designed to search MySQL databases and return the most relevant results."
    },
    {
      "content": "Source: https://docs.crewai.com/tools/nl2sqltool The `NL2SQLTool` is designed to convert natural language to SQL queries.",
      "title": "NL2SQL Tool",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "NL2SQL Tool",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "NL2SQL Tool",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > NL2SQL Tool"
      },
      "enhanced_content": "Context: Changelog > NL2SQL Tool\n\n# NL2SQL Tool\n\nSource: https://docs.crewai.com/tools/nl2sqltool The `NL2SQLTool` is designed to convert natural language to SQL queries.",
      "formatted_path": "Changelog > NL2SQL Tool",
      "enhanced_text": "Context: Changelog > NL2SQL Tool\n\n NL2SQL Tool\n\nSource: https://docs.crewai.com/tools/nl2sqltool The `NL2SQLTool` is designed to convert natural language to SQL queries."
    },
    {
      "content": "AWS credentials configured (either through environment variables or AWS CLI) `boto3` and `python-dotenv` packages Access to Amazon Bedrock Agents\n\nAWS credentials configured (either through environment variables or AWS CLI) `boto3` and `python-dotenv` packages Access to Amazon Bedrock Knowledge Base\n\nDocker must be installed and running on your system. If you don't have it, you can install it from [here](https://docs.docker.com/get-docker/).\n\nSqlAlchemy Any DB compatible library (e.g. psycopg2, mysql-connector-python)",
      "title": "Requirements",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`NL2SQLTool`",
          "level": 1
        },
        {
          "title": "Requirements",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`NL2SQLTool`",
            "level": 1
          },
          {
            "title": "Requirements",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 1,
        "formatted_path": "Changelog > `NL2SQLTool` > Requirements"
      },
      "enhanced_content": "Context: Changelog > `NL2SQLTool` > Requirements\n\n## Requirements\n\nAWS credentials configured (either through environment variables or AWS CLI) `boto3` and `python-dotenv` packages Access to Amazon Bedrock Agents\n\nAWS credentials configured (either through environment variables or AWS CLI) `boto3` and `python-dotenv` packages Access to Amazon Bedrock Knowledge Base\n\nDocker must be installed and running on your system. If you don't have it, you can install it from [here](https://docs.docker.com/get-docker/).\n\nSqlAlchemy Any DB compatible library (e.g. psycopg2, mysql-connector-python)",
      "formatted_path": "Changelog > `NL2SQLTool` > Requirements",
      "enhanced_text": "Context: Changelog > `NL2SQLTool` > Requirements\n\n Requirements\n\nAWS credentials configured (either through environment variables or AWS CLI) `boto3` and `python-dotenv` packages Access to Amazon Bedrock Agents\n\nAWS credentials configured (either through environment variables or AWS CLI) `boto3` and `python-dotenv` packages Access to Amazon Bedrock Knowledge Base\n\nDocker must be installed and running on your system. If you don't have it, you can install it from [here](https://docs.docker.com/get-docker/).\n\nSqlAlchemy Any DB compatible library (e.g. psycopg2, mysql-connector-python)\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "Source: https://docs.crewai.com/tools/patronustools The Patronus evaluation tools enable CrewAI agents to evaluate and score model inputs and outputs using the Patronus AI platform.",
      "title": "Patronus Evaluation Tools",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Patronus Evaluation Tools",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Patronus Evaluation Tools",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Patronus Evaluation Tools"
      },
      "enhanced_content": "Context: Changelog > Patronus Evaluation Tools\n\n# Patronus Evaluation Tools\n\nSource: https://docs.crewai.com/tools/patronustools The Patronus evaluation tools enable CrewAI agents to evaluate and score model inputs and outputs using the Patronus AI platform.",
      "formatted_path": "Changelog > Patronus Evaluation Tools",
      "enhanced_text": "Context: Changelog > Patronus Evaluation Tools\n\n Patronus Evaluation Tools\n\nSource: https://docs.crewai.com/tools/patronustools The Patronus evaluation tools enable CrewAI agents to evaluate and score model inputs and outputs using the Patronus AI platform.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "from crewai import Agent, Task, Crew\nfrom crewai_tools import PatronusEvalTool\n\n# Initialize the tool\npatronus_eval_tool = PatronusEvalTool()\n\n# Define an agent that uses the tool\ncoding_agent = Agent(\n    role=\"Coding Agent\",\n    goal=\"Generate high quality code and verify that the output is code\",\n    backstory=\"An experienced coder who can generate high quality python code.\",\n    tools=[patronus_eval_tool],\n    verbose=True,\n)\n\n# Example task to generate and evaluate code\ngenerate_code_task = Task(\n    description=\"Create a simple program to generate the first N numbers in the Fibonacci sequence. Select the most appropriate evaluator and criteria for evaluating your output.\",\n    expected_output=\"Program that generates the first N numbers in the Fibonacci sequence.\",\n    agent=coding_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[coding_agent], tasks=[generate_code_task])\nresult = crew.kickoff()",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`Patronus Evaluation Tools`",
          "level": 1
        },
        {
          "title": "Examples",
          "level": 2
        },
        {
          "title": "Using PatronusEvalTool",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`Patronus Evaluation Tools`",
            "level": 1
          },
          {
            "title": "Examples",
            "level": 2
          },
          {
            "title": "Using PatronusEvalTool",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `Patronus Evaluation Tools` > Examples > Using PatronusEvalTool"
      },
      "enhanced_content": "Context: Changelog > `Patronus Evaluation Tools` > Examples > Using PatronusEvalTool\n\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import PatronusEvalTool\n\n# Initialize the tool\npatronus_eval_tool = PatronusEvalTool()\n\n# Define an agent that uses the tool\ncoding_agent = Agent(\n    role=\"Coding Agent\",\n    goal=\"Generate high quality code and verify that the output is code\",\n    backstory=\"An experienced coder who can generate high quality python code.\",\n    tools=[patronus_eval_tool],\n    verbose=True,\n)\n\n# Example task to generate and evaluate code\ngenerate_code_task = Task(\n    description=\"Create a simple program to generate the first N numbers in the Fibonacci sequence. Select the most appropriate evaluator and criteria for evaluating your output.\",\n    expected_output=\"Program that generates the first N numbers in the Fibonacci sequence.\",\n    agent=coding_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[coding_agent], tasks=[generate_code_task])\nresult = crew.kickoff()",
      "formatted_path": "Changelog > `Patronus Evaluation Tools` > Examples > Using PatronusEvalTool",
      "enhanced_text": "Context: Changelog > `Patronus Evaluation Tools` > Examples > Using PatronusEvalTool\n\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import PatronusEvalTool\n\n# Initialize the tool\npatronus_eval_tool = PatronusEvalTool()\n\n# Define an agent that uses the tool\ncoding_agent = Agent(\n    role=\"Coding Agent\",\n    goal=\"Generate high quality code and verify that the output is code\",\n    backstory=\"An experienced coder who can generate high quality python code.\",\n    tools=[patronus_eval_tool],\n    verbose=True,\n)\n\n# Example task to generate and evaluate code\ngenerate_code_task = Task(\n    description=\"Create a simple program to generate the first N numbers in the Fibonacci sequence. Select the most appropriate evaluator and criteria for evaluating your output.\",\n    expected_output=\"Program that generates the first N numbers in the Fibonacci sequence.\",\n    agent=coding_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[coding_agent], tasks=[generate_code_task])\nresult = crew.kickoff()"
    },
    {
      "content": "from crewai import Agent, Task, Crew\nfrom crewai_tools import PatronusPredefinedCriteriaEvalTool\n\n# Initialize the tool with predefined criteria\npatronus_eval_tool = PatronusPredefinedCriteriaEvalTool(\n    evaluators=[{\"evaluator\": \"judge\", \"criteria\": \"contains-code\"}]\n)\n\n# Define an agent that uses the tool\ncoding_agent = Agent(\n    role=\"Coding Agent\",\n    goal=\"Generate high quality code\",\n    backstory=\"An experienced coder who can generate high quality python code.\",\n    tools=[patronus_eval_tool],\n    verbose=True,\n)\n\n# Example task to generate code\ngenerate_code_task = Task(\n    description=\"Create a simple program to generate the first N numbers in the Fibonacci sequence.\",\n    expected_output=\"Program that generates the first N numbers in the Fibonacci sequence.\",\n    agent=coding_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[coding_agent], tasks=[generate_code_task])\nresult = crew.kickoff()",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`Patronus Evaluation Tools`",
          "level": 1
        },
        {
          "title": "Examples",
          "level": 2
        },
        {
          "title": "Using PatronusPredefinedCriteriaEvalTool",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`Patronus Evaluation Tools`",
            "level": 1
          },
          {
            "title": "Examples",
            "level": 2
          },
          {
            "title": "Using PatronusPredefinedCriteriaEvalTool",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `Patronus Evaluation Tools` > Examples > Using PatronusPredefinedCriteriaEvalTool"
      },
      "enhanced_content": "Context: Changelog > `Patronus Evaluation Tools` > Examples > Using PatronusPredefinedCriteriaEvalTool\n\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import PatronusPredefinedCriteriaEvalTool\n\n# Initialize the tool with predefined criteria\npatronus_eval_tool = PatronusPredefinedCriteriaEvalTool(\n    evaluators=[{\"evaluator\": \"judge\", \"criteria\": \"contains-code\"}]\n)\n\n# Define an agent that uses the tool\ncoding_agent = Agent(\n    role=\"Coding Agent\",\n    goal=\"Generate high quality code\",\n    backstory=\"An experienced coder who can generate high quality python code.\",\n    tools=[patronus_eval_tool],\n    verbose=True,\n)\n\n# Example task to generate code\ngenerate_code_task = Task(\n    description=\"Create a simple program to generate the first N numbers in the Fibonacci sequence.\",\n    expected_output=\"Program that generates the first N numbers in the Fibonacci sequence.\",\n    agent=coding_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[coding_agent], tasks=[generate_code_task])\nresult = crew.kickoff()",
      "formatted_path": "Changelog > `Patronus Evaluation Tools` > Examples > Using PatronusPredefinedCriteriaEvalTool",
      "enhanced_text": "Context: Changelog > `Patronus Evaluation Tools` > Examples > Using PatronusPredefinedCriteriaEvalTool\n\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import PatronusPredefinedCriteriaEvalTool\n\n# Initialize the tool with predefined criteria\npatronus_eval_tool = PatronusPredefinedCriteriaEvalTool(\n    evaluators=[{\"evaluator\": \"judge\", \"criteria\": \"contains-code\"}]\n)\n\n# Define an agent that uses the tool\ncoding_agent = Agent(\n    role=\"Coding Agent\",\n    goal=\"Generate high quality code\",\n    backstory=\"An experienced coder who can generate high quality python code.\",\n    tools=[patronus_eval_tool],\n    verbose=True,\n)\n\n# Example task to generate code\ngenerate_code_task = Task(\n    description=\"Create a simple program to generate the first N numbers in the Fibonacci sequence.\",\n    expected_output=\"Program that generates the first N numbers in the Fibonacci sequence.\",\n    agent=coding_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[coding_agent], tasks=[generate_code_task])\nresult = crew.kickoff()"
    },
    {
      "content": "from crewai import Agent, Task, Crew\nfrom crewai_tools import PatronusLocalEvaluatorTool\nfrom patronus import Client, EvaluationResult\nimport random\n\n# Initialize the Patronus client\nclient = Client()\n\n# Register a custom evaluator\n@client.register_local_evaluator(\"random_evaluator\")\ndef random_evaluator(**kwargs):\n    score = random.random()\n    return EvaluationResult(\n        score_raw=score,\n        pass_=score >= 0.5,\n        explanation=\"example explanation\",\n    )\n\n# Initialize the tool with the custom evaluator\npatronus_eval_tool = PatronusLocalEvaluatorTool(\n    patronus_client=client,\n    evaluator=\"random_evaluator\",\n    evaluated_model_gold_answer=\"example label\",\n)\n\n# Define an agent that uses the tool\ncoding_agent = Agent(\n    role=\"Coding Agent\",\n    goal=\"Generate high quality code\",\n    backstory=\"An experienced coder who can generate high quality python code.\",\n    tools=[patronus_eval_tool],\n    verbose=True,\n)\n\n# Example task to generate code\ngenerate_code_task = Task(\n    description=\"Create a simple program to generate the first N numbers in the Fibonacci sequence.\",\n    expected_output=\"Program that generates the first N numbers in the Fibonacci sequence.\",\n    agent=coding_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[coding_agent], tasks=[generate_code_task])\nresult = crew.kickoff()",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`Patronus Evaluation Tools`",
          "level": 1
        },
        {
          "title": "Examples",
          "level": 2
        },
        {
          "title": "Using PatronusLocalEvaluatorTool",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`Patronus Evaluation Tools`",
            "level": 1
          },
          {
            "title": "Examples",
            "level": 2
          },
          {
            "title": "Using PatronusLocalEvaluatorTool",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `Patronus Evaluation Tools` > Examples > Using PatronusLocalEvaluatorTool"
      },
      "enhanced_content": "Context: Changelog > `Patronus Evaluation Tools` > Examples > Using PatronusLocalEvaluatorTool\n\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import PatronusLocalEvaluatorTool\nfrom patronus import Client, EvaluationResult\nimport random\n\n# Initialize the Patronus client\nclient = Client()\n\n# Register a custom evaluator\n@client.register_local_evaluator(\"random_evaluator\")\ndef random_evaluator(**kwargs):\n    score = random.random()\n    return EvaluationResult(\n        score_raw=score,\n        pass_=score >= 0.5,\n        explanation=\"example explanation\",\n    )\n\n# Initialize the tool with the custom evaluator\npatronus_eval_tool = PatronusLocalEvaluatorTool(\n    patronus_client=client,\n    evaluator=\"random_evaluator\",\n    evaluated_model_gold_answer=\"example label\",\n)\n\n# Define an agent that uses the tool\ncoding_agent = Agent(\n    role=\"Coding Agent\",\n    goal=\"Generate high quality code\",\n    backstory=\"An experienced coder who can generate high quality python code.\",\n    tools=[patronus_eval_tool],\n    verbose=True,\n)\n\n# Example task to generate code\ngenerate_code_task = Task(\n    description=\"Create a simple program to generate the first N numbers in the Fibonacci sequence.\",\n    expected_output=\"Program that generates the first N numbers in the Fibonacci sequence.\",\n    agent=coding_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[coding_agent], tasks=[generate_code_task])\nresult = crew.kickoff()",
      "formatted_path": "Changelog > `Patronus Evaluation Tools` > Examples > Using PatronusLocalEvaluatorTool",
      "enhanced_text": "Context: Changelog > `Patronus Evaluation Tools` > Examples > Using PatronusLocalEvaluatorTool\n\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import PatronusLocalEvaluatorTool\nfrom patronus import Client, EvaluationResult\nimport random\n\n# Initialize the Patronus client\nclient = Client()\n\n# Register a custom evaluator\n@client.register_local_evaluator(\"random_evaluator\")\ndef random_evaluator(**kwargs):\n    score = random.random()\n    return EvaluationResult(\n        score_raw=score,\n        pass_=score >= 0.5,\n        explanation=\"example explanation\",\n    )\n\n# Initialize the tool with the custom evaluator\npatronus_eval_tool = PatronusLocalEvaluatorTool(\n    patronus_client=client,\n    evaluator=\"random_evaluator\",\n    evaluated_model_gold_answer=\"example label\",\n)\n\n# Define an agent that uses the tool\ncoding_agent = Agent(\n    role=\"Coding Agent\",\n    goal=\"Generate high quality code\",\n    backstory=\"An experienced coder who can generate high quality python code.\",\n    tools=[patronus_eval_tool],\n    verbose=True,\n)\n\n# Example task to generate code\ngenerate_code_task = Task(\n    description=\"Create a simple program to generate the first N numbers in the Fibonacci sequence.\",\n    expected_output=\"Program that generates the first N numbers in the Fibonacci sequence.\",\n    agent=coding_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[coding_agent], tasks=[generate_code_task])\nresult = crew.kickoff()"
    },
    {
      "content": "The `PatronusEvalTool` does not require any parameters during initialization. It automatically fetches available evaluators and criteria from the Patronus API.",
      "title": "PatronusEvalTool",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`Patronus Evaluation Tools`",
          "level": 1
        },
        {
          "title": "Parameters",
          "level": 2
        },
        {
          "title": "PatronusEvalTool",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`Patronus Evaluation Tools`",
            "level": 1
          },
          {
            "title": "Parameters",
            "level": 2
          },
          {
            "title": "PatronusEvalTool",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `Patronus Evaluation Tools` > Parameters > PatronusEvalTool"
      },
      "enhanced_content": "Context: Changelog > `Patronus Evaluation Tools` > Parameters > PatronusEvalTool\n\n### PatronusEvalTool\n\nThe `PatronusEvalTool` does not require any parameters during initialization. It automatically fetches available evaluators and criteria from the Patronus API.",
      "formatted_path": "Changelog > `Patronus Evaluation Tools` > Parameters > PatronusEvalTool",
      "enhanced_text": "Context: Changelog > `Patronus Evaluation Tools` > Parameters > PatronusEvalTool\n\n PatronusEvalTool\n\nThe `PatronusEvalTool` does not require any parameters during initialization. It automatically fetches available evaluators and criteria from the Patronus API.\n\nRelated sections:\n- \n"
    },
    {
      "content": "The `PatronusPredefinedCriteriaEvalTool` accepts the following parameters during initialization: **evaluators**: Required. A list of dictionaries containing the evaluator and criteria to use. For example: `[{\"evaluator\": \"judge\", \"criteria\": \"contains-code\"}]`.",
      "title": "PatronusPredefinedCriteriaEvalTool",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`Patronus Evaluation Tools`",
          "level": 1
        },
        {
          "title": "Parameters",
          "level": 2
        },
        {
          "title": "PatronusPredefinedCriteriaEvalTool",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`Patronus Evaluation Tools`",
            "level": 1
          },
          {
            "title": "Parameters",
            "level": 2
          },
          {
            "title": "PatronusPredefinedCriteriaEvalTool",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `Patronus Evaluation Tools` > Parameters > PatronusPredefinedCriteriaEvalTool"
      },
      "enhanced_content": "Context: Changelog > `Patronus Evaluation Tools` > Parameters > PatronusPredefinedCriteriaEvalTool\n\n### PatronusPredefinedCriteriaEvalTool\n\nThe `PatronusPredefinedCriteriaEvalTool` accepts the following parameters during initialization: **evaluators**: Required. A list of dictionaries containing the evaluator and criteria to use. For example: `[{\"evaluator\": \"judge\", \"criteria\": \"contains-code\"}]`.",
      "formatted_path": "Changelog > `Patronus Evaluation Tools` > Parameters > PatronusPredefinedCriteriaEvalTool",
      "enhanced_text": "Context: Changelog > `Patronus Evaluation Tools` > Parameters > PatronusPredefinedCriteriaEvalTool\n\n PatronusPredefinedCriteriaEvalTool\n\nThe `PatronusPredefinedCriteriaEvalTool` accepts the following parameters during initialization: **evaluators**: Required. A list of dictionaries containing the evaluator and criteria to use. For example: `[{\"evaluator\": \"judge\", \"criteria\": \"contains-code\"}]`.\n\nRelated sections:\n- \n"
    },
    {
      "content": "The `PatronusLocalEvaluatorTool` accepts the following parameters during initialization: **patronus\\_client**: Required. The Patronus client instance. **evaluator**: Optional. The name of the registered local evaluator to use. Default is an empty string. **evaluated\\_model\\_gold\\_answer**: Optional. The gold answer to use for evaluation. Default is an empty string.",
      "title": "PatronusLocalEvaluatorTool",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`Patronus Evaluation Tools`",
          "level": 1
        },
        {
          "title": "Parameters",
          "level": 2
        },
        {
          "title": "PatronusLocalEvaluatorTool",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`Patronus Evaluation Tools`",
            "level": 1
          },
          {
            "title": "Parameters",
            "level": 2
          },
          {
            "title": "PatronusLocalEvaluatorTool",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `Patronus Evaluation Tools` > Parameters > PatronusLocalEvaluatorTool"
      },
      "enhanced_content": "Context: Changelog > `Patronus Evaluation Tools` > Parameters > PatronusLocalEvaluatorTool\n\n### PatronusLocalEvaluatorTool\n\nThe `PatronusLocalEvaluatorTool` accepts the following parameters during initialization: **patronus\\_client**: Required. The Patronus client instance. **evaluator**: Optional. The name of the registered local evaluator to use. Default is an empty string. **evaluated\\_model\\_gold\\_answer**: Optional. The gold answer to use for evaluation. Default is an empty string.",
      "formatted_path": "Changelog > `Patronus Evaluation Tools` > Parameters > PatronusLocalEvaluatorTool",
      "enhanced_text": "Context: Changelog > `Patronus Evaluation Tools` > Parameters > PatronusLocalEvaluatorTool\n\n PatronusLocalEvaluatorTool\n\nThe `PatronusLocalEvaluatorTool` accepts the following parameters during initialization: **patronus\\_client**: Required. The Patronus client instance. **evaluator**: Optional. The name of the registered local evaluator to use. Default is an empty string. **evaluated\\_model\\_gold\\_answer**: Optional. The gold answer to use for evaluation. Default is an empty string.\n\nRelated sections:\n- \n"
    },
    {
      "content": "Source: https://docs.crewai.com/tools/pdfsearchtool The `PDFSearchTool` is designed to search PDF files and return the most relevant results.",
      "title": "PDF RAG Search",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "PDF RAG Search",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "PDF RAG Search",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > PDF RAG Search"
      },
      "enhanced_content": "Context: Changelog > PDF RAG Search\n\n# PDF RAG Search\n\nSource: https://docs.crewai.com/tools/pdfsearchtool The `PDFSearchTool` is designed to search PDF files and return the most relevant results.",
      "formatted_path": "Changelog > PDF RAG Search",
      "enhanced_text": "Context: Changelog > PDF RAG Search\n\n PDF RAG Search\n\nSource: https://docs.crewai.com/tools/pdfsearchtool The `PDFSearchTool` is designed to search PDF files and return the most relevant results."
    },
    {
      "content": "Source: https://docs.crewai.com/tools/pgsearchtool The `PGSearchTool` is designed to search PostgreSQL databases and return the most relevant results.",
      "title": "PG RAG Search",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "PG RAG Search",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "PG RAG Search",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > PG RAG Search"
      },
      "enhanced_content": "Context: Changelog > PG RAG Search\n\n# PG RAG Search\n\nSource: https://docs.crewai.com/tools/pgsearchtool The `PGSearchTool` is designed to search PostgreSQL databases and return the most relevant results.",
      "formatted_path": "Changelog > PG RAG Search",
      "enhanced_text": "Context: Changelog > PG RAG Search\n\n PG RAG Search\n\nSource: https://docs.crewai.com/tools/pgsearchtool The `PGSearchTool` is designed to search PostgreSQL databases and return the most relevant results."
    },
    {
      "content": "Source: https://docs.crewai.com/tools/qdrantvectorsearchtool Semantic search capabilities for CrewAI agents using Qdrant vector database",
      "title": "Qdrant Vector Search Tool",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Qdrant Vector Search Tool",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Qdrant Vector Search Tool",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Qdrant Vector Search Tool"
      },
      "enhanced_content": "Context: Changelog > Qdrant Vector Search Tool\n\n# Qdrant Vector Search Tool\n\nSource: https://docs.crewai.com/tools/qdrantvectorsearchtool Semantic search capabilities for CrewAI agents using Qdrant vector database",
      "formatted_path": "Changelog > Qdrant Vector Search Tool",
      "enhanced_text": "Context: Changelog > Qdrant Vector Search Tool\n\n Qdrant Vector Search Tool\n\nSource: https://docs.crewai.com/tools/qdrantvectorsearchtool Semantic search capabilities for CrewAI agents using Qdrant vector database"
    },
    {
      "content": "The Qdrant Vector Search Tool enables semantic search capabilities in your CrewAI agents by leveraging [Qdrant](https://qdrant.tech/), a vector similarity search engine. This tool allows your agents to search through documents stored in a Qdrant collection using semantic similarity.",
      "title": "`QdrantVectorSearchTool`",
      "type": "link_list",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`QdrantVectorSearchTool`",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`QdrantVectorSearchTool`",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 1,
        "formatted_path": "Changelog > `QdrantVectorSearchTool`"
      },
      "enhanced_content": "Context: Changelog > `QdrantVectorSearchTool`\n\n# `QdrantVectorSearchTool`\n\nThe Qdrant Vector Search Tool enables semantic search capabilities in your CrewAI agents by leveraging [Qdrant](https://qdrant.tech/), a vector similarity search engine. This tool allows your agents to search through documents stored in a Qdrant collection using semantic similarity.",
      "formatted_path": "Changelog > `QdrantVectorSearchTool`",
      "enhanced_text": "Context: Changelog > `QdrantVectorSearchTool`\n\n `QdrantVectorSearchTool`\n\nThe Qdrant Vector Search Tool enables semantic search capabilities in your CrewAI agents by leveraging [Qdrant](https://qdrant.tech/), a vector similarity search engine. This tool allows your agents to search through documents stored in a Qdrant collection using semantic similarity."
    },
    {
      "content": "crewai [COMMAND] [OPTIONS] [ARGUMENTS]",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`QdrantVectorSearchTool`",
          "level": 1
        },
        {
          "title": "Basic Usage",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`QdrantVectorSearchTool`",
            "level": 1
          },
          {
            "title": "Basic Usage",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `QdrantVectorSearchTool` > Basic Usage"
      },
      "enhanced_content": "Context: Changelog > `QdrantVectorSearchTool` > Basic Usage\n\ncrewai [COMMAND] [OPTIONS] [ARGUMENTS]",
      "formatted_path": "Changelog > `QdrantVectorSearchTool` > Basic Usage",
      "enhanced_text": "Context: Changelog > `QdrantVectorSearchTool` > Basic Usage\n\ncrewai [COMMAND] [OPTIONS] [ARGUMENTS]"
    },
    {
      "content": "from typing import Tuple, Union\nfrom crewai import Task\n\ndef validate_json_output(result: str) -> Tuple[bool, Union[dict, str]]:\n    \"\"\"Validate that the output is valid JSON.\"\"\"\n    try:\n        json_data = json.loads(result)\n        return (True, json_data)\n    except json.JSONDecodeError:\n        return (False, \"Output must be valid JSON\")\n\ntask = Task(\n    description=\"Generate JSON data\",\n    expected_output=\"Valid JSON object\",\n    guardrail=validate_json_output\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`QdrantVectorSearchTool`",
          "level": 1
        },
        {
          "title": "Basic Usage",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`QdrantVectorSearchTool`",
            "level": 1
          },
          {
            "title": "Basic Usage",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `QdrantVectorSearchTool` > Basic Usage"
      },
      "enhanced_content": "Context: Changelog > `QdrantVectorSearchTool` > Basic Usage\n\nfrom typing import Tuple, Union\nfrom crewai import Task\n\ndef validate_json_output(result: str) -> Tuple[bool, Union[dict, str]]:\n    \"\"\"Validate that the output is valid JSON.\"\"\"\n    try:\n        json_data = json.loads(result)\n        return (True, json_data)\n    except json.JSONDecodeError:\n        return (False, \"Output must be valid JSON\")\n\ntask = Task(\n    description=\"Generate JSON data\",\n    expected_output=\"Valid JSON object\",\n    guardrail=validate_json_output\n)",
      "formatted_path": "Changelog > `QdrantVectorSearchTool` > Basic Usage",
      "enhanced_text": "Context: Changelog > `QdrantVectorSearchTool` > Basic Usage\n\nfrom typing import Tuple, Union\nfrom crewai import Task\n\ndef validate_json_output(result: str) -> Tuple[bool, Union[dict, str]]:\n    \"\"\"Validate that the output is valid JSON.\"\"\"\n    try:\n        json_data = json.loads(result)\n        return (True, json_data)\n    except json.JSONDecodeError:\n        return (False, \"Output must be valid JSON\")\n\ntask = Task(\n    description=\"Generate JSON data\",\n    expected_output=\"Valid JSON object\",\n    guardrail=validate_json_output\n)"
    },
    {
      "content": "from crewai import Agent\nfrom crewai_tools import QdrantVectorSearchTool\n\n# Initialize the tool\nqdrant_tool = QdrantVectorSearchTool(\n    qdrant_url=\"your_qdrant_url\",\n    qdrant_api_key=\"your_qdrant_api_key\",\n    collection_name=\"your_collection\"\n)\n\n# Create an agent that uses the tool\nagent = Agent(\n    role=\"Research Assistant\",\n    goal=\"Find relevant information in documents\",\n    tools=[qdrant_tool]\n)\n\n# The tool will automatically use OpenAI embeddings\n# and return the 3 most relevant results with scores > 0.35",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`QdrantVectorSearchTool`",
          "level": 1
        },
        {
          "title": "Basic Usage",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`QdrantVectorSearchTool`",
            "level": 1
          },
          {
            "title": "Basic Usage",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `QdrantVectorSearchTool` > Basic Usage"
      },
      "enhanced_content": "Context: Changelog > `QdrantVectorSearchTool` > Basic Usage\n\nfrom crewai import Agent\nfrom crewai_tools import QdrantVectorSearchTool\n\n# Initialize the tool\nqdrant_tool = QdrantVectorSearchTool(\n    qdrant_url=\"your_qdrant_url\",\n    qdrant_api_key=\"your_qdrant_api_key\",\n    collection_name=\"your_collection\"\n)\n\n# Create an agent that uses the tool\nagent = Agent(\n    role=\"Research Assistant\",\n    goal=\"Find relevant information in documents\",\n    tools=[qdrant_tool]\n)\n\n# The tool will automatically use OpenAI embeddings\n# and return the 3 most relevant results with scores > 0.35",
      "formatted_path": "Changelog > `QdrantVectorSearchTool` > Basic Usage",
      "enhanced_text": "Context: Changelog > `QdrantVectorSearchTool` > Basic Usage\n\nfrom crewai import Agent\nfrom crewai_tools import QdrantVectorSearchTool\n\n# Initialize the tool\nqdrant_tool = QdrantVectorSearchTool(\n    qdrant_url=\"your_qdrant_url\",\n    qdrant_api_key=\"your_qdrant_api_key\",\n    collection_name=\"your_collection\"\n)\n\n# Create an agent that uses the tool\nagent = Agent(\n    role=\"Research Assistant\",\n    goal=\"Find relevant information in documents\",\n    tools=[qdrant_tool]\n)\n\n# The tool will automatically use OpenAI embeddings\n# and return the 3 most relevant results with scores > 0.35"
    },
    {
      "content": "import os\nimport uuid\nimport pdfplumber\nfrom openai import OpenAI\nfrom dotenv import load_dotenv\nfrom crewai import Agent, Task, Crew, Process, LLM\nfrom crewai_tools import QdrantVectorSearchTool\nfrom qdrant_client import QdrantClient\nfrom qdrant_client.models import PointStruct, Distance, VectorParams\n\n# Load environment variables\nload_dotenv()\n\n# Initialize OpenAI client\nclient = OpenAI(api_key=os.getenv(\"OPENAI_API_KEY\"))\n\n# Extract text from PDF\ndef extract_text_from_pdf(pdf_path):\n    text = []\n    with pdfplumber.open(pdf_path) as pdf:\n        for page in pdf.pages:\n            page_text = page.extract_text()\n            if page_text:\n                text.append(page_text.strip())\n    return text\n\n# Generate OpenAI embeddings\ndef get_openai_embedding(text):\n    response = client.embeddings.create(\n        input=text,\n        model=\"text-embedding-3-small\"\n    )\n    return response.data[0].embedding\n\n# Store text and embeddings in Qdrant\ndef load_pdf_to_qdrant(pdf_path, qdrant, collection_name):\n    # Extract text from PDF\n    text_chunks = extract_text_from_pdf(pdf_path)\n    \n    # Create Qdrant collection\n    if qdrant.collection_exists(collection_name):\n        qdrant.delete_collection(collection_name)\n    qdrant.create_collection(\n        collection_name=collection_name,\n        vectors_config=VectorParams(size=1536, distance=Distance.COSINE)\n    )\n\n    # Store embeddings\n    points = []\n    for chunk in text_chunks:\n        embedding = get_openai_embedding(chunk)\n        points.append(PointStruct(\n            id=str(uuid.uuid4()),\n            vector=embedding,\n            payload={\"text\": chunk}\n        ))\n    qdrant.upsert(collection_name=collection_name, points=points)\n\n# Initialize Qdrant client and load data\nqdrant = QdrantClient(\n    url=os.getenv(\"QDRANT_URL\"),\n    api_key=os.getenv(\"QDRANT_API_KEY\")\n)\ncollection_name = \"example_collection\"\npdf_path = \"path/to/your/document.pdf\"\nload_pdf_to_qdrant(pdf_path, qdrant, collection_name)\n\n# Initialize Qdrant search tool\nqdrant_tool = QdrantVectorSearchTool(\n    qdrant_url=os.getenv(\"QDRANT_URL\"),\n    qdrant_api_key=os.getenv(\"QDRANT_API_KEY\"),\n    collection_name=collection_name,\n    limit=3,\n    score_threshold=0.35\n)\n\n# Create CrewAI agents\nsearch_agent = Agent(\n    role=\"Senior Semantic Search Agent\",\n    goal=\"Find and analyze documents based on semantic search\",\n    backstory=\"\"\"You are an expert research assistant who can find relevant \n    information using semantic search in a Qdrant database.\"\"\",\n    tools=[qdrant_tool],\n    verbose=True\n)\n\nanswer_agent = Agent(\n    role=\"Senior Answer Assistant\",\n    goal=\"Generate answers to questions based on the context provided\",\n    backstory=\"\"\"You are an expert answer assistant who can generate \n    answers to questions based on the context provided.\"\"\",\n    tools=[qdrant_tool],\n    verbose=True\n)\n\n# Define tasks\nsearch_task = Task(\n    description=\"\"\"Search for relevant documents about the {query}.\n    Your final answer should include:\n    - The relevant information found\n    - The similarity scores of the results\n    - The metadata of the relevant documents\"\"\",\n    agent=search_agent\n)\n\nanswer_task = Task(\n    description=\"\"\"Given the context and metadata of relevant documents,\n    generate a final answer based on the context.\"\"\",\n    agent=answer_agent\n)\n\n# Run CrewAI workflow\ncrew = Crew(\n    agents=[search_agent, answer_agent],\n    tasks=[search_task, answer_task],\n    process=Process.sequential,\n    verbose=True\n)\n\nresult = crew.kickoff(\n    inputs={\"query\": \"What is the role of X in the document?\"}\n)\nprint(result)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`QdrantVectorSearchTool`",
          "level": 1
        },
        {
          "title": "Complete Working Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`QdrantVectorSearchTool`",
            "level": 1
          },
          {
            "title": "Complete Working Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `QdrantVectorSearchTool` > Complete Working Example"
      },
      "enhanced_content": "Context: Changelog > `QdrantVectorSearchTool` > Complete Working Example\n\nimport os\nimport uuid\nimport pdfplumber\nfrom openai import OpenAI\nfrom dotenv import load_dotenv\nfrom crewai import Agent, Task, Crew, Process, LLM\nfrom crewai_tools import QdrantVectorSearchTool\nfrom qdrant_client import QdrantClient\nfrom qdrant_client.models import PointStruct, Distance, VectorParams\n\n# Load environment variables\nload_dotenv()\n\n# Initialize OpenAI client\nclient = OpenAI(api_key=os.getenv(\"OPENAI_API_KEY\"))\n\n# Extract text from PDF\ndef extract_text_from_pdf(pdf_path):\n    text = []\n    with pdfplumber.open(pdf_path) as pdf:\n        for page in pdf.pages:\n            page_text = page.extract_text()\n            if page_text:\n                text.append(page_text.strip())\n    return text\n\n# Generate OpenAI embeddings\ndef get_openai_embedding(text):\n    response = client.embeddings.create(\n        input=text,\n        model=\"text-embedding-3-small\"\n    )\n    return response.data[0].embedding\n\n# Store text and embeddings in Qdrant\ndef load_pdf_to_qdrant(pdf_path, qdrant, collection_name):\n    # Extract text from PDF\n    text_chunks = extract_text_from_pdf(pdf_path)\n    \n    # Create Qdrant collection\n    if qdrant.collection_exists(collection_name):\n        qdrant.delete_collection(collection_name)\n    qdrant.create_collection(\n        collection_name=collection_name,\n        vectors_config=VectorParams(size=1536, distance=Distance.COSINE)\n    )\n\n    # Store embeddings\n    points = []\n    for chunk in text_chunks:\n        embedding = get_openai_embedding(chunk)\n        points.append(PointStruct(\n            id=str(uuid.uuid4()),\n            vector=embedding,\n            payload={\"text\": chunk}\n        ))\n    qdrant.upsert(collection_name=collection_name, points=points)\n\n# Initialize Qdrant client and load data\nqdrant = QdrantClient(\n    url=os.getenv(\"QDRANT_URL\"),\n    api_key=os.getenv(\"QDRANT_API_KEY\")\n)\ncollection_name = \"example_collection\"\npdf_path = \"path/to/your/document.pdf\"\nload_pdf_to_qdrant(pdf_path, qdrant, collection_name)\n\n# Initialize Qdrant search tool\nqdrant_tool = QdrantVectorSearchTool(\n    qdrant_url=os.getenv(\"QDRANT_URL\"),\n    qdrant_api_key=os.getenv(\"QDRANT_API_KEY\"),\n    collection_name=collection_name,\n    limit=3,\n    score_threshold=0.35\n)\n\n# Create CrewAI agents\nsearch_agent = Agent(\n    role=\"Senior Semantic Search Agent\",\n    goal=\"Find and analyze documents based on semantic search\",\n    backstory=\"\"\"You are an expert research assistant who can find relevant \n    information using semantic search in a Qdrant database.\"\"\",\n    tools=[qdrant_tool],\n    verbose=True\n)\n\nanswer_agent = Agent(\n    role=\"Senior Answer Assistant\",\n    goal=\"Generate answers to questions based on the context provided\",\n    backstory=\"\"\"You are an expert answer assistant who can generate \n    answers to questions based on the context provided.\"\"\",\n    tools=[qdrant_tool],\n    verbose=True\n)\n\n# Define tasks\nsearch_task = Task(\n    description=\"\"\"Search for relevant documents about the {query}.\n    Your final answer should include:\n    - The relevant information found\n    - The similarity scores of the results\n    - The metadata of the relevant documents\"\"\",\n    agent=search_agent\n)\n\nanswer_task = Task(\n    description=\"\"\"Given the context and metadata of relevant documents,\n    generate a final answer based on the context.\"\"\",\n    agent=answer_agent\n)\n\n# Run CrewAI workflow\ncrew = Crew(\n    agents=[search_agent, answer_agent],\n    tasks=[search_task, answer_task],\n    process=Process.sequential,\n    verbose=True\n)\n\nresult = crew.kickoff(\n    inputs={\"query\": \"What is the role of X in the document?\"}\n)\nprint(result)",
      "formatted_path": "Changelog > `QdrantVectorSearchTool` > Complete Working Example",
      "enhanced_text": "Context: Changelog > `QdrantVectorSearchTool` > Complete Working Example\n\nimport os\nimport uuid\nimport pdfplumber\nfrom openai import OpenAI\nfrom dotenv import load_dotenv\nfrom crewai import Agent, Task, Crew, Process, LLM\nfrom crewai_tools import QdrantVectorSearchTool\nfrom qdrant_client import QdrantClient\nfrom qdrant_client.models import PointStruct, Distance, VectorParams\n\n# Load environment variables\nload_dotenv()\n\n# Initialize OpenAI client\nclient = OpenAI(api_key=os.getenv(\"OPENAI_API_KEY\"))\n\n# Extract text from PDF\ndef extract_text_from_pdf(pdf_path):\n    text = []\n    with pdfplumber.open(pdf_path) as pdf:\n        for page in pdf.pages:\n            page_text = page.extract_text()\n            if page_text:\n                text.append(page_text.strip())\n    return text\n\n# Generate OpenAI embeddings\ndef get_openai_embedding(text):\n    response = client.embeddings.create(\n        input=text,\n        model=\"text-embedding-3-small\"\n    )\n    return response.data[0].embedding\n\n# Store text and embeddings in Qdrant\ndef load_pdf_to_qdrant(pdf_path, qdrant, collection_name):\n    # Extract text from PDF\n    text_chunks = extract_text_from_pdf(pdf_path)\n    \n    # Create Qdrant collection\n    if qdrant.collection_exists(collection_name):\n        qdrant.delete_collection(collection_name)\n    qdrant.create_collection(\n        collection_name=collection_name,\n        vectors_config=VectorParams(size=1536, distance=Distance.COSINE)\n    )\n\n    # Store embeddings\n    points = []\n    for chunk in text_chunks:\n        embedding = get_openai_embedding(chunk)\n        points.append(PointStruct(\n            id=str(uuid.uuid4()),\n            vector=embedding,\n            payload={\"text\": chunk}\n        ))\n    qdrant.upsert(collection_name=collection_name, points=points)\n\n# Initialize Qdrant client and load data\nqdrant = QdrantClient(\n    url=os.getenv(\"QDRANT_URL\"),\n    api_key=os.getenv(\"QDRANT_API_KEY\")\n)\ncollection_name = \"example_collection\"\npdf_path = \"path/to/your/document.pdf\"\nload_pdf_to_qdrant(pdf_path, qdrant, collection_name)\n\n# Initialize Qdrant search tool\nqdrant_tool = QdrantVectorSearchTool(\n    qdrant_url=os.getenv(\"QDRANT_URL\"),\n    qdrant_api_key=os.getenv(\"QDRANT_API_KEY\"),\n    collection_name=collection_name,\n    limit=3,\n    score_threshold=0.35\n)\n\n# Create CrewAI agents\nsearch_agent = Agent(\n    role=\"Senior Semantic Search Agent\",\n    goal=\"Find and analyze documents based on semantic search\",\n    backstory=\"\"\"You are an expert research assistant who can find relevant \n    information using semantic search in a Qdrant database.\"\"\",\n    tools=[qdrant_tool],\n    verbose=True\n)\n\nanswer_agent = Agent(\n    role=\"Senior Answer Assistant\",\n    goal=\"Generate answers to questions based on the context provided\",\n    backstory=\"\"\"You are an expert answer assistant who can generate \n    answers to questions based on the context provided.\"\"\",\n    tools=[qdrant_tool],\n    verbose=True\n)\n\n# Define tasks\nsearch_task = Task(\n    description=\"\"\"Search for relevant documents about the {query}.\n    Your final answer should include:\n    - The relevant information found\n    - The similarity scores of the results\n    - The metadata of the relevant documents\"\"\",\n    agent=search_agent\n)\n\nanswer_task = Task(\n    description=\"\"\"Given the context and metadata of relevant documents,\n    generate a final answer based on the context.\"\"\",\n    agent=answer_agent\n)\n\n# Run CrewAI workflow\ncrew = Crew(\n    agents=[search_agent, answer_agent],\n    tasks=[search_task, answer_task],\n    process=Process.sequential,\n    verbose=True\n)\n\nresult = crew.kickoff(\n    inputs={\"query\": \"What is the role of X in the document?\"}\n)\nprint(result)"
    },
    {
      "content": "`qdrant_url` (str): The URL of your Qdrant server `qdrant_api_key` (str): API key for authentication with Qdrant `collection_name` (str): Name of the Qdrant collection to search",
      "title": "Required Parameters",
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`QdrantVectorSearchTool`",
          "level": 1
        },
        {
          "title": "Tool Parameters",
          "level": 2
        },
        {
          "title": "Required Parameters",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`QdrantVectorSearchTool`",
            "level": 1
          },
          {
            "title": "Tool Parameters",
            "level": 2
          },
          {
            "title": "Required Parameters",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `QdrantVectorSearchTool` > Tool Parameters > Required Parameters"
      },
      "enhanced_content": "Context: Changelog > `QdrantVectorSearchTool` > Tool Parameters > Required Parameters\n\n### Required Parameters\n\n`qdrant_url` (str): The URL of your Qdrant server `qdrant_api_key` (str): API key for authentication with Qdrant `collection_name` (str): Name of the Qdrant collection to search",
      "formatted_path": "Changelog > `QdrantVectorSearchTool` > Tool Parameters > Required Parameters",
      "enhanced_text": "Context: Changelog > `QdrantVectorSearchTool` > Tool Parameters > Required Parameters\n\n Required Parameters\n\n`qdrant_url` (str): The URL of your Qdrant server `qdrant_api_key` (str): API key for authentication with Qdrant `collection_name` (str): Name of the Qdrant collection to search\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "`limit` (int): Maximum number of results to return (default: 3) `score_threshold` (float): Minimum similarity score threshold (default: 0.35) `custom_embedding_fn` (Callable\\[\\[str], list\\[float]]): Custom function for text vectorization",
      "title": "Optional Parameters",
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`QdrantVectorSearchTool`",
          "level": 1
        },
        {
          "title": "Tool Parameters",
          "level": 2
        },
        {
          "title": "Optional Parameters",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "Optional",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`QdrantVectorSearchTool`",
            "level": 1
          },
          {
            "title": "Tool Parameters",
            "level": 2
          },
          {
            "title": "Optional Parameters",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `QdrantVectorSearchTool` > Tool Parameters > Optional Parameters"
      },
      "enhanced_content": "Context: Changelog > `QdrantVectorSearchTool` > Tool Parameters > Optional Parameters\n\n### Optional Parameters\n\n`limit` (int): Maximum number of results to return (default: 3) `score_threshold` (float): Minimum similarity score threshold (default: 0.35) `custom_embedding_fn` (Callable\\[\\[str], list\\[float]]): Custom function for text vectorization",
      "formatted_path": "Changelog > `QdrantVectorSearchTool` > Tool Parameters > Optional Parameters",
      "enhanced_text": "Context: Changelog > `QdrantVectorSearchTool` > Tool Parameters > Optional Parameters\n\n Optional Parameters\n\n`limit` (int): Maximum number of results to return (default: 3) `score_threshold` (float): Minimum similarity score threshold (default: 0.35) `custom_embedding_fn` (Callable\\[\\[str], list\\[float]]): Custom function for text vectorization\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "The tool accepts these parameters in its schema: `query` (str): The search query to find similar documents `filter_by` (str, optional): Metadata field to filter on `filter_value` (str, optional): Value to filter by",
      "title": "Search Parameters",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`QdrantVectorSearchTool`",
          "level": 1
        },
        {
          "title": "Search Parameters",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`QdrantVectorSearchTool`",
            "level": 1
          },
          {
            "title": "Search Parameters",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `QdrantVectorSearchTool` > Search Parameters"
      },
      "enhanced_content": "Context: Changelog > `QdrantVectorSearchTool` > Search Parameters\n\n## Search Parameters\n\nThe tool accepts these parameters in its schema: `query` (str): The search query to find similar documents `filter_by` (str, optional): Metadata field to filter on `filter_value` (str, optional): Value to filter by",
      "formatted_path": "Changelog > `QdrantVectorSearchTool` > Search Parameters",
      "enhanced_text": "Context: Changelog > `QdrantVectorSearchTool` > Search Parameters\n\n Search Parameters\n\nThe tool accepts these parameters in its schema: `query` (str): The search query to find similar documents `filter_by` (str, optional): Metadata field to filter on `filter_value` (str, optional): Value to filter by\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "{\n  \"success\": true,\n  \"results\": [\n    {\n      \"name\": \"Result Title\",\n      \"url\": \"https://example.com/result\",\n      \"content\": \"Content of the result...\"\n    },\n    // Additional results...\n  ]\n}",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`QdrantVectorSearchTool`",
          "level": 1
        },
        {
          "title": "Return Format",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`QdrantVectorSearchTool`",
            "level": 1
          },
          {
            "title": "Return Format",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `QdrantVectorSearchTool` > Return Format"
      },
      "enhanced_content": "Context: Changelog > `QdrantVectorSearchTool` > Return Format\n\n{\n  \"success\": true,\n  \"results\": [\n    {\n      \"name\": \"Result Title\",\n      \"url\": \"https://example.com/result\",\n      \"content\": \"Content of the result...\"\n    },\n    // Additional results...\n  ]\n}",
      "formatted_path": "Changelog > `QdrantVectorSearchTool` > Return Format",
      "enhanced_text": "Context: Changelog > `QdrantVectorSearchTool` > Return Format\n\n{\n  \"success\": true,\n  \"results\": [\n    {\n      \"name\": \"Result Title\",\n      \"url\": \"https://example.com/result\",\n      \"content\": \"Content of the result...\"\n    },\n    // Additional results...\n  ]\n}"
    },
    {
      "content": "{\n  \"success\": false,\n  \"error\": \"Error message\"\n}",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`QdrantVectorSearchTool`",
          "level": 1
        },
        {
          "title": "Return Format",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`QdrantVectorSearchTool`",
            "level": 1
          },
          {
            "title": "Return Format",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `QdrantVectorSearchTool` > Return Format"
      },
      "enhanced_content": "Context: Changelog > `QdrantVectorSearchTool` > Return Format\n\n{\n  \"success\": false,\n  \"error\": \"Error message\"\n}",
      "formatted_path": "Changelog > `QdrantVectorSearchTool` > Return Format",
      "enhanced_text": "Context: Changelog > `QdrantVectorSearchTool` > Return Format\n\n{\n  \"success\": false,\n  \"error\": \"Error message\"\n}"
    },
    {
      "content": "[\n  {\n    \"metadata\": {\n      // Any metadata stored with the document\n    },\n    \"context\": \"The actual text content of the document\",\n    \"distance\": 0.95  // Similarity score\n  }\n]",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`QdrantVectorSearchTool`",
          "level": 1
        },
        {
          "title": "Return Format",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`QdrantVectorSearchTool`",
            "level": 1
          },
          {
            "title": "Return Format",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `QdrantVectorSearchTool` > Return Format"
      },
      "enhanced_content": "Context: Changelog > `QdrantVectorSearchTool` > Return Format\n\n[\n  {\n    \"metadata\": {\n      // Any metadata stored with the document\n    },\n    \"context\": \"The actual text content of the document\",\n    \"distance\": 0.95  // Similarity score\n  }\n]",
      "formatted_path": "Changelog > `QdrantVectorSearchTool` > Return Format",
      "enhanced_text": "Context: Changelog > `QdrantVectorSearchTool` > Return Format\n\n[\n  {\n    \"metadata\": {\n      // Any metadata stored with the document\n    },\n    \"context\": \"The actual text content of the document\",\n    \"distance\": 0.95  // Similarity score\n  }\n]"
    },
    {
      "content": "By default, the tool uses OpenAI's `text-embedding-3-small` model for vectorization. This requires: OpenAI API key set in environment: `OPENAI_API_KEY`",
      "title": "Default Embedding",
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`QdrantVectorSearchTool`",
          "level": 1
        },
        {
          "title": "Default Embedding",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`QdrantVectorSearchTool`",
            "level": 1
          },
          {
            "title": "Default Embedding",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `QdrantVectorSearchTool` > Default Embedding"
      },
      "enhanced_content": "Context: Changelog > `QdrantVectorSearchTool` > Default Embedding\n\n## Default Embedding\n\nBy default, the tool uses OpenAI's `text-embedding-3-small` model for vectorization. This requires: OpenAI API key set in environment: `OPENAI_API_KEY`",
      "formatted_path": "Changelog > `QdrantVectorSearchTool` > Default Embedding",
      "enhanced_text": "Context: Changelog > `QdrantVectorSearchTool` > Default Embedding\n\n Default Embedding\n\nBy default, the tool uses OpenAI's `text-embedding-3-small` model for vectorization. This requires: OpenAI API key set in environment: `OPENAI_API_KEY`"
    },
    {
      "content": "from transformers import AutoTokenizer, AutoModel\nimport torch\n\n# Load model and tokenizer\ntokenizer = AutoTokenizer.from_pretrained('sentence-transformers/all-MiniLM-L6-v2')\nmodel = AutoModel.from_pretrained('sentence-transformers/all-MiniLM-L6-v2')\n\ndef custom_embeddings(text: str) -> list[float]:\n    # Tokenize and get model outputs\n    inputs = tokenizer(text, return_tensors=\"pt\", padding=True, truncation=True)\n    outputs = model(**inputs)\n    \n    # Use mean pooling to get text embedding\n    embeddings = outputs.last_hidden_state.mean(dim=1)\n    \n    # Convert to list of floats and return\n    return embeddings[0].tolist()\n\n# Use custom embeddings with the tool\ntool = QdrantVectorSearchTool(\n    qdrant_url=\"your_url\",\n    qdrant_api_key=\"your_key\",\n    collection_name=\"your_collection\",\n    custom_embedding_fn=custom_embeddings  # Pass your custom function\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`QdrantVectorSearchTool`",
          "level": 1
        },
        {
          "title": "Custom Embeddings",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`QdrantVectorSearchTool`",
            "level": 1
          },
          {
            "title": "Custom Embeddings",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `QdrantVectorSearchTool` > Custom Embeddings"
      },
      "enhanced_content": "Context: Changelog > `QdrantVectorSearchTool` > Custom Embeddings\n\nfrom transformers import AutoTokenizer, AutoModel\nimport torch\n\n# Load model and tokenizer\ntokenizer = AutoTokenizer.from_pretrained('sentence-transformers/all-MiniLM-L6-v2')\nmodel = AutoModel.from_pretrained('sentence-transformers/all-MiniLM-L6-v2')\n\ndef custom_embeddings(text: str) -> list[float]:\n    # Tokenize and get model outputs\n    inputs = tokenizer(text, return_tensors=\"pt\", padding=True, truncation=True)\n    outputs = model(**inputs)\n    \n    # Use mean pooling to get text embedding\n    embeddings = outputs.last_hidden_state.mean(dim=1)\n    \n    # Convert to list of floats and return\n    return embeddings[0].tolist()\n\n# Use custom embeddings with the tool\ntool = QdrantVectorSearchTool(\n    qdrant_url=\"your_url\",\n    qdrant_api_key=\"your_key\",\n    collection_name=\"your_collection\",\n    custom_embedding_fn=custom_embeddings  # Pass your custom function\n)",
      "formatted_path": "Changelog > `QdrantVectorSearchTool` > Custom Embeddings",
      "enhanced_text": "Context: Changelog > `QdrantVectorSearchTool` > Custom Embeddings\n\nfrom transformers import AutoTokenizer, AutoModel\nimport torch\n\n# Load model and tokenizer\ntokenizer = AutoTokenizer.from_pretrained('sentence-transformers/all-MiniLM-L6-v2')\nmodel = AutoModel.from_pretrained('sentence-transformers/all-MiniLM-L6-v2')\n\ndef custom_embeddings(text: str) -> list[float]:\n    # Tokenize and get model outputs\n    inputs = tokenizer(text, return_tensors=\"pt\", padding=True, truncation=True)\n    outputs = model(**inputs)\n    \n    # Use mean pooling to get text embedding\n    embeddings = outputs.last_hidden_state.mean(dim=1)\n    \n    # Convert to list of floats and return\n    return embeddings[0].tolist()\n\n# Use custom embeddings with the tool\ntool = QdrantVectorSearchTool(\n    qdrant_url=\"your_url\",\n    qdrant_api_key=\"your_key\",\n    collection_name=\"your_collection\",\n    custom_embedding_fn=custom_embeddings  # Pass your custom function\n)"
    },
    {
      "content": "BEDROCK_AGENT_ID=your-agent-id           # Alternative to passing agent_id\nBEDROCK_AGENT_ALIAS_ID=your-agent-alias-id # Alternative to passing agent_alias_id\nAWS_REGION=your-aws-region               # Defaults to us-west-2\nAWS_ACCESS_KEY_ID=your-access-key        # Required for AWS authentication\nAWS_SECRET_ACCESS_KEY=your-secret-key    # Required for AWS authentication",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`QdrantVectorSearchTool`",
          "level": 1
        },
        {
          "title": "Environment Variables",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`QdrantVectorSearchTool`",
            "level": 1
          },
          {
            "title": "Environment Variables",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `QdrantVectorSearchTool` > Environment Variables"
      },
      "enhanced_content": "Context: Changelog > `QdrantVectorSearchTool` > Environment Variables\n\nBEDROCK_AGENT_ID=your-agent-id           # Alternative to passing agent_id\nBEDROCK_AGENT_ALIAS_ID=your-agent-alias-id # Alternative to passing agent_alias_id\nAWS_REGION=your-aws-region               # Defaults to us-west-2\nAWS_ACCESS_KEY_ID=your-access-key        # Required for AWS authentication\nAWS_SECRET_ACCESS_KEY=your-secret-key    # Required for AWS authentication",
      "formatted_path": "Changelog > `QdrantVectorSearchTool` > Environment Variables",
      "enhanced_text": "Context: Changelog > `QdrantVectorSearchTool` > Environment Variables\n\nBEDROCK_AGENT_ID=your-agent-id           # Alternative to passing agent_id\nBEDROCK_AGENT_ALIAS_ID=your-agent-alias-id # Alternative to passing agent_alias_id\nAWS_REGION=your-aws-region               # Defaults to us-west-2\nAWS_ACCESS_KEY_ID=your-access-key        # Required for AWS authentication\nAWS_SECRET_ACCESS_KEY=your-secret-key    # Required for AWS authentication"
    },
    {
      "content": "BEDROCK_KB_ID=your-knowledge-base-id  # Alternative to passing knowledge_base_id\nAWS_REGION=your-aws-region            # Defaults to us-east-1\nAWS_ACCESS_KEY_ID=your-access-key     # Required for AWS authentication\nAWS_SECRET_ACCESS_KEY=your-secret-key # Required for AWS authentication",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`QdrantVectorSearchTool`",
          "level": 1
        },
        {
          "title": "Environment Variables",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`QdrantVectorSearchTool`",
            "level": 1
          },
          {
            "title": "Environment Variables",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `QdrantVectorSearchTool` > Environment Variables"
      },
      "enhanced_content": "Context: Changelog > `QdrantVectorSearchTool` > Environment Variables\n\nBEDROCK_KB_ID=your-knowledge-base-id  # Alternative to passing knowledge_base_id\nAWS_REGION=your-aws-region            # Defaults to us-east-1\nAWS_ACCESS_KEY_ID=your-access-key     # Required for AWS authentication\nAWS_SECRET_ACCESS_KEY=your-secret-key # Required for AWS authentication",
      "formatted_path": "Changelog > `QdrantVectorSearchTool` > Environment Variables",
      "enhanced_text": "Context: Changelog > `QdrantVectorSearchTool` > Environment Variables\n\nBEDROCK_KB_ID=your-knowledge-base-id  # Alternative to passing knowledge_base_id\nAWS_REGION=your-aws-region            # Defaults to us-east-1\nAWS_ACCESS_KEY_ID=your-access-key     # Required for AWS authentication\nAWS_SECRET_ACCESS_KEY=your-secret-key # Required for AWS authentication"
    },
    {
      "content": "export QDRANT_URL=\"your_qdrant_url\"  # If not provided in constructor\nexport QDRANT_API_KEY=\"your_api_key\"  # If not provided in constructor\nexport OPENAI_API_KEY=\"your_openai_key\"  # If using default embeddings",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`QdrantVectorSearchTool`",
          "level": 1
        },
        {
          "title": "Environment Variables",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`QdrantVectorSearchTool`",
            "level": 1
          },
          {
            "title": "Environment Variables",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `QdrantVectorSearchTool` > Environment Variables"
      },
      "enhanced_content": "Context: Changelog > `QdrantVectorSearchTool` > Environment Variables\n\nexport QDRANT_URL=\"your_qdrant_url\"  # If not provided in constructor\nexport QDRANT_API_KEY=\"your_api_key\"  # If not provided in constructor\nexport OPENAI_API_KEY=\"your_openai_key\"  # If using default embeddings",
      "formatted_path": "Changelog > `QdrantVectorSearchTool` > Environment Variables",
      "enhanced_text": "Context: Changelog > `QdrantVectorSearchTool` > Environment Variables\n\nexport QDRANT_URL=\"your_qdrant_url\"  # If not provided in constructor\nexport QDRANT_API_KEY=\"your_api_key\"  # If not provided in constructor\nexport OPENAI_API_KEY=\"your_openai_key\"  # If using default embeddings"
    },
    {
      "content": "Source: https://docs.crewai.com/tools/ragtool The `RagTool` is a dynamic knowledge base tool for answering questions using Retrieval-Augmented Generation.",
      "title": "RAG Tool",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "RAG Tool",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "RAG Tool",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > RAG Tool"
      },
      "enhanced_content": "Context: Changelog > RAG Tool\n\n# RAG Tool\n\nSource: https://docs.crewai.com/tools/ragtool The `RagTool` is a dynamic knowledge base tool for answering questions using Retrieval-Augmented Generation.",
      "formatted_path": "Changelog > RAG Tool",
      "enhanced_text": "Context: Changelog > RAG Tool\n\n RAG Tool\n\nSource: https://docs.crewai.com/tools/ragtool The `RagTool` is a dynamic knowledge base tool for answering questions using Retrieval-Augmented Generation."
    },
    {
      "content": "Amazon S3 Confluence Salesforce SharePoint Web pages Custom document locations Amazon Kendra SQL databases\n\nThe `RagTool` can be used with a wide variety of data sources, including: \ud83d\udcf0 PDF files \ud83d\udcca CSV files \ud83d\udcc3 JSON files \ud83d\udcdd Text \ud83d\udcc1 Directories/Folders \ud83c\udf10 HTML Web pages \ud83d\udcfd\ufe0f YouTube Channels \ud83d\udcfa YouTube Videos \ud83d\udcda Documentation websites \ud83d\udcdd MDX files \ud83d\udcc4 DOCX files \ud83e\uddfe XML files \ud83d\udcec Gmail \ud83d\udcdd GitHub repositories \ud83d\udc18 PostgreSQL databases \ud83d\udc2c MySQL databases \ud83e\udd16 Slack conversations \ud83d\udcac Discord messages \ud83d\udde8\ufe0f Discourse forums \ud83d\udcdd Substack newsletters \ud83d\udc1d Beehiiv content \ud83d\udcbe Dropbox files \ud83d\uddbc\ufe0f Images \u2699\ufe0f Custom data sources",
      "title": "Supported Data Sources",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`RagTool`",
          "level": 1
        },
        {
          "title": "Supported Data Sources",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`RagTool`",
            "level": 1
          },
          {
            "title": "Supported Data Sources",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `RagTool` > Supported Data Sources"
      },
      "enhanced_content": "Context: Changelog > `RagTool` > Supported Data Sources\n\n## Supported Data Sources\n\nAmazon S3 Confluence Salesforce SharePoint Web pages Custom document locations Amazon Kendra SQL databases\n\nThe `RagTool` can be used with a wide variety of data sources, including: \ud83d\udcf0 PDF files \ud83d\udcca CSV files \ud83d\udcc3 JSON files \ud83d\udcdd Text \ud83d\udcc1 Directories/Folders \ud83c\udf10 HTML Web pages \ud83d\udcfd\ufe0f YouTube Channels \ud83d\udcfa YouTube Videos \ud83d\udcda Documentation websites \ud83d\udcdd MDX files \ud83d\udcc4 DOCX files \ud83e\uddfe XML files \ud83d\udcec Gmail \ud83d\udcdd GitHub repositories \ud83d\udc18 PostgreSQL databases \ud83d\udc2c MySQL databases \ud83e\udd16 Slack conversations \ud83d\udcac Discord messages \ud83d\udde8\ufe0f Discourse forums \ud83d\udcdd Substack newsletters \ud83d\udc1d Beehiiv content \ud83d\udcbe Dropbox files \ud83d\uddbc\ufe0f Images \u2699\ufe0f Custom data sources",
      "formatted_path": "Changelog > `RagTool` > Supported Data Sources",
      "enhanced_text": "Context: Changelog > `RagTool` > Supported Data Sources\n\n Supported Data Sources\n\nAmazon S3 Confluence Salesforce SharePoint Web pages Custom document locations Amazon Kendra SQL databases\n\nThe `RagTool` can be used with a wide variety of data sources, including: \ud83d\udcf0 PDF files \ud83d\udcca CSV files \ud83d\udcc3 JSON files \ud83d\udcdd Text \ud83d\udcc1 Directories/Folders \ud83c\udf10 HTML Web pages \ud83d\udcfd\ufe0f YouTube Channels \ud83d\udcfa YouTube Videos \ud83d\udcda Documentation websites \ud83d\udcdd MDX files \ud83d\udcc4 DOCX files \ud83e\uddfe XML files \ud83d\udcec Gmail \ud83d\udcdd GitHub repositories \ud83d\udc18 PostgreSQL databases \ud83d\udc2c MySQL databases \ud83e\udd16 Slack conversations \ud83d\udcac Discord messages \ud83d\udde8\ufe0f Discourse forums \ud83d\udcdd Substack newsletters \ud83d\udc1d Beehiiv content \ud83d\udcbe Dropbox files \ud83d\uddbc\ufe0f Images \u2699\ufe0f Custom data sources"
    },
    {
      "content": "# Add a PDF file\nrag_tool.add(data_type=\"file\", path=\"path/to/your/document.pdf\")\n\n# Add a web page\nrag_tool.add(data_type=\"web_page\", url=\"https://example.com\")\n\n# Add a YouTube video\nrag_tool.add(data_type=\"youtube_video\", url=\"https://www.youtube.com/watch?v=VIDEO_ID\")\n\n# Add a directory of files\nrag_tool.add(data_type=\"directory\", path=\"path/to/your/directory\")",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`RagTool`",
          "level": 1
        },
        {
          "title": "Adding Content",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`RagTool`",
            "level": 1
          },
          {
            "title": "Adding Content",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `RagTool` > Adding Content"
      },
      "enhanced_content": "Context: Changelog > `RagTool` > Adding Content\n\n# Add a PDF file\nrag_tool.add(data_type=\"file\", path=\"path/to/your/document.pdf\")\n\n# Add a web page\nrag_tool.add(data_type=\"web_page\", url=\"https://example.com\")\n\n# Add a YouTube video\nrag_tool.add(data_type=\"youtube_video\", url=\"https://www.youtube.com/watch?v=VIDEO_ID\")\n\n# Add a directory of files\nrag_tool.add(data_type=\"directory\", path=\"path/to/your/directory\")",
      "formatted_path": "Changelog > `RagTool` > Adding Content",
      "enhanced_text": "Context: Changelog > `RagTool` > Adding Content\n\n# Add a PDF file\nrag_tool.add(data_type=\"file\", path=\"path/to/your/document.pdf\")\n\n# Add a web page\nrag_tool.add(data_type=\"web_page\", url=\"https://example.com\")\n\n# Add a YouTube video\nrag_tool.add(data_type=\"youtube_video\", url=\"https://www.youtube.com/watch?v=VIDEO_ID\")\n\n# Add a directory of files\nrag_tool.add(data_type=\"directory\", path=\"path/to/your/directory\")"
    },
    {
      "content": "Source: https://docs.crewai.com/tools/s3readertool The `S3ReaderTool` enables CrewAI agents to read files from Amazon S3 buckets.",
      "title": "S3 Reader Tool",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "S3 Reader Tool",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "S3 Reader Tool",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > S3 Reader Tool"
      },
      "enhanced_content": "Context: Changelog > S3 Reader Tool\n\n# S3 Reader Tool\n\nSource: https://docs.crewai.com/tools/s3readertool The `S3ReaderTool` enables CrewAI agents to read files from Amazon S3 buckets.",
      "formatted_path": "Changelog > S3 Reader Tool",
      "enhanced_text": "Context: Changelog > S3 Reader Tool\n\n S3 Reader Tool\n\nSource: https://docs.crewai.com/tools/s3readertool The `S3ReaderTool` enables CrewAI agents to read files from Amazon S3 buckets."
    },
    {
      "content": "Source: https://docs.crewai.com/tools/s3writertool The `S3WriterTool` enables CrewAI agents to write content to files in Amazon S3 buckets.",
      "title": "S3 Writer Tool",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "S3 Writer Tool",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "S3 Writer Tool",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > S3 Writer Tool"
      },
      "enhanced_content": "Context: Changelog > S3 Writer Tool\n\n# S3 Writer Tool\n\nSource: https://docs.crewai.com/tools/s3writertool The `S3WriterTool` enables CrewAI agents to write content to files in Amazon S3 buckets.",
      "formatted_path": "Changelog > S3 Writer Tool",
      "enhanced_text": "Context: Changelog > S3 Writer Tool\n\n S3 Writer Tool\n\nSource: https://docs.crewai.com/tools/s3writertool The `S3WriterTool` enables CrewAI agents to write content to files in Amazon S3 buckets."
    },
    {
      "content": "The tool requires AWS credentials to access S3 buckets. You can configure these credentials using environment variables: **CREW\\_AWS\\_REGION**: The AWS region where your S3 bucket is located. Default is `us-east-1`. **CREW\\_AWS\\_ACCESS\\_KEY\\_ID**: Your AWS access key ID. **CREW\\_AWS\\_SEC\\_ACCESS\\_KEY**: Your AWS secret access key.\n\nThe tool requires AWS credentials to access S3 buckets. You can configure these credentials using environment variables: **CREW\\_AWS\\_REGION**: The AWS region where your S3 bucket is located. Default is `us-east-1`. **CREW\\_AWS\\_ACCESS\\_KEY\\_ID**: Your AWS access key ID. **CREW\\_AWS\\_SEC\\_ACCESS\\_KEY**: Your AWS secret access key.",
      "title": "AWS Credentials",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`S3WriterTool`",
          "level": 1
        },
        {
          "title": "AWS Credentials",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`S3WriterTool`",
            "level": 1
          },
          {
            "title": "AWS Credentials",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `S3WriterTool` > AWS Credentials"
      },
      "enhanced_content": "Context: Changelog > `S3WriterTool` > AWS Credentials\n\n## AWS Credentials\n\nThe tool requires AWS credentials to access S3 buckets. You can configure these credentials using environment variables: **CREW\\_AWS\\_REGION**: The AWS region where your S3 bucket is located. Default is `us-east-1`. **CREW\\_AWS\\_ACCESS\\_KEY\\_ID**: Your AWS access key ID. **CREW\\_AWS\\_SEC\\_ACCESS\\_KEY**: Your AWS secret access key.\n\nThe tool requires AWS credentials to access S3 buckets. You can configure these credentials using environment variables: **CREW\\_AWS\\_REGION**: The AWS region where your S3 bucket is located. Default is `us-east-1`. **CREW\\_AWS\\_ACCESS\\_KEY\\_ID**: Your AWS access key ID. **CREW\\_AWS\\_SEC\\_ACCESS\\_KEY**: Your AWS secret access key.",
      "formatted_path": "Changelog > `S3WriterTool` > AWS Credentials",
      "enhanced_text": "Context: Changelog > `S3WriterTool` > AWS Credentials\n\n AWS Credentials\n\nThe tool requires AWS credentials to access S3 buckets. You can configure these credentials using environment variables: **CREW\\_AWS\\_REGION**: The AWS region where your S3 bucket is located. Default is `us-east-1`. **CREW\\_AWS\\_ACCESS\\_KEY\\_ID**: Your AWS access key ID. **CREW\\_AWS\\_SEC\\_ACCESS\\_KEY**: Your AWS secret access key.\n\nThe tool requires AWS credentials to access S3 buckets. You can configure these credentials using environment variables: **CREW\\_AWS\\_REGION**: The AWS region where your S3 bucket is located. Default is `us-east-1`. **CREW\\_AWS\\_ACCESS\\_KEY\\_ID**: Your AWS access key ID. **CREW\\_AWS\\_SEC\\_ACCESS\\_KEY**: Your AWS secret access key."
    },
    {
      "content": "Source: https://docs.crewai.com/tools/scrapeelementfromwebsitetool The `ScrapeElementFromWebsiteTool` enables CrewAI agents to extract specific elements from websites using CSS selectors.",
      "title": "Scrape Element From Website Tool",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Scrape Element From Website Tool",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Scrape Element From Website Tool",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Scrape Element From Website Tool"
      },
      "enhanced_content": "Context: Changelog > Scrape Element From Website Tool\n\n# Scrape Element From Website Tool\n\nSource: https://docs.crewai.com/tools/scrapeelementfromwebsitetool The `ScrapeElementFromWebsiteTool` enables CrewAI agents to extract specific elements from websites using CSS selectors.",
      "formatted_path": "Changelog > Scrape Element From Website Tool",
      "enhanced_text": "Context: Changelog > Scrape Element From Website Tool\n\n Scrape Element From Website Tool\n\nSource: https://docs.crewai.com/tools/scrapeelementfromwebsitetool The `ScrapeElementFromWebsiteTool` enables CrewAI agents to extract specific elements from websites using CSS selectors."
    },
    {
      "content": "Source: https://docs.crewai.com/tools/scrapegraphscrapetool The `ScrapegraphScrapeTool` leverages Scrapegraph AI's SmartScraper API to intelligently extract content from websites.",
      "title": "Scrapegraph Scrape Tool",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Scrapegraph Scrape Tool",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Scrapegraph Scrape Tool",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Scrapegraph Scrape Tool"
      },
      "enhanced_content": "Context: Changelog > Scrapegraph Scrape Tool\n\n# Scrapegraph Scrape Tool\n\nSource: https://docs.crewai.com/tools/scrapegraphscrapetool The `ScrapegraphScrapeTool` leverages Scrapegraph AI's SmartScraper API to intelligently extract content from websites.",
      "formatted_path": "Changelog > Scrapegraph Scrape Tool",
      "enhanced_text": "Context: Changelog > Scrapegraph Scrape Tool\n\n Scrapegraph Scrape Tool\n\nSource: https://docs.crewai.com/tools/scrapegraphscrapetool The `ScrapegraphScrapeTool` leverages Scrapegraph AI's SmartScraper API to intelligently extract content from websites."
    },
    {
      "content": "The Scrapegraph API has rate limits that vary based on your subscription plan. Consider the following best practices: Implement appropriate delays between requests when processing multiple URLs. Handle rate limit errors gracefully in your application. Check your API plan limits on the Scrapegraph dashboard.",
      "title": "Rate Limiting",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`ScrapegraphScrapeTool`",
          "level": 1
        },
        {
          "title": "Rate Limiting",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`ScrapegraphScrapeTool`",
            "level": 1
          },
          {
            "title": "Rate Limiting",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `ScrapegraphScrapeTool` > Rate Limiting"
      },
      "enhanced_content": "Context: Changelog > `ScrapegraphScrapeTool` > Rate Limiting\n\n## Rate Limiting\n\nThe Scrapegraph API has rate limits that vary based on your subscription plan. Consider the following best practices: Implement appropriate delays between requests when processing multiple URLs. Handle rate limit errors gracefully in your application. Check your API plan limits on the Scrapegraph dashboard.",
      "formatted_path": "Changelog > `ScrapegraphScrapeTool` > Rate Limiting",
      "enhanced_text": "Context: Changelog > `ScrapegraphScrapeTool` > Rate Limiting\n\n Rate Limiting\n\nThe Scrapegraph API has rate limits that vary based on your subscription plan. Consider the following best practices: Implement appropriate delays between requests when processing multiple URLs. Handle rate limit errors gracefully in your application. Check your API plan limits on the Scrapegraph dashboard."
    },
    {
      "content": "Source: https://docs.crewai.com/tools/scrapewebsitetool The `ScrapeWebsiteTool` is designed to extract and read the content of a specified website.",
      "title": "Scrape Website",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Scrape Website",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Scrape Website",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Scrape Website"
      },
      "enhanced_content": "Context: Changelog > Scrape Website\n\n# Scrape Website\n\nSource: https://docs.crewai.com/tools/scrapewebsitetool The `ScrapeWebsiteTool` is designed to extract and read the content of a specified website.",
      "formatted_path": "Changelog > Scrape Website",
      "enhanced_text": "Context: Changelog > Scrape Website\n\n Scrape Website\n\nSource: https://docs.crewai.com/tools/scrapewebsitetool The `ScrapeWebsiteTool` is designed to extract and read the content of a specified website.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "Source: https://docs.crewai.com/tools/scrapflyscrapetool The `ScrapflyScrapeWebsiteTool` leverages Scrapfly's web scraping API to extract content from websites in various formats.",
      "title": "Scrapfly Scrape Website Tool",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Scrapfly Scrape Website Tool",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Scrapfly Scrape Website Tool",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Scrapfly Scrape Website Tool"
      },
      "enhanced_content": "Context: Changelog > Scrapfly Scrape Website Tool\n\n# Scrapfly Scrape Website Tool\n\nSource: https://docs.crewai.com/tools/scrapflyscrapetool The `ScrapflyScrapeWebsiteTool` leverages Scrapfly's web scraping API to extract content from websites in various formats.",
      "formatted_path": "Changelog > Scrapfly Scrape Website Tool",
      "enhanced_text": "Context: Changelog > Scrapfly Scrape Website Tool\n\n Scrapfly Scrape Website Tool\n\nSource: https://docs.crewai.com/tools/scrapflyscrapetool The `ScrapflyScrapeWebsiteTool` leverages Scrapfly's web scraping API to extract content from websites in various formats.\n\nRelated sections:\n- \n"
    },
    {
      "content": "**api\\_key**: Required. Your Scrapfly API key.",
      "title": "Initialization Parameters",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`ScrapflyScrapeWebsiteTool`",
          "level": 1
        },
        {
          "title": "Parameters",
          "level": 2
        },
        {
          "title": "Initialization Parameters",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`ScrapflyScrapeWebsiteTool`",
            "level": 1
          },
          {
            "title": "Parameters",
            "level": 2
          },
          {
            "title": "Initialization Parameters",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `ScrapflyScrapeWebsiteTool` > Parameters > Initialization Parameters"
      },
      "enhanced_content": "Context: Changelog > `ScrapflyScrapeWebsiteTool` > Parameters > Initialization Parameters\n\n### Initialization Parameters\n\n**api\\_key**: Required. Your Scrapfly API key.",
      "formatted_path": "Changelog > `ScrapflyScrapeWebsiteTool` > Parameters > Initialization Parameters",
      "enhanced_text": "Context: Changelog > `ScrapflyScrapeWebsiteTool` > Parameters > Initialization Parameters\n\n Initialization Parameters\n\n**api\\_key**: Required. Your Scrapfly API key.\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "**url**: Required. The website URL to scrape or crawl. **operation**: Optional. The operation to perform on the website. Either 'scrape' or 'crawl'. Default is 'scrape'. **params**: Optional. Additional parameters for the scrape or crawl operation.\n\n**query**: Required. The search term or phrase. **depth**: Optional. The search depth. Default is \"standard\". **output\\_type**: Optional. The type of output. Default is \"searchResults\".\n\n**url**: Required. The URL of the website to scrape. **scrape\\_format**: Optional. The format in which to extract the web page content. Options are \"raw\" (HTML), \"markdown\", or \"text\". Default is \"markdown\". **scrape\\_config**: Optional. A dictionary containing additional Scrapfly scraping configuration options. **ignore\\_scrape\\_failures**: Optional. Whether to ignore failures during scraping. If set to `True`, the tool will return `None` instead of raising an exception when scraping fails.",
      "title": "Run Parameters",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`ScrapflyScrapeWebsiteTool`",
          "level": 1
        },
        {
          "title": "Parameters",
          "level": 2
        },
        {
          "title": "Run Parameters",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`ScrapflyScrapeWebsiteTool`",
            "level": 1
          },
          {
            "title": "Parameters",
            "level": 2
          },
          {
            "title": "Run Parameters",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `ScrapflyScrapeWebsiteTool` > Parameters > Run Parameters"
      },
      "enhanced_content": "Context: Changelog > `ScrapflyScrapeWebsiteTool` > Parameters > Run Parameters\n\n### Run Parameters\n\n**url**: Required. The website URL to scrape or crawl. **operation**: Optional. The operation to perform on the website. Either 'scrape' or 'crawl'. Default is 'scrape'. **params**: Optional. Additional parameters for the scrape or crawl operation.\n\n**query**: Required. The search term or phrase. **depth**: Optional. The search depth. Default is \"standard\". **output\\_type**: Optional. The type of output. Default is \"searchResults\".\n\n**url**: Required. The URL of the website to scrape. **scrape\\_format**: Optional. The format in which to extract the web page content. Options are \"raw\" (HTML), \"markdown\", or \"text\". Default is \"markdown\". **scrape\\_config**: Optional. A dictionary containing additional Scrapfly scraping configuration options. **ignore\\_scrape\\_failures**: Optional. Whether to ignore failures during scraping. If set to `True`, the tool will return `None` instead of raising an exception when scraping fails.",
      "formatted_path": "Changelog > `ScrapflyScrapeWebsiteTool` > Parameters > Run Parameters",
      "enhanced_text": "Context: Changelog > `ScrapflyScrapeWebsiteTool` > Parameters > Run Parameters\n\n Run Parameters\n\n**url**: Required. The website URL to scrape or crawl. **operation**: Optional. The operation to perform on the website. Either 'scrape' or 'crawl'. Default is 'scrape'. **params**: Optional. Additional parameters for the scrape or crawl operation.\n\n**query**: Required. The search term or phrase. **depth**: Optional. The search depth. Default is \"standard\". **output\\_type**: Optional. The type of output. Default is \"searchResults\".\n\n**url**: Required. The URL of the website to scrape. **scrape\\_format**: Optional. The format in which to extract the web page content. Options are \"raw\" (HTML), \"markdown\", or \"text\". Default is \"markdown\". **scrape\\_config**: Optional. A dictionary containing additional Scrapfly scraping configuration options. **ignore\\_scrape\\_failures**: Optional. Whether to ignore failures during scraping. If set to `True`, the tool will return `None` instead of raising an exception when scraping fails.\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "The `scrape_config` parameter allows you to customize the scraping behavior with the following options: **asp**: Enable anti-scraping protection bypass. **render\\_js**: Enable JavaScript rendering with a cloud headless browser. **proxy\\_pool**: Select a proxy pool (e.g., \"public\\_residential\\_pool\", \"datacenter\"). **country**: Select a proxy location (e.g., \"us\", \"uk\"). **auto\\_scroll**: Automatically scroll the page to load lazy-loaded content. **js**: Execute custom JavaScript code by the headless browser. For a complete list of configuration options, refer to the [Scrapfly API documentation](https://scrapfly.io/docs/scrape-api/getting-started).",
      "title": "Scrapfly Configuration Options",
      "type": "link_list",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`ScrapflyScrapeWebsiteTool`",
          "level": 1
        },
        {
          "title": "Scrapfly Configuration Options",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`ScrapflyScrapeWebsiteTool`",
            "level": 1
          },
          {
            "title": "Scrapfly Configuration Options",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 1,
        "formatted_path": "Changelog > `ScrapflyScrapeWebsiteTool` > Scrapfly Configuration Options"
      },
      "enhanced_content": "Context: Changelog > `ScrapflyScrapeWebsiteTool` > Scrapfly Configuration Options\n\n## Scrapfly Configuration Options\n\nThe `scrape_config` parameter allows you to customize the scraping behavior with the following options: **asp**: Enable anti-scraping protection bypass. **render\\_js**: Enable JavaScript rendering with a cloud headless browser. **proxy\\_pool**: Select a proxy pool (e.g., \"public\\_residential\\_pool\", \"datacenter\"). **country**: Select a proxy location (e.g., \"us\", \"uk\"). **auto\\_scroll**: Automatically scroll the page to load lazy-loaded content. **js**: Execute custom JavaScript code by the headless browser. For a complete list of configuration options, refer to the [Scrapfly API documentation](https://scrapfly.io/docs/scrape-api/getting-started).",
      "formatted_path": "Changelog > `ScrapflyScrapeWebsiteTool` > Scrapfly Configuration Options",
      "enhanced_text": "Context: Changelog > `ScrapflyScrapeWebsiteTool` > Scrapfly Configuration Options\n\n Scrapfly Configuration Options\n\nThe `scrape_config` parameter allows you to customize the scraping behavior with the following options: **asp**: Enable anti-scraping protection bypass. **render\\_js**: Enable JavaScript rendering with a cloud headless browser. **proxy\\_pool**: Select a proxy pool (e.g., \"public\\_residential\\_pool\", \"datacenter\"). **country**: Select a proxy location (e.g., \"us\", \"uk\"). **auto\\_scroll**: Automatically scroll the page to load lazy-loaded content. **js**: Execute custom JavaScript code by the headless browser. For a complete list of configuration options, refer to the [Scrapfly API documentation](https://scrapfly.io/docs/scrape-api/getting-started).\n\nRelated sections:\n- \n- \n- \n"
    },
    {
      "content": "Source: https://docs.crewai.com/tools/seleniumscrapingtool The `SeleniumScrapingTool` is designed to extract and read the content of a specified website using Selenium.",
      "title": "Selenium Scraper",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Selenium Scraper",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Selenium Scraper",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Selenium Scraper"
      },
      "enhanced_content": "Context: Changelog > Selenium Scraper\n\n# Selenium Scraper\n\nSource: https://docs.crewai.com/tools/seleniumscrapingtool The `SeleniumScrapingTool` is designed to extract and read the content of a specified website using Selenium.",
      "formatted_path": "Changelog > Selenium Scraper",
      "enhanced_text": "Context: Changelog > Selenium Scraper\n\n Selenium Scraper\n\nSource: https://docs.crewai.com/tools/seleniumscrapingtool The `SeleniumScrapingTool` is designed to extract and read the content of a specified website using Selenium."
    },
    {
      "content": "The `SeleniumScrapingTool` is particularly useful for scraping websites with dynamic content that is loaded via JavaScript. By using a real browser instance, it can: Execute JavaScript on the page Wait for dynamic content to load Interact with elements if needed Extract content that would not be available with simple HTTP requests You can adjust the `wait_time` parameter to ensure that all dynamic content has loaded before extraction.",
      "title": "Handling Dynamic Content",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`SeleniumScrapingTool`",
          "level": 1
        },
        {
          "title": "Handling Dynamic Content",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`SeleniumScrapingTool`",
            "level": 1
          },
          {
            "title": "Handling Dynamic Content",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `SeleniumScrapingTool` > Handling Dynamic Content"
      },
      "enhanced_content": "Context: Changelog > `SeleniumScrapingTool` > Handling Dynamic Content\n\n## Handling Dynamic Content\n\nThe `SeleniumScrapingTool` is particularly useful for scraping websites with dynamic content that is loaded via JavaScript. By using a real browser instance, it can: Execute JavaScript on the page Wait for dynamic content to load Interact with elements if needed Extract content that would not be available with simple HTTP requests You can adjust the `wait_time` parameter to ensure that all dynamic content has loaded before extraction.",
      "formatted_path": "Changelog > `SeleniumScrapingTool` > Handling Dynamic Content",
      "enhanced_text": "Context: Changelog > `SeleniumScrapingTool` > Handling Dynamic Content\n\n Handling Dynamic Content\n\nThe `SeleniumScrapingTool` is particularly useful for scraping websites with dynamic content that is loaded via JavaScript. By using a real browser instance, it can: Execute JavaScript on the page Wait for dynamic content to load Interact with elements if needed Extract content that would not be available with simple HTTP requests You can adjust the `wait_time` parameter to ensure that all dynamic content has loaded before extraction."
    },
    {
      "content": "Source: https://docs.crewai.com/tools/serperdevtool The `SerperDevTool` is designed to search the internet and return the most relevant results.",
      "title": "Google Serper Search",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Google Serper Search",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Google Serper Search",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Google Serper Search"
      },
      "enhanced_content": "Context: Changelog > Google Serper Search\n\n# Google Serper Search\n\nSource: https://docs.crewai.com/tools/serperdevtool The `SerperDevTool` is designed to search the internet and return the most relevant results.",
      "formatted_path": "Changelog > Google Serper Search",
      "enhanced_text": "Context: Changelog > Google Serper Search\n\n Google Serper Search\n\nSource: https://docs.crewai.com/tools/serperdevtool The `SerperDevTool` is designed to search the internet and return the most relevant results."
    },
    {
      "content": "from crewai_tools import BraveSearchTool\n\n# Initialize the tool with custom parameters\ntool = BraveSearchTool(\n    country=\"US\",\n    n_results=5,\n    save_file=True\n)\n\n# Execute a search\nresults = tool.run(search_query=\"Latest AI developments\")\nprint(results)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`SerperDevTool`",
          "level": 1
        },
        {
          "title": "Example with Parameters",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`SerperDevTool`",
            "level": 1
          },
          {
            "title": "Example with Parameters",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `SerperDevTool` > Example with Parameters"
      },
      "enhanced_content": "Context: Changelog > `SerperDevTool` > Example with Parameters\n\nfrom crewai_tools import BraveSearchTool\n\n# Initialize the tool with custom parameters\ntool = BraveSearchTool(\n    country=\"US\",\n    n_results=5,\n    save_file=True\n)\n\n# Execute a search\nresults = tool.run(search_query=\"Latest AI developments\")\nprint(results)",
      "formatted_path": "Changelog > `SerperDevTool` > Example with Parameters",
      "enhanced_text": "Context: Changelog > `SerperDevTool` > Example with Parameters\n\nfrom crewai_tools import BraveSearchTool\n\n# Initialize the tool with custom parameters\ntool = BraveSearchTool(\n    country=\"US\",\n    n_results=5,\n    save_file=True\n)\n\n# Execute a search\nresults = tool.run(search_query=\"Latest AI developments\")\nprint(results)"
    },
    {
      "content": "from crewai_tools import SerperDevTool\n\ntool = SerperDevTool(\n    search_url=\"https://google.serper.dev/scholar\",\n    n_results=2,\n)\n\nprint(tool.run(search_query=\"ChatGPT\"))\n\n# Using Tool: Search the internet\n\n# Search results: Title: Role of chat gpt in public health\n# Link: https://link.springer.com/article/10.1007/s10439-023-03172-7\n# Snippet: \u2026 ChatGPT in public health. In this overview, we will examine the potential uses of ChatGPT in\n# ---\n# Title: Potential use of chat gpt in global warming\n# Link: https://link.springer.com/article/10.1007/s10439-023-03171-8\n# Snippet: \u2026 as ChatGPT, have the potential to play a critical role in advancing our understanding of climate\n# ---",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`SerperDevTool`",
          "level": 1
        },
        {
          "title": "Example with Parameters",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`SerperDevTool`",
            "level": 1
          },
          {
            "title": "Example with Parameters",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `SerperDevTool` > Example with Parameters"
      },
      "enhanced_content": "Context: Changelog > `SerperDevTool` > Example with Parameters\n\nfrom crewai_tools import SerperDevTool\n\ntool = SerperDevTool(\n    search_url=\"https://google.serper.dev/scholar\",\n    n_results=2,\n)\n\nprint(tool.run(search_query=\"ChatGPT\"))\n\n# Using Tool: Search the internet\n\n# Search results: Title: Role of chat gpt in public health\n# Link: https://link.springer.com/article/10.1007/s10439-023-03172-7\n# Snippet: \u2026 ChatGPT in public health. In this overview, we will examine the potential uses of ChatGPT in\n# ---\n# Title: Potential use of chat gpt in global warming\n# Link: https://link.springer.com/article/10.1007/s10439-023-03171-8\n# Snippet: \u2026 as ChatGPT, have the potential to play a critical role in advancing our understanding of climate\n# ---",
      "formatted_path": "Changelog > `SerperDevTool` > Example with Parameters",
      "enhanced_text": "Context: Changelog > `SerperDevTool` > Example with Parameters\n\nfrom crewai_tools import SerperDevTool\n\ntool = SerperDevTool(\n    search_url=\"https://google.serper.dev/scholar\",\n    n_results=2,\n)\n\nprint(tool.run(search_query=\"ChatGPT\"))\n\n# Using Tool: Search the internet\n\n# Search results: Title: Role of chat gpt in public health\n# Link: https://link.springer.com/article/10.1007/s10439-023-03172-7\n# Snippet: \u2026 ChatGPT in public health. In this overview, we will examine the potential uses of ChatGPT in\n# ---\n# Title: Potential use of chat gpt in global warming\n# Link: https://link.springer.com/article/10.1007/s10439-023-03171-8\n# Snippet: \u2026 as ChatGPT, have the potential to play a critical role in advancing our understanding of climate\n# ---"
    },
    {
      "content": "from crewai_tools import SerperDevTool\n\ntool = SerperDevTool(\n    country=\"fr\",\n    locale=\"fr\",\n    location=\"Paris, Paris, Ile-de-France, France\",\n    n_results=2,\n)\n\nprint(tool.run(search_query=\"Jeux Olympiques\"))\n\n# Using Tool: Search the internet\n\n# Search results: Title: Jeux Olympiques de Paris 2024 - Actualit\u00e9s, calendriers, r\u00e9sultats\n# Link: https://olympics.com/fr/paris-2024\n# Snippet: Quels sont les sports pr\u00e9sents aux Jeux Olympiques de Paris 2024 ? \u00b7 Athl\u00e9tisme \u00b7 Aviron \u00b7 Badminton \u00b7 Basketball \u00b7 Basketball 3x3 \u00b7 Boxe \u00b7 Breaking \u00b7 Cano\u00eb ...\n# ---\n# Title: Billetterie Officielle de Paris 2024 - Jeux Olympiques et Paralympiques\n# Link: https://tickets.paris2024.org/\n# Snippet: Achetez vos billets exclusivement sur le site officiel de la billetterie de Paris 2024 pour participer au plus grand \u00e9v\u00e9nement sportif au monde.\n# ---",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`SerperDevTool`",
          "level": 1
        },
        {
          "title": "Example with Parameters",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`SerperDevTool`",
            "level": 1
          },
          {
            "title": "Example with Parameters",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `SerperDevTool` > Example with Parameters"
      },
      "enhanced_content": "Context: Changelog > `SerperDevTool` > Example with Parameters\n\nfrom crewai_tools import SerperDevTool\n\ntool = SerperDevTool(\n    country=\"fr\",\n    locale=\"fr\",\n    location=\"Paris, Paris, Ile-de-France, France\",\n    n_results=2,\n)\n\nprint(tool.run(search_query=\"Jeux Olympiques\"))\n\n# Using Tool: Search the internet\n\n# Search results: Title: Jeux Olympiques de Paris 2024 - Actualit\u00e9s, calendriers, r\u00e9sultats\n# Link: https://olympics.com/fr/paris-2024\n# Snippet: Quels sont les sports pr\u00e9sents aux Jeux Olympiques de Paris 2024 ? \u00b7 Athl\u00e9tisme \u00b7 Aviron \u00b7 Badminton \u00b7 Basketball \u00b7 Basketball 3x3 \u00b7 Boxe \u00b7 Breaking \u00b7 Cano\u00eb ...\n# ---\n# Title: Billetterie Officielle de Paris 2024 - Jeux Olympiques et Paralympiques\n# Link: https://tickets.paris2024.org/\n# Snippet: Achetez vos billets exclusivement sur le site officiel de la billetterie de Paris 2024 pour participer au plus grand \u00e9v\u00e9nement sportif au monde.\n# ---",
      "formatted_path": "Changelog > `SerperDevTool` > Example with Parameters",
      "enhanced_text": "Context: Changelog > `SerperDevTool` > Example with Parameters\n\nfrom crewai_tools import SerperDevTool\n\ntool = SerperDevTool(\n    country=\"fr\",\n    locale=\"fr\",\n    location=\"Paris, Paris, Ile-de-France, France\",\n    n_results=2,\n)\n\nprint(tool.run(search_query=\"Jeux Olympiques\"))\n\n# Using Tool: Search the internet\n\n# Search results: Title: Jeux Olympiques de Paris 2024 - Actualit\u00e9s, calendriers, r\u00e9sultats\n# Link: https://olympics.com/fr/paris-2024\n# Snippet: Quels sont les sports pr\u00e9sents aux Jeux Olympiques de Paris 2024 ? \u00b7 Athl\u00e9tisme \u00b7 Aviron \u00b7 Badminton \u00b7 Basketball \u00b7 Basketball 3x3 \u00b7 Boxe \u00b7 Breaking \u00b7 Cano\u00eb ...\n# ---\n# Title: Billetterie Officielle de Paris 2024 - Jeux Olympiques et Paralympiques\n# Link: https://tickets.paris2024.org/\n# Snippet: Achetez vos billets exclusivement sur le site officiel de la billetterie de Paris 2024 pour participer au plus grand \u00e9v\u00e9nement sportif au monde.\n# ---"
    },
    {
      "content": "Source: https://docs.crewai.com/tools/snowflakesearchtool The `SnowflakeSearchTool` enables CrewAI agents to execute SQL queries and perform semantic search on Snowflake data warehouses.",
      "title": "Snowflake Search Tool",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Snowflake Search Tool",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Snowflake Search Tool",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Snowflake Search Tool"
      },
      "enhanced_content": "Context: Changelog > Snowflake Search Tool\n\n# Snowflake Search Tool\n\nSource: https://docs.crewai.com/tools/snowflakesearchtool The `SnowflakeSearchTool` enables CrewAI agents to execute SQL queries and perform semantic search on Snowflake data warehouses.",
      "formatted_path": "Changelog > Snowflake Search Tool",
      "enhanced_text": "Context: Changelog > Snowflake Search Tool\n\n Snowflake Search Tool\n\nSource: https://docs.crewai.com/tools/snowflakesearchtool The `SnowflakeSearchTool` enables CrewAI agents to execute SQL queries and perform semantic search on Snowflake data warehouses."
    },
    {
      "content": "The `SnowflakeConfig` class accepts the following parameters: **account**: Required. Snowflake account identifier. **user**: Required. Snowflake username. **password**: Optional\\*. Snowflake password. **private\\_key\\_path**: Optional\\*. Path to private key file (alternative to password). **warehouse**: Required. Snowflake warehouse name. **database**: Required. Default database. **snowflake\\_schema**: Required. Default schema. **role**: Optional. Snowflake role. **session\\_parameters**: Optional. Custom session parameters as a dictionary. \\*Either `password` or `private_key_path` must be provided.",
      "title": "SnowflakeConfig Parameters",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`SnowflakeSearchTool`",
          "level": 1
        },
        {
          "title": "Parameters",
          "level": 2
        },
        {
          "title": "SnowflakeConfig Parameters",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`SnowflakeSearchTool`",
            "level": 1
          },
          {
            "title": "Parameters",
            "level": 2
          },
          {
            "title": "SnowflakeConfig Parameters",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `SnowflakeSearchTool` > Parameters > SnowflakeConfig Parameters"
      },
      "enhanced_content": "Context: Changelog > `SnowflakeSearchTool` > Parameters > SnowflakeConfig Parameters\n\n### SnowflakeConfig Parameters\n\nThe `SnowflakeConfig` class accepts the following parameters: **account**: Required. Snowflake account identifier. **user**: Required. Snowflake username. **password**: Optional\\*. Snowflake password. **private\\_key\\_path**: Optional\\*. Path to private key file (alternative to password). **warehouse**: Required. Snowflake warehouse name. **database**: Required. Default database. **snowflake\\_schema**: Required. Default schema. **role**: Optional. Snowflake role. **session\\_parameters**: Optional. Custom session parameters as a dictionary. \\*Either `password` or `private_key_path` must be provided.",
      "formatted_path": "Changelog > `SnowflakeSearchTool` > Parameters > SnowflakeConfig Parameters",
      "enhanced_text": "Context: Changelog > `SnowflakeSearchTool` > Parameters > SnowflakeConfig Parameters\n\n SnowflakeConfig Parameters\n\nThe `SnowflakeConfig` class accepts the following parameters: **account**: Required. Snowflake account identifier. **user**: Required. Snowflake username. **password**: Optional\\*. Snowflake password. **private\\_key\\_path**: Optional\\*. Path to private key file (alternative to password). **warehouse**: Required. Snowflake warehouse name. **database**: Required. Default database. **snowflake\\_schema**: Required. Default schema. **role**: Optional. Snowflake role. **session\\_parameters**: Optional. Custom session parameters as a dictionary. \\*Either `password` or `private_key_path` must be provided.\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "The `SnowflakeSearchTool` accepts the following parameters during initialization: **config**: Required. A `SnowflakeConfig` object containing connection details. **pool\\_size**: Optional. Number of connections in the pool. Default is 5. **max\\_retries**: Optional. Maximum retry attempts for failed queries. Default is 3. **retry\\_delay**: Optional. Delay between retries in seconds. Default is 1.0. **enable\\_caching**: Optional. Whether to enable query result caching. Default is True.",
      "title": "SnowflakeSearchTool Parameters",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`SnowflakeSearchTool`",
          "level": 1
        },
        {
          "title": "Parameters",
          "level": 2
        },
        {
          "title": "SnowflakeSearchTool Parameters",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`SnowflakeSearchTool`",
            "level": 1
          },
          {
            "title": "Parameters",
            "level": 2
          },
          {
            "title": "SnowflakeSearchTool Parameters",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `SnowflakeSearchTool` > Parameters > SnowflakeSearchTool Parameters"
      },
      "enhanced_content": "Context: Changelog > `SnowflakeSearchTool` > Parameters > SnowflakeSearchTool Parameters\n\n### SnowflakeSearchTool Parameters\n\nThe `SnowflakeSearchTool` accepts the following parameters during initialization: **config**: Required. A `SnowflakeConfig` object containing connection details. **pool\\_size**: Optional. Number of connections in the pool. Default is 5. **max\\_retries**: Optional. Maximum retry attempts for failed queries. Default is 3. **retry\\_delay**: Optional. Delay between retries in seconds. Default is 1.0. **enable\\_caching**: Optional. Whether to enable query result caching. Default is True.",
      "formatted_path": "Changelog > `SnowflakeSearchTool` > Parameters > SnowflakeSearchTool Parameters",
      "enhanced_text": "Context: Changelog > `SnowflakeSearchTool` > Parameters > SnowflakeSearchTool Parameters\n\n SnowflakeSearchTool Parameters\n\nThe `SnowflakeSearchTool` accepts the following parameters during initialization: **config**: Required. A `SnowflakeConfig` object containing connection details. **pool\\_size**: Optional. Number of connections in the pool. Default is 5. **max\\_retries**: Optional. Maximum retry attempts for failed queries. Default is 3. **retry\\_delay**: Optional. Delay between retries in seconds. Default is 1.0. **enable\\_caching**: Optional. Whether to enable query result caching. Default is True.\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "The `SnowflakeSearchTool` implements connection pooling to improve performance by reusing database connections. You can control the pool size with the `pool_size` parameter.",
      "title": "Connection Pooling",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`SnowflakeSearchTool`",
          "level": 1
        },
        {
          "title": "Advanced Features",
          "level": 2
        },
        {
          "title": "Connection Pooling",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`SnowflakeSearchTool`",
            "level": 1
          },
          {
            "title": "Advanced Features",
            "level": 2
          },
          {
            "title": "Connection Pooling",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `SnowflakeSearchTool` > Advanced Features > Connection Pooling"
      },
      "enhanced_content": "Context: Changelog > `SnowflakeSearchTool` > Advanced Features > Connection Pooling\n\n### Connection Pooling\n\nThe `SnowflakeSearchTool` implements connection pooling to improve performance by reusing database connections. You can control the pool size with the `pool_size` parameter.",
      "formatted_path": "Changelog > `SnowflakeSearchTool` > Advanced Features > Connection Pooling",
      "enhanced_text": "Context: Changelog > `SnowflakeSearchTool` > Advanced Features > Connection Pooling\n\n Connection Pooling\n\nThe `SnowflakeSearchTool` implements connection pooling to improve performance by reusing database connections. You can control the pool size with the `pool_size` parameter."
    },
    {
      "content": "The tool automatically retries failed queries with exponential backoff. You can configure the retry behavior with the `max_retries` and `retry_delay` parameters.",
      "title": "Automatic Retries",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`SnowflakeSearchTool`",
          "level": 1
        },
        {
          "title": "Advanced Features",
          "level": 2
        },
        {
          "title": "Automatic Retries",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`SnowflakeSearchTool`",
            "level": 1
          },
          {
            "title": "Advanced Features",
            "level": 2
          },
          {
            "title": "Automatic Retries",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `SnowflakeSearchTool` > Advanced Features > Automatic Retries"
      },
      "enhanced_content": "Context: Changelog > `SnowflakeSearchTool` > Advanced Features > Automatic Retries\n\n### Automatic Retries\n\nThe tool automatically retries failed queries with exponential backoff. You can configure the retry behavior with the `max_retries` and `retry_delay` parameters.",
      "formatted_path": "Changelog > `SnowflakeSearchTool` > Advanced Features > Automatic Retries",
      "enhanced_text": "Context: Changelog > `SnowflakeSearchTool` > Advanced Features > Automatic Retries\n\n Automatic Retries\n\nThe tool automatically retries failed queries with exponential backoff. You can configure the retry behavior with the `max_retries` and `retry_delay` parameters."
    },
    {
      "content": "To improve performance for repeated queries, the tool can cache query results. This feature is enabled by default but can be disabled by setting `enable_caching=False`.",
      "title": "Query Result Caching",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`SnowflakeSearchTool`",
          "level": 1
        },
        {
          "title": "Advanced Features",
          "level": 2
        },
        {
          "title": "Query Result Caching",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`SnowflakeSearchTool`",
            "level": 1
          },
          {
            "title": "Advanced Features",
            "level": 2
          },
          {
            "title": "Query Result Caching",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `SnowflakeSearchTool` > Advanced Features > Query Result Caching"
      },
      "enhanced_content": "Context: Changelog > `SnowflakeSearchTool` > Advanced Features > Query Result Caching\n\n### Query Result Caching\n\nTo improve performance for repeated queries, the tool can cache query results. This feature is enabled by default but can be disabled by setting `enable_caching=False`.",
      "formatted_path": "Changelog > `SnowflakeSearchTool` > Advanced Features > Query Result Caching",
      "enhanced_text": "Context: Changelog > `SnowflakeSearchTool` > Advanced Features > Query Result Caching\n\n Query Result Caching\n\nTo improve performance for repeated queries, the tool can cache query results. This feature is enabled by default but can be disabled by setting `enable_caching=False`."
    },
    {
      "content": "config = SnowflakeConfig(\n    account=\"your_account\",\n    user=\"your_username\",\n    private_key_path=\"/path/to/your/private/key.p8\",\n    warehouse=\"COMPUTE_WH\",\n    database=\"your_database\",\n    snowflake_schema=\"your_schema\"\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`SnowflakeSearchTool`",
          "level": 1
        },
        {
          "title": "Advanced Features",
          "level": 2
        },
        {
          "title": "Key-Pair Authentication",
          "level": 3
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`SnowflakeSearchTool`",
            "level": 1
          },
          {
            "title": "Advanced Features",
            "level": 2
          },
          {
            "title": "Key-Pair Authentication",
            "level": 3
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `SnowflakeSearchTool` > Advanced Features > Key-Pair Authentication"
      },
      "enhanced_content": "Context: Changelog > `SnowflakeSearchTool` > Advanced Features > Key-Pair Authentication\n\nconfig = SnowflakeConfig(\n    account=\"your_account\",\n    user=\"your_username\",\n    private_key_path=\"/path/to/your/private/key.p8\",\n    warehouse=\"COMPUTE_WH\",\n    database=\"your_database\",\n    snowflake_schema=\"your_schema\"\n)",
      "formatted_path": "Changelog > `SnowflakeSearchTool` > Advanced Features > Key-Pair Authentication",
      "enhanced_text": "Context: Changelog > `SnowflakeSearchTool` > Advanced Features > Key-Pair Authentication\n\nconfig = SnowflakeConfig(\n    account=\"your_account\",\n    user=\"your_username\",\n    private_key_path=\"/path/to/your/private/key.p8\",\n    warehouse=\"COMPUTE_WH\",\n    database=\"your_database\",\n    snowflake_schema=\"your_schema\"\n)"
    },
    {
      "content": "# Create a task that includes error handling instructions\nrobust_extract_task = Task(\n    description=\"\"\"\n    Extract the main heading from example.com.\n    Be aware that you might encounter errors such as:\n    - Invalid URL format\n    - Missing API key\n    - Rate limit exceeded\n    - Network or API errors\n    \n    If you encounter any errors, provide a clear explanation of what went wrong\n    and suggest possible solutions.\n    \"\"\",\n    expected_output=\"Either the extracted heading or a clear error explanation\",\n    agent=web_scraper_agent,\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`SnowflakeSearchTool`",
          "level": 1
        },
        {
          "title": "Error Handling",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`SnowflakeSearchTool`",
            "level": 1
          },
          {
            "title": "Error Handling",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `SnowflakeSearchTool` > Error Handling"
      },
      "enhanced_content": "Context: Changelog > `SnowflakeSearchTool` > Error Handling\n\n# Create a task that includes error handling instructions\nrobust_extract_task = Task(\n    description=\"\"\"\n    Extract the main heading from example.com.\n    Be aware that you might encounter errors such as:\n    - Invalid URL format\n    - Missing API key\n    - Rate limit exceeded\n    - Network or API errors\n    \n    If you encounter any errors, provide a clear explanation of what went wrong\n    and suggest possible solutions.\n    \"\"\",\n    expected_output=\"Either the extracted heading or a clear error explanation\",\n    agent=web_scraper_agent,\n)",
      "formatted_path": "Changelog > `SnowflakeSearchTool` > Error Handling",
      "enhanced_text": "Context: Changelog > `SnowflakeSearchTool` > Error Handling\n\n# Create a task that includes error handling instructions\nrobust_extract_task = Task(\n    description=\"\"\"\n    Extract the main heading from example.com.\n    Be aware that you might encounter errors such as:\n    - Invalid URL format\n    - Missing API key\n    - Rate limit exceeded\n    - Network or API errors\n    \n    If you encounter any errors, provide a clear explanation of what went wrong\n    and suggest possible solutions.\n    \"\"\",\n    expected_output=\"Either the extracted heading or a clear error explanation\",\n    agent=web_scraper_agent,\n)"
    },
    {
      "content": "# Create a task that instructs the agent to handle errors\nerror_handling_task = Task(\n    description=\"\"\"\n    Extract content from a potentially problematic website and make sure to handle any \n    scraping failures gracefully by setting ignore_scrape_failures to True.\n    \"\"\",\n    expected_output=\"Either the extracted content or a graceful error message\",\n    agent=web_scraper_agent,\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`SnowflakeSearchTool`",
          "level": 1
        },
        {
          "title": "Error Handling",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`SnowflakeSearchTool`",
            "level": 1
          },
          {
            "title": "Error Handling",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `SnowflakeSearchTool` > Error Handling"
      },
      "enhanced_content": "Context: Changelog > `SnowflakeSearchTool` > Error Handling\n\n# Create a task that instructs the agent to handle errors\nerror_handling_task = Task(\n    description=\"\"\"\n    Extract content from a potentially problematic website and make sure to handle any \n    scraping failures gracefully by setting ignore_scrape_failures to True.\n    \"\"\",\n    expected_output=\"Either the extracted content or a graceful error message\",\n    agent=web_scraper_agent,\n)",
      "formatted_path": "Changelog > `SnowflakeSearchTool` > Error Handling",
      "enhanced_text": "Context: Changelog > `SnowflakeSearchTool` > Error Handling\n\n# Create a task that instructs the agent to handle errors\nerror_handling_task = Task(\n    description=\"\"\"\n    Extract content from a potentially problematic website and make sure to handle any \n    scraping failures gracefully by setting ignore_scrape_failures to True.\n    \"\"\",\n    expected_output=\"Either the extracted content or a graceful error message\",\n    agent=web_scraper_agent,\n)"
    },
    {
      "content": "Source: https://docs.crewai.com/tools/spidertool The `SpiderTool` is designed to extract and read the content of a specified website using Spider.",
      "title": "Spider Scraper",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Spider Scraper",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Spider Scraper",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Spider Scraper"
      },
      "enhanced_content": "Context: Changelog > Spider Scraper\n\n# Spider Scraper\n\nSource: https://docs.crewai.com/tools/spidertool The `SpiderTool` is designed to extract and read the content of a specified website using Spider.",
      "formatted_path": "Changelog > Spider Scraper",
      "enhanced_text": "Context: Changelog > Spider Scraper\n\n Spider Scraper\n\nSource: https://docs.crewai.com/tools/spidertool The `SpiderTool` is designed to extract and read the content of a specified website using Spider."
    },
    {
      "content": "Source: https://docs.crewai.com/tools/txtsearchtool The `TXTSearchTool` is designed to perform a RAG (Retrieval-Augmented Generation) search within the content of a text file.",
      "title": "TXT RAG Search",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "TXT RAG Search",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "TXT RAG Search",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > TXT RAG Search"
      },
      "enhanced_content": "Context: Changelog > TXT RAG Search\n\n# TXT RAG Search\n\nSource: https://docs.crewai.com/tools/txtsearchtool The `TXTSearchTool` is designed to perform a RAG (Retrieval-Augmented Generation) search within the content of a text file.",
      "formatted_path": "Changelog > TXT RAG Search",
      "enhanced_text": "Context: Changelog > TXT RAG Search\n\n TXT RAG Search\n\nSource: https://docs.crewai.com/tools/txtsearchtool The `TXTSearchTool` is designed to perform a RAG (Retrieval-Augmented Generation) search within the content of a text file."
    },
    {
      "content": "Source: https://docs.crewai.com/tools/visiontool The `VisionTool` is designed to extract text from images.",
      "title": "Vision Tool",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Vision Tool",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Vision Tool",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Vision Tool"
      },
      "enhanced_content": "Context: Changelog > Vision Tool\n\n# Vision Tool\n\nSource: https://docs.crewai.com/tools/visiontool The `VisionTool` is designed to extract text from images.",
      "formatted_path": "Changelog > Vision Tool",
      "enhanced_text": "Context: Changelog > Vision Tool\n\n Vision Tool\n\nSource: https://docs.crewai.com/tools/visiontool The `VisionTool` is designed to extract text from images."
    },
    {
      "content": "@listen(\"generate_city\")\ndef generate_fun_fact(self, random_city):\n    # Implementation",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`VisionTool`",
          "level": 1
        },
        {
          "title": "Usage",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`VisionTool`",
            "level": 1
          },
          {
            "title": "Usage",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `VisionTool` > Usage"
      },
      "enhanced_content": "Context: Changelog > `VisionTool` > Usage\n\n@listen(\"generate_city\")\ndef generate_fun_fact(self, random_city):\n    # Implementation",
      "formatted_path": "Changelog > `VisionTool` > Usage",
      "enhanced_text": "Context: Changelog > `VisionTool` > Usage\n\n@listen(\"generate_city\")\ndef generate_fun_fact(self, random_city):\n    # Implementation"
    },
    {
      "content": "@listen(generate_city)\ndef generate_fun_fact(self, random_city):\n    # Implementation",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`VisionTool`",
          "level": 1
        },
        {
          "title": "Usage",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`VisionTool`",
            "level": 1
          },
          {
            "title": "Usage",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `VisionTool` > Usage"
      },
      "enhanced_content": "Context: Changelog > `VisionTool` > Usage\n\n@listen(generate_city)\ndef generate_fun_fact(self, random_city):\n    # Implementation",
      "formatted_path": "Changelog > `VisionTool` > Usage",
      "enhanced_text": "Context: Changelog > `VisionTool` > Usage\n\n@listen(generate_city)\ndef generate_fun_fact(self, random_city):\n    # Implementation"
    },
    {
      "content": "from crewai import Agent, Task, Crew\nfrom crewai_tools.aws.bedrock.agents.invoke_agent_tool import BedrockInvokeAgentTool\n\n# Initialize the tool\nagent_tool = BedrockInvokeAgentTool(\n    agent_id=\"your-agent-id\",\n    agent_alias_id=\"your-agent-alias-id\"\n)\n\n# Create a CrewAI agent that uses the tool\naws_expert = Agent(\n    role='AWS Service Expert',\n    goal='Help users understand AWS services and quotas',\n    backstory='I am an expert in AWS services and can provide detailed information about them.',\n    tools=[agent_tool],\n    verbose=True\n)\n\n# Create a task for the agent\nquota_task = Task(\n    description=\"Find out the current service quotas for EC2 in us-west-2 and explain any recent changes.\",\n    agent=aws_expert\n)\n\n# Create a crew with the agent\ncrew = Crew(\n    agents=[aws_expert],\n    tasks=[quota_task],\n    verbose=2\n)\n\n# Run the crew\nresult = crew.kickoff()\nprint(result)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`VisionTool`",
          "level": 1
        },
        {
          "title": "Usage",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`VisionTool`",
            "level": 1
          },
          {
            "title": "Usage",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `VisionTool` > Usage"
      },
      "enhanced_content": "Context: Changelog > `VisionTool` > Usage\n\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools.aws.bedrock.agents.invoke_agent_tool import BedrockInvokeAgentTool\n\n# Initialize the tool\nagent_tool = BedrockInvokeAgentTool(\n    agent_id=\"your-agent-id\",\n    agent_alias_id=\"your-agent-alias-id\"\n)\n\n# Create a CrewAI agent that uses the tool\naws_expert = Agent(\n    role='AWS Service Expert',\n    goal='Help users understand AWS services and quotas',\n    backstory='I am an expert in AWS services and can provide detailed information about them.',\n    tools=[agent_tool],\n    verbose=True\n)\n\n# Create a task for the agent\nquota_task = Task(\n    description=\"Find out the current service quotas for EC2 in us-west-2 and explain any recent changes.\",\n    agent=aws_expert\n)\n\n# Create a crew with the agent\ncrew = Crew(\n    agents=[aws_expert],\n    tasks=[quota_task],\n    verbose=2\n)\n\n# Run the crew\nresult = crew.kickoff()\nprint(result)",
      "formatted_path": "Changelog > `VisionTool` > Usage",
      "enhanced_text": "Context: Changelog > `VisionTool` > Usage\n\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools.aws.bedrock.agents.invoke_agent_tool import BedrockInvokeAgentTool\n\n# Initialize the tool\nagent_tool = BedrockInvokeAgentTool(\n    agent_id=\"your-agent-id\",\n    agent_alias_id=\"your-agent-alias-id\"\n)\n\n# Create a CrewAI agent that uses the tool\naws_expert = Agent(\n    role='AWS Service Expert',\n    goal='Help users understand AWS services and quotas',\n    backstory='I am an expert in AWS services and can provide detailed information about them.',\n    tools=[agent_tool],\n    verbose=True\n)\n\n# Create a task for the agent\nquota_task = Task(\n    description=\"Find out the current service quotas for EC2 in us-west-2 and explain any recent changes.\",\n    agent=aws_expert\n)\n\n# Create a crew with the agent\ncrew = Crew(\n    agents=[aws_expert],\n    tasks=[quota_task],\n    verbose=2\n)\n\n# Run the crew\nresult = crew.kickoff()\nprint(result)"
    },
    {
      "content": "from crewai import Agent, Task, Crew\nfrom crewai_tools.aws.bedrock.knowledge_base.retriever_tool import BedrockKBRetrieverTool\n\n# Initialize the tool\nkb_tool = BedrockKBRetrieverTool(\n    knowledge_base_id=\"your-kb-id\",\n    number_of_results=5\n)\n\n# Create a CrewAI agent that uses the tool\nresearcher = Agent(\n    role='Knowledge Base Researcher',\n    goal='Find information about company policies',\n    backstory='I am a researcher specialized in retrieving and analyzing company documentation.',\n    tools=[kb_tool],\n    verbose=True\n)\n\n# Create a task for the agent\nresearch_task = Task(\n    description=\"Find our company's remote work policy and summarize the key points.\",\n    agent=researcher\n)\n\n# Create a crew with the agent\ncrew = Crew(\n    agents=[researcher],\n    tasks=[research_task],\n    verbose=2\n)\n\n# Run the crew\nresult = crew.kickoff()\nprint(result)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`VisionTool`",
          "level": 1
        },
        {
          "title": "Usage",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`VisionTool`",
            "level": 1
          },
          {
            "title": "Usage",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `VisionTool` > Usage"
      },
      "enhanced_content": "Context: Changelog > `VisionTool` > Usage\n\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools.aws.bedrock.knowledge_base.retriever_tool import BedrockKBRetrieverTool\n\n# Initialize the tool\nkb_tool = BedrockKBRetrieverTool(\n    knowledge_base_id=\"your-kb-id\",\n    number_of_results=5\n)\n\n# Create a CrewAI agent that uses the tool\nresearcher = Agent(\n    role='Knowledge Base Researcher',\n    goal='Find information about company policies',\n    backstory='I am a researcher specialized in retrieving and analyzing company documentation.',\n    tools=[kb_tool],\n    verbose=True\n)\n\n# Create a task for the agent\nresearch_task = Task(\n    description=\"Find our company's remote work policy and summarize the key points.\",\n    agent=researcher\n)\n\n# Create a crew with the agent\ncrew = Crew(\n    agents=[researcher],\n    tasks=[research_task],\n    verbose=2\n)\n\n# Run the crew\nresult = crew.kickoff()\nprint(result)",
      "formatted_path": "Changelog > `VisionTool` > Usage",
      "enhanced_text": "Context: Changelog > `VisionTool` > Usage\n\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools.aws.bedrock.knowledge_base.retriever_tool import BedrockKBRetrieverTool\n\n# Initialize the tool\nkb_tool = BedrockKBRetrieverTool(\n    knowledge_base_id=\"your-kb-id\",\n    number_of_results=5\n)\n\n# Create a CrewAI agent that uses the tool\nresearcher = Agent(\n    role='Knowledge Base Researcher',\n    goal='Find information about company policies',\n    backstory='I am a researcher specialized in retrieving and analyzing company documentation.',\n    tools=[kb_tool],\n    verbose=True\n)\n\n# Create a task for the agent\nresearch_task = Task(\n    description=\"Find our company's remote work policy and summarize the key points.\",\n    agent=researcher\n)\n\n# Create a crew with the agent\ncrew = Crew(\n    agents=[researcher],\n    tasks=[research_task],\n    verbose=2\n)\n\n# Run the crew\nresult = crew.kickoff()\nprint(result)"
    },
    {
      "content": "# Example of using the tool with an agent\nbrowser_agent = Agent(\n    role=\"Web Browser Agent\",\n    goal=\"Search for and summarize information from the web\",\n    backstory=\"An expert at finding and extracting information from websites.\",\n    tools=[multion_tool],\n    verbose=True,\n)\n\n# Create a task for the agent\nsearch_task = Task(\n    description=\"Search for the latest AI news on TechCrunch and summarize the top 3 headlines\",\n    expected_output=\"A summary of the top 3 AI news headlines from TechCrunch\",\n    agent=browser_agent,\n)\n\n# Run the task\ncrew = Crew(agents=[browser_agent], tasks=[search_task])\nresult = crew.kickoff()",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`VisionTool`",
          "level": 1
        },
        {
          "title": "Usage",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`VisionTool`",
            "level": 1
          },
          {
            "title": "Usage",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `VisionTool` > Usage"
      },
      "enhanced_content": "Context: Changelog > `VisionTool` > Usage\n\n# Example of using the tool with an agent\nbrowser_agent = Agent(\n    role=\"Web Browser Agent\",\n    goal=\"Search for and summarize information from the web\",\n    backstory=\"An expert at finding and extracting information from websites.\",\n    tools=[multion_tool],\n    verbose=True,\n)\n\n# Create a task for the agent\nsearch_task = Task(\n    description=\"Search for the latest AI news on TechCrunch and summarize the top 3 headlines\",\n    expected_output=\"A summary of the top 3 AI news headlines from TechCrunch\",\n    agent=browser_agent,\n)\n\n# Run the task\ncrew = Crew(agents=[browser_agent], tasks=[search_task])\nresult = crew.kickoff()",
      "formatted_path": "Changelog > `VisionTool` > Usage",
      "enhanced_text": "Context: Changelog > `VisionTool` > Usage\n\n# Example of using the tool with an agent\nbrowser_agent = Agent(\n    role=\"Web Browser Agent\",\n    goal=\"Search for and summarize information from the web\",\n    backstory=\"An expert at finding and extracting information from websites.\",\n    tools=[multion_tool],\n    verbose=True,\n)\n\n# Create a task for the agent\nsearch_task = Task(\n    description=\"Search for the latest AI news on TechCrunch and summarize the top 3 headlines\",\n    expected_output=\"A summary of the top 3 AI news headlines from TechCrunch\",\n    agent=browser_agent,\n)\n\n# Run the task\ncrew = Crew(agents=[browser_agent], tasks=[search_task])\nresult = crew.kickoff()"
    },
    {
      "content": "from crewai_tools import NL2SQLTool\n\n# psycopg2 was installed to run this example with PostgreSQL\nnl2sql = NL2SQLTool(db_uri=\"postgresql://example@localhost:5432/test_db\")\n\n@agent\ndef researcher(self) -> Agent:\n    return Agent(\n        config=self.agents_config[\"researcher\"],\n        allow_delegation=False,\n        tools=[nl2sql]\n    )",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`VisionTool`",
          "level": 1
        },
        {
          "title": "Usage",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`VisionTool`",
            "level": 1
          },
          {
            "title": "Usage",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `VisionTool` > Usage"
      },
      "enhanced_content": "Context: Changelog > `VisionTool` > Usage\n\nfrom crewai_tools import NL2SQLTool\n\n# psycopg2 was installed to run this example with PostgreSQL\nnl2sql = NL2SQLTool(db_uri=\"postgresql://example@localhost:5432/test_db\")\n\n@agent\ndef researcher(self) -> Agent:\n    return Agent(\n        config=self.agents_config[\"researcher\"],\n        allow_delegation=False,\n        tools=[nl2sql]\n    )",
      "formatted_path": "Changelog > `VisionTool` > Usage",
      "enhanced_text": "Context: Changelog > `VisionTool` > Usage\n\nfrom crewai_tools import NL2SQLTool\n\n# psycopg2 was installed to run this example with PostgreSQL\nnl2sql = NL2SQLTool(db_uri=\"postgresql://example@localhost:5432/test_db\")\n\n@agent\ndef researcher(self) -> Agent:\n    return Agent(\n        config=self.agents_config[\"researcher\"],\n        allow_delegation=False,\n        tools=[nl2sql]\n    )"
    },
    {
      "content": "# Example of using the tool with an agent\nfile_reader_agent = Agent(\n    role=\"File Reader\",\n    goal=\"Read files from S3 buckets\",\n    backstory=\"An expert in retrieving and processing files from cloud storage.\",\n    tools=[s3_reader_tool],\n    verbose=True,\n)\n\n# Create a task for the agent to read a specific file\nread_config_task = Task(\n    description=\"Read the application configuration file from {my_bucket} and extract the database connection settings.\",\n    expected_output=\"The database connection settings from the configuration file.\",\n    agent=file_reader_agent,\n)\n\n# Run the task\ncrew = Crew(agents=[file_reader_agent], tasks=[read_config_task])\nresult = crew.kickoff(inputs={\"my_bucket\": \"s3://my-bucket/config/app-config.json\"})",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`VisionTool`",
          "level": 1
        },
        {
          "title": "Usage",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`VisionTool`",
            "level": 1
          },
          {
            "title": "Usage",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `VisionTool` > Usage"
      },
      "enhanced_content": "Context: Changelog > `VisionTool` > Usage\n\n# Example of using the tool with an agent\nfile_reader_agent = Agent(\n    role=\"File Reader\",\n    goal=\"Read files from S3 buckets\",\n    backstory=\"An expert in retrieving and processing files from cloud storage.\",\n    tools=[s3_reader_tool],\n    verbose=True,\n)\n\n# Create a task for the agent to read a specific file\nread_config_task = Task(\n    description=\"Read the application configuration file from {my_bucket} and extract the database connection settings.\",\n    expected_output=\"The database connection settings from the configuration file.\",\n    agent=file_reader_agent,\n)\n\n# Run the task\ncrew = Crew(agents=[file_reader_agent], tasks=[read_config_task])\nresult = crew.kickoff(inputs={\"my_bucket\": \"s3://my-bucket/config/app-config.json\"})",
      "formatted_path": "Changelog > `VisionTool` > Usage",
      "enhanced_text": "Context: Changelog > `VisionTool` > Usage\n\n# Example of using the tool with an agent\nfile_reader_agent = Agent(\n    role=\"File Reader\",\n    goal=\"Read files from S3 buckets\",\n    backstory=\"An expert in retrieving and processing files from cloud storage.\",\n    tools=[s3_reader_tool],\n    verbose=True,\n)\n\n# Create a task for the agent to read a specific file\nread_config_task = Task(\n    description=\"Read the application configuration file from {my_bucket} and extract the database connection settings.\",\n    expected_output=\"The database connection settings from the configuration file.\",\n    agent=file_reader_agent,\n)\n\n# Run the task\ncrew = Crew(agents=[file_reader_agent], tasks=[read_config_task])\nresult = crew.kickoff(inputs={\"my_bucket\": \"s3://my-bucket/config/app-config.json\"})"
    },
    {
      "content": "# Example of using the tool with an agent\nfile_writer_agent = Agent(\n    role=\"File Writer\",\n    goal=\"Write content to files in S3 buckets\",\n    backstory=\"An expert in storing and managing files in cloud storage.\",\n    tools=[s3_writer_tool],\n    verbose=True,\n)\n\n# Create a task for the agent to write a specific file\nwrite_config_task = Task(\n    description=\"\"\"\n    Create a configuration file with the following database settings:\n    - host: db.example.com\n    - port: 5432\n    - username: app_user\n    - password: secure_password\n    \n    Save this configuration as JSON to {my_bucket}.\n    \"\"\",\n    expected_output=\"Confirmation that the configuration file was successfully saved to S3.\",\n    agent=file_writer_agent,\n)\n\n# Run the task\ncrew = Crew(agents=[file_writer_agent], tasks=[write_config_task])\nresult = crew.kickoff(inputs={\"my_bucket\": \"s3://my-bucket/config/db-config.json\"})",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`VisionTool`",
          "level": 1
        },
        {
          "title": "Usage",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`VisionTool`",
            "level": 1
          },
          {
            "title": "Usage",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `VisionTool` > Usage"
      },
      "enhanced_content": "Context: Changelog > `VisionTool` > Usage\n\n# Example of using the tool with an agent\nfile_writer_agent = Agent(\n    role=\"File Writer\",\n    goal=\"Write content to files in S3 buckets\",\n    backstory=\"An expert in storing and managing files in cloud storage.\",\n    tools=[s3_writer_tool],\n    verbose=True,\n)\n\n# Create a task for the agent to write a specific file\nwrite_config_task = Task(\n    description=\"\"\"\n    Create a configuration file with the following database settings:\n    - host: db.example.com\n    - port: 5432\n    - username: app_user\n    - password: secure_password\n    \n    Save this configuration as JSON to {my_bucket}.\n    \"\"\",\n    expected_output=\"Confirmation that the configuration file was successfully saved to S3.\",\n    agent=file_writer_agent,\n)\n\n# Run the task\ncrew = Crew(agents=[file_writer_agent], tasks=[write_config_task])\nresult = crew.kickoff(inputs={\"my_bucket\": \"s3://my-bucket/config/db-config.json\"})",
      "formatted_path": "Changelog > `VisionTool` > Usage",
      "enhanced_text": "Context: Changelog > `VisionTool` > Usage\n\n# Example of using the tool with an agent\nfile_writer_agent = Agent(\n    role=\"File Writer\",\n    goal=\"Write content to files in S3 buckets\",\n    backstory=\"An expert in storing and managing files in cloud storage.\",\n    tools=[s3_writer_tool],\n    verbose=True,\n)\n\n# Create a task for the agent to write a specific file\nwrite_config_task = Task(\n    description=\"\"\"\n    Create a configuration file with the following database settings:\n    - host: db.example.com\n    - port: 5432\n    - username: app_user\n    - password: secure_password\n    \n    Save this configuration as JSON to {my_bucket}.\n    \"\"\",\n    expected_output=\"Confirmation that the configuration file was successfully saved to S3.\",\n    agent=file_writer_agent,\n)\n\n# Run the task\ncrew = Crew(agents=[file_writer_agent], tasks=[write_config_task])\nresult = crew.kickoff(inputs={\"my_bucket\": \"s3://my-bucket/config/db-config.json\"})"
    },
    {
      "content": "# Example of using the tool with an agent\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract specific elements from websites\",\n    backstory=\"An expert in web scraping who can extract targeted content using CSS selectors.\",\n    tools=[scrape_tool],\n    verbose=True,\n)\n\n# Create a task for the agent to extract specific elements\nextract_task = Task(\n    description=\"\"\"\n    Extract all product titles from the featured products section on example.com.\n    Use the CSS selector '.product-title' to target the title elements.\n    \"\"\",\n    expected_output=\"A list of product titles from the website\",\n    agent=web_scraper_agent,\n)\n\n# Run the task through a crew\ncrew = Crew(agents=[web_scraper_agent], tasks=[extract_task])\nresult = crew.kickoff()",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`VisionTool`",
          "level": 1
        },
        {
          "title": "Usage",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`VisionTool`",
            "level": 1
          },
          {
            "title": "Usage",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `VisionTool` > Usage"
      },
      "enhanced_content": "Context: Changelog > `VisionTool` > Usage\n\n# Example of using the tool with an agent\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract specific elements from websites\",\n    backstory=\"An expert in web scraping who can extract targeted content using CSS selectors.\",\n    tools=[scrape_tool],\n    verbose=True,\n)\n\n# Create a task for the agent to extract specific elements\nextract_task = Task(\n    description=\"\"\"\n    Extract all product titles from the featured products section on example.com.\n    Use the CSS selector '.product-title' to target the title elements.\n    \"\"\",\n    expected_output=\"A list of product titles from the website\",\n    agent=web_scraper_agent,\n)\n\n# Run the task through a crew\ncrew = Crew(agents=[web_scraper_agent], tasks=[extract_task])\nresult = crew.kickoff()",
      "formatted_path": "Changelog > `VisionTool` > Usage",
      "enhanced_text": "Context: Changelog > `VisionTool` > Usage\n\n# Example of using the tool with an agent\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract specific elements from websites\",\n    backstory=\"An expert in web scraping who can extract targeted content using CSS selectors.\",\n    tools=[scrape_tool],\n    verbose=True,\n)\n\n# Create a task for the agent to extract specific elements\nextract_task = Task(\n    description=\"\"\"\n    Extract all product titles from the featured products section on example.com.\n    Use the CSS selector '.product-title' to target the title elements.\n    \"\"\",\n    expected_output=\"A list of product titles from the website\",\n    agent=web_scraper_agent,\n)\n\n# Run the task through a crew\ncrew = Crew(agents=[web_scraper_agent], tasks=[extract_task])\nresult = crew.kickoff()"
    },
    {
      "content": "# Example of using the tool with an agent\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract specific information from websites\",\n    backstory=\"An expert in web scraping who can extract targeted content from web pages.\",\n    tools=[scrape_tool],\n    verbose=True,\n)\n\n# Create a task for the agent to extract specific content\nextract_task = Task(\n    description=\"Extract the main heading and summary from example.com\",\n    expected_output=\"The main heading and summary from the website\",\n    agent=web_scraper_agent,\n)\n\n# Run the task\ncrew = Crew(agents=[web_scraper_agent], tasks=[extract_task])\nresult = crew.kickoff()",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`VisionTool`",
          "level": 1
        },
        {
          "title": "Usage",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`VisionTool`",
            "level": 1
          },
          {
            "title": "Usage",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `VisionTool` > Usage"
      },
      "enhanced_content": "Context: Changelog > `VisionTool` > Usage\n\n# Example of using the tool with an agent\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract specific information from websites\",\n    backstory=\"An expert in web scraping who can extract targeted content from web pages.\",\n    tools=[scrape_tool],\n    verbose=True,\n)\n\n# Create a task for the agent to extract specific content\nextract_task = Task(\n    description=\"Extract the main heading and summary from example.com\",\n    expected_output=\"The main heading and summary from the website\",\n    agent=web_scraper_agent,\n)\n\n# Run the task\ncrew = Crew(agents=[web_scraper_agent], tasks=[extract_task])\nresult = crew.kickoff()",
      "formatted_path": "Changelog > `VisionTool` > Usage",
      "enhanced_text": "Context: Changelog > `VisionTool` > Usage\n\n# Example of using the tool with an agent\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract specific information from websites\",\n    backstory=\"An expert in web scraping who can extract targeted content from web pages.\",\n    tools=[scrape_tool],\n    verbose=True,\n)\n\n# Create a task for the agent to extract specific content\nextract_task = Task(\n    description=\"Extract the main heading and summary from example.com\",\n    expected_output=\"The main heading and summary from the website\",\n    agent=web_scraper_agent,\n)\n\n# Run the task\ncrew = Crew(agents=[web_scraper_agent], tasks=[extract_task])\nresult = crew.kickoff()"
    },
    {
      "content": "# Example of using the tool with an agent\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract information from websites\",\n    backstory=\"An expert in web scraping who can extract content from any website.\",\n    tools=[scrape_tool],\n    verbose=True,\n)\n\n# Create a task for the agent\nscrape_task = Task(\n    description=\"Extract the main content from example.com in markdown format.\",\n    expected_output=\"The main content of example.com in markdown format.\",\n    agent=web_scraper_agent,\n)\n\n# Run the task\ncrew = Crew(agents=[web_scraper_agent], tasks=[scrape_task])\nresult = crew.kickoff()",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`VisionTool`",
          "level": 1
        },
        {
          "title": "Usage",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`VisionTool`",
            "level": 1
          },
          {
            "title": "Usage",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `VisionTool` > Usage"
      },
      "enhanced_content": "Context: Changelog > `VisionTool` > Usage\n\n# Example of using the tool with an agent\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract information from websites\",\n    backstory=\"An expert in web scraping who can extract content from any website.\",\n    tools=[scrape_tool],\n    verbose=True,\n)\n\n# Create a task for the agent\nscrape_task = Task(\n    description=\"Extract the main content from example.com in markdown format.\",\n    expected_output=\"The main content of example.com in markdown format.\",\n    agent=web_scraper_agent,\n)\n\n# Run the task\ncrew = Crew(agents=[web_scraper_agent], tasks=[scrape_task])\nresult = crew.kickoff()",
      "formatted_path": "Changelog > `VisionTool` > Usage",
      "enhanced_text": "Context: Changelog > `VisionTool` > Usage\n\n# Example of using the tool with an agent\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract information from websites\",\n    backstory=\"An expert in web scraping who can extract content from any website.\",\n    tools=[scrape_tool],\n    verbose=True,\n)\n\n# Create a task for the agent\nscrape_task = Task(\n    description=\"Extract the main content from example.com in markdown format.\",\n    expected_output=\"The main content of example.com in markdown format.\",\n    agent=web_scraper_agent,\n)\n\n# Run the task\ncrew = Crew(agents=[web_scraper_agent], tasks=[scrape_task])\nresult = crew.kickoff()"
    },
    {
      "content": "# Create a task with more specific instructions\nadvanced_scrape_task = Task(\n    description=\"\"\"\n    Extract content from example.com with the following requirements:\n    - Convert the content to plain text format\n    - Enable JavaScript rendering\n    - Use a US-based proxy\n    - Handle any scraping failures gracefully\n    \"\"\",\n    expected_output=\"The extracted content from example.com\",\n    agent=web_scraper_agent,\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`VisionTool`",
          "level": 1
        },
        {
          "title": "Usage",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`VisionTool`",
            "level": 1
          },
          {
            "title": "Usage",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `VisionTool` > Usage"
      },
      "enhanced_content": "Context: Changelog > `VisionTool` > Usage\n\n# Create a task with more specific instructions\nadvanced_scrape_task = Task(\n    description=\"\"\"\n    Extract content from example.com with the following requirements:\n    - Convert the content to plain text format\n    - Enable JavaScript rendering\n    - Use a US-based proxy\n    - Handle any scraping failures gracefully\n    \"\"\",\n    expected_output=\"The extracted content from example.com\",\n    agent=web_scraper_agent,\n)",
      "formatted_path": "Changelog > `VisionTool` > Usage",
      "enhanced_text": "Context: Changelog > `VisionTool` > Usage\n\n# Create a task with more specific instructions\nadvanced_scrape_task = Task(\n    description=\"\"\"\n    Extract content from example.com with the following requirements:\n    - Convert the content to plain text format\n    - Enable JavaScript rendering\n    - Use a US-based proxy\n    - Handle any scraping failures gracefully\n    \"\"\",\n    expected_output=\"The extracted content from example.com\",\n    agent=web_scraper_agent,\n)"
    },
    {
      "content": "# Example of using the tool with an agent\ndata_analyst = Agent(\n    role=\"Data Analyst\",\n    goal=\"Analyze sales data from Snowflake\",\n    backstory=\"An expert data analyst with experience in SQL and data visualization.\",\n    tools=[snowflake_tool],\n    verbose=True\n)\n\n# The agent will use the tool with parameters like:\n# query=\"SELECT product_name, SUM(revenue) as total_revenue FROM sales GROUP BY product_name ORDER BY total_revenue DESC LIMIT 5\"\n# timeout=600\n\n# Create a task for the agent\nanalysis_task = Task(\n    description=\"Query the sales database and identify the top 5 products by revenue for the last quarter.\",\n    expected_output=\"A detailed analysis of the top 5 products by revenue.\",\n    agent=data_analyst\n)\n\n# Run the task\ncrew = Crew(\n    agents=[data_analyst], \n    tasks=[analysis_task]\n)\nresult = crew.kickoff()",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`VisionTool`",
          "level": 1
        },
        {
          "title": "Usage",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`VisionTool`",
            "level": 1
          },
          {
            "title": "Usage",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `VisionTool` > Usage"
      },
      "enhanced_content": "Context: Changelog > `VisionTool` > Usage\n\n# Example of using the tool with an agent\ndata_analyst = Agent(\n    role=\"Data Analyst\",\n    goal=\"Analyze sales data from Snowflake\",\n    backstory=\"An expert data analyst with experience in SQL and data visualization.\",\n    tools=[snowflake_tool],\n    verbose=True\n)\n\n# The agent will use the tool with parameters like:\n# query=\"SELECT product_name, SUM(revenue) as total_revenue FROM sales GROUP BY product_name ORDER BY total_revenue DESC LIMIT 5\"\n# timeout=600\n\n# Create a task for the agent\nanalysis_task = Task(\n    description=\"Query the sales database and identify the top 5 products by revenue for the last quarter.\",\n    expected_output=\"A detailed analysis of the top 5 products by revenue.\",\n    agent=data_analyst\n)\n\n# Run the task\ncrew = Crew(\n    agents=[data_analyst], \n    tasks=[analysis_task]\n)\nresult = crew.kickoff()",
      "formatted_path": "Changelog > `VisionTool` > Usage",
      "enhanced_text": "Context: Changelog > `VisionTool` > Usage\n\n# Example of using the tool with an agent\ndata_analyst = Agent(\n    role=\"Data Analyst\",\n    goal=\"Analyze sales data from Snowflake\",\n    backstory=\"An expert data analyst with experience in SQL and data visualization.\",\n    tools=[snowflake_tool],\n    verbose=True\n)\n\n# The agent will use the tool with parameters like:\n# query=\"SELECT product_name, SUM(revenue) as total_revenue FROM sales GROUP BY product_name ORDER BY total_revenue DESC LIMIT 5\"\n# timeout=600\n\n# Create a task for the agent\nanalysis_task = Task(\n    description=\"Query the sales database and identify the top 5 products by revenue for the last quarter.\",\n    expected_output=\"A detailed analysis of the top 5 products by revenue.\",\n    agent=data_analyst\n)\n\n# Run the task\ncrew = Crew(\n    agents=[data_analyst], \n    tasks=[analysis_task]\n)\nresult = crew.kickoff()"
    },
    {
      "content": "from crewai_tools import VisionTool\n\nvision_tool = VisionTool()\n\n@agent\ndef researcher(self) -> Agent:\n    '''\n    This agent uses the VisionTool to extract text from images.\n    '''\n    return Agent(\n        config=self.agents_config[\"researcher\"],\n        allow_delegation=False,\n        tools=[vision_tool]\n    )",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`VisionTool`",
          "level": 1
        },
        {
          "title": "Usage",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`VisionTool`",
            "level": 1
          },
          {
            "title": "Usage",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `VisionTool` > Usage"
      },
      "enhanced_content": "Context: Changelog > `VisionTool` > Usage\n\nfrom crewai_tools import VisionTool\n\nvision_tool = VisionTool()\n\n@agent\ndef researcher(self) -> Agent:\n    '''\n    This agent uses the VisionTool to extract text from images.\n    '''\n    return Agent(\n        config=self.agents_config[\"researcher\"],\n        allow_delegation=False,\n        tools=[vision_tool]\n    )",
      "formatted_path": "Changelog > `VisionTool` > Usage",
      "enhanced_text": "Context: Changelog > `VisionTool` > Usage\n\nfrom crewai_tools import VisionTool\n\nvision_tool = VisionTool()\n\n@agent\ndef researcher(self) -> Agent:\n    '''\n    This agent uses the VisionTool to extract text from images.\n    '''\n    return Agent(\n        config=self.agents_config[\"researcher\"],\n        allow_delegation=False,\n        tools=[vision_tool]\n    )"
    },
    {
      "content": "Source: https://docs.crewai.com/tools/weaviatevectorsearchtool The `WeaviateVectorSearchTool` is designed to search a Weaviate vector database for semantically similar documents.",
      "title": "Weaviate Vector Search",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Weaviate Vector Search",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Weaviate Vector Search",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Weaviate Vector Search"
      },
      "enhanced_content": "Context: Changelog > Weaviate Vector Search\n\n# Weaviate Vector Search\n\nSource: https://docs.crewai.com/tools/weaviatevectorsearchtool The `WeaviateVectorSearchTool` is designed to search a Weaviate vector database for semantically similar documents.",
      "formatted_path": "Changelog > Weaviate Vector Search",
      "enhanced_text": "Context: Changelog > Weaviate Vector Search\n\n Weaviate Vector Search\n\nSource: https://docs.crewai.com/tools/weaviatevectorsearchtool The `WeaviateVectorSearchTool` is designed to search a Weaviate vector database for semantically similar documents."
    },
    {
      "content": "To effectively use the LlamaIndexTool, follow these steps:\n\nTo effectively use the `AIMindTool`, follow these steps: **Package Installation**: Confirm that the `crewai[tools]` and `minds-sdk` packages are installed in your Python environment. **API Key Acquisition**: Sign up for a Minds account [here](https://mdb.ai/register), and obtain an API key. **Environment Configuration**: Store your obtained API key in an environment variable named `MINDS_API_KEY` to facilitate its use by the tool.\n\nTo effectively use the `BraveSearchTool`, follow these steps: **Package Installation**: Confirm that the `crewai[tools]` package is installed in your Python environment. **API Key Acquisition**: Acquire a Brave Search API key by registering at [Brave Search API](https://api.search.brave.com/app/keys). **Environment Configuration**: Store your obtained API key in an environment variable named `BRAVE_API_KEY` to facilitate its use by the tool.\n\nTo effectively use the EXASearchTool, follow these steps:",
      "title": "Steps to Get Started",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`WeaviateVectorSearchTool`",
          "level": 1
        },
        {
          "title": "Steps to Get Started",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`WeaviateVectorSearchTool`",
            "level": 1
          },
          {
            "title": "Steps to Get Started",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 2,
        "formatted_path": "Changelog > `WeaviateVectorSearchTool` > Steps to Get Started"
      },
      "enhanced_content": "Context: Changelog > `WeaviateVectorSearchTool` > Steps to Get Started\n\n## Steps to Get Started\n\nTo effectively use the LlamaIndexTool, follow these steps:\n\nTo effectively use the `AIMindTool`, follow these steps: **Package Installation**: Confirm that the `crewai[tools]` and `minds-sdk` packages are installed in your Python environment. **API Key Acquisition**: Sign up for a Minds account [here](https://mdb.ai/register), and obtain an API key. **Environment Configuration**: Store your obtained API key in an environment variable named `MINDS_API_KEY` to facilitate its use by the tool.\n\nTo effectively use the `BraveSearchTool`, follow these steps: **Package Installation**: Confirm that the `crewai[tools]` package is installed in your Python environment. **API Key Acquisition**: Acquire a Brave Search API key by registering at [Brave Search API](https://api.search.brave.com/app/keys). **Environment Configuration**: Store your obtained API key in an environment variable named `BRAVE_API_KEY` to facilitate its use by the tool.\n\nTo effectively use the EXASearchTool, follow these steps:",
      "formatted_path": "Changelog > `WeaviateVectorSearchTool` > Steps to Get Started",
      "enhanced_text": "Context: Changelog > `WeaviateVectorSearchTool` > Steps to Get Started\n\n Steps to Get Started\n\nTo effectively use the LlamaIndexTool, follow these steps:\n\nTo effectively use the `AIMindTool`, follow these steps: **Package Installation**: Confirm that the `crewai[tools]` and `minds-sdk` packages are installed in your Python environment. **API Key Acquisition**: Sign up for a Minds account [here](https://mdb.ai/register), and obtain an API key. **Environment Configuration**: Store your obtained API key in an environment variable named `MINDS_API_KEY` to facilitate its use by the tool.\n\nTo effectively use the `BraveSearchTool`, follow these steps: **Package Installation**: Confirm that the `crewai[tools]` package is installed in your Python environment. **API Key Acquisition**: Acquire a Brave Search API key by registering at [Brave Search API](https://api.search.brave.com/app/keys). **Environment Configuration**: Store your obtained API key in an environment variable named `BRAVE_API_KEY` to facilitate its use by the tool.\n\nTo effectively use the EXASearchTool, follow these steps:\n\nRelated sections:\n- \n"
    },
    {
      "content": "To effectively use the `HyperbrowserLoadTool`, follow these steps: **Sign Up**: Head to [Hyperbrowser](https://app.hyperbrowser.ai/) to sign up and generate an API key. **API Key**: Set the `HYPERBROWSER_API_KEY` environment variable or pass it directly to the tool constructor. **Install SDK**: Install the Hyperbrowser SDK using the command above.\n\nTo effectively use the `LinkupSearchTool`, follow these steps: **API Key**: Obtain a Linkup API key. **Environment Setup**: Set up your environment with the API key. **Install SDK**: Install the Linkup SDK using the command above.\n\nTo effectively use the `LlamaIndexTool`, follow these steps: **Install LlamaIndex**: Install the LlamaIndex package using the command above. **Set Up LlamaIndex**: Follow the [LlamaIndex documentation](https://docs.llamaindex.ai/) to set up a RAG/agent pipeline. **Create a Tool or Query Engine**: Create a LlamaIndex tool or query engine that you want to use with CrewAI.",
      "title": "Steps to Get Started",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`WeaviateVectorSearchTool`",
          "level": 1
        },
        {
          "title": "Steps to Get Started",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`WeaviateVectorSearchTool`",
            "level": 1
          },
          {
            "title": "Steps to Get Started",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 2,
        "formatted_path": "Changelog > `WeaviateVectorSearchTool` > Steps to Get Started"
      },
      "enhanced_content": "Context: Changelog > `WeaviateVectorSearchTool` > Steps to Get Started\n\n## Steps to Get Started\n\nTo effectively use the `HyperbrowserLoadTool`, follow these steps: **Sign Up**: Head to [Hyperbrowser](https://app.hyperbrowser.ai/) to sign up and generate an API key. **API Key**: Set the `HYPERBROWSER_API_KEY` environment variable or pass it directly to the tool constructor. **Install SDK**: Install the Hyperbrowser SDK using the command above.\n\nTo effectively use the `LinkupSearchTool`, follow these steps: **API Key**: Obtain a Linkup API key. **Environment Setup**: Set up your environment with the API key. **Install SDK**: Install the Linkup SDK using the command above.\n\nTo effectively use the `LlamaIndexTool`, follow these steps: **Install LlamaIndex**: Install the LlamaIndex package using the command above. **Set Up LlamaIndex**: Follow the [LlamaIndex documentation](https://docs.llamaindex.ai/) to set up a RAG/agent pipeline. **Create a Tool or Query Engine**: Create a LlamaIndex tool or query engine that you want to use with CrewAI.",
      "formatted_path": "Changelog > `WeaviateVectorSearchTool` > Steps to Get Started",
      "enhanced_text": "Context: Changelog > `WeaviateVectorSearchTool` > Steps to Get Started\n\n Steps to Get Started\n\nTo effectively use the `HyperbrowserLoadTool`, follow these steps: **Sign Up**: Head to [Hyperbrowser](https://app.hyperbrowser.ai/) to sign up and generate an API key. **API Key**: Set the `HYPERBROWSER_API_KEY` environment variable or pass it directly to the tool constructor. **Install SDK**: Install the Hyperbrowser SDK using the command above.\n\nTo effectively use the `LinkupSearchTool`, follow these steps: **API Key**: Obtain a Linkup API key. **Environment Setup**: Set up your environment with the API key. **Install SDK**: Install the Linkup SDK using the command above.\n\nTo effectively use the `LlamaIndexTool`, follow these steps: **Install LlamaIndex**: Install the LlamaIndex package using the command above. **Set Up LlamaIndex**: Follow the [LlamaIndex documentation](https://docs.llamaindex.ai/) to set up a RAG/agent pipeline. **Create a Tool or Query Engine**: Create a LlamaIndex tool or query engine that you want to use with CrewAI.\n\nRelated sections:\n- \n"
    },
    {
      "content": "To effectively use the `MultiOnTool`, follow these steps: **Install CrewAI**: Ensure that the `crewai[tools]` package is installed in your Python environment. **Install and use MultiOn**: Follow [MultiOn documentation](https://docs.multion.ai/learn/browser-extension) for installing the MultiOn Browser Extension. **Enable API Usage**: Click on the MultiOn extension in the extensions folder of your browser (not the hovering MultiOn icon on the web page) to open the extension configurations. Click the API Enabled toggle to enable the API.\n\nTo effectively use the Patronus evaluation tools, follow these steps: **Install Patronus**: Install the Patronus package using the command above. **Set Up API Key**: Set your Patronus API key as an environment variable. **Choose the Right Tool**: Select the appropriate Patronus evaluation tool based on your needs. **Configure the Tool**: Configure the tool with the necessary parameters.",
      "title": "Steps to Get Started",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`WeaviateVectorSearchTool`",
          "level": 1
        },
        {
          "title": "Steps to Get Started",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`WeaviateVectorSearchTool`",
            "level": 1
          },
          {
            "title": "Steps to Get Started",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 1,
        "formatted_path": "Changelog > `WeaviateVectorSearchTool` > Steps to Get Started"
      },
      "enhanced_content": "Context: Changelog > `WeaviateVectorSearchTool` > Steps to Get Started\n\n## Steps to Get Started\n\nTo effectively use the `MultiOnTool`, follow these steps: **Install CrewAI**: Ensure that the `crewai[tools]` package is installed in your Python environment. **Install and use MultiOn**: Follow [MultiOn documentation](https://docs.multion.ai/learn/browser-extension) for installing the MultiOn Browser Extension. **Enable API Usage**: Click on the MultiOn extension in the extensions folder of your browser (not the hovering MultiOn icon on the web page) to open the extension configurations. Click the API Enabled toggle to enable the API.\n\nTo effectively use the Patronus evaluation tools, follow these steps: **Install Patronus**: Install the Patronus package using the command above. **Set Up API Key**: Set your Patronus API key as an environment variable. **Choose the Right Tool**: Select the appropriate Patronus evaluation tool based on your needs. **Configure the Tool**: Configure the tool with the necessary parameters.",
      "formatted_path": "Changelog > `WeaviateVectorSearchTool` > Steps to Get Started",
      "enhanced_text": "Context: Changelog > `WeaviateVectorSearchTool` > Steps to Get Started\n\n Steps to Get Started\n\nTo effectively use the `MultiOnTool`, follow these steps: **Install CrewAI**: Ensure that the `crewai[tools]` package is installed in your Python environment. **Install and use MultiOn**: Follow [MultiOn documentation](https://docs.multion.ai/learn/browser-extension) for installing the MultiOn Browser Extension. **Enable API Usage**: Click on the MultiOn extension in the extensions folder of your browser (not the hovering MultiOn icon on the web page) to open the extension configurations. Click the API Enabled toggle to enable the API.\n\nTo effectively use the Patronus evaluation tools, follow these steps: **Install Patronus**: Install the Patronus package using the command above. **Set Up API Key**: Set your Patronus API key as an environment variable. **Choose the Right Tool**: Select the appropriate Patronus evaluation tool based on your needs. **Configure the Tool**: Configure the tool with the necessary parameters.\n\nRelated sections:\n- \n"
    },
    {
      "content": "To effectively use the `S3ReaderTool`, follow these steps: **Install Dependencies**: Install the required packages using the command above. **Configure AWS Credentials**: Set up your AWS credentials as environment variables. **Initialize the Tool**: Create an instance of the tool. **Specify S3 Path**: Provide the S3 path to the file you want to read.\n\nTo effectively use the `S3WriterTool`, follow these steps: **Install Dependencies**: Install the required packages using the command above. **Configure AWS Credentials**: Set up your AWS credentials as environment variables. **Initialize the Tool**: Create an instance of the tool. **Specify S3 Path and Content**: Provide the S3 path where you want to write the file and the content to be written.",
      "title": "Steps to Get Started",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`WeaviateVectorSearchTool`",
          "level": 1
        },
        {
          "title": "Steps to Get Started",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`WeaviateVectorSearchTool`",
            "level": 1
          },
          {
            "title": "Steps to Get Started",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `WeaviateVectorSearchTool` > Steps to Get Started"
      },
      "enhanced_content": "Context: Changelog > `WeaviateVectorSearchTool` > Steps to Get Started\n\n## Steps to Get Started\n\nTo effectively use the `S3ReaderTool`, follow these steps: **Install Dependencies**: Install the required packages using the command above. **Configure AWS Credentials**: Set up your AWS credentials as environment variables. **Initialize the Tool**: Create an instance of the tool. **Specify S3 Path**: Provide the S3 path to the file you want to read.\n\nTo effectively use the `S3WriterTool`, follow these steps: **Install Dependencies**: Install the required packages using the command above. **Configure AWS Credentials**: Set up your AWS credentials as environment variables. **Initialize the Tool**: Create an instance of the tool. **Specify S3 Path and Content**: Provide the S3 path where you want to write the file and the content to be written.",
      "formatted_path": "Changelog > `WeaviateVectorSearchTool` > Steps to Get Started",
      "enhanced_text": "Context: Changelog > `WeaviateVectorSearchTool` > Steps to Get Started\n\n Steps to Get Started\n\nTo effectively use the `S3ReaderTool`, follow these steps: **Install Dependencies**: Install the required packages using the command above. **Configure AWS Credentials**: Set up your AWS credentials as environment variables. **Initialize the Tool**: Create an instance of the tool. **Specify S3 Path**: Provide the S3 path to the file you want to read.\n\nTo effectively use the `S3WriterTool`, follow these steps: **Install Dependencies**: Install the required packages using the command above. **Configure AWS Credentials**: Set up your AWS credentials as environment variables. **Initialize the Tool**: Create an instance of the tool. **Specify S3 Path and Content**: Provide the S3 path where you want to write the file and the content to be written.\n\nRelated sections:\n- \n"
    },
    {
      "content": "To effectively use the `ScrapeElementFromWebsiteTool`, follow these steps: **Install Dependencies**: Install the required packages using the command above. **Identify CSS Selectors**: Determine the CSS selectors for the elements you want to extract from the website. **Initialize the Tool**: Create an instance of the tool with the necessary parameters.\n\nTo effectively use the `ScrapegraphScrapeTool`, follow these steps: **Install Dependencies**: Install the required package using the command above. **Set Up API Key**: Set your Scrapegraph API key as an environment variable or provide it during initialization. **Initialize the Tool**: Create an instance of the tool with the necessary parameters. **Define Extraction Prompts**: Create natural language prompts to guide the extraction of specific content.",
      "title": "Steps to Get Started",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`WeaviateVectorSearchTool`",
          "level": 1
        },
        {
          "title": "Steps to Get Started",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`WeaviateVectorSearchTool`",
            "level": 1
          },
          {
            "title": "Steps to Get Started",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `WeaviateVectorSearchTool` > Steps to Get Started"
      },
      "enhanced_content": "Context: Changelog > `WeaviateVectorSearchTool` > Steps to Get Started\n\n## Steps to Get Started\n\nTo effectively use the `ScrapeElementFromWebsiteTool`, follow these steps: **Install Dependencies**: Install the required packages using the command above. **Identify CSS Selectors**: Determine the CSS selectors for the elements you want to extract from the website. **Initialize the Tool**: Create an instance of the tool with the necessary parameters.\n\nTo effectively use the `ScrapegraphScrapeTool`, follow these steps: **Install Dependencies**: Install the required package using the command above. **Set Up API Key**: Set your Scrapegraph API key as an environment variable or provide it during initialization. **Initialize the Tool**: Create an instance of the tool with the necessary parameters. **Define Extraction Prompts**: Create natural language prompts to guide the extraction of specific content.",
      "formatted_path": "Changelog > `WeaviateVectorSearchTool` > Steps to Get Started",
      "enhanced_text": "Context: Changelog > `WeaviateVectorSearchTool` > Steps to Get Started\n\n Steps to Get Started\n\nTo effectively use the `ScrapeElementFromWebsiteTool`, follow these steps: **Install Dependencies**: Install the required packages using the command above. **Identify CSS Selectors**: Determine the CSS selectors for the elements you want to extract from the website. **Initialize the Tool**: Create an instance of the tool with the necessary parameters.\n\nTo effectively use the `ScrapegraphScrapeTool`, follow these steps: **Install Dependencies**: Install the required package using the command above. **Set Up API Key**: Set your Scrapegraph API key as an environment variable or provide it during initialization. **Initialize the Tool**: Create an instance of the tool with the necessary parameters. **Define Extraction Prompts**: Create natural language prompts to guide the extraction of specific content.\n\nRelated sections:\n- \n"
    },
    {
      "content": "To effectively use the `ScrapflyScrapeWebsiteTool`, follow these steps: **Install Dependencies**: Install the Scrapfly SDK using the command above. **Obtain API Key**: Register at Scrapfly to get your API key. **Initialize the Tool**: Create an instance of the tool with your API key. **Configure Scraping Parameters**: Customize the scraping parameters based on your needs.\n\nTo effectively use the `SerperDevTool`, follow these steps: **Package Installation**: Confirm that the `crewai[tools]` package is installed in your Python environment. **API Key Acquisition**: Acquire a `serper.dev` API key by registering for a free account at `serper.dev`. **Environment Configuration**: Store your obtained API key in an environment variable named `SERPER_API_KEY` to facilitate its use by the tool.",
      "title": "Steps to Get Started",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`WeaviateVectorSearchTool`",
          "level": 1
        },
        {
          "title": "Steps to Get Started",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`WeaviateVectorSearchTool`",
            "level": 1
          },
          {
            "title": "Steps to Get Started",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `WeaviateVectorSearchTool` > Steps to Get Started"
      },
      "enhanced_content": "Context: Changelog > `WeaviateVectorSearchTool` > Steps to Get Started\n\n## Steps to Get Started\n\nTo effectively use the `ScrapflyScrapeWebsiteTool`, follow these steps: **Install Dependencies**: Install the Scrapfly SDK using the command above. **Obtain API Key**: Register at Scrapfly to get your API key. **Initialize the Tool**: Create an instance of the tool with your API key. **Configure Scraping Parameters**: Customize the scraping parameters based on your needs.\n\nTo effectively use the `SerperDevTool`, follow these steps: **Package Installation**: Confirm that the `crewai[tools]` package is installed in your Python environment. **API Key Acquisition**: Acquire a `serper.dev` API key by registering for a free account at `serper.dev`. **Environment Configuration**: Store your obtained API key in an environment variable named `SERPER_API_KEY` to facilitate its use by the tool.",
      "formatted_path": "Changelog > `WeaviateVectorSearchTool` > Steps to Get Started",
      "enhanced_text": "Context: Changelog > `WeaviateVectorSearchTool` > Steps to Get Started\n\n Steps to Get Started\n\nTo effectively use the `ScrapflyScrapeWebsiteTool`, follow these steps: **Install Dependencies**: Install the Scrapfly SDK using the command above. **Obtain API Key**: Register at Scrapfly to get your API key. **Initialize the Tool**: Create an instance of the tool with your API key. **Configure Scraping Parameters**: Customize the scraping parameters based on your needs.\n\nTo effectively use the `SerperDevTool`, follow these steps: **Package Installation**: Confirm that the `crewai[tools]` package is installed in your Python environment. **API Key Acquisition**: Acquire a `serper.dev` API key by registering for a free account at `serper.dev`. **Environment Configuration**: Store your obtained API key in an environment variable named `SERPER_API_KEY` to facilitate its use by the tool.\n\nRelated sections:\n- \n"
    },
    {
      "content": "To effectively use the `SnowflakeSearchTool`, follow these steps: **Install Dependencies**: Install the required packages using one of the commands above. **Configure Snowflake Connection**: Create a `SnowflakeConfig` object with your Snowflake credentials. **Initialize the Tool**: Create an instance of the tool with the necessary configuration. **Execute Queries**: Use the tool to run SQL queries against your Snowflake database.\n\nTo effectively use the `WeaviateVectorSearchTool`, follow these steps: **Package Installation**: Confirm that the `crewai[tools]` and `weaviate-client` packages are installed in your Python environment. **Weaviate Setup**: Set up a Weaviate cluster. You can follow the [Weaviate documentation](https://weaviate.io/developers/wcs/connect) for instructions. **API Keys**: Obtain your Weaviate cluster URL and API key. **OpenAI API Key**: Ensure you have an OpenAI API key set in your environment variables as `OPENAI_API_KEY`.",
      "title": "Steps to Get Started",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`WeaviateVectorSearchTool`",
          "level": 1
        },
        {
          "title": "Steps to Get Started",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`WeaviateVectorSearchTool`",
            "level": 1
          },
          {
            "title": "Steps to Get Started",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 1,
        "formatted_path": "Changelog > `WeaviateVectorSearchTool` > Steps to Get Started"
      },
      "enhanced_content": "Context: Changelog > `WeaviateVectorSearchTool` > Steps to Get Started\n\n## Steps to Get Started\n\nTo effectively use the `SnowflakeSearchTool`, follow these steps: **Install Dependencies**: Install the required packages using one of the commands above. **Configure Snowflake Connection**: Create a `SnowflakeConfig` object with your Snowflake credentials. **Initialize the Tool**: Create an instance of the tool with the necessary configuration. **Execute Queries**: Use the tool to run SQL queries against your Snowflake database.\n\nTo effectively use the `WeaviateVectorSearchTool`, follow these steps: **Package Installation**: Confirm that the `crewai[tools]` and `weaviate-client` packages are installed in your Python environment. **Weaviate Setup**: Set up a Weaviate cluster. You can follow the [Weaviate documentation](https://weaviate.io/developers/wcs/connect) for instructions. **API Keys**: Obtain your Weaviate cluster URL and API key. **OpenAI API Key**: Ensure you have an OpenAI API key set in your environment variables as `OPENAI_API_KEY`.",
      "formatted_path": "Changelog > `WeaviateVectorSearchTool` > Steps to Get Started",
      "enhanced_text": "Context: Changelog > `WeaviateVectorSearchTool` > Steps to Get Started\n\n Steps to Get Started\n\nTo effectively use the `SnowflakeSearchTool`, follow these steps: **Install Dependencies**: Install the required packages using one of the commands above. **Configure Snowflake Connection**: Create a `SnowflakeConfig` object with your Snowflake credentials. **Initialize the Tool**: Create an instance of the tool with the necessary configuration. **Execute Queries**: Use the tool to run SQL queries against your Snowflake database.\n\nTo effectively use the `WeaviateVectorSearchTool`, follow these steps: **Package Installation**: Confirm that the `crewai[tools]` and `weaviate-client` packages are installed in your Python environment. **Weaviate Setup**: Set up a Weaviate cluster. You can follow the [Weaviate documentation](https://weaviate.io/developers/wcs/connect) for instructions. **API Keys**: Obtain your Weaviate cluster URL and API key. **OpenAI API Key**: Ensure you have an OpenAI API key set in your environment variables as `OPENAI_API_KEY`.\n\nRelated sections:\n- \n"
    },
    {
      "content": "from crewai_tools import RagTool\n\n# Create a RAG tool with custom configuration\nconfig = {\n    \"app\": {\n        \"name\": \"custom_app\",\n    },\n    \"llm\": {\n        \"provider\": \"openai\",\n        \"config\": {\n            \"model\": \"gpt-4\",\n        }\n    },\n    \"embedding_model\": {\n        \"provider\": \"openai\",\n        \"config\": {\n            \"model\": \"text-embedding-ada-002\"\n        }\n    }\n}\n\nrag_tool = RagTool(config=config, summarize=True)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`WeaviateVectorSearchTool`",
          "level": 1
        },
        {
          "title": "Advanced Configuration",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`WeaviateVectorSearchTool`",
            "level": 1
          },
          {
            "title": "Advanced Configuration",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `WeaviateVectorSearchTool` > Advanced Configuration"
      },
      "enhanced_content": "Context: Changelog > `WeaviateVectorSearchTool` > Advanced Configuration\n\nfrom crewai_tools import RagTool\n\n# Create a RAG tool with custom configuration\nconfig = {\n    \"app\": {\n        \"name\": \"custom_app\",\n    },\n    \"llm\": {\n        \"provider\": \"openai\",\n        \"config\": {\n            \"model\": \"gpt-4\",\n        }\n    },\n    \"embedding_model\": {\n        \"provider\": \"openai\",\n        \"config\": {\n            \"model\": \"text-embedding-ada-002\"\n        }\n    }\n}\n\nrag_tool = RagTool(config=config, summarize=True)",
      "formatted_path": "Changelog > `WeaviateVectorSearchTool` > Advanced Configuration",
      "enhanced_text": "Context: Changelog > `WeaviateVectorSearchTool` > Advanced Configuration\n\nfrom crewai_tools import RagTool\n\n# Create a RAG tool with custom configuration\nconfig = {\n    \"app\": {\n        \"name\": \"custom_app\",\n    },\n    \"llm\": {\n        \"provider\": \"openai\",\n        \"config\": {\n            \"model\": \"gpt-4\",\n        }\n    },\n    \"embedding_model\": {\n        \"provider\": \"openai\",\n        \"config\": {\n            \"model\": \"text-embedding-ada-002\"\n        }\n    }\n}\n\nrag_tool = RagTool(config=config, summarize=True)"
    },
    {
      "content": "from crewai_tools import WeaviateVectorSearchTool\nfrom weaviate.classes.config import Configure\n\n# Setup custom model for vectorizer and generative model\ntool = WeaviateVectorSearchTool(\n    collection_name='example_collections',\n    limit=3,\n    vectorizer=Configure.Vectorizer.text2vec_openai(model=\"nomic-embed-text\"),\n    generative_model=Configure.Generative.openai(model=\"gpt-4o-mini\"),\n    weaviate_cluster_url=\"https://your-weaviate-cluster-url.com\",\n    weaviate_api_key=\"your-weaviate-api-key\",\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`WeaviateVectorSearchTool`",
          "level": 1
        },
        {
          "title": "Advanced Configuration",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`WeaviateVectorSearchTool`",
            "level": 1
          },
          {
            "title": "Advanced Configuration",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `WeaviateVectorSearchTool` > Advanced Configuration"
      },
      "enhanced_content": "Context: Changelog > `WeaviateVectorSearchTool` > Advanced Configuration\n\nfrom crewai_tools import WeaviateVectorSearchTool\nfrom weaviate.classes.config import Configure\n\n# Setup custom model for vectorizer and generative model\ntool = WeaviateVectorSearchTool(\n    collection_name='example_collections',\n    limit=3,\n    vectorizer=Configure.Vectorizer.text2vec_openai(model=\"nomic-embed-text\"),\n    generative_model=Configure.Generative.openai(model=\"gpt-4o-mini\"),\n    weaviate_cluster_url=\"https://your-weaviate-cluster-url.com\",\n    weaviate_api_key=\"your-weaviate-api-key\",\n)",
      "formatted_path": "Changelog > `WeaviateVectorSearchTool` > Advanced Configuration",
      "enhanced_text": "Context: Changelog > `WeaviateVectorSearchTool` > Advanced Configuration\n\nfrom crewai_tools import WeaviateVectorSearchTool\nfrom weaviate.classes.config import Configure\n\n# Setup custom model for vectorizer and generative model\ntool = WeaviateVectorSearchTool(\n    collection_name='example_collections',\n    limit=3,\n    vectorizer=Configure.Vectorizer.text2vec_openai(model=\"nomic-embed-text\"),\n    generative_model=Configure.Generative.openai(model=\"gpt-4o-mini\"),\n    weaviate_cluster_url=\"https://your-weaviate-cluster-url.com\",\n    weaviate_api_key=\"your-weaviate-api-key\",\n)"
    },
    {
      "content": "import os\nfrom crewai_tools import WeaviateVectorSearchTool\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Connect to Weaviate\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=\"https://your-weaviate-cluster-url.com\",\n    auth_credentials=Auth.api_key(\"your-weaviate-api-key\"),\n    headers={\"X-OpenAI-Api-Key\": \"your-openai-api-key\"}\n)\n\n# Get or create collection\ntest_docs = client.collections.get(\"example_collections\")\nif not test_docs:\n    test_docs = client.collections.create(\n        name=\"example_collections\",\n        vectorizer_config=Configure.Vectorizer.text2vec_openai(model=\"nomic-embed-text\"),\n        generative_config=Configure.Generative.openai(model=\"gpt-4o\"),\n    )\n\n# Load documents\ndocs_to_load = os.listdir(\"knowledge\")\nwith test_docs.batch.dynamic() as batch:\n    for d in docs_to_load:\n        with open(os.path.join(\"knowledge\", d), \"r\") as f:\n            content = f.read()\n        batch.add_object(\n            {\n                \"content\": content,\n                \"year\": d.split(\"_\")[0],\n            }\n        )\n\n# Initialize the tool\ntool = WeaviateVectorSearchTool(\n    collection_name='example_collections', \n    limit=3,\n    weaviate_cluster_url=\"https://your-weaviate-cluster-url.com\",\n    weaviate_api_key=\"your-weaviate-api-key\",\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`WeaviateVectorSearchTool`",
          "level": 1
        },
        {
          "title": "Preloading Documents",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`WeaviateVectorSearchTool`",
            "level": 1
          },
          {
            "title": "Preloading Documents",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `WeaviateVectorSearchTool` > Preloading Documents"
      },
      "enhanced_content": "Context: Changelog > `WeaviateVectorSearchTool` > Preloading Documents\n\nimport os\nfrom crewai_tools import WeaviateVectorSearchTool\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Connect to Weaviate\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=\"https://your-weaviate-cluster-url.com\",\n    auth_credentials=Auth.api_key(\"your-weaviate-api-key\"),\n    headers={\"X-OpenAI-Api-Key\": \"your-openai-api-key\"}\n)\n\n# Get or create collection\ntest_docs = client.collections.get(\"example_collections\")\nif not test_docs:\n    test_docs = client.collections.create(\n        name=\"example_collections\",\n        vectorizer_config=Configure.Vectorizer.text2vec_openai(model=\"nomic-embed-text\"),\n        generative_config=Configure.Generative.openai(model=\"gpt-4o\"),\n    )\n\n# Load documents\ndocs_to_load = os.listdir(\"knowledge\")\nwith test_docs.batch.dynamic() as batch:\n    for d in docs_to_load:\n        with open(os.path.join(\"knowledge\", d), \"r\") as f:\n            content = f.read()\n        batch.add_object(\n            {\n                \"content\": content,\n                \"year\": d.split(\"_\")[0],\n            }\n        )\n\n# Initialize the tool\ntool = WeaviateVectorSearchTool(\n    collection_name='example_collections', \n    limit=3,\n    weaviate_cluster_url=\"https://your-weaviate-cluster-url.com\",\n    weaviate_api_key=\"your-weaviate-api-key\",\n)",
      "formatted_path": "Changelog > `WeaviateVectorSearchTool` > Preloading Documents",
      "enhanced_text": "Context: Changelog > `WeaviateVectorSearchTool` > Preloading Documents\n\nimport os\nfrom crewai_tools import WeaviateVectorSearchTool\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Connect to Weaviate\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=\"https://your-weaviate-cluster-url.com\",\n    auth_credentials=Auth.api_key(\"your-weaviate-api-key\"),\n    headers={\"X-OpenAI-Api-Key\": \"your-openai-api-key\"}\n)\n\n# Get or create collection\ntest_docs = client.collections.get(\"example_collections\")\nif not test_docs:\n    test_docs = client.collections.create(\n        name=\"example_collections\",\n        vectorizer_config=Configure.Vectorizer.text2vec_openai(model=\"nomic-embed-text\"),\n        generative_config=Configure.Generative.openai(model=\"gpt-4o\"),\n    )\n\n# Load documents\ndocs_to_load = os.listdir(\"knowledge\")\nwith test_docs.batch.dynamic() as batch:\n    for d in docs_to_load:\n        with open(os.path.join(\"knowledge\", d), \"r\") as f:\n            content = f.read()\n        batch.add_object(\n            {\n                \"content\": content,\n                \"year\": d.split(\"_\")[0],\n            }\n        )\n\n# Initialize the tool\ntool = WeaviateVectorSearchTool(\n    collection_name='example_collections', \n    limit=3,\n    weaviate_cluster_url=\"https://your-weaviate-cluster-url.com\",\n    weaviate_api_key=\"your-weaviate-api-key\",\n)"
    },
    {
      "content": "Source: https://docs.crewai.com/tools/websitesearchtool The `WebsiteSearchTool` is designed to perform a RAG (Retrieval-Augmented Generation) search within the content of a website.",
      "title": "Website RAG Search",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "Website RAG Search",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "Website RAG Search",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > Website RAG Search"
      },
      "enhanced_content": "Context: Changelog > Website RAG Search\n\n# Website RAG Search\n\nSource: https://docs.crewai.com/tools/websitesearchtool The `WebsiteSearchTool` is designed to perform a RAG (Retrieval-Augmented Generation) search within the content of a website.",
      "formatted_path": "Changelog > Website RAG Search",
      "enhanced_text": "Context: Changelog > Website RAG Search\n\n Website RAG Search\n\nSource: https://docs.crewai.com/tools/websitesearchtool The `WebsiteSearchTool` is designed to perform a RAG (Retrieval-Augmented Generation) search within the content of a website."
    },
    {
      "content": "from crewai import Agent, Task, Crew\n\n# Create an agent with code execution enabled\ncoding_agent = Agent(\n    role=\"Python Data Analyst\",\n    goal=\"Analyze data and provide insights using Python\",\n    backstory=\"You are an experienced data analyst with strong Python skills.\",\n    allow_code_execution=True\n)\n\n# Create a task that requires code execution\ndata_analysis_task = Task(\n    description=\"Analyze the given dataset and calculate the average age of participants.\",\n    agent=coding_agent\n)\n\n# Create a crew and add the task\nanalysis_crew = Crew(\n    agents=[coding_agent],\n    tasks=[data_analysis_task]\n)\n\n# Execute the crew\nresult = analysis_crew.kickoff()\n\nprint(result)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`WebsiteSearchTool`",
          "level": 1
        },
        {
          "title": "Example Usage",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`WebsiteSearchTool`",
            "level": 1
          },
          {
            "title": "Example Usage",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `WebsiteSearchTool` > Example Usage"
      },
      "enhanced_content": "Context: Changelog > `WebsiteSearchTool` > Example Usage\n\nfrom crewai import Agent, Task, Crew\n\n# Create an agent with code execution enabled\ncoding_agent = Agent(\n    role=\"Python Data Analyst\",\n    goal=\"Analyze data and provide insights using Python\",\n    backstory=\"You are an experienced data analyst with strong Python skills.\",\n    allow_code_execution=True\n)\n\n# Create a task that requires code execution\ndata_analysis_task = Task(\n    description=\"Analyze the given dataset and calculate the average age of participants.\",\n    agent=coding_agent\n)\n\n# Create a crew and add the task\nanalysis_crew = Crew(\n    agents=[coding_agent],\n    tasks=[data_analysis_task]\n)\n\n# Execute the crew\nresult = analysis_crew.kickoff()\n\nprint(result)",
      "formatted_path": "Changelog > `WebsiteSearchTool` > Example Usage",
      "enhanced_text": "Context: Changelog > `WebsiteSearchTool` > Example Usage\n\nfrom crewai import Agent, Task, Crew\n\n# Create an agent with code execution enabled\ncoding_agent = Agent(\n    role=\"Python Data Analyst\",\n    goal=\"Analyze data and provide insights using Python\",\n    backstory=\"You are an experienced data analyst with strong Python skills.\",\n    allow_code_execution=True\n)\n\n# Create a task that requires code execution\ndata_analysis_task = Task(\n    description=\"Analyze the given dataset and calculate the average age of participants.\",\n    agent=coding_agent\n)\n\n# Create a crew and add the task\nanalysis_crew = Crew(\n    agents=[coding_agent],\n    tasks=[data_analysis_task]\n)\n\n# Execute the crew\nresult = analysis_crew.kickoff()\n\nprint(result)"
    },
    {
      "content": "from typing import List\nfrom pydantic import BaseModel\nfrom crewai import Agent, Crew\nfrom crewai.tasks.conditional_task import ConditionalTask\nfrom crewai.tasks.task_output import TaskOutput\nfrom crewai.task import Task\nfrom crewai_tools import SerperDevTool\n\n# Define a condition function for the conditional task\n# If false, the task will be skipped, if true, then execute the task.\ndef is_data_missing(output: TaskOutput) -> bool:\n    return len(output.pydantic.events) < 10  # this will skip this task\n\n# Define the agents\ndata_fetcher_agent = Agent(\n    role=\"Data Fetcher\",\n    goal=\"Fetch data online using Serper tool\",\n    backstory=\"Backstory 1\",\n    verbose=True,\n    tools=[SerperDevTool()]\n)\n\ndata_processor_agent = Agent(\n    role=\"Data Processor\",\n    goal=\"Process fetched data\",\n    backstory=\"Backstory 2\",\n    verbose=True\n)\n\nsummary_generator_agent = Agent(\n    role=\"Summary Generator\",\n    goal=\"Generate summary from fetched data\",\n    backstory=\"Backstory 3\",\n    verbose=True\n)\n\nclass EventOutput(BaseModel):\n    events: List[str]\n\ntask1 = Task(\n    description=\"Fetch data about events in San Francisco using Serper tool\",\n    expected_output=\"List of 10 things to do in SF this week\",\n    agent=data_fetcher_agent,\n    output_pydantic=EventOutput,\n)\n\nconditional_task = ConditionalTask(\n    description=\"\"\"\n        Check if data is missing. If we have less than 10 events,\n        fetch more events using Serper tool so that\n        we have a total of 10 events in SF this week..\n        \"\"\",\n    expected_output=\"List of 10 Things to do in SF this week\",\n    condition=is_data_missing,\n    agent=data_processor_agent,\n)\n\ntask3 = Task(\n    description=\"Generate summary of events in San Francisco from fetched data\",\n    expected_output=\"A complete report on the customer and their customers and competitors, including their demographics, preferences, market positioning and audience engagement.\",\n    agent=summary_generator_agent,\n)\n\n# Create a crew with the tasks\ncrew = Crew(\n    agents=[data_fetcher_agent, data_processor_agent, summary_generator_agent],\n    tasks=[task1, conditional_task, task3],\n    verbose=True,\n    planning=True\n)\n\n# Run the crew\nresult = crew.kickoff()\nprint(\"results\", result)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`WebsiteSearchTool`",
          "level": 1
        },
        {
          "title": "Example Usage",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`WebsiteSearchTool`",
            "level": 1
          },
          {
            "title": "Example Usage",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `WebsiteSearchTool` > Example Usage"
      },
      "enhanced_content": "Context: Changelog > `WebsiteSearchTool` > Example Usage\n\nfrom typing import List\nfrom pydantic import BaseModel\nfrom crewai import Agent, Crew\nfrom crewai.tasks.conditional_task import ConditionalTask\nfrom crewai.tasks.task_output import TaskOutput\nfrom crewai.task import Task\nfrom crewai_tools import SerperDevTool\n\n# Define a condition function for the conditional task\n# If false, the task will be skipped, if true, then execute the task.\ndef is_data_missing(output: TaskOutput) -> bool:\n    return len(output.pydantic.events) < 10  # this will skip this task\n\n# Define the agents\ndata_fetcher_agent = Agent(\n    role=\"Data Fetcher\",\n    goal=\"Fetch data online using Serper tool\",\n    backstory=\"Backstory 1\",\n    verbose=True,\n    tools=[SerperDevTool()]\n)\n\ndata_processor_agent = Agent(\n    role=\"Data Processor\",\n    goal=\"Process fetched data\",\n    backstory=\"Backstory 2\",\n    verbose=True\n)\n\nsummary_generator_agent = Agent(\n    role=\"Summary Generator\",\n    goal=\"Generate summary from fetched data\",\n    backstory=\"Backstory 3\",\n    verbose=True\n)\n\nclass EventOutput(BaseModel):\n    events: List[str]\n\ntask1 = Task(\n    description=\"Fetch data about events in San Francisco using Serper tool\",\n    expected_output=\"List of 10 things to do in SF this week\",\n    agent=data_fetcher_agent,\n    output_pydantic=EventOutput,\n)\n\nconditional_task = ConditionalTask(\n    description=\"\"\"\n        Check if data is missing. If we have less than 10 events,\n        fetch more events using Serper tool so that\n        we have a total of 10 events in SF this week..\n        \"\"\",\n    expected_output=\"List of 10 Things to do in SF this week\",\n    condition=is_data_missing,\n    agent=data_processor_agent,\n)\n\ntask3 = Task(\n    description=\"Generate summary of events in San Francisco from fetched data\",\n    expected_output=\"A complete report on the customer and their customers and competitors, including their demographics, preferences, market positioning and audience engagement.\",\n    agent=summary_generator_agent,\n)\n\n# Create a crew with the tasks\ncrew = Crew(\n    agents=[data_fetcher_agent, data_processor_agent, summary_generator_agent],\n    tasks=[task1, conditional_task, task3],\n    verbose=True,\n    planning=True\n)\n\n# Run the crew\nresult = crew.kickoff()\nprint(\"results\", result)",
      "formatted_path": "Changelog > `WebsiteSearchTool` > Example Usage",
      "enhanced_text": "Context: Changelog > `WebsiteSearchTool` > Example Usage\n\nfrom typing import List\nfrom pydantic import BaseModel\nfrom crewai import Agent, Crew\nfrom crewai.tasks.conditional_task import ConditionalTask\nfrom crewai.tasks.task_output import TaskOutput\nfrom crewai.task import Task\nfrom crewai_tools import SerperDevTool\n\n# Define a condition function for the conditional task\n# If false, the task will be skipped, if true, then execute the task.\ndef is_data_missing(output: TaskOutput) -> bool:\n    return len(output.pydantic.events) < 10  # this will skip this task\n\n# Define the agents\ndata_fetcher_agent = Agent(\n    role=\"Data Fetcher\",\n    goal=\"Fetch data online using Serper tool\",\n    backstory=\"Backstory 1\",\n    verbose=True,\n    tools=[SerperDevTool()]\n)\n\ndata_processor_agent = Agent(\n    role=\"Data Processor\",\n    goal=\"Process fetched data\",\n    backstory=\"Backstory 2\",\n    verbose=True\n)\n\nsummary_generator_agent = Agent(\n    role=\"Summary Generator\",\n    goal=\"Generate summary from fetched data\",\n    backstory=\"Backstory 3\",\n    verbose=True\n)\n\nclass EventOutput(BaseModel):\n    events: List[str]\n\ntask1 = Task(\n    description=\"Fetch data about events in San Francisco using Serper tool\",\n    expected_output=\"List of 10 things to do in SF this week\",\n    agent=data_fetcher_agent,\n    output_pydantic=EventOutput,\n)\n\nconditional_task = ConditionalTask(\n    description=\"\"\"\n        Check if data is missing. If we have less than 10 events,\n        fetch more events using Serper tool so that\n        we have a total of 10 events in SF this week..\n        \"\"\",\n    expected_output=\"List of 10 Things to do in SF this week\",\n    condition=is_data_missing,\n    agent=data_processor_agent,\n)\n\ntask3 = Task(\n    description=\"Generate summary of events in San Francisco from fetched data\",\n    expected_output=\"A complete report on the customer and their customers and competitors, including their demographics, preferences, market positioning and audience engagement.\",\n    agent=summary_generator_agent,\n)\n\n# Create a crew with the tasks\ncrew = Crew(\n    agents=[data_fetcher_agent, data_processor_agent, summary_generator_agent],\n    tasks=[task1, conditional_task, task3],\n    verbose=True,\n    planning=True\n)\n\n# Run the crew\nresult = crew.kickoff()\nprint(\"results\", result)"
    },
    {
      "content": "from crewai_tools import PGSearchTool\n\n# Initialize the tool with the database URI and the target table name\ntool = PGSearchTool(\n    db_uri='postgresql://user:password@localhost:5432/mydatabase', \n    table_name='employees'\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`WebsiteSearchTool`",
          "level": 1
        },
        {
          "title": "Example Usage",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`WebsiteSearchTool`",
            "level": 1
          },
          {
            "title": "Example Usage",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `WebsiteSearchTool` > Example Usage"
      },
      "enhanced_content": "Context: Changelog > `WebsiteSearchTool` > Example Usage\n\nfrom crewai_tools import PGSearchTool\n\n# Initialize the tool with the database URI and the target table name\ntool = PGSearchTool(\n    db_uri='postgresql://user:password@localhost:5432/mydatabase', \n    table_name='employees'\n)",
      "formatted_path": "Changelog > `WebsiteSearchTool` > Example Usage",
      "enhanced_text": "Context: Changelog > `WebsiteSearchTool` > Example Usage\n\nfrom crewai_tools import PGSearchTool\n\n# Initialize the tool with the database URI and the target table name\ntool = PGSearchTool(\n    db_uri='postgresql://user:password@localhost:5432/mydatabase', \n    table_name='employees'\n)"
    },
    {
      "content": "from crewai_tools import WebsiteSearchTool\n\n# Example of initiating tool that agents can use \n# to search across any discovered websites\ntool = WebsiteSearchTool()\n\n# Example of limiting the search to the content of a specific website, \n# so now agents can only search within that website\ntool = WebsiteSearchTool(website='https://example.com')",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`WebsiteSearchTool`",
          "level": 1
        },
        {
          "title": "Example Usage",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`WebsiteSearchTool`",
            "level": 1
          },
          {
            "title": "Example Usage",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `WebsiteSearchTool` > Example Usage"
      },
      "enhanced_content": "Context: Changelog > `WebsiteSearchTool` > Example Usage\n\nfrom crewai_tools import WebsiteSearchTool\n\n# Example of initiating tool that agents can use \n# to search across any discovered websites\ntool = WebsiteSearchTool()\n\n# Example of limiting the search to the content of a specific website, \n# so now agents can only search within that website\ntool = WebsiteSearchTool(website='https://example.com')",
      "formatted_path": "Changelog > `WebsiteSearchTool` > Example Usage",
      "enhanced_text": "Context: Changelog > `WebsiteSearchTool` > Example Usage\n\nfrom crewai_tools import WebsiteSearchTool\n\n# Example of initiating tool that agents can use \n# to search across any discovered websites\ntool = WebsiteSearchTool()\n\n# Example of limiting the search to the content of a specific website, \n# so now agents can only search within that website\ntool = WebsiteSearchTool(website='https://example.com')"
    },
    {
      "content": "tool = WebsiteSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`WebsiteSearchTool`",
          "level": 1
        },
        {
          "title": "Customization Options",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`WebsiteSearchTool`",
            "level": 1
          },
          {
            "title": "Customization Options",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `WebsiteSearchTool` > Customization Options"
      },
      "enhanced_content": "Context: Changelog > `WebsiteSearchTool` > Customization Options\n\ntool = WebsiteSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)",
      "formatted_path": "Changelog > `WebsiteSearchTool` > Customization Options",
      "enhanced_text": "Context: Changelog > `WebsiteSearchTool` > Customization Options\n\ntool = WebsiteSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)"
    },
    {
      "content": "Source: https://docs.crewai.com/tools/xmlsearchtool The `XMLSearchTool` is designed to perform a RAG (Retrieval-Augmented Generation) search within the content of a XML file.",
      "title": "XML RAG Search",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "XML RAG Search",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "XML RAG Search",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > XML RAG Search"
      },
      "enhanced_content": "Context: Changelog > XML RAG Search\n\n# XML RAG Search\n\nSource: https://docs.crewai.com/tools/xmlsearchtool The `XMLSearchTool` is designed to perform a RAG (Retrieval-Augmented Generation) search within the content of a XML file.",
      "formatted_path": "Changelog > XML RAG Search",
      "enhanced_text": "Context: Changelog > XML RAG Search\n\n XML RAG Search\n\nSource: https://docs.crewai.com/tools/xmlsearchtool The `XMLSearchTool` is designed to perform a RAG (Retrieval-Augmented Generation) search within the content of a XML file."
    },
    {
      "content": "The following parameters can be used to customize the `BrowserbaseLoadTool`'s behavior: | Argument          | Type     | Description                                                                           |\n| :---------------- | :------- | :------------------------------------------------------------------------------------ |\n| **api\\_key**      | `string` | *Optional*. Browserbase API key. Default is `BROWSERBASE_API_KEY` env variable.       |\n| **project\\_id**   | `string` | *Optional*. Browserbase Project ID. Default is `BROWSERBASE_PROJECT_ID` env variable. |\n| **text\\_content** | `bool`   | *Optional*. Retrieve only text content. Default is `False`.                           |\n| **session\\_id**   | `string` | *Optional*. Provide an existing Session ID.                                           |\n| **proxy**         | `bool`   | *Optional*. Enable/Disable Proxies. Default is `False`.                               |",
      "title": "Arguments",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`XMLSearchTool`",
          "level": 1
        },
        {
          "title": "Arguments",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`XMLSearchTool`",
            "level": 1
          },
          {
            "title": "Arguments",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `XMLSearchTool` > Arguments"
      },
      "enhanced_content": "Context: Changelog > `XMLSearchTool` > Arguments\n\n## Arguments\n\nThe following parameters can be used to customize the `BrowserbaseLoadTool`'s behavior: | Argument          | Type     | Description                                                                           |\n| :---------------- | :------- | :------------------------------------------------------------------------------------ |\n| **api\\_key**      | `string` | *Optional*. Browserbase API key. Default is `BROWSERBASE_API_KEY` env variable.       |\n| **project\\_id**   | `string` | *Optional*. Browserbase Project ID. Default is `BROWSERBASE_PROJECT_ID` env variable. |\n| **text\\_content** | `bool`   | *Optional*. Retrieve only text content. Default is `False`.                           |\n| **session\\_id**   | `string` | *Optional*. Provide an existing Session ID.                                           |\n| **proxy**         | `bool`   | *Optional*. Enable/Disable Proxies. Default is `False`.                               |",
      "formatted_path": "Changelog > `XMLSearchTool` > Arguments",
      "enhanced_text": "Context: Changelog > `XMLSearchTool` > Arguments\n\n Arguments\n\nThe following parameters can be used to customize the `BrowserbaseLoadTool`'s behavior: | Argument          | Type     | Description                                                                           |\n| :---------------- | :------- | :------------------------------------------------------------------------------------ |\n| **api\\_key**      | `string` | *Optional*. Browserbase API key. Default is `BROWSERBASE_API_KEY` env variable.       |\n| **project\\_id**   | `string` | *Optional*. Browserbase Project ID. Default is `BROWSERBASE_PROJECT_ID` env variable. |\n| **text\\_content** | `bool`   | *Optional*. Retrieve only text content. Default is `False`.                           |\n| **session\\_id**   | `string` | *Optional*. Provide an existing Session ID.                                           |\n| **proxy**         | `bool`   | *Optional*. Enable/Disable Proxies. Default is `False`.                               |\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "The following parameters can be used to customize the `CodeDocsSearchTool`'s behavior: | Argument      | Type     | Description                                                             |\n| :------------ | :------- | :---------------------------------------------------------------------- |\n| **docs\\_url** | `string` | *Optional*. Specifies the URL of the code documentation to be searched. |",
      "title": "Arguments",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`XMLSearchTool`",
          "level": 1
        },
        {
          "title": "Arguments",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`XMLSearchTool`",
            "level": 1
          },
          {
            "title": "Arguments",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `XMLSearchTool` > Arguments"
      },
      "enhanced_content": "Context: Changelog > `XMLSearchTool` > Arguments\n\n## Arguments\n\nThe following parameters can be used to customize the `CodeDocsSearchTool`'s behavior: | Argument      | Type     | Description                                                             |\n| :------------ | :------- | :---------------------------------------------------------------------- |\n| **docs\\_url** | `string` | *Optional*. Specifies the URL of the code documentation to be searched. |",
      "formatted_path": "Changelog > `XMLSearchTool` > Arguments",
      "enhanced_text": "Context: Changelog > `XMLSearchTool` > Arguments\n\n Arguments\n\nThe following parameters can be used to customize the `CodeDocsSearchTool`'s behavior: | Argument      | Type     | Description                                                             |\n| :------------ | :------- | :---------------------------------------------------------------------- |\n| **docs\\_url** | `string` | *Optional*. Specifies the URL of the code documentation to be searched. |\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "The following parameters can be used to customize the `CSVSearchTool`'s behavior: | Argument | Type     | Description                                                                                                                                                               |\n| :------- | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| **csv**  | `string` | *Optional*. The path to the CSV file you want to search. This is a mandatory argument if the tool was initialized without a specific CSV file; otherwise, it is optional. |",
      "title": "Arguments",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`XMLSearchTool`",
          "level": 1
        },
        {
          "title": "Arguments",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`XMLSearchTool`",
            "level": 1
          },
          {
            "title": "Arguments",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `XMLSearchTool` > Arguments"
      },
      "enhanced_content": "Context: Changelog > `XMLSearchTool` > Arguments\n\n## Arguments\n\nThe following parameters can be used to customize the `CSVSearchTool`'s behavior: | Argument | Type     | Description                                                                                                                                                               |\n| :------- | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| **csv**  | `string` | *Optional*. The path to the CSV file you want to search. This is a mandatory argument if the tool was initialized without a specific CSV file; otherwise, it is optional. |",
      "formatted_path": "Changelog > `XMLSearchTool` > Arguments",
      "enhanced_text": "Context: Changelog > `XMLSearchTool` > Arguments\n\n Arguments\n\nThe following parameters can be used to customize the `CSVSearchTool`'s behavior: | Argument | Type     | Description                                                                                                                                                               |\n| :------- | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| **csv**  | `string` | *Optional*. The path to the CSV file you want to search. This is a mandatory argument if the tool was initialized without a specific CSV file; otherwise, it is optional. |\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "The following parameters can be used to customize the `DirectoryReadTool`'s behavior: | Argument      | Type     | Description                                                                                                                                                                                                   |\n| :------------ | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| **directory** | `string` | *Optional*. An argument that specifies the path to the directory whose contents you wish to list. It accepts both absolute and relative paths, guiding the tool to the desired directory for content listing. |\n\n`directory`: A string argument that specifies the search directory. This is optional during initialization but required for searches if not set initially.",
      "title": "Arguments",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`XMLSearchTool`",
          "level": 1
        },
        {
          "title": "Arguments",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`XMLSearchTool`",
            "level": 1
          },
          {
            "title": "Arguments",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `XMLSearchTool` > Arguments"
      },
      "enhanced_content": "Context: Changelog > `XMLSearchTool` > Arguments\n\n## Arguments\n\nThe following parameters can be used to customize the `DirectoryReadTool`'s behavior: | Argument      | Type     | Description                                                                                                                                                                                                   |\n| :------------ | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| **directory** | `string` | *Optional*. An argument that specifies the path to the directory whose contents you wish to list. It accepts both absolute and relative paths, guiding the tool to the desired directory for content listing. |\n\n`directory`: A string argument that specifies the search directory. This is optional during initialization but required for searches if not set initially.",
      "formatted_path": "Changelog > `XMLSearchTool` > Arguments",
      "enhanced_text": "Context: Changelog > `XMLSearchTool` > Arguments\n\n Arguments\n\nThe following parameters can be used to customize the `DirectoryReadTool`'s behavior: | Argument      | Type     | Description                                                                                                                                                                                                   |\n| :------------ | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| **directory** | `string` | *Optional*. An argument that specifies the path to the directory whose contents you wish to list. It accepts both absolute and relative paths, guiding the tool to the desired directory for content listing. |\n\n`directory`: A string argument that specifies the search directory. This is optional during initialization but required for searches if not set initially.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "The following parameters can be used to customize the `DOCXSearchTool`'s behavior: | Argument | Type     | Description                                                                                                                                                                                                        |\n| :------- | :------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **docx** | `string` | *Optional*. An argument that specifies the path to the DOCX file you want to search. If not provided during initialization, the tool allows for later specification of any DOCX file's content path for searching. |\n\n`file_path`: The path to the file you want to read. It accepts both absolute and relative paths. Ensure the file exists and you have the necessary permissions to access it.",
      "title": "Arguments",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`XMLSearchTool`",
          "level": 1
        },
        {
          "title": "Arguments",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`XMLSearchTool`",
            "level": 1
          },
          {
            "title": "Arguments",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `XMLSearchTool` > Arguments"
      },
      "enhanced_content": "Context: Changelog > `XMLSearchTool` > Arguments\n\n## Arguments\n\nThe following parameters can be used to customize the `DOCXSearchTool`'s behavior: | Argument | Type     | Description                                                                                                                                                                                                        |\n| :------- | :------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **docx** | `string` | *Optional*. An argument that specifies the path to the DOCX file you want to search. If not provided during initialization, the tool allows for later specification of any DOCX file's content path for searching. |\n\n`file_path`: The path to the file you want to read. It accepts both absolute and relative paths. Ensure the file exists and you have the necessary permissions to access it.",
      "formatted_path": "Changelog > `XMLSearchTool` > Arguments",
      "enhanced_text": "Context: Changelog > `XMLSearchTool` > Arguments\n\n Arguments\n\nThe following parameters can be used to customize the `DOCXSearchTool`'s behavior: | Argument | Type     | Description                                                                                                                                                                                                        |\n| :------- | :------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **docx** | `string` | *Optional*. An argument that specifies the path to the DOCX file you want to search. If not provided during initialization, the tool allows for later specification of any DOCX file's content path for searching. |\n\n`file_path`: The path to the file you want to read. It accepts both absolute and relative paths. Ensure the file exists and you have the necessary permissions to access it.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "`filename`: The name of the file you want to create or overwrite. `content`: The content to write into the file. `directory` (optional): The path to the directory where the file will be created. Defaults to the current directory (`.`). If the directory does not exist, it will be created.",
      "title": "Arguments",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`XMLSearchTool`",
          "level": 1
        },
        {
          "title": "Arguments",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`XMLSearchTool`",
            "level": 1
          },
          {
            "title": "Arguments",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `XMLSearchTool` > Arguments"
      },
      "enhanced_content": "Context: Changelog > `XMLSearchTool` > Arguments\n\n## Arguments\n\n`filename`: The name of the file you want to create or overwrite. `content`: The content to write into the file. `directory` (optional): The path to the directory where the file will be created. Defaults to the current directory (`.`). If the directory does not exist, it will be created.",
      "formatted_path": "Changelog > `XMLSearchTool` > Arguments",
      "enhanced_text": "Context: Changelog > `XMLSearchTool` > Arguments\n\n Arguments\n\n`filename`: The name of the file you want to create or overwrite. `content`: The content to write into the file. `directory` (optional): The path to the directory where the file will be created. Defaults to the current directory (`.`). If the directory does not exist, it will be created.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "`api_key`: Optional. Specifies Firecrawl API key. Defaults is the `FIRECRAWL_API_KEY` environment variable. `url`: The base URL to start crawling from. `page_options`: Optional. `onlyMainContent`: Optional. Only return the main content of the page excluding headers, navs, footers, etc. `includeHtml`: Optional. Include the raw HTML content of the page. Will output a html key in the response. `crawler_options`: Optional. Options for controlling the crawling behavior. `includes`: Optional. URL patterns to include in the crawl. `exclude`: Optional. URL patterns to exclude from the crawl. `generateImgAltText`: Optional. Generate alt text for images using LLMs (requires a paid plan). `returnOnlyUrls`: Optional. If true, returns only the URLs as a list in the crawl status. Note: the response will be a list of URLs inside the data, not a list of documents. `maxDepth`: Optional. Maximum depth to crawl. Depth 1 is the base URL, depth 2 includes the base URL and its direct children, and so on. `mode`: Optional. The crawling mode to use. Fast mode crawls 4x faster on websites without a sitemap but may not be as accurate and shouldn't be used on heavily JavaScript-rendered websites. `limit`: Optional. Maximum number of pages to crawl. `timeout`: Optional. Timeout in milliseconds for the crawling operation.",
      "title": "Arguments",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`XMLSearchTool`",
          "level": 1
        },
        {
          "title": "Arguments",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`XMLSearchTool`",
            "level": 1
          },
          {
            "title": "Arguments",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `XMLSearchTool` > Arguments"
      },
      "enhanced_content": "Context: Changelog > `XMLSearchTool` > Arguments\n\n## Arguments\n\n`api_key`: Optional. Specifies Firecrawl API key. Defaults is the `FIRECRAWL_API_KEY` environment variable. `url`: The base URL to start crawling from. `page_options`: Optional. `onlyMainContent`: Optional. Only return the main content of the page excluding headers, navs, footers, etc. `includeHtml`: Optional. Include the raw HTML content of the page. Will output a html key in the response. `crawler_options`: Optional. Options for controlling the crawling behavior. `includes`: Optional. URL patterns to include in the crawl. `exclude`: Optional. URL patterns to exclude from the crawl. `generateImgAltText`: Optional. Generate alt text for images using LLMs (requires a paid plan). `returnOnlyUrls`: Optional. If true, returns only the URLs as a list in the crawl status. Note: the response will be a list of URLs inside the data, not a list of documents. `maxDepth`: Optional. Maximum depth to crawl. Depth 1 is the base URL, depth 2 includes the base URL and its direct children, and so on. `mode`: Optional. The crawling mode to use. Fast mode crawls 4x faster on websites without a sitemap but may not be as accurate and shouldn't be used on heavily JavaScript-rendered websites. `limit`: Optional. Maximum number of pages to crawl. `timeout`: Optional. Timeout in milliseconds for the crawling operation.",
      "formatted_path": "Changelog > `XMLSearchTool` > Arguments",
      "enhanced_text": "Context: Changelog > `XMLSearchTool` > Arguments\n\n Arguments\n\n`api_key`: Optional. Specifies Firecrawl API key. Defaults is the `FIRECRAWL_API_KEY` environment variable. `url`: The base URL to start crawling from. `page_options`: Optional. `onlyMainContent`: Optional. Only return the main content of the page excluding headers, navs, footers, etc. `includeHtml`: Optional. Include the raw HTML content of the page. Will output a html key in the response. `crawler_options`: Optional. Options for controlling the crawling behavior. `includes`: Optional. URL patterns to include in the crawl. `exclude`: Optional. URL patterns to exclude from the crawl. `generateImgAltText`: Optional. Generate alt text for images using LLMs (requires a paid plan). `returnOnlyUrls`: Optional. If true, returns only the URLs as a list in the crawl status. Note: the response will be a list of URLs inside the data, not a list of documents. `maxDepth`: Optional. Maximum depth to crawl. Depth 1 is the base URL, depth 2 includes the base URL and its direct children, and so on. `mode`: Optional. The crawling mode to use. Fast mode crawls 4x faster on websites without a sitemap but may not be as accurate and shouldn't be used on heavily JavaScript-rendered websites. `limit`: Optional. Maximum number of pages to crawl. `timeout`: Optional. Timeout in milliseconds for the crawling operation.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "a html key in the response. `crawler_options`: Optional. Options for controlling the crawling behavior. `includes`: Optional. URL patterns to include in the crawl. `exclude`: Optional. URL patterns to exclude from the crawl. `generateImgAltText`: Optional. Generate alt text for images using LLMs (requires a paid plan). `returnOnlyUrls`: Optional. If true, returns only the URLs as a list in the crawl status. Note: the response will be a list of URLs inside the data, not a list of documents. `maxDepth`: Optional. Maximum depth to crawl. Depth 1 is the base URL, depth 2 includes the base URL and its direct children, and so on. `mode`: Optional. The crawling mode to use. Fast mode crawls 4x faster on websites without a sitemap but may not be as accurate and shouldn't be used on heavily JavaScript-rendered websites. `limit`: Optional. Maximum number of pages to crawl. `timeout`: Optional. Timeout in milliseconds for the crawling operation.\n\n`api_key`: Optional. Specifies Firecrawl API key. Defaults is the `FIRECRAWL_API_KEY` environment variable. `url`: The URL to scrape. `page_options`: Optional. `onlyMainContent`: Optional. Only return the main content of the page excluding headers, navs, footers, etc. `includeHtml`: Optional. Include the raw HTML content of the page. Will output a html key in the response. `extractor_options`: Optional. Options for LLM-based extraction of structured information from the page content `mode`: The extraction mode to use, currently supports 'llm-extraction' `extractionPrompt`: Optional. A prompt describing what information to extract from the page `extractionSchema`: Optional. The schema for the data to be extracted `timeout`: Optional. Timeout in milliseconds for the request",
      "title": "Arguments",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`XMLSearchTool`",
          "level": 1
        },
        {
          "title": "Arguments",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`XMLSearchTool`",
            "level": 1
          },
          {
            "title": "Arguments",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `XMLSearchTool` > Arguments"
      },
      "enhanced_content": "Context: Changelog > `XMLSearchTool` > Arguments\n\n## Arguments\n\na html key in the response. `crawler_options`: Optional. Options for controlling the crawling behavior. `includes`: Optional. URL patterns to include in the crawl. `exclude`: Optional. URL patterns to exclude from the crawl. `generateImgAltText`: Optional. Generate alt text for images using LLMs (requires a paid plan). `returnOnlyUrls`: Optional. If true, returns only the URLs as a list in the crawl status. Note: the response will be a list of URLs inside the data, not a list of documents. `maxDepth`: Optional. Maximum depth to crawl. Depth 1 is the base URL, depth 2 includes the base URL and its direct children, and so on. `mode`: Optional. The crawling mode to use. Fast mode crawls 4x faster on websites without a sitemap but may not be as accurate and shouldn't be used on heavily JavaScript-rendered websites. `limit`: Optional. Maximum number of pages to crawl. `timeout`: Optional. Timeout in milliseconds for the crawling operation.\n\n`api_key`: Optional. Specifies Firecrawl API key. Defaults is the `FIRECRAWL_API_KEY` environment variable. `url`: The URL to scrape. `page_options`: Optional. `onlyMainContent`: Optional. Only return the main content of the page excluding headers, navs, footers, etc. `includeHtml`: Optional. Include the raw HTML content of the page. Will output a html key in the response. `extractor_options`: Optional. Options for LLM-based extraction of structured information from the page content `mode`: The extraction mode to use, currently supports 'llm-extraction' `extractionPrompt`: Optional. A prompt describing what information to extract from the page `extractionSchema`: Optional. The schema for the data to be extracted `timeout`: Optional. Timeout in milliseconds for the request",
      "formatted_path": "Changelog > `XMLSearchTool` > Arguments",
      "enhanced_text": "Context: Changelog > `XMLSearchTool` > Arguments\n\n Arguments\n\na html key in the response. `crawler_options`: Optional. Options for controlling the crawling behavior. `includes`: Optional. URL patterns to include in the crawl. `exclude`: Optional. URL patterns to exclude from the crawl. `generateImgAltText`: Optional. Generate alt text for images using LLMs (requires a paid plan). `returnOnlyUrls`: Optional. If true, returns only the URLs as a list in the crawl status. Note: the response will be a list of URLs inside the data, not a list of documents. `maxDepth`: Optional. Maximum depth to crawl. Depth 1 is the base URL, depth 2 includes the base URL and its direct children, and so on. `mode`: Optional. The crawling mode to use. Fast mode crawls 4x faster on websites without a sitemap but may not be as accurate and shouldn't be used on heavily JavaScript-rendered websites. `limit`: Optional. Maximum number of pages to crawl. `timeout`: Optional. Timeout in milliseconds for the crawling operation.\n\n`api_key`: Optional. Specifies Firecrawl API key. Defaults is the `FIRECRAWL_API_KEY` environment variable. `url`: The URL to scrape. `page_options`: Optional. `onlyMainContent`: Optional. Only return the main content of the page excluding headers, navs, footers, etc. `includeHtml`: Optional. Include the raw HTML content of the page. Will output a html key in the response. `extractor_options`: Optional. Options for LLM-based extraction of structured information from the page content `mode`: The extraction mode to use, currently supports 'llm-extraction' `extractionPrompt`: Optional. A prompt describing what information to extract from the page `extractionSchema`: Optional. The schema for the data to be extracted `timeout`: Optional. Timeout in milliseconds for the request\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "The crawling mode to use. Fast mode crawls 4x faster on websites without a sitemap but may not be as accurate and shouldn't be used on heavily JavaScript-rendered websites. `limit`: Optional. Maximum number of pages to crawl. `timeout`: Optional. Timeout in milliseconds for the crawling operation. `api_key`: Optional. Specifies Firecrawl API key. Defaults is the `FIRECRAWL_API_KEY` environment variable. `url`: The URL to scrape. `page_options`: Optional. `onlyMainContent`: Optional. Only return the main content of the page excluding headers, navs, footers, etc. `includeHtml`: Optional. Include the raw HTML content of the page. Will output a html key in the response. `extractor_options`: Optional. Options for LLM-based extraction of structured information from the page content `mode`: The extraction mode to use, currently supports 'llm-extraction' `extractionPrompt`: Optional. A prompt describing what information to extract from the page `extractionSchema`: Optional. The schema for the data to be extracted `timeout`: Optional. Timeout in milliseconds for the request\n\n`api_key`: Optional. Specifies Firecrawl API key. Defaults is the `FIRECRAWL_API_KEY` environment variable. `query`: The search query string to be used for searching. `page_options`: Optional. Options for result formatting. `onlyMainContent`: Optional. Only return the main content of the page excluding headers, navs, footers, etc. `includeHtml`: Optional. Include the raw HTML content of the page. Will output a html key in the response. `fetchPageContent`: Optional. Fetch the full content of the page. `search_options`: Optional. Options for controlling the crawling behavior. `limit`: Optional. Maximum number of pages to crawl.",
      "title": "Arguments",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`XMLSearchTool`",
          "level": 1
        },
        {
          "title": "Arguments",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`XMLSearchTool`",
            "level": 1
          },
          {
            "title": "Arguments",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `XMLSearchTool` > Arguments"
      },
      "enhanced_content": "Context: Changelog > `XMLSearchTool` > Arguments\n\n## Arguments\n\nThe crawling mode to use. Fast mode crawls 4x faster on websites without a sitemap but may not be as accurate and shouldn't be used on heavily JavaScript-rendered websites. `limit`: Optional. Maximum number of pages to crawl. `timeout`: Optional. Timeout in milliseconds for the crawling operation. `api_key`: Optional. Specifies Firecrawl API key. Defaults is the `FIRECRAWL_API_KEY` environment variable. `url`: The URL to scrape. `page_options`: Optional. `onlyMainContent`: Optional. Only return the main content of the page excluding headers, navs, footers, etc. `includeHtml`: Optional. Include the raw HTML content of the page. Will output a html key in the response. `extractor_options`: Optional. Options for LLM-based extraction of structured information from the page content `mode`: The extraction mode to use, currently supports 'llm-extraction' `extractionPrompt`: Optional. A prompt describing what information to extract from the page `extractionSchema`: Optional. The schema for the data to be extracted `timeout`: Optional. Timeout in milliseconds for the request\n\n`api_key`: Optional. Specifies Firecrawl API key. Defaults is the `FIRECRAWL_API_KEY` environment variable. `query`: The search query string to be used for searching. `page_options`: Optional. Options for result formatting. `onlyMainContent`: Optional. Only return the main content of the page excluding headers, navs, footers, etc. `includeHtml`: Optional. Include the raw HTML content of the page. Will output a html key in the response. `fetchPageContent`: Optional. Fetch the full content of the page. `search_options`: Optional. Options for controlling the crawling behavior. `limit`: Optional. Maximum number of pages to crawl.",
      "formatted_path": "Changelog > `XMLSearchTool` > Arguments",
      "enhanced_text": "Context: Changelog > `XMLSearchTool` > Arguments\n\n Arguments\n\nThe crawling mode to use. Fast mode crawls 4x faster on websites without a sitemap but may not be as accurate and shouldn't be used on heavily JavaScript-rendered websites. `limit`: Optional. Maximum number of pages to crawl. `timeout`: Optional. Timeout in milliseconds for the crawling operation. `api_key`: Optional. Specifies Firecrawl API key. Defaults is the `FIRECRAWL_API_KEY` environment variable. `url`: The URL to scrape. `page_options`: Optional. `onlyMainContent`: Optional. Only return the main content of the page excluding headers, navs, footers, etc. `includeHtml`: Optional. Include the raw HTML content of the page. Will output a html key in the response. `extractor_options`: Optional. Options for LLM-based extraction of structured information from the page content `mode`: The extraction mode to use, currently supports 'llm-extraction' `extractionPrompt`: Optional. A prompt describing what information to extract from the page `extractionSchema`: Optional. The schema for the data to be extracted `timeout`: Optional. Timeout in milliseconds for the request\n\n`api_key`: Optional. Specifies Firecrawl API key. Defaults is the `FIRECRAWL_API_KEY` environment variable. `query`: The search query string to be used for searching. `page_options`: Optional. Options for result formatting. `onlyMainContent`: Optional. Only return the main content of the page excluding headers, navs, footers, etc. `includeHtml`: Optional. Include the raw HTML content of the page. Will output a html key in the response. `fetchPageContent`: Optional. Fetch the full content of the page. `search_options`: Optional. Options for controlling the crawling behavior. `limit`: Optional. Maximum number of pages to crawl.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "content of the page. Will output a html key in the response. `extractor_options`: Optional. Options for LLM-based extraction of structured information from the page content `mode`: The extraction mode to use, currently supports 'llm-extraction' `extractionPrompt`: Optional. A prompt describing what information to extract from the page `extractionSchema`: Optional. The schema for the data to be extracted `timeout`: Optional. Timeout in milliseconds for the request `api_key`: Optional. Specifies Firecrawl API key. Defaults is the `FIRECRAWL_API_KEY` environment variable. `query`: The search query string to be used for searching. `page_options`: Optional. Options for result formatting. `onlyMainContent`: Optional. Only return the main content of the page excluding headers, navs, footers, etc. `includeHtml`: Optional. Include the raw HTML content of the page. Will output a html key in the response. `fetchPageContent`: Optional. Fetch the full content of the page. `search_options`: Optional. Options for controlling the crawling behavior. `limit`: Optional. Maximum number of pages to crawl.\n\n`github_repo` : The URL of the GitHub repository where the search will be conducted. This is a mandatory field and specifies the target repository for your search. `gh_token` : Your GitHub Personal Access Token (PAT) required for authentication. You can create one in your GitHub account settings under Developer Settings > Personal Access Tokens. `content_types` : Specifies the types of content to include in your search. You must provide a list of content types from the following options: `code` for searching within the code,\n`repo` for searching within the repository's general information, `pr` for searching within pull requests, and `issue` for searching within issues.\nThis field is mandatory and allows tailoring the search to specific content types within the GitHub repository.",
      "title": "Arguments",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`XMLSearchTool`",
          "level": 1
        },
        {
          "title": "Arguments",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`XMLSearchTool`",
            "level": 1
          },
          {
            "title": "Arguments",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `XMLSearchTool` > Arguments"
      },
      "enhanced_content": "Context: Changelog > `XMLSearchTool` > Arguments\n\n## Arguments\n\ncontent of the page. Will output a html key in the response. `extractor_options`: Optional. Options for LLM-based extraction of structured information from the page content `mode`: The extraction mode to use, currently supports 'llm-extraction' `extractionPrompt`: Optional. A prompt describing what information to extract from the page `extractionSchema`: Optional. The schema for the data to be extracted `timeout`: Optional. Timeout in milliseconds for the request `api_key`: Optional. Specifies Firecrawl API key. Defaults is the `FIRECRAWL_API_KEY` environment variable. `query`: The search query string to be used for searching. `page_options`: Optional. Options for result formatting. `onlyMainContent`: Optional. Only return the main content of the page excluding headers, navs, footers, etc. `includeHtml`: Optional. Include the raw HTML content of the page. Will output a html key in the response. `fetchPageContent`: Optional. Fetch the full content of the page. `search_options`: Optional. Options for controlling the crawling behavior. `limit`: Optional. Maximum number of pages to crawl.\n\n`github_repo` : The URL of the GitHub repository where the search will be conducted. This is a mandatory field and specifies the target repository for your search. `gh_token` : Your GitHub Personal Access Token (PAT) required for authentication. You can create one in your GitHub account settings under Developer Settings > Personal Access Tokens. `content_types` : Specifies the types of content to include in your search. You must provide a list of content types from the following options: `code` for searching within the code,\n`repo` for searching within the repository's general information, `pr` for searching within pull requests, and `issue` for searching within issues.\nThis field is mandatory and allows tailoring the search to specific content types within the GitHub repository.",
      "formatted_path": "Changelog > `XMLSearchTool` > Arguments",
      "enhanced_text": "Context: Changelog > `XMLSearchTool` > Arguments\n\n Arguments\n\ncontent of the page. Will output a html key in the response. `extractor_options`: Optional. Options for LLM-based extraction of structured information from the page content `mode`: The extraction mode to use, currently supports 'llm-extraction' `extractionPrompt`: Optional. A prompt describing what information to extract from the page `extractionSchema`: Optional. The schema for the data to be extracted `timeout`: Optional. Timeout in milliseconds for the request `api_key`: Optional. Specifies Firecrawl API key. Defaults is the `FIRECRAWL_API_KEY` environment variable. `query`: The search query string to be used for searching. `page_options`: Optional. Options for result formatting. `onlyMainContent`: Optional. Only return the main content of the page excluding headers, navs, footers, etc. `includeHtml`: Optional. Include the raw HTML content of the page. Will output a html key in the response. `fetchPageContent`: Optional. Fetch the full content of the page. `search_options`: Optional. Options for controlling the crawling behavior. `limit`: Optional. Maximum number of pages to crawl.\n\n`github_repo` : The URL of the GitHub repository where the search will be conducted. This is a mandatory field and specifies the target repository for your search. `gh_token` : Your GitHub Personal Access Token (PAT) required for authentication. You can create one in your GitHub account settings under Developer Settings > Personal Access Tokens. `content_types` : Specifies the types of content to include in your search. You must provide a list of content types from the following options: `code` for searching within the code,\n`repo` for searching within the repository's general information, `pr` for searching within pull requests, and `issue` for searching within issues.\nThis field is mandatory and allows tailoring the search to specific content types within the GitHub repository.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "key in the response. `fetchPageContent`: Optional. Fetch the full content of the page. `search_options`: Optional. Options for controlling the crawling behavior. `limit`: Optional. Maximum number of pages to crawl. `github_repo` : The URL of the GitHub repository where the search will be conducted. This is a mandatory field and specifies the target repository for your search. `gh_token` : Your GitHub Personal Access Token (PAT) required for authentication. You can create one in your GitHub account settings under Developer Settings > Personal Access Tokens. `content_types` : Specifies the types of content to include in your search. You must provide a list of content types from the following options: `code` for searching within the code, `repo` for searching within the repository's general information, `pr` for searching within pull requests, and `issue` for searching within issues. This field is mandatory and allows tailoring the search to specific content types within the GitHub repository.\n\n`json_path` (str, optional): Specifies the path to the JSON file to be searched. This argument is not required if the tool is initialized for a general search. When provided, it confines the search to the specified JSON file.",
      "title": "Arguments",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`XMLSearchTool`",
          "level": 1
        },
        {
          "title": "Arguments",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`XMLSearchTool`",
            "level": 1
          },
          {
            "title": "Arguments",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `XMLSearchTool` > Arguments"
      },
      "enhanced_content": "Context: Changelog > `XMLSearchTool` > Arguments\n\n## Arguments\n\nkey in the response. `fetchPageContent`: Optional. Fetch the full content of the page. `search_options`: Optional. Options for controlling the crawling behavior. `limit`: Optional. Maximum number of pages to crawl. `github_repo` : The URL of the GitHub repository where the search will be conducted. This is a mandatory field and specifies the target repository for your search. `gh_token` : Your GitHub Personal Access Token (PAT) required for authentication. You can create one in your GitHub account settings under Developer Settings > Personal Access Tokens. `content_types` : Specifies the types of content to include in your search. You must provide a list of content types from the following options: `code` for searching within the code, `repo` for searching within the repository's general information, `pr` for searching within pull requests, and `issue` for searching within issues. This field is mandatory and allows tailoring the search to specific content types within the GitHub repository.\n\n`json_path` (str, optional): Specifies the path to the JSON file to be searched. This argument is not required if the tool is initialized for a general search. When provided, it confines the search to the specified JSON file.",
      "formatted_path": "Changelog > `XMLSearchTool` > Arguments",
      "enhanced_text": "Context: Changelog > `XMLSearchTool` > Arguments\n\n Arguments\n\nkey in the response. `fetchPageContent`: Optional. Fetch the full content of the page. `search_options`: Optional. Options for controlling the crawling behavior. `limit`: Optional. Maximum number of pages to crawl. `github_repo` : The URL of the GitHub repository where the search will be conducted. This is a mandatory field and specifies the target repository for your search. `gh_token` : Your GitHub Personal Access Token (PAT) required for authentication. You can create one in your GitHub account settings under Developer Settings > Personal Access Tokens. `content_types` : Specifies the types of content to include in your search. You must provide a list of content types from the following options: `code` for searching within the code, `repo` for searching within the repository's general information, `pr` for searching within pull requests, and `issue` for searching within issues. This field is mandatory and allows tailoring the search to specific content types within the GitHub repository.\n\n`json_path` (str, optional): Specifies the path to the JSON file to be searched. This argument is not required if the tool is initialized for a general search. When provided, it confines the search to the specified JSON file.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "the search will be conducted. This is a mandatory field and specifies the target repository for your search. `gh_token` : Your GitHub Personal Access Token (PAT) required for authentication. You can create one in your GitHub account settings under Developer Settings > Personal Access Tokens. `content_types` : Specifies the types of content to include in your search. You must provide a list of content types from the following options: `code` for searching within the code, `repo` for searching within the repository's general information, `pr` for searching within pull requests, and `issue` for searching within issues. This field is mandatory and allows tailoring the search to specific content types within the GitHub repository. `json_path` (str, optional): Specifies the path to the JSON file to be searched. This argument is not required if the tool is initialized for a general search. When provided, it confines the search to the specified JSON file.\n\nThe MySQLSearchTool requires the following arguments for its operation: `db_uri`: A string representing the URI of the MySQL database to be queried. This argument is mandatory and must include the necessary authentication details and the location of the database. `table_name`: A string specifying the name of the table within the database on which the semantic search will be performed. This argument is mandatory.",
      "title": "Arguments",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`XMLSearchTool`",
          "level": 1
        },
        {
          "title": "Arguments",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`XMLSearchTool`",
            "level": 1
          },
          {
            "title": "Arguments",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `XMLSearchTool` > Arguments"
      },
      "enhanced_content": "Context: Changelog > `XMLSearchTool` > Arguments\n\n## Arguments\n\nthe search will be conducted. This is a mandatory field and specifies the target repository for your search. `gh_token` : Your GitHub Personal Access Token (PAT) required for authentication. You can create one in your GitHub account settings under Developer Settings > Personal Access Tokens. `content_types` : Specifies the types of content to include in your search. You must provide a list of content types from the following options: `code` for searching within the code, `repo` for searching within the repository's general information, `pr` for searching within pull requests, and `issue` for searching within issues. This field is mandatory and allows tailoring the search to specific content types within the GitHub repository. `json_path` (str, optional): Specifies the path to the JSON file to be searched. This argument is not required if the tool is initialized for a general search. When provided, it confines the search to the specified JSON file.\n\nThe MySQLSearchTool requires the following arguments for its operation: `db_uri`: A string representing the URI of the MySQL database to be queried. This argument is mandatory and must include the necessary authentication details and the location of the database. `table_name`: A string specifying the name of the table within the database on which the semantic search will be performed. This argument is mandatory.",
      "formatted_path": "Changelog > `XMLSearchTool` > Arguments",
      "enhanced_text": "Context: Changelog > `XMLSearchTool` > Arguments\n\n Arguments\n\nthe search will be conducted. This is a mandatory field and specifies the target repository for your search. `gh_token` : Your GitHub Personal Access Token (PAT) required for authentication. You can create one in your GitHub account settings under Developer Settings > Personal Access Tokens. `content_types` : Specifies the types of content to include in your search. You must provide a list of content types from the following options: `code` for searching within the code, `repo` for searching within the repository's general information, `pr` for searching within pull requests, and `issue` for searching within issues. This field is mandatory and allows tailoring the search to specific content types within the GitHub repository. `json_path` (str, optional): Specifies the path to the JSON file to be searched. This argument is not required if the tool is initialized for a general search. When provided, it confines the search to the specified JSON file.\n\nThe MySQLSearchTool requires the following arguments for its operation: `db_uri`: A string representing the URI of the MySQL database to be queried. This argument is mandatory and must include the necessary authentication details and the location of the database. `table_name`: A string specifying the name of the table within the database on which the semantic search will be performed. This argument is mandatory.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "content types from the following options: `code` for searching within the code, `repo` for searching within the repository's general information, `pr` for searching within pull requests, and `issue` for searching within issues. This field is mandatory and allows tailoring the search to specific content types within the GitHub repository. `json_path` (str, optional): Specifies the path to the JSON file to be searched. This argument is not required if the tool is initialized for a general search. When provided, it confines the search to the specified JSON file. The MySQLSearchTool requires the following arguments for its operation: `db_uri`: A string representing the URI of the MySQL database to be queried. This argument is mandatory and must include the necessary authentication details and the location of the database. `table_name`: A string specifying the name of the table within the database on which the semantic search will be performed. This argument is mandatory.\n\n`pdf`: **Optional** The PDF path for the search. Can be provided at initialization or within the `run` method's arguments. If provided at initialization, the tool confines its search to the specified document.",
      "title": "Arguments",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`XMLSearchTool`",
          "level": 1
        },
        {
          "title": "Arguments",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`XMLSearchTool`",
            "level": 1
          },
          {
            "title": "Arguments",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `XMLSearchTool` > Arguments"
      },
      "enhanced_content": "Context: Changelog > `XMLSearchTool` > Arguments\n\n## Arguments\n\ncontent types from the following options: `code` for searching within the code, `repo` for searching within the repository's general information, `pr` for searching within pull requests, and `issue` for searching within issues. This field is mandatory and allows tailoring the search to specific content types within the GitHub repository. `json_path` (str, optional): Specifies the path to the JSON file to be searched. This argument is not required if the tool is initialized for a general search. When provided, it confines the search to the specified JSON file. The MySQLSearchTool requires the following arguments for its operation: `db_uri`: A string representing the URI of the MySQL database to be queried. This argument is mandatory and must include the necessary authentication details and the location of the database. `table_name`: A string specifying the name of the table within the database on which the semantic search will be performed. This argument is mandatory.\n\n`pdf`: **Optional** The PDF path for the search. Can be provided at initialization or within the `run` method's arguments. If provided at initialization, the tool confines its search to the specified document.",
      "formatted_path": "Changelog > `XMLSearchTool` > Arguments",
      "enhanced_text": "Context: Changelog > `XMLSearchTool` > Arguments\n\n Arguments\n\ncontent types from the following options: `code` for searching within the code, `repo` for searching within the repository's general information, `pr` for searching within pull requests, and `issue` for searching within issues. This field is mandatory and allows tailoring the search to specific content types within the GitHub repository. `json_path` (str, optional): Specifies the path to the JSON file to be searched. This argument is not required if the tool is initialized for a general search. When provided, it confines the search to the specified JSON file. The MySQLSearchTool requires the following arguments for its operation: `db_uri`: A string representing the URI of the MySQL database to be queried. This argument is mandatory and must include the necessary authentication details and the location of the database. `table_name`: A string specifying the name of the table within the database on which the semantic search will be performed. This argument is mandatory.\n\n`pdf`: **Optional** The PDF path for the search. Can be provided at initialization or within the `run` method's arguments. If provided at initialization, the tool confines its search to the specified document.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "This field is mandatory and allows tailoring the search to specific content types within the GitHub repository. `json_path` (str, optional): Specifies the path to the JSON file to be searched. This argument is not required if the tool is initialized for a general search. When provided, it confines the search to the specified JSON file. The MySQLSearchTool requires the following arguments for its operation: `db_uri`: A string representing the URI of the MySQL database to be queried. This argument is mandatory and must include the necessary authentication details and the location of the database. `table_name`: A string specifying the name of the table within the database on which the semantic search will be performed. This argument is mandatory. `pdf`: **Optional** The PDF path for the search. Can be provided at initialization or within the `run` method's arguments. If provided at initialization, the tool confines its search to the specified document.\n\nThe PGSearchTool is designed to require the following arguments for its operation: | Argument        | Type     | Description                                                                                                                                                                                                    |\n| :-------------- | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **db\\_uri**     | `string` | **Mandatory**. A string representing the URI of the PostgreSQL database to be queried. This argument will be mandatory and must include the necessary authentication details and the location of the database. |\n| **table\\_name** | `string` | **Mandatory**. A string specifying the name of the table within the database on which the semantic search will be performed. This argument will also be mandatory.                                             |",
      "title": "Arguments",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`XMLSearchTool`",
          "level": 1
        },
        {
          "title": "Arguments",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`XMLSearchTool`",
            "level": 1
          },
          {
            "title": "Arguments",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `XMLSearchTool` > Arguments"
      },
      "enhanced_content": "Context: Changelog > `XMLSearchTool` > Arguments\n\n## Arguments\n\nThis field is mandatory and allows tailoring the search to specific content types within the GitHub repository. `json_path` (str, optional): Specifies the path to the JSON file to be searched. This argument is not required if the tool is initialized for a general search. When provided, it confines the search to the specified JSON file. The MySQLSearchTool requires the following arguments for its operation: `db_uri`: A string representing the URI of the MySQL database to be queried. This argument is mandatory and must include the necessary authentication details and the location of the database. `table_name`: A string specifying the name of the table within the database on which the semantic search will be performed. This argument is mandatory. `pdf`: **Optional** The PDF path for the search. Can be provided at initialization or within the `run` method's arguments. If provided at initialization, the tool confines its search to the specified document.\n\nThe PGSearchTool is designed to require the following arguments for its operation: | Argument        | Type     | Description                                                                                                                                                                                                    |\n| :-------------- | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **db\\_uri**     | `string` | **Mandatory**. A string representing the URI of the PostgreSQL database to be queried. This argument will be mandatory and must include the necessary authentication details and the location of the database. |\n| **table\\_name** | `string` | **Mandatory**. A string specifying the name of the table within the database on which the semantic search will be performed. This argument will also be mandatory.                                             |",
      "formatted_path": "Changelog > `XMLSearchTool` > Arguments",
      "enhanced_text": "Context: Changelog > `XMLSearchTool` > Arguments\n\n Arguments\n\nThis field is mandatory and allows tailoring the search to specific content types within the GitHub repository. `json_path` (str, optional): Specifies the path to the JSON file to be searched. This argument is not required if the tool is initialized for a general search. When provided, it confines the search to the specified JSON file. The MySQLSearchTool requires the following arguments for its operation: `db_uri`: A string representing the URI of the MySQL database to be queried. This argument is mandatory and must include the necessary authentication details and the location of the database. `table_name`: A string specifying the name of the table within the database on which the semantic search will be performed. This argument is mandatory. `pdf`: **Optional** The PDF path for the search. Can be provided at initialization or within the `run` method's arguments. If provided at initialization, the tool confines its search to the specified document.\n\nThe PGSearchTool is designed to require the following arguments for its operation: | Argument        | Type     | Description                                                                                                                                                                                                    |\n| :-------------- | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **db\\_uri**     | `string` | **Mandatory**. A string representing the URI of the PostgreSQL database to be queried. This argument will be mandatory and must include the necessary authentication details and the location of the database. |\n| **table\\_name** | `string` | **Mandatory**. A string specifying the name of the table within the database on which the semantic search will be performed. This argument will also be mandatory.                                             |\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "A string specifying the name of the table within the database on which the semantic search will be performed. This argument is mandatory. `pdf`: **Optional** The PDF path for the search. Can be provided at initialization or within the `run` method's arguments. If provided at initialization, the tool confines its search to the specified document. The PGSearchTool is designed to require the following arguments for its operation: | Argument | Type | Description | | :-------------- | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | **db\\_uri** | `string` | **Mandatory**. A string representing the URI of the PostgreSQL database to be queried. This argument will be mandatory and must include the necessary authentication details and the location of the database. | | **table\\_name** | `string` | **Mandatory**. A string specifying the name of the table within the database on which the semantic search will be performed. This argument will also be mandatory. |\n\n| Argument         | Type     | Description                                                                                                                                        |\n| :--------------- | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **website\\_url** | `string` | **Mandatory** website URL to read the file. This is the primary input for the tool, specifying which website's content should be scraped and read. |",
      "title": "Arguments",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`XMLSearchTool`",
          "level": 1
        },
        {
          "title": "Arguments",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`XMLSearchTool`",
            "level": 1
          },
          {
            "title": "Arguments",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `XMLSearchTool` > Arguments"
      },
      "enhanced_content": "Context: Changelog > `XMLSearchTool` > Arguments\n\n## Arguments\n\nA string specifying the name of the table within the database on which the semantic search will be performed. This argument is mandatory. `pdf`: **Optional** The PDF path for the search. Can be provided at initialization or within the `run` method's arguments. If provided at initialization, the tool confines its search to the specified document. The PGSearchTool is designed to require the following arguments for its operation: | Argument | Type | Description | | :-------------- | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | **db\\_uri** | `string` | **Mandatory**. A string representing the URI of the PostgreSQL database to be queried. This argument will be mandatory and must include the necessary authentication details and the location of the database. | | **table\\_name** | `string` | **Mandatory**. A string specifying the name of the table within the database on which the semantic search will be performed. This argument will also be mandatory. |\n\n| Argument         | Type     | Description                                                                                                                                        |\n| :--------------- | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **website\\_url** | `string` | **Mandatory** website URL to read the file. This is the primary input for the tool, specifying which website's content should be scraped and read. |",
      "formatted_path": "Changelog > `XMLSearchTool` > Arguments",
      "enhanced_text": "Context: Changelog > `XMLSearchTool` > Arguments\n\n Arguments\n\nA string specifying the name of the table within the database on which the semantic search will be performed. This argument is mandatory. `pdf`: **Optional** The PDF path for the search. Can be provided at initialization or within the `run` method's arguments. If provided at initialization, the tool confines its search to the specified document. The PGSearchTool is designed to require the following arguments for its operation: | Argument | Type | Description | | :-------------- | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | **db\\_uri** | `string` | **Mandatory**. A string representing the URI of the PostgreSQL database to be queried. This argument will be mandatory and must include the necessary authentication details and the location of the database. | | **table\\_name** | `string` | **Mandatory**. A string specifying the name of the table within the database on which the semantic search will be performed. This argument will also be mandatory. |\n\n| Argument         | Type     | Description                                                                                                                                        |\n| :--------------- | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **website\\_url** | `string` | **Mandatory** website URL to read the file. This is the primary input for the tool, specifying which website's content should be scraped and read. |\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "at initialization, the tool confines its search to the specified document. The PGSearchTool is designed to require the following arguments for its operation: | Argument | Type | Description | | :-------------- | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | **db\\_uri** | `string` | **Mandatory**. A string representing the URI of the PostgreSQL database to be queried. This argument will be mandatory and must include the necessary authentication details and the location of the database. | | **table\\_name** | `string` | **Mandatory**. A string specifying the name of the table within the database on which the semantic search will be performed. This argument will also be mandatory. | | Argument | Type | Description | | :--------------- | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------- | | **website\\_url** | `string` | **Mandatory** website URL to read the file. This is the primary input for the tool, specifying which website's content should be scraped and read. |\n\n| Argument                | Type     | Description                                                                                                                       |\n| :---------------------- | :------- | :-------------------------------------------------------------------------------------------------------------------------------- |\n| **api\\_key**            | `string` | Specifies Spider API key. If not specified, it looks for `SPIDER_API_KEY` in environment variables.                               |\n| **params**              | `object` | Optional parameters for the request. Defaults to `{\"return_format\": \"markdown\"}` to optimize content for LLMs.                    |\n| **request**             | `string` | Type of request to perform (`http`, `chrome`, `smart`). `smart` defaults to HTTP, switching to JavaScript rendering if needed.    |\n| **limit**               | `int`    | Max pages to crawl per website. Set to `0` or omit for unlimited.                                                                 |\n| **depth**               | `int`    | Max crawl depth. Set to `0` for no limit.                                                                                         |\n| **cache**               | `bool`   | Enables HTTP caching to speed up repeated runs. Default is `true`.                                                                |\n| **budget**              | `object` | Sets path-based limits for crawled pages, e.g., `{\"*\":1}` for root page only.                                                     |\n| **locale**              | `string` | Locale for the request, e.g., `en-US`.                                                                                            |\n| **cookies**             | `string` | HTTP cookies for the request.                                                                                                     |\n| **stealth**             | `bool`   | Enables stealth mode for Chrome requests to avoid detection. Default is `true`.                                                   |\n| **headers**             | `object` | HTTP headers as a map of key-value pairs for all requests.                                                                        |\n| **metadata**            | `bool`   | Stores metadata about pages and content, aiding AI interoperability. Defaults to `false`.                                         |\n| **viewport**            | `object` | Sets Chrome viewport dimensions. Default is `800x600`.                                                                            |\n| **encoding**            | `string` | Specifies encoding type, e.g., `UTF-8`, `SHIFT_JIS`.                                                                              |\n| **subdomains**          | `bool`   | Includes subdomains in the crawl. Default is `false`.                                                                             |\n| **user\\_agent**         | `string` | Custom HTTP user agent. Defaults to a random agent.                                                                               |\n| **store\\_data**         | `bool`   | Enables data storage for the request. Overrides `storageless` when set. Default is `false`.                                       |\n| **gpt\\_config**         | `object` | Allows AI to generate crawl actions, with optional chaining steps via an array for `\"prompt\"`.                                    |\n| **fingerprint**         | `bool`   | Enables advanced fingerprinting for Chrome.                                                                                       |\n| **storageless**         | `bool`   | Prevents all data storage, including AI embeddings. Default is `false`.                                                           |\n| **readability**         | `bool`   | Pre-processes content for reading via [Mozilla\u2019s readability](https://github.com/mozilla/readability). Improves content for LLMs. |\n| **return\\_format**      | `string` | Format to return data: `markdown`, `raw`, `text`, `html2text`. Use `raw` for default page format.                                 |\n| **proxy\\_enabled**      | `bool`   | Enables high-performance proxies to avoid network-level blocking.                                                                 |\n| **query\\_selector**     | `string` | CSS query selector for content extraction from markup.                                                                            |\n| **full\\_resources**     | `bool`   | Downloads all resources linked to the website.                                                                                    |\n| **request\\_timeout**    | `int`    | Timeout in seconds for requests (5-60). Default is `30`.                                                                          |\n| **run\\_in\\_background** | `bool`   | Runs the request in the background, useful for data storage and triggering dashboard crawls. No effect if `storageless` is set.   |",
      "title": "Arguments",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`XMLSearchTool`",
          "level": 1
        },
        {
          "title": "Arguments",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`XMLSearchTool`",
            "level": 1
          },
          {
            "title": "Arguments",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 1,
        "formatted_path": "Changelog > `XMLSearchTool` > Arguments"
      },
      "enhanced_content": "Context: Changelog > `XMLSearchTool` > Arguments\n\n## Arguments\n\nat initialization, the tool confines its search to the specified document. The PGSearchTool is designed to require the following arguments for its operation: | Argument | Type | Description | | :-------------- | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | **db\\_uri** | `string` | **Mandatory**. A string representing the URI of the PostgreSQL database to be queried. This argument will be mandatory and must include the necessary authentication details and the location of the database. | | **table\\_name** | `string` | **Mandatory**. A string specifying the name of the table within the database on which the semantic search will be performed. This argument will also be mandatory. | | Argument | Type | Description | | :--------------- | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------- | | **website\\_url** | `string` | **Mandatory** website URL to read the file. This is the primary input for the tool, specifying which website's content should be scraped and read. |\n\n| Argument                | Type     | Description                                                                                                                       |\n| :---------------------- | :------- | :-------------------------------------------------------------------------------------------------------------------------------- |\n| **api\\_key**            | `string` | Specifies Spider API key. If not specified, it looks for `SPIDER_API_KEY` in environment variables.                               |\n| **params**              | `object` | Optional parameters for the request. Defaults to `{\"return_format\": \"markdown\"}` to optimize content for LLMs.                    |\n| **request**             | `string` | Type of request to perform (`http`, `chrome`, `smart`). `smart` defaults to HTTP, switching to JavaScript rendering if needed.    |\n| **limit**               | `int`    | Max pages to crawl per website. Set to `0` or omit for unlimited.                                                                 |\n| **depth**               | `int`    | Max crawl depth. Set to `0` for no limit.                                                                                         |\n| **cache**               | `bool`   | Enables HTTP caching to speed up repeated runs. Default is `true`.                                                                |\n| **budget**              | `object` | Sets path-based limits for crawled pages, e.g., `{\"*\":1}` for root page only.                                                     |\n| **locale**              | `string` | Locale for the request, e.g., `en-US`.                                                                                            |\n| **cookies**             | `string` | HTTP cookies for the request.                                                                                                     |\n| **stealth**             | `bool`   | Enables stealth mode for Chrome requests to avoid detection. Default is `true`.                                                   |\n| **headers**             | `object` | HTTP headers as a map of key-value pairs for all requests.                                                                        |\n| **metadata**            | `bool`   | Stores metadata about pages and content, aiding AI interoperability. Defaults to `false`.                                         |\n| **viewport**            | `object` | Sets Chrome viewport dimensions. Default is `800x600`.                                                                            |\n| **encoding**            | `string` | Specifies encoding type, e.g., `UTF-8`, `SHIFT_JIS`.                                                                              |\n| **subdomains**          | `bool`   | Includes subdomains in the crawl. Default is `false`.                                                                             |\n| **user\\_agent**         | `string` | Custom HTTP user agent. Defaults to a random agent.                                                                               |\n| **store\\_data**         | `bool`   | Enables data storage for the request. Overrides `storageless` when set. Default is `false`.                                       |\n| **gpt\\_config**         | `object` | Allows AI to generate crawl actions, with optional chaining steps via an array for `\"prompt\"`.                                    |\n| **fingerprint**         | `bool`   | Enables advanced fingerprinting for Chrome.                                                                                       |\n| **storageless**         | `bool`   | Prevents all data storage, including AI embeddings. Default is `false`.                                                           |\n| **readability**         | `bool`   | Pre-processes content for reading via [Mozilla\u2019s readability](https://github.com/mozilla/readability). Improves content for LLMs. |\n| **return\\_format**      | `string` | Format to return data: `markdown`, `raw`, `text`, `html2text`. Use `raw` for default page format.                                 |\n| **proxy\\_enabled**      | `bool`   | Enables high-performance proxies to avoid network-level blocking.                                                                 |\n| **query\\_selector**     | `string` | CSS query selector for content extraction from markup.                                                                            |\n| **full\\_resources**     | `bool`   | Downloads all resources linked to the website.                                                                                    |\n| **request\\_timeout**    | `int`    | Timeout in seconds for requests (5-60). Default is `30`.                                                                          |\n| **run\\_in\\_background** | `bool`   | Runs the request in the background, useful for data storage and triggering dashboard crawls. No effect if `storageless` is set.   |",
      "formatted_path": "Changelog > `XMLSearchTool` > Arguments",
      "enhanced_text": "Context: Changelog > `XMLSearchTool` > Arguments\n\n Arguments\n\nat initialization, the tool confines its search to the specified document. The PGSearchTool is designed to require the following arguments for its operation: | Argument | Type | Description | | :-------------- | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | **db\\_uri** | `string` | **Mandatory**. A string representing the URI of the PostgreSQL database to be queried. This argument will be mandatory and must include the necessary authentication details and the location of the database. | | **table\\_name** | `string` | **Mandatory**. A string specifying the name of the table within the database on which the semantic search will be performed. This argument will also be mandatory. | | Argument | Type | Description | | :--------------- | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------- | | **website\\_url** | `string` | **Mandatory** website URL to read the file. This is the primary input for the tool, specifying which website's content should be scraped and read. |\n\n| Argument                | Type     | Description                                                                                                                       |\n| :---------------------- | :------- | :-------------------------------------------------------------------------------------------------------------------------------- |\n| **api\\_key**            | `string` | Specifies Spider API key. If not specified, it looks for `SPIDER_API_KEY` in environment variables.                               |\n| **params**              | `object` | Optional parameters for the request. Defaults to `{\"return_format\": \"markdown\"}` to optimize content for LLMs.                    |\n| **request**             | `string` | Type of request to perform (`http`, `chrome`, `smart`). `smart` defaults to HTTP, switching to JavaScript rendering if needed.    |\n| **limit**               | `int`    | Max pages to crawl per website. Set to `0` or omit for unlimited.                                                                 |\n| **depth**               | `int`    | Max crawl depth. Set to `0` for no limit.                                                                                         |\n| **cache**               | `bool`   | Enables HTTP caching to speed up repeated runs. Default is `true`.                                                                |\n| **budget**              | `object` | Sets path-based limits for crawled pages, e.g., `{\"*\":1}` for root page only.                                                     |\n| **locale**              | `string` | Locale for the request, e.g., `en-US`.                                                                                            |\n| **cookies**             | `string` | HTTP cookies for the request.                                                                                                     |\n| **stealth**             | `bool`   | Enables stealth mode for Chrome requests to avoid detection. Default is `true`.                                                   |\n| **headers**             | `object` | HTTP headers as a map of key-value pairs for all requests.                                                                        |\n| **metadata**            | `bool`   | Stores metadata about pages and content, aiding AI interoperability. Defaults to `false`.                                         |\n| **viewport**            | `object` | Sets Chrome viewport dimensions. Default is `800x600`.                                                                            |\n| **encoding**            | `string` | Specifies encoding type, e.g., `UTF-8`, `SHIFT_JIS`.                                                                              |\n| **subdomains**          | `bool`   | Includes subdomains in the crawl. Default is `false`.                                                                             |\n| **user\\_agent**         | `string` | Custom HTTP user agent. Defaults to a random agent.                                                                               |\n| **store\\_data**         | `bool`   | Enables data storage for the request. Overrides `storageless` when set. Default is `false`.                                       |\n| **gpt\\_config**         | `object` | Allows AI to generate crawl actions, with optional chaining steps via an array for `\"prompt\"`.                                    |\n| **fingerprint**         | `bool`   | Enables advanced fingerprinting for Chrome.                                                                                       |\n| **storageless**         | `bool`   | Prevents all data storage, including AI embeddings. Default is `false`.                                                           |\n| **readability**         | `bool`   | Pre-processes content for reading via [Mozilla\u2019s readability](https://github.com/mozilla/readability). Improves content for LLMs. |\n| **return\\_format**      | `string` | Format to return data: `markdown`, `raw`, `text`, `html2text`. Use `raw` for default page format.                                 |\n| **proxy\\_enabled**      | `bool`   | Enables high-performance proxies to avoid network-level blocking.                                                                 |\n| **query\\_selector**     | `string` | CSS query selector for content extraction from markup.                                                                            |\n| **full\\_resources**     | `bool`   | Downloads all resources linked to the website.                                                                                    |\n| **request\\_timeout**    | `int`    | Timeout in seconds for requests (5-60). Default is `30`.                                                                          |\n| **run\\_in\\_background** | `bool`   | Runs the request in the background, useful for data storage and triggering dashboard crawls. No effect if `storageless` is set.   |\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "an array for `\"prompt\"`. | | **fingerprint** | `bool` | Enables advanced fingerprinting for Chrome. | | **storageless** | `bool` | Prevents all data storage, including AI embeddings. Default is `false`. | | **readability** | `bool` | Pre-processes content for reading via [Mozilla\u2019s readability](https://github.com/mozilla/readability). Improves content for LLMs. | | **return\\_format** | `string` | Format to return data: `markdown`, `raw`, `text`, `html2text`. Use `raw` for default page format. | | **proxy\\_enabled** | `bool` | Enables high-performance proxies to avoid network-level blocking. | | **query\\_selector** | `string` | CSS query selector for content extraction from markup. | | **full\\_resources** | `bool` | Downloads all resources linked to the website. | | **request\\_timeout** | `int` | Timeout in seconds for requests (5-60). Default is `30`. | | **run\\_in\\_background** | `bool` | Runs the request in the background, useful for data storage and triggering dashboard crawls. No effect if `storageless` is set. |\n\n`txt` (str): **Optional**. The path to the text file you want to search.\nThis argument is only required if the tool was not initialized with a specific text file;\notherwise, the search will be conducted within the initially provided text file.",
      "title": "Arguments",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`XMLSearchTool`",
          "level": 1
        },
        {
          "title": "Arguments",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`XMLSearchTool`",
            "level": 1
          },
          {
            "title": "Arguments",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 1,
        "formatted_path": "Changelog > `XMLSearchTool` > Arguments"
      },
      "enhanced_content": "Context: Changelog > `XMLSearchTool` > Arguments\n\n## Arguments\n\nan array for `\"prompt\"`. | | **fingerprint** | `bool` | Enables advanced fingerprinting for Chrome. | | **storageless** | `bool` | Prevents all data storage, including AI embeddings. Default is `false`. | | **readability** | `bool` | Pre-processes content for reading via [Mozilla\u2019s readability](https://github.com/mozilla/readability). Improves content for LLMs. | | **return\\_format** | `string` | Format to return data: `markdown`, `raw`, `text`, `html2text`. Use `raw` for default page format. | | **proxy\\_enabled** | `bool` | Enables high-performance proxies to avoid network-level blocking. | | **query\\_selector** | `string` | CSS query selector for content extraction from markup. | | **full\\_resources** | `bool` | Downloads all resources linked to the website. | | **request\\_timeout** | `int` | Timeout in seconds for requests (5-60). Default is `30`. | | **run\\_in\\_background** | `bool` | Runs the request in the background, useful for data storage and triggering dashboard crawls. No effect if `storageless` is set. |\n\n`txt` (str): **Optional**. The path to the text file you want to search.\nThis argument is only required if the tool was not initialized with a specific text file;\notherwise, the search will be conducted within the initially provided text file.",
      "formatted_path": "Changelog > `XMLSearchTool` > Arguments",
      "enhanced_text": "Context: Changelog > `XMLSearchTool` > Arguments\n\n Arguments\n\nan array for `\"prompt\"`. | | **fingerprint** | `bool` | Enables advanced fingerprinting for Chrome. | | **storageless** | `bool` | Prevents all data storage, including AI embeddings. Default is `false`. | | **readability** | `bool` | Pre-processes content for reading via [Mozilla\u2019s readability](https://github.com/mozilla/readability). Improves content for LLMs. | | **return\\_format** | `string` | Format to return data: `markdown`, `raw`, `text`, `html2text`. Use `raw` for default page format. | | **proxy\\_enabled** | `bool` | Enables high-performance proxies to avoid network-level blocking. | | **query\\_selector** | `string` | CSS query selector for content extraction from markup. | | **full\\_resources** | `bool` | Downloads all resources linked to the website. | | **request\\_timeout** | `int` | Timeout in seconds for requests (5-60). Default is `30`. | | **run\\_in\\_background** | `bool` | Runs the request in the background, useful for data storage and triggering dashboard crawls. No effect if `storageless` is set. |\n\n`txt` (str): **Optional**. The path to the text file you want to search.\nThis argument is only required if the tool was not initialized with a specific text file;\notherwise, the search will be conducted within the initially provided text file.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "via [Mozilla\u2019s readability](https://github.com/mozilla/readability). Improves content for LLMs. | | **return\\_format** | `string` | Format to return data: `markdown`, `raw`, `text`, `html2text`. Use `raw` for default page format. | | **proxy\\_enabled** | `bool` | Enables high-performance proxies to avoid network-level blocking. | | **query\\_selector** | `string` | CSS query selector for content extraction from markup. | | **full\\_resources** | `bool` | Downloads all resources linked to the website. | | **request\\_timeout** | `int` | Timeout in seconds for requests (5-60). Default is `30`. | | **run\\_in\\_background** | `bool` | Runs the request in the background, useful for data storage and triggering dashboard crawls. No effect if `storageless` is set. | `txt` (str): **Optional**. The path to the text file you want to search. This argument is only required if the tool was not initialized with a specific text file; otherwise, the search will be conducted within the initially provided text file.\n\nThe VisionTool requires the following arguments: | Argument             | Type     | Description                                                                      |\n| :------------------- | :------- | :------------------------------------------------------------------------------- |\n| **image\\_path\\_url** | `string` | **Mandatory**. The path to the image file from which text needs to be extracted. |",
      "title": "Arguments",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`XMLSearchTool`",
          "level": 1
        },
        {
          "title": "Arguments",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`XMLSearchTool`",
            "level": 1
          },
          {
            "title": "Arguments",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 1,
        "formatted_path": "Changelog > `XMLSearchTool` > Arguments"
      },
      "enhanced_content": "Context: Changelog > `XMLSearchTool` > Arguments\n\n## Arguments\n\nvia [Mozilla\u2019s readability](https://github.com/mozilla/readability). Improves content for LLMs. | | **return\\_format** | `string` | Format to return data: `markdown`, `raw`, `text`, `html2text`. Use `raw` for default page format. | | **proxy\\_enabled** | `bool` | Enables high-performance proxies to avoid network-level blocking. | | **query\\_selector** | `string` | CSS query selector for content extraction from markup. | | **full\\_resources** | `bool` | Downloads all resources linked to the website. | | **request\\_timeout** | `int` | Timeout in seconds for requests (5-60). Default is `30`. | | **run\\_in\\_background** | `bool` | Runs the request in the background, useful for data storage and triggering dashboard crawls. No effect if `storageless` is set. | `txt` (str): **Optional**. The path to the text file you want to search. This argument is only required if the tool was not initialized with a specific text file; otherwise, the search will be conducted within the initially provided text file.\n\nThe VisionTool requires the following arguments: | Argument             | Type     | Description                                                                      |\n| :------------------- | :------- | :------------------------------------------------------------------------------- |\n| **image\\_path\\_url** | `string` | **Mandatory**. The path to the image file from which text needs to be extracted. |",
      "formatted_path": "Changelog > `XMLSearchTool` > Arguments",
      "enhanced_text": "Context: Changelog > `XMLSearchTool` > Arguments\n\n Arguments\n\nvia [Mozilla\u2019s readability](https://github.com/mozilla/readability). Improves content for LLMs. | | **return\\_format** | `string` | Format to return data: `markdown`, `raw`, `text`, `html2text`. Use `raw` for default page format. | | **proxy\\_enabled** | `bool` | Enables high-performance proxies to avoid network-level blocking. | | **query\\_selector** | `string` | CSS query selector for content extraction from markup. | | **full\\_resources** | `bool` | Downloads all resources linked to the website. | | **request\\_timeout** | `int` | Timeout in seconds for requests (5-60). Default is `30`. | | **run\\_in\\_background** | `bool` | Runs the request in the background, useful for data storage and triggering dashboard crawls. No effect if `storageless` is set. | `txt` (str): **Optional**. The path to the text file you want to search. This argument is only required if the tool was not initialized with a specific text file; otherwise, the search will be conducted within the initially provided text file.\n\nThe VisionTool requires the following arguments: | Argument             | Type     | Description                                                                      |\n| :------------------- | :------- | :------------------------------------------------------------------------------- |\n| **image\\_path\\_url** | `string` | **Mandatory**. The path to the image file from which text needs to be extracted. |\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "| | **query\\_selector** | `string` | CSS query selector for content extraction from markup. | | **full\\_resources** | `bool` | Downloads all resources linked to the website. | | **request\\_timeout** | `int` | Timeout in seconds for requests (5-60). Default is `30`. | | **run\\_in\\_background** | `bool` | Runs the request in the background, useful for data storage and triggering dashboard crawls. No effect if `storageless` is set. | `txt` (str): **Optional**. The path to the text file you want to search. This argument is only required if the tool was not initialized with a specific text file; otherwise, the search will be conducted within the initially provided text file. The VisionTool requires the following arguments: | Argument | Type | Description | | :------------------- | :------- | :------------------------------------------------------------------------------- | | **image\\_path\\_url** | `string` | **Mandatory**. The path to the image file from which text needs to be extracted. |\n\n`website`: An optional argument intended to specify the website URL for focused searches. This argument is designed to enhance the tool's flexibility by allowing targeted searches when necessary.",
      "title": "Arguments",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`XMLSearchTool`",
          "level": 1
        },
        {
          "title": "Arguments",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`XMLSearchTool`",
            "level": 1
          },
          {
            "title": "Arguments",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `XMLSearchTool` > Arguments"
      },
      "enhanced_content": "Context: Changelog > `XMLSearchTool` > Arguments\n\n## Arguments\n\n| | **query\\_selector** | `string` | CSS query selector for content extraction from markup. | | **full\\_resources** | `bool` | Downloads all resources linked to the website. | | **request\\_timeout** | `int` | Timeout in seconds for requests (5-60). Default is `30`. | | **run\\_in\\_background** | `bool` | Runs the request in the background, useful for data storage and triggering dashboard crawls. No effect if `storageless` is set. | `txt` (str): **Optional**. The path to the text file you want to search. This argument is only required if the tool was not initialized with a specific text file; otherwise, the search will be conducted within the initially provided text file. The VisionTool requires the following arguments: | Argument | Type | Description | | :------------------- | :------- | :------------------------------------------------------------------------------- | | **image\\_path\\_url** | `string` | **Mandatory**. The path to the image file from which text needs to be extracted. |\n\n`website`: An optional argument intended to specify the website URL for focused searches. This argument is designed to enhance the tool's flexibility by allowing targeted searches when necessary.",
      "formatted_path": "Changelog > `XMLSearchTool` > Arguments",
      "enhanced_text": "Context: Changelog > `XMLSearchTool` > Arguments\n\n Arguments\n\n| | **query\\_selector** | `string` | CSS query selector for content extraction from markup. | | **full\\_resources** | `bool` | Downloads all resources linked to the website. | | **request\\_timeout** | `int` | Timeout in seconds for requests (5-60). Default is `30`. | | **run\\_in\\_background** | `bool` | Runs the request in the background, useful for data storage and triggering dashboard crawls. No effect if `storageless` is set. | `txt` (str): **Optional**. The path to the text file you want to search. This argument is only required if the tool was not initialized with a specific text file; otherwise, the search will be conducted within the initially provided text file. The VisionTool requires the following arguments: | Argument | Type | Description | | :------------------- | :------- | :------------------------------------------------------------------------------- | | **image\\_path\\_url** | `string` | **Mandatory**. The path to the image file from which text needs to be extracted. |\n\n`website`: An optional argument intended to specify the website URL for focused searches. This argument is designed to enhance the tool's flexibility by allowing targeted searches when necessary.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "| **request\\_timeout** | `int` | Timeout in seconds for requests (5-60). Default is `30`. | | **run\\_in\\_background** | `bool` | Runs the request in the background, useful for data storage and triggering dashboard crawls. No effect if `storageless` is set. | `txt` (str): **Optional**. The path to the text file you want to search. This argument is only required if the tool was not initialized with a specific text file; otherwise, the search will be conducted within the initially provided text file. The VisionTool requires the following arguments: | Argument | Type | Description | | :------------------- | :------- | :------------------------------------------------------------------------------- | | **image\\_path\\_url** | `string` | **Mandatory**. The path to the image file from which text needs to be extracted. | `website`: An optional argument intended to specify the website URL for focused searches. This argument is designed to enhance the tool's flexibility by allowing targeted searches when necessary.\n\n`xml`: This is the path to the XML file you wish to search.\nIt is an optional parameter during the tool's initialization but must be provided either at initialization or as part of the `run` method's arguments to execute a search.",
      "title": "Arguments",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`XMLSearchTool`",
          "level": 1
        },
        {
          "title": "Arguments",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`XMLSearchTool`",
            "level": 1
          },
          {
            "title": "Arguments",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `XMLSearchTool` > Arguments"
      },
      "enhanced_content": "Context: Changelog > `XMLSearchTool` > Arguments\n\n## Arguments\n\n| **request\\_timeout** | `int` | Timeout in seconds for requests (5-60). Default is `30`. | | **run\\_in\\_background** | `bool` | Runs the request in the background, useful for data storage and triggering dashboard crawls. No effect if `storageless` is set. | `txt` (str): **Optional**. The path to the text file you want to search. This argument is only required if the tool was not initialized with a specific text file; otherwise, the search will be conducted within the initially provided text file. The VisionTool requires the following arguments: | Argument | Type | Description | | :------------------- | :------- | :------------------------------------------------------------------------------- | | **image\\_path\\_url** | `string` | **Mandatory**. The path to the image file from which text needs to be extracted. | `website`: An optional argument intended to specify the website URL for focused searches. This argument is designed to enhance the tool's flexibility by allowing targeted searches when necessary.\n\n`xml`: This is the path to the XML file you wish to search.\nIt is an optional parameter during the tool's initialization but must be provided either at initialization or as part of the `run` method's arguments to execute a search.",
      "formatted_path": "Changelog > `XMLSearchTool` > Arguments",
      "enhanced_text": "Context: Changelog > `XMLSearchTool` > Arguments\n\n Arguments\n\n| **request\\_timeout** | `int` | Timeout in seconds for requests (5-60). Default is `30`. | | **run\\_in\\_background** | `bool` | Runs the request in the background, useful for data storage and triggering dashboard crawls. No effect if `storageless` is set. | `txt` (str): **Optional**. The path to the text file you want to search. This argument is only required if the tool was not initialized with a specific text file; otherwise, the search will be conducted within the initially provided text file. The VisionTool requires the following arguments: | Argument | Type | Description | | :------------------- | :------- | :------------------------------------------------------------------------------- | | **image\\_path\\_url** | `string` | **Mandatory**. The path to the image file from which text needs to be extracted. | `website`: An optional argument intended to specify the website URL for focused searches. This argument is designed to enhance the tool's flexibility by allowing targeted searches when necessary.\n\n`xml`: This is the path to the XML file you wish to search.\nIt is an optional parameter during the tool's initialization but must be provided either at initialization or as part of the `run` method's arguments to execute a search.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "tool = CodeDocsSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`XMLSearchTool`",
          "level": 1
        },
        {
          "title": "Custom model and embeddings",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`XMLSearchTool`",
            "level": 1
          },
          {
            "title": "Custom model and embeddings",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `XMLSearchTool` > Custom model and embeddings"
      },
      "enhanced_content": "Context: Changelog > `XMLSearchTool` > Custom model and embeddings\n\ntool = CodeDocsSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)",
      "formatted_path": "Changelog > `XMLSearchTool` > Custom model and embeddings",
      "enhanced_text": "Context: Changelog > `XMLSearchTool` > Custom model and embeddings\n\ntool = CodeDocsSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)"
    },
    {
      "content": "tool = CSVSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`XMLSearchTool`",
          "level": 1
        },
        {
          "title": "Custom model and embeddings",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`XMLSearchTool`",
            "level": 1
          },
          {
            "title": "Custom model and embeddings",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `XMLSearchTool` > Custom model and embeddings"
      },
      "enhanced_content": "Context: Changelog > `XMLSearchTool` > Custom model and embeddings\n\ntool = CSVSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)",
      "formatted_path": "Changelog > `XMLSearchTool` > Custom model and embeddings",
      "enhanced_text": "Context: Changelog > `XMLSearchTool` > Custom model and embeddings\n\ntool = CSVSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)"
    },
    {
      "content": "tool = DOCXSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`XMLSearchTool`",
          "level": 1
        },
        {
          "title": "Custom model and embeddings",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`XMLSearchTool`",
            "level": 1
          },
          {
            "title": "Custom model and embeddings",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `XMLSearchTool` > Custom model and embeddings"
      },
      "enhanced_content": "Context: Changelog > `XMLSearchTool` > Custom model and embeddings\n\ntool = DOCXSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)",
      "formatted_path": "Changelog > `XMLSearchTool` > Custom model and embeddings",
      "enhanced_text": "Context: Changelog > `XMLSearchTool` > Custom model and embeddings\n\ntool = DOCXSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)"
    },
    {
      "content": "tool = GithubSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`XMLSearchTool`",
          "level": 1
        },
        {
          "title": "Custom model and embeddings",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`XMLSearchTool`",
            "level": 1
          },
          {
            "title": "Custom model and embeddings",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `XMLSearchTool` > Custom model and embeddings"
      },
      "enhanced_content": "Context: Changelog > `XMLSearchTool` > Custom model and embeddings\n\ntool = GithubSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)",
      "formatted_path": "Changelog > `XMLSearchTool` > Custom model and embeddings",
      "enhanced_text": "Context: Changelog > `XMLSearchTool` > Custom model and embeddings\n\ntool = GithubSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)"
    },
    {
      "content": "tool = MySQLSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\",\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`XMLSearchTool`",
          "level": 1
        },
        {
          "title": "Custom model and embeddings",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`XMLSearchTool`",
            "level": 1
          },
          {
            "title": "Custom model and embeddings",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `XMLSearchTool` > Custom model and embeddings"
      },
      "enhanced_content": "Context: Changelog > `XMLSearchTool` > Custom model and embeddings\n\ntool = MySQLSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\",\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)",
      "formatted_path": "Changelog > `XMLSearchTool` > Custom model and embeddings",
      "enhanced_text": "Context: Changelog > `XMLSearchTool` > Custom model and embeddings\n\ntool = MySQLSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\",\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)"
    },
    {
      "content": "tool = PDFSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`XMLSearchTool`",
          "level": 1
        },
        {
          "title": "Custom model and embeddings",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`XMLSearchTool`",
            "level": 1
          },
          {
            "title": "Custom model and embeddings",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `XMLSearchTool` > Custom model and embeddings"
      },
      "enhanced_content": "Context: Changelog > `XMLSearchTool` > Custom model and embeddings\n\ntool = PDFSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)",
      "formatted_path": "Changelog > `XMLSearchTool` > Custom model and embeddings",
      "enhanced_text": "Context: Changelog > `XMLSearchTool` > Custom model and embeddings\n\ntool = PDFSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)"
    },
    {
      "content": "tool = TXTSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`XMLSearchTool`",
          "level": 1
        },
        {
          "title": "Custom model and embeddings",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`XMLSearchTool`",
            "level": 1
          },
          {
            "title": "Custom model and embeddings",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `XMLSearchTool` > Custom model and embeddings"
      },
      "enhanced_content": "Context: Changelog > `XMLSearchTool` > Custom model and embeddings\n\ntool = TXTSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)",
      "formatted_path": "Changelog > `XMLSearchTool` > Custom model and embeddings",
      "enhanced_text": "Context: Changelog > `XMLSearchTool` > Custom model and embeddings\n\ntool = TXTSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)"
    },
    {
      "content": "tool = XMLSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`XMLSearchTool`",
          "level": 1
        },
        {
          "title": "Custom model and embeddings",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`XMLSearchTool`",
            "level": 1
          },
          {
            "title": "Custom model and embeddings",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `XMLSearchTool` > Custom model and embeddings"
      },
      "enhanced_content": "Context: Changelog > `XMLSearchTool` > Custom model and embeddings\n\ntool = XMLSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)",
      "formatted_path": "Changelog > `XMLSearchTool` > Custom model and embeddings",
      "enhanced_text": "Context: Changelog > `XMLSearchTool` > Custom model and embeddings\n\ntool = XMLSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)"
    },
    {
      "content": "Source: https://docs.crewai.com/tools/youtubechannelsearchtool The `YoutubeChannelSearchTool` is designed to perform a RAG (Retrieval-Augmented Generation) search within the content of a Youtube channel.",
      "title": "YouTube Channel RAG Search",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "YouTube Channel RAG Search",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "YouTube Channel RAG Search",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > YouTube Channel RAG Search"
      },
      "enhanced_content": "Context: Changelog > YouTube Channel RAG Search\n\n# YouTube Channel RAG Search\n\nSource: https://docs.crewai.com/tools/youtubechannelsearchtool The `YoutubeChannelSearchTool` is designed to perform a RAG (Retrieval-Augmented Generation) search within the content of a Youtube channel.",
      "formatted_path": "Changelog > YouTube Channel RAG Search",
      "enhanced_text": "Context: Changelog > YouTube Channel RAG Search\n\n YouTube Channel RAG Search\n\nSource: https://docs.crewai.com/tools/youtubechannelsearchtool The `YoutubeChannelSearchTool` is designed to perform a RAG (Retrieval-Augmented Generation) search within the content of a Youtube channel."
    },
    {
      "content": "Source: https://docs.crewai.com/tools/youtubevideosearchtool The `YoutubeVideoSearchTool` is designed to perform a RAG (Retrieval-Augmented Generation) search within the content of a Youtube video.",
      "title": "YouTube Video RAG Search",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "YouTube Video RAG Search",
          "level": 1
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "YouTube Video RAG Search",
            "level": 1
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > YouTube Video RAG Search"
      },
      "enhanced_content": "Context: Changelog > YouTube Video RAG Search\n\n# YouTube Video RAG Search\n\nSource: https://docs.crewai.com/tools/youtubevideosearchtool The `YoutubeVideoSearchTool` is designed to perform a RAG (Retrieval-Augmented Generation) search within the content of a Youtube video.",
      "formatted_path": "Changelog > YouTube Video RAG Search",
      "enhanced_text": "Context: Changelog > YouTube Video RAG Search\n\n YouTube Video RAG Search\n\nSource: https://docs.crewai.com/tools/youtubevideosearchtool The `YoutubeVideoSearchTool` is designed to perform a RAG (Retrieval-Augmented Generation) search within the content of a Youtube video."
    },
    {
      "content": "The `AIMindTool` is a wrapper around [AI-Minds](https://mindsdb.com/minds) provided by [MindsDB](https://mindsdb.com/). It allows you to query data sources in natural language by simply configuring their connection parameters. This tool is useful when you need answers to questions from your data stored in various data sources including PostgreSQL, MySQL, MariaDB, ClickHouse, Snowflake, and Google BigQuery. Minds are AI systems that work similarly to large language models (LLMs) but go beyond by answering any question from any data. This is accomplished by: Selecting the most relevant data for an answer using parametric search Understanding the meaning and providing responses within the correct context through semantic search Delivering precise answers by analyzing data and using machine learning (ML) models",
      "title": "Description",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Description",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Description",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 2,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n## Description\n\nThe `AIMindTool` is a wrapper around [AI-Minds](https://mindsdb.com/minds) provided by [MindsDB](https://mindsdb.com/). It allows you to query data sources in natural language by simply configuring their connection parameters. This tool is useful when you need answers to questions from your data stored in various data sources including PostgreSQL, MySQL, MariaDB, ClickHouse, Snowflake, and Google BigQuery. Minds are AI systems that work similarly to large language models (LLMs) but go beyond by answering any question from any data. This is accomplished by: Selecting the most relevant data for an answer using parametric search Understanding the meaning and providing responses within the correct context through semantic search Delivering precise answers by analyzing data and using machine learning (ML) models",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n Description\n\nThe `AIMindTool` is a wrapper around [AI-Minds](https://mindsdb.com/minds) provided by [MindsDB](https://mindsdb.com/). It allows you to query data sources in natural language by simply configuring their connection parameters. This tool is useful when you need answers to questions from your data stored in various data sources including PostgreSQL, MySQL, MariaDB, ClickHouse, Snowflake, and Google BigQuery. Minds are AI systems that work similarly to large language models (LLMs) but go beyond by answering any question from any data. This is accomplished by: Selecting the most relevant data for an answer using parametric search Understanding the meaning and providing responses within the correct context through semantic search Delivering precise answers by analyzing data and using machine learning (ML) models\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "The `ApifyActorsTool` connects [Apify Actors](https://apify.com/actors), cloud-based programs for web scraping and automation, to your CrewAI workflows.\nUse any of the 4,000+ Actors on [Apify Store](https://apify.com/store) for use cases such as extracting data from social media, search engines, online maps, e-commerce sites, travel portals, or general websites. For details, see the [Apify CrewAI integration](https://docs.apify.com/platform/integrations/crewai) in Apify documentation.\n\nThis tool is designed to perform web searches using the Brave Search API. It allows you to search the internet with a specified query and retrieve relevant results. The tool supports customizable result counts and country-specific searches.",
      "title": "Description",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Description",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Description",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 3,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n## Description\n\nThe `ApifyActorsTool` connects [Apify Actors](https://apify.com/actors), cloud-based programs for web scraping and automation, to your CrewAI workflows.\nUse any of the 4,000+ Actors on [Apify Store](https://apify.com/store) for use cases such as extracting data from social media, search engines, online maps, e-commerce sites, travel portals, or general websites. For details, see the [Apify CrewAI integration](https://docs.apify.com/platform/integrations/crewai) in Apify documentation.\n\nThis tool is designed to perform web searches using the Brave Search API. It allows you to search the internet with a specified query and retrieve relevant results. The tool supports customizable result counts and country-specific searches.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n Description\n\nThe `ApifyActorsTool` connects [Apify Actors](https://apify.com/actors), cloud-based programs for web scraping and automation, to your CrewAI workflows.\nUse any of the 4,000+ Actors on [Apify Store](https://apify.com/store) for use cases such as extracting data from social media, search engines, online maps, e-commerce sites, travel portals, or general websites. For details, see the [Apify CrewAI integration](https://docs.apify.com/platform/integrations/crewai) in Apify documentation.\n\nThis tool is designed to perform web searches using the Brave Search API. It allows you to search the internet with a specified query and retrieve relevant results. The tool supports customizable result counts and country-specific searches.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "[Browserbase](https://browserbase.com) is a developer platform to reliably run, manage, and monitor headless browsers. Power your AI data retrievals with: [Serverless Infrastructure](https://docs.browserbase.com/under-the-hood) providing reliable browsers to extract data from complex UIs [Stealth Mode](https://docs.browserbase.com/features/stealth-mode) with included fingerprinting tactics and automatic captcha solving [Session Debugger](https://docs.browserbase.com/features/sessions) to inspect your Browser Session with networks timeline and logs [Live Debug](https://docs.browserbase.com/guides/session-debug-connection/browser-remote-control) to quickly debug your automation",
      "title": "Description",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Description",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Description",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 5,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n## Description\n\n[Browserbase](https://browserbase.com) is a developer platform to reliably run, manage, and monitor headless browsers. Power your AI data retrievals with: [Serverless Infrastructure](https://docs.browserbase.com/under-the-hood) providing reliable browsers to extract data from complex UIs [Stealth Mode](https://docs.browserbase.com/features/stealth-mode) with included fingerprinting tactics and automatic captcha solving [Session Debugger](https://docs.browserbase.com/features/sessions) to inspect your Browser Session with networks timeline and logs [Live Debug](https://docs.browserbase.com/guides/session-debug-connection/browser-remote-control) to quickly debug your automation",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n Description\n\n[Browserbase](https://browserbase.com) is a developer platform to reliably run, manage, and monitor headless browsers. Power your AI data retrievals with: [Serverless Infrastructure](https://docs.browserbase.com/under-the-hood) providing reliable browsers to extract data from complex UIs [Stealth Mode](https://docs.browserbase.com/features/stealth-mode) with included fingerprinting tactics and automatic captcha solving [Session Debugger](https://docs.browserbase.com/features/sessions) to inspect your Browser Session with networks timeline and logs [Live Debug](https://docs.browserbase.com/guides/session-debug-connection/browser-remote-control) to quickly debug your automation\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "The CodeDocsSearchTool is a powerful RAG (Retrieval-Augmented Generation) tool designed for semantic searches within code documentation.\nIt enables users to efficiently find specific information or topics within code documentation. By providing a `docs_url` during initialization,\nthe tool narrows down the search to that particular documentation site. Alternatively, without a specific `docs_url`,\nit searches across a wide array of code documentation known or discovered throughout its execution, making it versatile for various documentation search needs.\n\nThe `CodeInterpreterTool` enables CrewAI agents to execute Python 3 code that they generate autonomously. The code is run in a secure, isolated Docker container, ensuring safety regardless of the content. This functionality is particularly valuable as it allows agents to create code, execute it, obtain the results, and utilize that information to inform subsequent decisions and actions.",
      "title": "Description",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Description",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Description",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n## Description\n\nThe CodeDocsSearchTool is a powerful RAG (Retrieval-Augmented Generation) tool designed for semantic searches within code documentation.\nIt enables users to efficiently find specific information or topics within code documentation. By providing a `docs_url` during initialization,\nthe tool narrows down the search to that particular documentation site. Alternatively, without a specific `docs_url`,\nit searches across a wide array of code documentation known or discovered throughout its execution, making it versatile for various documentation search needs.\n\nThe `CodeInterpreterTool` enables CrewAI agents to execute Python 3 code that they generate autonomously. The code is run in a secure, isolated Docker container, ensuring safety regardless of the content. This functionality is particularly valuable as it allows agents to create code, execute it, obtain the results, and utilize that information to inform subsequent decisions and actions.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n Description\n\nThe CodeDocsSearchTool is a powerful RAG (Retrieval-Augmented Generation) tool designed for semantic searches within code documentation.\nIt enables users to efficiently find specific information or topics within code documentation. By providing a `docs_url` during initialization,\nthe tool narrows down the search to that particular documentation site. Alternatively, without a specific `docs_url`,\nit searches across a wide array of code documentation known or discovered throughout its execution, making it versatile for various documentation search needs.\n\nThe `CodeInterpreterTool` enables CrewAI agents to execute Python 3 code that they generate autonomously. The code is run in a secure, isolated Docker container, ensuring safety regardless of the content. This functionality is particularly valuable as it allows agents to create code, execute it, obtain the results, and utilize that information to inform subsequent decisions and actions.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "Composio is an integration platform that allows you to connect your AI agents to 250+ tools. Key features include: **Enterprise-Grade Authentication**: Built-in support for OAuth, API Keys, JWT with automatic token refresh **Full Observability**: Detailed tool usage logs, execution timestamps, and more\n\nThis tool is used to perform a RAG (Retrieval-Augmented Generation) search within a CSV file's content. It allows users to semantically search for queries in the content of a specified CSV file.\nThis feature is particularly useful for extracting information from large CSV datasets where traditional search methods might be inefficient. All tools with \"Search\" in their name, including CSVSearchTool,\nare RAG tools designed for searching different sources of data.",
      "title": "Description",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Description",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Description",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n## Description\n\nComposio is an integration platform that allows you to connect your AI agents to 250+ tools. Key features include: **Enterprise-Grade Authentication**: Built-in support for OAuth, API Keys, JWT with automatic token refresh **Full Observability**: Detailed tool usage logs, execution timestamps, and more\n\nThis tool is used to perform a RAG (Retrieval-Augmented Generation) search within a CSV file's content. It allows users to semantically search for queries in the content of a specified CSV file.\nThis feature is particularly useful for extracting information from large CSV datasets where traditional search methods might be inefficient. All tools with \"Search\" in their name, including CSVSearchTool,\nare RAG tools designed for searching different sources of data.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n Description\n\nComposio is an integration platform that allows you to connect your AI agents to 250+ tools. Key features include: **Enterprise-Grade Authentication**: Built-in support for OAuth, API Keys, JWT with automatic token refresh **Full Observability**: Detailed tool usage logs, execution timestamps, and more\n\nThis tool is used to perform a RAG (Retrieval-Augmented Generation) search within a CSV file's content. It allows users to semantically search for queries in the content of a specified CSV file.\nThis feature is particularly useful for extracting information from large CSV datasets where traditional search methods might be inefficient. All tools with \"Search\" in their name, including CSVSearchTool,\nare RAG tools designed for searching different sources of data.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "This tool is used to give the Agent the ability to generate images using the DALL-E model. It is a transformer-based model that generates images from textual descriptions.\nThis tool allows the Agent to generate images based on the text input provided by the user.\n\nThe DirectoryReadTool is a powerful utility designed to provide a comprehensive listing of directory contents.\nIt can recursively navigate through the specified directory, offering users a detailed enumeration of all files, including those within subdirectories.\nThis tool is crucial for tasks that require a thorough inventory of directory structures or for validating the organization of files within directories.",
      "title": "Description",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Description",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Description",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n## Description\n\nThis tool is used to give the Agent the ability to generate images using the DALL-E model. It is a transformer-based model that generates images from textual descriptions.\nThis tool allows the Agent to generate images based on the text input provided by the user.\n\nThe DirectoryReadTool is a powerful utility designed to provide a comprehensive listing of directory contents.\nIt can recursively navigate through the specified directory, offering users a detailed enumeration of all files, including those within subdirectories.\nThis tool is crucial for tasks that require a thorough inventory of directory structures or for validating the organization of files within directories.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n Description\n\nThis tool is used to give the Agent the ability to generate images using the DALL-E model. It is a transformer-based model that generates images from textual descriptions.\nThis tool allows the Agent to generate images based on the text input provided by the user.\n\nThe DirectoryReadTool is a powerful utility designed to provide a comprehensive listing of directory contents.\nIt can recursively navigate through the specified directory, offering users a detailed enumeration of all files, including those within subdirectories.\nThis tool is crucial for tasks that require a thorough inventory of directory structures or for validating the organization of files within directories.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "The DirectorySearchTool enables semantic search within the content of specified directories, leveraging the Retrieval-Augmented Generation (RAG) methodology for efficient navigation through files. Designed for flexibility, it allows users to dynamically specify search directories at runtime or set a fixed directory during initial setup.\n\nThe `DOCXSearchTool` is a RAG tool designed for semantic searching within DOCX documents.\nIt enables users to effectively search and extract relevant information from DOCX files using query-based searches.\nThis tool is invaluable for data analysis, information management, and research tasks,\nstreamlining the process of finding specific information within large document collections.\n\nThe EXASearchTool is designed to perform a semantic search for a specified query from a text's content across the internet.\nIt utilizes the [exa.ai](https://exa.ai/) API to fetch and display the most relevant search results based on the query provided by the user.",
      "title": "Description",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Description",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Description",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 1,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n## Description\n\nThe DirectorySearchTool enables semantic search within the content of specified directories, leveraging the Retrieval-Augmented Generation (RAG) methodology for efficient navigation through files. Designed for flexibility, it allows users to dynamically specify search directories at runtime or set a fixed directory during initial setup.\n\nThe `DOCXSearchTool` is a RAG tool designed for semantic searching within DOCX documents.\nIt enables users to effectively search and extract relevant information from DOCX files using query-based searches.\nThis tool is invaluable for data analysis, information management, and research tasks,\nstreamlining the process of finding specific information within large document collections.\n\nThe EXASearchTool is designed to perform a semantic search for a specified query from a text's content across the internet.\nIt utilizes the [exa.ai](https://exa.ai/) API to fetch and display the most relevant search results based on the query provided by the user.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n Description\n\nThe DirectorySearchTool enables semantic search within the content of specified directories, leveraging the Retrieval-Augmented Generation (RAG) methodology for efficient navigation through files. Designed for flexibility, it allows users to dynamically specify search directories at runtime or set a fixed directory during initial setup.\n\nThe `DOCXSearchTool` is a RAG tool designed for semantic searching within DOCX documents.\nIt enables users to effectively search and extract relevant information from DOCX files using query-based searches.\nThis tool is invaluable for data analysis, information management, and research tasks,\nstreamlining the process of finding specific information within large document collections.\n\nThe EXASearchTool is designed to perform a semantic search for a specified query from a text's content across the internet.\nIt utilizes the [exa.ai](https://exa.ai/) API to fetch and display the most relevant search results based on the query provided by the user.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "The FileReadTool conceptually represents a suite of functionalities within the crewai\\_tools package aimed at facilitating file reading and content retrieval.\nThis suite includes tools for processing batch text files, reading runtime configuration files, and importing data for analytics.\nIt supports a variety of text-based file formats such as `.txt`, `.csv`, `.json`, and more. Depending on the file type, the suite offers specialized functionality,\nsuch as converting JSON content into a Python dictionary for ease of use.",
      "title": "Description",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Description",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Description",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n## Description\n\nThe FileReadTool conceptually represents a suite of functionalities within the crewai\\_tools package aimed at facilitating file reading and content retrieval.\nThis suite includes tools for processing batch text files, reading runtime configuration files, and importing data for analytics.\nIt supports a variety of text-based file formats such as `.txt`, `.csv`, `.json`, and more. Depending on the file type, the suite offers specialized functionality,\nsuch as converting JSON content into a Python dictionary for ease of use.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n Description\n\nThe FileReadTool conceptually represents a suite of functionalities within the crewai\\_tools package aimed at facilitating file reading and content retrieval.\nThis suite includes tools for processing batch text files, reading runtime configuration files, and importing data for analytics.\nIt supports a variety of text-based file formats such as `.txt`, `.csv`, `.json`, and more. Depending on the file type, the suite offers specialized functionality,\nsuch as converting JSON content into a Python dictionary for ease of use.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "The `FileWriterTool` is a component of the crewai\\_tools package, designed to simplify the process of writing content to files with cross-platform compatibility (Windows, Linux, macOS).\nIt is particularly useful in scenarios such as generating reports, saving logs, creating configuration files, and more.\nThis tool handles path differences across operating systems, supports UTF-8 encoding, and automatically creates directories if they don't exist, making it easier to organize your output reliably across different platforms.\n\n[Firecrawl](https://firecrawl.dev) is a platform for crawling and convert any website into clean markdown or structured data.\n\n[Firecrawl](https://firecrawl.dev) is a platform for crawling and convert any website into clean markdown or structured data.\n\n[Firecrawl](https://firecrawl.dev) is a platform for crawling and convert any website into clean markdown or structured data.",
      "title": "Description",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Description",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Description",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 3,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n## Description\n\nThe `FileWriterTool` is a component of the crewai\\_tools package, designed to simplify the process of writing content to files with cross-platform compatibility (Windows, Linux, macOS).\nIt is particularly useful in scenarios such as generating reports, saving logs, creating configuration files, and more.\nThis tool handles path differences across operating systems, supports UTF-8 encoding, and automatically creates directories if they don't exist, making it easier to organize your output reliably across different platforms.\n\n[Firecrawl](https://firecrawl.dev) is a platform for crawling and convert any website into clean markdown or structured data.\n\n[Firecrawl](https://firecrawl.dev) is a platform for crawling and convert any website into clean markdown or structured data.\n\n[Firecrawl](https://firecrawl.dev) is a platform for crawling and convert any website into clean markdown or structured data.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n Description\n\nThe `FileWriterTool` is a component of the crewai\\_tools package, designed to simplify the process of writing content to files with cross-platform compatibility (Windows, Linux, macOS).\nIt is particularly useful in scenarios such as generating reports, saving logs, creating configuration files, and more.\nThis tool handles path differences across operating systems, supports UTF-8 encoding, and automatically creates directories if they don't exist, making it easier to organize your output reliably across different platforms.\n\n[Firecrawl](https://firecrawl.dev) is a platform for crawling and convert any website into clean markdown or structured data.\n\n[Firecrawl](https://firecrawl.dev) is a platform for crawling and convert any website into clean markdown or structured data.\n\n[Firecrawl](https://firecrawl.dev) is a platform for crawling and convert any website into clean markdown or structured data.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "The GithubSearchTool is a Retrieval-Augmented Generation (RAG) tool specifically designed for conducting semantic searches within GitHub repositories. Utilizing advanced semantic search capabilities, it sifts through code, pull requests, issues, and repositories, making it an essential tool for developers, researchers, or anyone in need of precise information from GitHub.",
      "title": "Description",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Description",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Description",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n## Description\n\nThe GithubSearchTool is a Retrieval-Augmented Generation (RAG) tool specifically designed for conducting semantic searches within GitHub repositories. Utilizing advanced semantic search capabilities, it sifts through code, pull requests, issues, and repositories, making it an essential tool for developers, researchers, or anyone in need of precise information from GitHub.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n Description\n\nThe GithubSearchTool is a Retrieval-Augmented Generation (RAG) tool specifically designed for conducting semantic searches within GitHub repositories. Utilizing advanced semantic search capabilities, it sifts through code, pull requests, issues, and repositories, making it an essential tool for developers, researchers, or anyone in need of precise information from GitHub.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "The `HyperbrowserLoadTool` enables web scraping and crawling using [Hyperbrowser](https://hyperbrowser.ai), a platform for running and scaling headless browsers. This tool allows you to scrape a single page or crawl an entire site, returning the content in properly formatted markdown or HTML. Key Features: Instant Scalability - Spin up hundreds of browser sessions in seconds without infrastructure headaches Simple Integration - Works seamlessly with popular tools like Puppeteer and Playwright Powerful APIs - Easy to use APIs for scraping/crawling any site Bypass Anti-Bot Measures - Built-in stealth mode, ad blocking, automatic CAPTCHA solving, and rotating proxies",
      "title": "Description",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Description",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Description",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 1,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n## Description\n\nThe `HyperbrowserLoadTool` enables web scraping and crawling using [Hyperbrowser](https://hyperbrowser.ai), a platform for running and scaling headless browsers. This tool allows you to scrape a single page or crawl an entire site, returning the content in properly formatted markdown or HTML. Key Features: Instant Scalability - Spin up hundreds of browser sessions in seconds without infrastructure headaches Simple Integration - Works seamlessly with popular tools like Puppeteer and Playwright Powerful APIs - Easy to use APIs for scraping/crawling any site Bypass Anti-Bot Measures - Built-in stealth mode, ad blocking, automatic CAPTCHA solving, and rotating proxies",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n Description\n\nThe `HyperbrowserLoadTool` enables web scraping and crawling using [Hyperbrowser](https://hyperbrowser.ai), a platform for running and scaling headless browsers. This tool allows you to scrape a single page or crawl an entire site, returning the content in properly formatted markdown or HTML. Key Features: Instant Scalability - Spin up hundreds of browser sessions in seconds without infrastructure headaches Simple Integration - Works seamlessly with popular tools like Puppeteer and Playwright Powerful APIs - Easy to use APIs for scraping/crawling any site Bypass Anti-Bot Measures - Built-in stealth mode, ad blocking, automatic CAPTCHA solving, and rotating proxies\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "The JSONSearchTool is designed to facilitate efficient and precise searches within JSON file contents. It utilizes a RAG (Retrieve and Generate) search mechanism, allowing users to specify a JSON path for targeted searches within a particular JSON file. This capability significantly improves the accuracy and relevance of search results.\n\nThe `LinkupSearchTool` provides the ability to query the Linkup API for contextual information and retrieve structured results. This tool is ideal for enriching workflows with up-to-date and reliable information from Linkup, allowing agents to access relevant data during their tasks.\n\nThe `LlamaIndexTool` is designed to be a general wrapper around LlamaIndex tools and query engines, enabling you to leverage LlamaIndex resources in terms of RAG/agentic pipelines as tools to plug into CrewAI agents. This tool allows you to seamlessly integrate LlamaIndex's powerful data processing and retrieval capabilities into your CrewAI workflows.",
      "title": "Description",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Description",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Description",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n## Description\n\nThe JSONSearchTool is designed to facilitate efficient and precise searches within JSON file contents. It utilizes a RAG (Retrieve and Generate) search mechanism, allowing users to specify a JSON path for targeted searches within a particular JSON file. This capability significantly improves the accuracy and relevance of search results.\n\nThe `LinkupSearchTool` provides the ability to query the Linkup API for contextual information and retrieve structured results. This tool is ideal for enriching workflows with up-to-date and reliable information from Linkup, allowing agents to access relevant data during their tasks.\n\nThe `LlamaIndexTool` is designed to be a general wrapper around LlamaIndex tools and query engines, enabling you to leverage LlamaIndex resources in terms of RAG/agentic pipelines as tools to plug into CrewAI agents. This tool allows you to seamlessly integrate LlamaIndex's powerful data processing and retrieval capabilities into your CrewAI workflows.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n Description\n\nThe JSONSearchTool is designed to facilitate efficient and precise searches within JSON file contents. It utilizes a RAG (Retrieve and Generate) search mechanism, allowing users to specify a JSON path for targeted searches within a particular JSON file. This capability significantly improves the accuracy and relevance of search results.\n\nThe `LinkupSearchTool` provides the ability to query the Linkup API for contextual information and retrieve structured results. This tool is ideal for enriching workflows with up-to-date and reliable information from Linkup, allowing agents to access relevant data during their tasks.\n\nThe `LlamaIndexTool` is designed to be a general wrapper around LlamaIndex tools and query engines, enabling you to leverage LlamaIndex resources in terms of RAG/agentic pipelines as tools to plug into CrewAI agents. This tool allows you to seamlessly integrate LlamaIndex's powerful data processing and retrieval capabilities into your CrewAI workflows.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "The MDX Search Tool is a component of the `crewai_tools` package aimed at facilitating advanced markdown language extraction. It enables users to effectively search and extract relevant information from MD files using query-based searches. This tool is invaluable for data analysis, information management, and research tasks, streamlining the process of finding specific information within large document collections.\n\nThe `MultiOnTool` is designed to wrap [MultiOn's](https://docs.multion.ai/welcome) web browsing capabilities, enabling CrewAI agents to control web browsers using natural language instructions. This tool facilitates seamless web browsing, making it an essential asset for projects requiring dynamic web data interaction and automation of web-based tasks.",
      "title": "Description",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Description",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Description",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 1,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n## Description\n\nThe MDX Search Tool is a component of the `crewai_tools` package aimed at facilitating advanced markdown language extraction. It enables users to effectively search and extract relevant information from MD files using query-based searches. This tool is invaluable for data analysis, information management, and research tasks, streamlining the process of finding specific information within large document collections.\n\nThe `MultiOnTool` is designed to wrap [MultiOn's](https://docs.multion.ai/welcome) web browsing capabilities, enabling CrewAI agents to control web browsers using natural language instructions. This tool facilitates seamless web browsing, making it an essential asset for projects requiring dynamic web data interaction and automation of web-based tasks.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n Description\n\nThe MDX Search Tool is a component of the `crewai_tools` package aimed at facilitating advanced markdown language extraction. It enables users to effectively search and extract relevant information from MD files using query-based searches. This tool is invaluable for data analysis, information management, and research tasks, streamlining the process of finding specific information within large document collections.\n\nThe `MultiOnTool` is designed to wrap [MultiOn's](https://docs.multion.ai/welcome) web browsing capabilities, enabling CrewAI agents to control web browsers using natural language instructions. This tool facilitates seamless web browsing, making it an essential asset for projects requiring dynamic web data interaction and automation of web-based tasks.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "This tool is designed to facilitate semantic searches within MySQL database tables. Leveraging the RAG (Retrieve and Generate) technology,\nthe MySQLSearchTool provides users with an efficient means of querying database table content, specifically tailored for MySQL databases.\nIt simplifies the process of finding relevant data through semantic search queries, making it an invaluable resource for users needing\nto perform advanced queries on extensive datasets within a MySQL database.",
      "title": "Description",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Description",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Description",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n## Description\n\nThis tool is designed to facilitate semantic searches within MySQL database tables. Leveraging the RAG (Retrieve and Generate) technology,\nthe MySQLSearchTool provides users with an efficient means of querying database table content, specifically tailored for MySQL databases.\nIt simplifies the process of finding relevant data through semantic search queries, making it an invaluable resource for users needing\nto perform advanced queries on extensive datasets within a MySQL database.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n Description\n\nThis tool is designed to facilitate semantic searches within MySQL database tables. Leveraging the RAG (Retrieve and Generate) technology,\nthe MySQLSearchTool provides users with an efficient means of querying database table content, specifically tailored for MySQL databases.\nIt simplifies the process of finding relevant data through semantic search queries, making it an invaluable resource for users needing\nto perform advanced queries on extensive datasets within a MySQL database.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "This tool is used to convert natural language to SQL queries. When passsed to the agent it will generate queries and then use them to interact with the database. This enables multiple workflows like having an Agent to access the database fetch information based on the goal and then use the information to generate a response, report or any other output.\nAlong with that proivdes the ability for the Agent to update the database based on its goal. **Attention**: Make sure that the Agent has access to a Read-Replica or that is okay for the Agent to run insert/update queries on the database.",
      "title": "Description",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Description",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Description",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n## Description\n\nThis tool is used to convert natural language to SQL queries. When passsed to the agent it will generate queries and then use them to interact with the database. This enables multiple workflows like having an Agent to access the database fetch information based on the goal and then use the information to generate a response, report or any other output.\nAlong with that proivdes the ability for the Agent to update the database based on its goal. **Attention**: Make sure that the Agent has access to a Read-Replica or that is okay for the Agent to run insert/update queries on the database.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n Description\n\nThis tool is used to convert natural language to SQL queries. When passsed to the agent it will generate queries and then use them to interact with the database. This enables multiple workflows like having an Agent to access the database fetch information based on the goal and then use the information to generate a response, report or any other output.\nAlong with that proivdes the ability for the Agent to update the database based on its goal. **Attention**: Make sure that the Agent has access to a Read-Replica or that is okay for the Agent to run insert/update queries on the database.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "The [Patronus evaluation tools](https://patronus.ai) are designed to enable CrewAI agents to evaluate and score model inputs and outputs using the Patronus AI platform. These tools provide different levels of control over the evaluation process, from allowing agents to select the most appropriate evaluator and criteria to using predefined criteria or custom local evaluators. There are three main Patronus evaluation tools: **PatronusEvalTool**: Allows agents to select the most appropriate evaluator and criteria for the evaluation task. **PatronusPredefinedCriteriaEvalTool**: Uses predefined evaluator and criteria specified by the user. **PatronusLocalEvaluatorTool**: Uses custom function evaluators defined by the user.",
      "title": "Description",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Description",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Description",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 1,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n## Description\n\nThe [Patronus evaluation tools](https://patronus.ai) are designed to enable CrewAI agents to evaluate and score model inputs and outputs using the Patronus AI platform. These tools provide different levels of control over the evaluation process, from allowing agents to select the most appropriate evaluator and criteria to using predefined criteria or custom local evaluators. There are three main Patronus evaluation tools: **PatronusEvalTool**: Allows agents to select the most appropriate evaluator and criteria for the evaluation task. **PatronusPredefinedCriteriaEvalTool**: Uses predefined evaluator and criteria specified by the user. **PatronusLocalEvaluatorTool**: Uses custom function evaluators defined by the user.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n Description\n\nThe [Patronus evaluation tools](https://patronus.ai) are designed to enable CrewAI agents to evaluate and score model inputs and outputs using the Patronus AI platform. These tools provide different levels of control over the evaluation process, from allowing agents to select the most appropriate evaluator and criteria to using predefined criteria or custom local evaluators. There are three main Patronus evaluation tools: **PatronusEvalTool**: Allows agents to select the most appropriate evaluator and criteria for the evaluation task. **PatronusPredefinedCriteriaEvalTool**: Uses predefined evaluator and criteria specified by the user. **PatronusLocalEvaluatorTool**: Uses custom function evaluators defined by the user.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "The PDFSearchTool is a RAG tool designed for semantic searches within PDF content. It allows for inputting a search query and a PDF document, leveraging advanced search techniques to find relevant content efficiently.\nThis capability makes it especially useful for extracting specific information from large PDF files quickly.\n\nThe PGSearchTool is envisioned as a powerful tool for facilitating semantic searches within PostgreSQL database tables. By leveraging advanced Retrieve and Generate (RAG) technology,\nit aims to provide an efficient means for querying database table content, specifically tailored for PostgreSQL databases.\nThe tool's goal is to simplify the process of finding relevant data through semantic search queries, offering a valuable resource for users needing to conduct advanced queries on\nextensive datasets within a PostgreSQL environment.",
      "title": "Description",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Description",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Description",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n## Description\n\nThe PDFSearchTool is a RAG tool designed for semantic searches within PDF content. It allows for inputting a search query and a PDF document, leveraging advanced search techniques to find relevant content efficiently.\nThis capability makes it especially useful for extracting specific information from large PDF files quickly.\n\nThe PGSearchTool is envisioned as a powerful tool for facilitating semantic searches within PostgreSQL database tables. By leveraging advanced Retrieve and Generate (RAG) technology,\nit aims to provide an efficient means for querying database table content, specifically tailored for PostgreSQL databases.\nThe tool's goal is to simplify the process of finding relevant data through semantic search queries, offering a valuable resource for users needing to conduct advanced queries on\nextensive datasets within a PostgreSQL environment.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n Description\n\nThe PDFSearchTool is a RAG tool designed for semantic searches within PDF content. It allows for inputting a search query and a PDF document, leveraging advanced search techniques to find relevant content efficiently.\nThis capability makes it especially useful for extracting specific information from large PDF files quickly.\n\nThe PGSearchTool is envisioned as a powerful tool for facilitating semantic searches within PostgreSQL database tables. By leveraging advanced Retrieve and Generate (RAG) technology,\nit aims to provide an efficient means for querying database table content, specifically tailored for PostgreSQL databases.\nThe tool's goal is to simplify the process of finding relevant data through semantic search queries, offering a valuable resource for users needing to conduct advanced queries on\nextensive datasets within a PostgreSQL environment.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "The `RagTool` is designed to answer questions by leveraging the power of Retrieval-Augmented Generation (RAG) through EmbedChain.\nIt provides a dynamic knowledge base that can be queried to retrieve relevant information from various data sources.\nThis tool is particularly useful for applications that require access to a vast array of information and need to provide contextually relevant answers.\n\nThe `S3ReaderTool` is designed to read files from Amazon S3 buckets. This tool allows CrewAI agents to access and retrieve content stored in S3, making it ideal for workflows that require reading data, configuration files, or any other content stored in AWS S3 storage.\n\nThe `S3WriterTool` is designed to write content to files in Amazon S3 buckets. This tool allows CrewAI agents to create or update files in S3, making it ideal for workflows that require storing data, saving configuration files, or persisting any other content to AWS S3 storage.",
      "title": "Description",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Description",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Description",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n## Description\n\nThe `RagTool` is designed to answer questions by leveraging the power of Retrieval-Augmented Generation (RAG) through EmbedChain.\nIt provides a dynamic knowledge base that can be queried to retrieve relevant information from various data sources.\nThis tool is particularly useful for applications that require access to a vast array of information and need to provide contextually relevant answers.\n\nThe `S3ReaderTool` is designed to read files from Amazon S3 buckets. This tool allows CrewAI agents to access and retrieve content stored in S3, making it ideal for workflows that require reading data, configuration files, or any other content stored in AWS S3 storage.\n\nThe `S3WriterTool` is designed to write content to files in Amazon S3 buckets. This tool allows CrewAI agents to create or update files in S3, making it ideal for workflows that require storing data, saving configuration files, or persisting any other content to AWS S3 storage.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n Description\n\nThe `RagTool` is designed to answer questions by leveraging the power of Retrieval-Augmented Generation (RAG) through EmbedChain.\nIt provides a dynamic knowledge base that can be queried to retrieve relevant information from various data sources.\nThis tool is particularly useful for applications that require access to a vast array of information and need to provide contextually relevant answers.\n\nThe `S3ReaderTool` is designed to read files from Amazon S3 buckets. This tool allows CrewAI agents to access and retrieve content stored in S3, making it ideal for workflows that require reading data, configuration files, or any other content stored in AWS S3 storage.\n\nThe `S3WriterTool` is designed to write content to files in Amazon S3 buckets. This tool allows CrewAI agents to create or update files in S3, making it ideal for workflows that require storing data, saving configuration files, or persisting any other content to AWS S3 storage.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "The `ScrapeElementFromWebsiteTool` is designed to extract specific elements from websites using CSS selectors. This tool allows CrewAI agents to scrape targeted content from web pages, making it useful for data extraction tasks where only specific parts of a webpage are needed.\n\nThe `ScrapegraphScrapeTool` is designed to leverage Scrapegraph AI's SmartScraper API to intelligently extract content from websites. This tool provides advanced web scraping capabilities with AI-powered content extraction, making it ideal for targeted data collection and content analysis tasks. Unlike traditional web scrapers, it can understand the context and structure of web pages to extract the most relevant information based on natural language prompts.",
      "title": "Description",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Description",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Description",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n## Description\n\nThe `ScrapeElementFromWebsiteTool` is designed to extract specific elements from websites using CSS selectors. This tool allows CrewAI agents to scrape targeted content from web pages, making it useful for data extraction tasks where only specific parts of a webpage are needed.\n\nThe `ScrapegraphScrapeTool` is designed to leverage Scrapegraph AI's SmartScraper API to intelligently extract content from websites. This tool provides advanced web scraping capabilities with AI-powered content extraction, making it ideal for targeted data collection and content analysis tasks. Unlike traditional web scrapers, it can understand the context and structure of web pages to extract the most relevant information based on natural language prompts.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n Description\n\nThe `ScrapeElementFromWebsiteTool` is designed to extract specific elements from websites using CSS selectors. This tool allows CrewAI agents to scrape targeted content from web pages, making it useful for data extraction tasks where only specific parts of a webpage are needed.\n\nThe `ScrapegraphScrapeTool` is designed to leverage Scrapegraph AI's SmartScraper API to intelligently extract content from websites. This tool provides advanced web scraping capabilities with AI-powered content extraction, making it ideal for targeted data collection and content analysis tasks. Unlike traditional web scrapers, it can understand the context and structure of web pages to extract the most relevant information based on natural language prompts.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "A tool designed to extract and read the content of a specified website. It is capable of handling various types of web pages by making HTTP requests and parsing the received HTML content.\nThis tool can be particularly useful for web scraping tasks, data collection, or extracting specific information from websites.\n\nThe `ScrapflyScrapeWebsiteTool` is designed to leverage [Scrapfly](https://scrapfly.io/)'s web scraping API to extract content from websites. This tool provides advanced web scraping capabilities with headless browser support, proxies, and anti-bot bypass features. It allows for extracting web page data in various formats, including raw HTML, markdown, and plain text, making it ideal for a wide range of web scraping tasks.",
      "title": "Description",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Description",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Description",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 1,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n## Description\n\nA tool designed to extract and read the content of a specified website. It is capable of handling various types of web pages by making HTTP requests and parsing the received HTML content.\nThis tool can be particularly useful for web scraping tasks, data collection, or extracting specific information from websites.\n\nThe `ScrapflyScrapeWebsiteTool` is designed to leverage [Scrapfly](https://scrapfly.io/)'s web scraping API to extract content from websites. This tool provides advanced web scraping capabilities with headless browser support, proxies, and anti-bot bypass features. It allows for extracting web page data in various formats, including raw HTML, markdown, and plain text, making it ideal for a wide range of web scraping tasks.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n Description\n\nA tool designed to extract and read the content of a specified website. It is capable of handling various types of web pages by making HTTP requests and parsing the received HTML content.\nThis tool can be particularly useful for web scraping tasks, data collection, or extracting specific information from websites.\n\nThe `ScrapflyScrapeWebsiteTool` is designed to leverage [Scrapfly](https://scrapfly.io/)'s web scraping API to extract content from websites. This tool provides advanced web scraping capabilities with headless browser support, proxies, and anti-bot bypass features. It allows for extracting web page data in various formats, including raw HTML, markdown, and plain text, making it ideal for a wide range of web scraping tasks.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "The `SeleniumScrapingTool` is crafted for high-efficiency web scraping tasks.\nIt allows for precise extraction of content from web pages by using CSS selectors to target specific elements.\nIts design caters to a wide range of scraping needs, offering flexibility to work with any provided website URL.\n\nThis tool is designed to perform a semantic search for a specified query from a text's content across the internet. It utilizes the [serper.dev](https://serper.dev) API\nto fetch and display the most relevant search results based on the query provided by the user.\n\nThe `SnowflakeSearchTool` is designed to connect to Snowflake data warehouses and execute SQL queries with advanced features like connection pooling, retry logic, and asynchronous execution. This tool allows CrewAI agents to interact with Snowflake databases, making it ideal for data analysis, reporting, and business intelligence tasks that require access to enterprise data stored in Snowflake.",
      "title": "Description",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Description",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Description",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 1,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n## Description\n\nThe `SeleniumScrapingTool` is crafted for high-efficiency web scraping tasks.\nIt allows for precise extraction of content from web pages by using CSS selectors to target specific elements.\nIts design caters to a wide range of scraping needs, offering flexibility to work with any provided website URL.\n\nThis tool is designed to perform a semantic search for a specified query from a text's content across the internet. It utilizes the [serper.dev](https://serper.dev) API\nto fetch and display the most relevant search results based on the query provided by the user.\n\nThe `SnowflakeSearchTool` is designed to connect to Snowflake data warehouses and execute SQL queries with advanced features like connection pooling, retry logic, and asynchronous execution. This tool allows CrewAI agents to interact with Snowflake databases, making it ideal for data analysis, reporting, and business intelligence tasks that require access to enterprise data stored in Snowflake.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n Description\n\nThe `SeleniumScrapingTool` is crafted for high-efficiency web scraping tasks.\nIt allows for precise extraction of content from web pages by using CSS selectors to target specific elements.\nIts design caters to a wide range of scraping needs, offering flexibility to work with any provided website URL.\n\nThis tool is designed to perform a semantic search for a specified query from a text's content across the internet. It utilizes the [serper.dev](https://serper.dev) API\nto fetch and display the most relevant search results based on the query provided by the user.\n\nThe `SnowflakeSearchTool` is designed to connect to Snowflake data warehouses and execute SQL queries with advanced features like connection pooling, retry logic, and asynchronous execution. This tool allows CrewAI agents to interact with Snowflake databases, making it ideal for data analysis, reporting, and business intelligence tasks that require access to enterprise data stored in Snowflake.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "[Spider](https://spider.cloud/?ref=crewai) is the [fastest](https://github.com/spider-rs/spider/blob/main/benches/BENCHMARKS.md#benchmark-results)\nopen source scraper and crawler that returns LLM-ready data.\nIt converts any website into pure HTML, markdown, metadata or text while enabling you to crawl with custom actions using AI.\n\nThis tool is used to perform a RAG (Retrieval-Augmented Generation) search within the content of a text file.\nIt allows for semantic searching of a query within a specified text file's content,\nmaking it an invaluable resource for quickly extracting information or finding specific sections of text based on the query provided.\n\nThis tool is used to extract text from images. When passed to the agent it will extract the text from the image and then use it to generate a response, report or any other output.\nThe URL or the PATH of the image should be passed to the Agent.",
      "title": "Description",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Description",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Description",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 2,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n## Description\n\n[Spider](https://spider.cloud/?ref=crewai) is the [fastest](https://github.com/spider-rs/spider/blob/main/benches/BENCHMARKS.md#benchmark-results)\nopen source scraper and crawler that returns LLM-ready data.\nIt converts any website into pure HTML, markdown, metadata or text while enabling you to crawl with custom actions using AI.\n\nThis tool is used to perform a RAG (Retrieval-Augmented Generation) search within the content of a text file.\nIt allows for semantic searching of a query within a specified text file's content,\nmaking it an invaluable resource for quickly extracting information or finding specific sections of text based on the query provided.\n\nThis tool is used to extract text from images. When passed to the agent it will extract the text from the image and then use it to generate a response, report or any other output.\nThe URL or the PATH of the image should be passed to the Agent.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n Description\n\n[Spider](https://spider.cloud/?ref=crewai) is the [fastest](https://github.com/spider-rs/spider/blob/main/benches/BENCHMARKS.md#benchmark-results)\nopen source scraper and crawler that returns LLM-ready data.\nIt converts any website into pure HTML, markdown, metadata or text while enabling you to crawl with custom actions using AI.\n\nThis tool is used to perform a RAG (Retrieval-Augmented Generation) search within the content of a text file.\nIt allows for semantic searching of a query within a specified text file's content,\nmaking it an invaluable resource for quickly extracting information or finding specific sections of text based on the query provided.\n\nThis tool is used to extract text from images. When passed to the agent it will extract the text from the image and then use it to generate a response, report or any other output.\nThe URL or the PATH of the image should be passed to the Agent.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "The `WeaviateVectorSearchTool` is specifically crafted for conducting semantic searches within documents stored in a Weaviate vector database. This tool allows you to find semantically similar documents to a given query, leveraging the power of vector embeddings for more accurate and contextually relevant search results. [Weaviate](https://weaviate.io/) is a vector database that stores and queries vector embeddings, enabling semantic search capabilities.",
      "title": "Description",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Description",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Description",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 1,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n## Description\n\nThe `WeaviateVectorSearchTool` is specifically crafted for conducting semantic searches within documents stored in a Weaviate vector database. This tool allows you to find semantically similar documents to a given query, leveraging the power of vector embeddings for more accurate and contextually relevant search results. [Weaviate](https://weaviate.io/) is a vector database that stores and queries vector embeddings, enabling semantic search capabilities.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n Description\n\nThe `WeaviateVectorSearchTool` is specifically crafted for conducting semantic searches within documents stored in a Weaviate vector database. This tool allows you to find semantically similar documents to a given query, leveraging the power of vector embeddings for more accurate and contextually relevant search results. [Weaviate](https://weaviate.io/) is a vector database that stores and queries vector embeddings, enabling semantic search capabilities.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "The WebsiteSearchTool is designed as a concept for conducting semantic searches within the content of websites.\nIt aims to leverage advanced machine learning models like Retrieval-Augmented Generation (RAG) to navigate and extract information from specified URLs efficiently.\nThis tool intends to offer flexibility, allowing users to perform searches across any website or focus on specific websites of interest.\nPlease note, the current implementation details of the WebsiteSearchTool are under development, and its functionalities as described may not yet be accessible.\n\nThe XMLSearchTool is a cutting-edge RAG tool engineered for conducting semantic searches within XML files.\nIdeal for users needing to parse and extract information from XML content efficiently, this tool supports inputting a search query and an optional XML file path.\nBy specifying an XML path, users can target their search more precisely to the content of that file, thereby obtaining more relevant search outcomes.",
      "title": "Description",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Description",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Description",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n## Description\n\nThe WebsiteSearchTool is designed as a concept for conducting semantic searches within the content of websites.\nIt aims to leverage advanced machine learning models like Retrieval-Augmented Generation (RAG) to navigate and extract information from specified URLs efficiently.\nThis tool intends to offer flexibility, allowing users to perform searches across any website or focus on specific websites of interest.\nPlease note, the current implementation details of the WebsiteSearchTool are under development, and its functionalities as described may not yet be accessible.\n\nThe XMLSearchTool is a cutting-edge RAG tool engineered for conducting semantic searches within XML files.\nIdeal for users needing to parse and extract information from XML content efficiently, this tool supports inputting a search query and an optional XML file path.\nBy specifying an XML path, users can target their search more precisely to the content of that file, thereby obtaining more relevant search outcomes.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n Description\n\nThe WebsiteSearchTool is designed as a concept for conducting semantic searches within the content of websites.\nIt aims to leverage advanced machine learning models like Retrieval-Augmented Generation (RAG) to navigate and extract information from specified URLs efficiently.\nThis tool intends to offer flexibility, allowing users to perform searches across any website or focus on specific websites of interest.\nPlease note, the current implementation details of the WebsiteSearchTool are under development, and its functionalities as described may not yet be accessible.\n\nThe XMLSearchTool is a cutting-edge RAG tool engineered for conducting semantic searches within XML files.\nIdeal for users needing to parse and extract information from XML content efficiently, this tool supports inputting a search query and an optional XML file path.\nBy specifying an XML path, users can target their search more precisely to the content of that file, thereby obtaining more relevant search outcomes.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "This tool is designed to perform semantic searches within a specific Youtube channel's content.\nLeveraging the RAG (Retrieval-Augmented Generation) methodology, it provides relevant search results,\nmaking it invaluable for extracting information or finding specific content without the need to manually sift through videos.\nIt streamlines the search process within Youtube channels, catering to researchers, content creators, and viewers seeking specific information or topics.\n\nThis tool is part of the `crewai_tools` package and is designed to perform semantic searches within Youtube video content, utilizing Retrieval-Augmented Generation (RAG) techniques.\nIt is one of several \"Search\" tools in the package that leverage RAG for different sources.\nThe YoutubeVideoSearchTool allows for flexibility in searches; users can search across any Youtube video content without specifying a video URL,\nor they can target their search to a specific Youtube video by providing its URL.",
      "title": "Description",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Description",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Description",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n## Description\n\nThis tool is designed to perform semantic searches within a specific Youtube channel's content.\nLeveraging the RAG (Retrieval-Augmented Generation) methodology, it provides relevant search results,\nmaking it invaluable for extracting information or finding specific content without the need to manually sift through videos.\nIt streamlines the search process within Youtube channels, catering to researchers, content creators, and viewers seeking specific information or topics.\n\nThis tool is part of the `crewai_tools` package and is designed to perform semantic searches within Youtube video content, utilizing Retrieval-Augmented Generation (RAG) techniques.\nIt is one of several \"Search\" tools in the package that leverage RAG for different sources.\nThe YoutubeVideoSearchTool allows for flexibility in searches; users can search across any Youtube video content without specifying a video URL,\nor they can target their search to a specific Youtube video by providing its URL.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Description",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Description\n\n Description\n\nThis tool is designed to perform semantic searches within a specific Youtube channel's content.\nLeveraging the RAG (Retrieval-Augmented Generation) methodology, it provides relevant search results,\nmaking it invaluable for extracting information or finding specific content without the need to manually sift through videos.\nIt streamlines the search process within Youtube channels, catering to researchers, content creators, and viewers seeking specific information or topics.\n\nThis tool is part of the `crewai_tools` package and is designed to perform semantic searches within Youtube video content, utilizing Retrieval-Augmented Generation (RAG) techniques.\nIt is one of several \"Search\" tools in the package that leverage RAG for different sources.\nThe YoutubeVideoSearchTool allows for flexibility in searches; users can search across any Youtube video content without specifying a video URL,\nor they can target their search to a specific Youtube video by providing its URL.\n\nRelated sections:\n- \n- \n"
    },
    {
      "content": "pip install crewai",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install crewai",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install crewai"
    },
    {
      "content": "python3 --version",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npython3 --version",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npython3 --version"
    },
    {
      "content": "uv add minds-sdk",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\nuv add minds-sdk",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\nuv add minds-sdk"
    },
    {
      "content": "uv pip install 'crewai[tools]'",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\nuv pip install 'crewai[tools]'",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\nuv pip install 'crewai[tools]'"
    },
    {
      "content": "uv pip install 'crewai[tools]'",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\nuv pip install 'crewai[tools]'",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\nuv pip install 'crewai[tools]'"
    },
    {
      "content": "pip install 'crewai[tools]'",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'"
    },
    {
      "content": "pip install browserbase 'crewai[tools]'",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install browserbase 'crewai[tools]'",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install browserbase 'crewai[tools]'"
    },
    {
      "content": "pip install 'crewai[tools]'",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'"
    },
    {
      "content": "pip install 'crewai[tools]'",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'"
    },
    {
      "content": "pip install composio-crewai\npip install crewai",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install composio-crewai\npip install crewai",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install composio-crewai\npip install crewai"
    },
    {
      "content": "pip install 'crewai[tools]'",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'"
    },
    {
      "content": "pip install 'crewai[tools]'",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'"
    },
    {
      "content": "pip install 'crewai[tools]'",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'"
    },
    {
      "content": "pip install 'crewai[tools]'",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'"
    },
    {
      "content": "pip install 'crewai[tools]'",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'"
    },
    {
      "content": "pip install 'crewai[tools]'",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'"
    },
    {
      "content": "pip install 'crewai[tools]'",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'"
    },
    {
      "content": "pip install 'crewai[tools]'",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'"
    },
    {
      "content": "pip install firecrawl-py 'crewai[tools]'",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install firecrawl-py 'crewai[tools]'",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install firecrawl-py 'crewai[tools]'"
    },
    {
      "content": "pip install firecrawl-py 'crewai[tools]'",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install firecrawl-py 'crewai[tools]'",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install firecrawl-py 'crewai[tools]'"
    },
    {
      "content": "pip install firecrawl-py 'crewai[tools]'",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install firecrawl-py 'crewai[tools]'",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install firecrawl-py 'crewai[tools]'"
    },
    {
      "content": "pip install 'crewai[tools]'",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'"
    },
    {
      "content": "uv add hyperbrowser",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\nuv add hyperbrowser",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\nuv add hyperbrowser"
    },
    {
      "content": "pip install 'crewai[tools]'",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'"
    },
    {
      "content": "uv add linkup-sdk",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\nuv add linkup-sdk",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\nuv add linkup-sdk"
    },
    {
      "content": "uv add llama-index",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\nuv add llama-index",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\nuv add llama-index"
    },
    {
      "content": "pip install 'crewai[tools]'",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'"
    },
    {
      "content": "uv add multion",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\nuv add multion",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\nuv add multion"
    },
    {
      "content": "pip install 'crewai[tools]'",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'"
    },
    {
      "content": "pip install 'crewai[tools]'",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'"
    },
    {
      "content": "uv add patronus",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\nuv add patronus",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\nuv add patronus"
    },
    {
      "content": "export PATRONUS_API_KEY=\"your_patronus_api_key\"",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\nexport PATRONUS_API_KEY=\"your_patronus_api_key\"",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\nexport PATRONUS_API_KEY=\"your_patronus_api_key\""
    },
    {
      "content": "pip install 'crewai[tools]'",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'"
    },
    {
      "content": "pip install 'crewai[tools]'",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'"
    },
    {
      "content": "uv add qdrant-client",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\nuv add qdrant-client",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\nuv add qdrant-client"
    },
    {
      "content": "uv add boto3",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\nuv add boto3",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\nuv add boto3"
    },
    {
      "content": "uv add boto3",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\nuv add boto3",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\nuv add boto3"
    },
    {
      "content": "uv add requests beautifulsoup4",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\nuv add requests beautifulsoup4",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\nuv add requests beautifulsoup4"
    },
    {
      "content": "uv add scrapegraph-py",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\nuv add scrapegraph-py",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\nuv add scrapegraph-py"
    },
    {
      "content": "export SCRAPEGRAPH_API_KEY=\"your_api_key\"",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\nexport SCRAPEGRAPH_API_KEY=\"your_api_key\"",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\nexport SCRAPEGRAPH_API_KEY=\"your_api_key\""
    },
    {
      "content": "pip install 'crewai[tools]'",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'"
    },
    {
      "content": "uv add scrapfly-sdk",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\nuv add scrapfly-sdk",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\nuv add scrapfly-sdk"
    },
    {
      "content": "pip install 'crewai[tools]'\nuv add selenium webdriver-manager",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'\nuv add selenium webdriver-manager",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'\nuv add selenium webdriver-manager"
    },
    {
      "content": "pip install 'crewai[tools]'",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'"
    },
    {
      "content": "uv add cryptography snowflake-connector-python snowflake-sqlalchemy",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\nuv add cryptography snowflake-connector-python snowflake-sqlalchemy",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\nuv add cryptography snowflake-connector-python snowflake-sqlalchemy"
    },
    {
      "content": "uv sync --extra snowflake",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\nuv sync --extra snowflake",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\nuv sync --extra snowflake"
    },
    {
      "content": "pip install spider-client 'crewai[tools]'",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install spider-client 'crewai[tools]'",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install spider-client 'crewai[tools]'"
    },
    {
      "content": "pip install 'crewai[tools]'",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'"
    },
    {
      "content": "pip install 'crewai[tools]'",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'"
    },
    {
      "content": "uv add weaviate-client",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\nuv add weaviate-client",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\nuv add weaviate-client"
    },
    {
      "content": "pip install 'crewai[tools]'",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'"
    },
    {
      "content": "pip install 'crewai[tools]'",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'"
    },
    {
      "content": "pip install 'crewai[tools]'",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'"
    },
    {
      "content": "pip install 'crewai[tools]'",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Installation",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Installation",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Installation",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Installation\n\npip install 'crewai[tools]'"
    },
    {
      "content": "# Example crew execution\ncrew = Crew(\n    agents=[research_agent, writer_agent],\n    tasks=[research_task, write_article_task],\n    verbose=True\n)\n\ncrew_output = crew.kickoff()\n\n# Accessing the crew output\nprint(f\"Raw Output: {crew_output.raw}\")\nif crew_output.json_dict:\n    print(f\"JSON Output: {json.dumps(crew_output.json_dict, indent=2)}\")\nif crew_output.pydantic:\n    print(f\"Pydantic Output: {crew_output.pydantic}\")\nprint(f\"Tasks Output: {crew_output.tasks_output}\")\nprint(f\"Token Usage: {crew_output.token_usage}\")",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\n# Example crew execution\ncrew = Crew(\n    agents=[research_agent, writer_agent],\n    tasks=[research_task, write_article_task],\n    verbose=True\n)\n\ncrew_output = crew.kickoff()\n\n# Accessing the crew output\nprint(f\"Raw Output: {crew_output.raw}\")\nif crew_output.json_dict:\n    print(f\"JSON Output: {json.dumps(crew_output.json_dict, indent=2)}\")\nif crew_output.pydantic:\n    print(f\"Pydantic Output: {crew_output.pydantic}\")\nprint(f\"Tasks Output: {crew_output.tasks_output}\")\nprint(f\"Token Usage: {crew_output.token_usage}\")",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\n# Example crew execution\ncrew = Crew(\n    agents=[research_agent, writer_agent],\n    tasks=[research_task, write_article_task],\n    verbose=True\n)\n\ncrew_output = crew.kickoff()\n\n# Accessing the crew output\nprint(f\"Raw Output: {crew_output.raw}\")\nif crew_output.json_dict:\n    print(f\"JSON Output: {json.dumps(crew_output.json_dict, indent=2)}\")\nif crew_output.pydantic:\n    print(f\"Pydantic Output: {crew_output.pydantic}\")\nprint(f\"Tasks Output: {crew_output.tasks_output}\")\nprint(f\"Token Usage: {crew_output.token_usage}\")"
    },
    {
      "content": "# Example task\ntask = Task(\n    description='Find and summarize the latest AI news',\n    expected_output='A bullet list summary of the top 5 most important AI news',\n    agent=research_agent,\n    tools=[search_tool]\n)\n\n# Execute the crew\ncrew = Crew(\n    agents=[research_agent],\n    tasks=[task],\n    verbose=True\n)\n\nresult = crew.kickoff()\n\n# Accessing the task output\ntask_output = task.output\n\nprint(f\"Task Description: {task_output.description}\")\nprint(f\"Task Summary: {task_output.summary}\")\nprint(f\"Raw Output: {task_output.raw}\")\nif task_output.json_dict:\n    print(f\"JSON Output: {json.dumps(task_output.json_dict, indent=2)}\")\nif task_output.pydantic:\n    print(f\"Pydantic Output: {task_output.pydantic}\")",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\n# Example task\ntask = Task(\n    description='Find and summarize the latest AI news',\n    expected_output='A bullet list summary of the top 5 most important AI news',\n    agent=research_agent,\n    tools=[search_tool]\n)\n\n# Execute the crew\ncrew = Crew(\n    agents=[research_agent],\n    tasks=[task],\n    verbose=True\n)\n\nresult = crew.kickoff()\n\n# Accessing the task output\ntask_output = task.output\n\nprint(f\"Task Description: {task_output.description}\")\nprint(f\"Task Summary: {task_output.summary}\")\nprint(f\"Raw Output: {task_output.raw}\")\nif task_output.json_dict:\n    print(f\"JSON Output: {json.dumps(task_output.json_dict, indent=2)}\")\nif task_output.pydantic:\n    print(f\"Pydantic Output: {task_output.pydantic}\")",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\n# Example task\ntask = Task(\n    description='Find and summarize the latest AI news',\n    expected_output='A bullet list summary of the top 5 most important AI news',\n    agent=research_agent,\n    tools=[search_tool]\n)\n\n# Execute the crew\ncrew = Crew(\n    agents=[research_agent],\n    tasks=[task],\n    verbose=True\n)\n\nresult = crew.kickoff()\n\n# Accessing the task output\ntask_output = task.output\n\nprint(f\"Task Description: {task_output.description}\")\nprint(f\"Task Summary: {task_output.summary}\")\nprint(f\"Raw Output: {task_output.raw}\")\nif task_output.json_dict:\n    print(f\"JSON Output: {json.dumps(task_output.json_dict, indent=2)}\")\nif task_output.pydantic:\n    print(f\"Pydantic Output: {task_output.pydantic}\")"
    },
    {
      "content": "import os\nfrom crewai import Agent, Task, Crew, Process\n\n# Define your agents\nresearcher = Agent(\n    role=\"Researcher\",\n    goal=\"Conduct thorough research and analysis on AI and AI agents\",\n    backstory=\"You're an expert researcher, specialized in technology, software engineering, AI, and startups. You work as a freelancer and are currently researching for a new client.\",\n    allow_delegation=False,\n)\n\nwriter = Agent(\n    role=\"Senior Writer\",\n    goal=\"Create compelling content about AI and AI agents\",\n    backstory=\"You're a senior writer, specialized in technology, software engineering, AI, and startups. You work as a freelancer and are currently writing content for a new client.\",\n    allow_delegation=False,\n)\n\n# Define your task\ntask = Task(\n    description=\"Generate a list of 5 interesting ideas for an article, then write one captivating paragraph for each idea that showcases the potential of a full article on this topic. Return the list of ideas with their paragraphs and your notes.\",\n    expected_output=\"5 bullet points, each with a paragraph and accompanying notes.\",\n)\n\n# Define the manager agent\nmanager = Agent(\n    role=\"Project Manager\",\n    goal=\"Efficiently manage the crew and ensure high-quality task completion\",\n    backstory=\"You're an experienced project manager, skilled in overseeing complex projects and guiding teams to success. Your role is to coordinate the efforts of the crew members, ensuring that each task is completed on time and to the highest standard.\",\n    allow_delegation=True,\n)\n\n# Instantiate your crew with a custom manager\ncrew = Crew(\n    agents=[researcher, writer],\n    tasks=[task],\n    manager_agent=manager,\n    process=Process.hierarchical,\n)\n\n# Start the crew's work\nresult = crew.kickoff()",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nimport os\nfrom crewai import Agent, Task, Crew, Process\n\n# Define your agents\nresearcher = Agent(\n    role=\"Researcher\",\n    goal=\"Conduct thorough research and analysis on AI and AI agents\",\n    backstory=\"You're an expert researcher, specialized in technology, software engineering, AI, and startups. You work as a freelancer and are currently researching for a new client.\",\n    allow_delegation=False,\n)\n\nwriter = Agent(\n    role=\"Senior Writer\",\n    goal=\"Create compelling content about AI and AI agents\",\n    backstory=\"You're a senior writer, specialized in technology, software engineering, AI, and startups. You work as a freelancer and are currently writing content for a new client.\",\n    allow_delegation=False,\n)\n\n# Define your task\ntask = Task(\n    description=\"Generate a list of 5 interesting ideas for an article, then write one captivating paragraph for each idea that showcases the potential of a full article on this topic. Return the list of ideas with their paragraphs and your notes.\",\n    expected_output=\"5 bullet points, each with a paragraph and accompanying notes.\",\n)\n\n# Define the manager agent\nmanager = Agent(\n    role=\"Project Manager\",\n    goal=\"Efficiently manage the crew and ensure high-quality task completion\",\n    backstory=\"You're an experienced project manager, skilled in overseeing complex projects and guiding teams to success. Your role is to coordinate the efforts of the crew members, ensuring that each task is completed on time and to the highest standard.\",\n    allow_delegation=True,\n)\n\n# Instantiate your crew with a custom manager\ncrew = Crew(\n    agents=[researcher, writer],\n    tasks=[task],\n    manager_agent=manager,\n    process=Process.hierarchical,\n)\n\n# Start the crew's work\nresult = crew.kickoff()",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nimport os\nfrom crewai import Agent, Task, Crew, Process\n\n# Define your agents\nresearcher = Agent(\n    role=\"Researcher\",\n    goal=\"Conduct thorough research and analysis on AI and AI agents\",\n    backstory=\"You're an expert researcher, specialized in technology, software engineering, AI, and startups. You work as a freelancer and are currently researching for a new client.\",\n    allow_delegation=False,\n)\n\nwriter = Agent(\n    role=\"Senior Writer\",\n    goal=\"Create compelling content about AI and AI agents\",\n    backstory=\"You're a senior writer, specialized in technology, software engineering, AI, and startups. You work as a freelancer and are currently writing content for a new client.\",\n    allow_delegation=False,\n)\n\n# Define your task\ntask = Task(\n    description=\"Generate a list of 5 interesting ideas for an article, then write one captivating paragraph for each idea that showcases the potential of a full article on this topic. Return the list of ideas with their paragraphs and your notes.\",\n    expected_output=\"5 bullet points, each with a paragraph and accompanying notes.\",\n)\n\n# Define the manager agent\nmanager = Agent(\n    role=\"Project Manager\",\n    goal=\"Efficiently manage the crew and ensure high-quality task completion\",\n    backstory=\"You're an experienced project manager, skilled in overseeing complex projects and guiding teams to success. Your role is to coordinate the efforts of the crew members, ensuring that each task is completed on time and to the highest standard.\",\n    allow_delegation=True,\n)\n\n# Instantiate your crew with a custom manager\ncrew = Crew(\n    agents=[researcher, writer],\n    tasks=[task],\n    manager_agent=manager,\n    process=Process.hierarchical,\n)\n\n# Start the crew's work\nresult = crew.kickoff()"
    },
    {
      "content": "from crewai_tools import AIMindTool\n\n# Initialize the AIMindTool\naimind_tool = AIMindTool(\n    datasources=[\n        {\n            \"description\": \"house sales data\",\n            \"engine\": \"postgres\",\n            \"connection_data\": {\n                \"user\": \"demo_user\",\n                \"password\": \"demo_password\",\n                \"host\": \"samples.mindsdb.com\",\n                \"port\": 5432,\n                \"database\": \"demo\",\n                \"schema\": \"demo_data\"\n            },\n            \"tables\": [\"house_sales\"]\n        }\n    ]\n)\n\n# Run a natural language query\nresult = aimind_tool.run(\"How many 3 bedroom houses were sold in 2008?\")\nprint(result)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import AIMindTool\n\n# Initialize the AIMindTool\naimind_tool = AIMindTool(\n    datasources=[\n        {\n            \"description\": \"house sales data\",\n            \"engine\": \"postgres\",\n            \"connection_data\": {\n                \"user\": \"demo_user\",\n                \"password\": \"demo_password\",\n                \"host\": \"samples.mindsdb.com\",\n                \"port\": 5432,\n                \"database\": \"demo\",\n                \"schema\": \"demo_data\"\n            },\n            \"tables\": [\"house_sales\"]\n        }\n    ]\n)\n\n# Run a natural language query\nresult = aimind_tool.run(\"How many 3 bedroom houses were sold in 2008?\")\nprint(result)",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import AIMindTool\n\n# Initialize the AIMindTool\naimind_tool = AIMindTool(\n    datasources=[\n        {\n            \"description\": \"house sales data\",\n            \"engine\": \"postgres\",\n            \"connection_data\": {\n                \"user\": \"demo_user\",\n                \"password\": \"demo_password\",\n                \"host\": \"samples.mindsdb.com\",\n                \"port\": 5432,\n                \"database\": \"demo\",\n                \"schema\": \"demo_data\"\n            },\n            \"tables\": [\"house_sales\"]\n        }\n    ]\n)\n\n# Run a natural language query\nresult = aimind_tool.run(\"How many 3 bedroom houses were sold in 2008?\")\nprint(result)"
    },
    {
      "content": "from crewai_tools import BraveSearchTool\n\n# Initialize the tool for internet searching capabilities\ntool = BraveSearchTool()\n\n# Execute a search\nresults = tool.run(search_query=\"CrewAI agent framework\")\nprint(results)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import BraveSearchTool\n\n# Initialize the tool for internet searching capabilities\ntool = BraveSearchTool()\n\n# Execute a search\nresults = tool.run(search_query=\"CrewAI agent framework\")\nprint(results)",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import BraveSearchTool\n\n# Initialize the tool for internet searching capabilities\ntool = BraveSearchTool()\n\n# Execute a search\nresults = tool.run(search_query=\"CrewAI agent framework\")\nprint(results)"
    },
    {
      "content": "from crewai_tools import BrowserbaseLoadTool\n\n# Initialize the tool with the Browserbase API key and Project ID\ntool = BrowserbaseLoadTool()",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import BrowserbaseLoadTool\n\n# Initialize the tool with the Browserbase API key and Project ID\ntool = BrowserbaseLoadTool()",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import BrowserbaseLoadTool\n\n# Initialize the tool with the Browserbase API key and Project ID\ntool = BrowserbaseLoadTool()"
    },
    {
      "content": "from crewai_tools import CodeDocsSearchTool\n\n# To search any code documentation content \n# if the URL is known or discovered during its execution:\ntool = CodeDocsSearchTool()\n\n# OR\n\n# To specifically focus your search on a given documentation site \n# by providing its URL:\ntool = CodeDocsSearchTool(docs_url='https://docs.example.com/reference')",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import CodeDocsSearchTool\n\n# To search any code documentation content \n# if the URL is known or discovered during its execution:\ntool = CodeDocsSearchTool()\n\n# OR\n\n# To specifically focus your search on a given documentation site \n# by providing its URL:\ntool = CodeDocsSearchTool(docs_url='https://docs.example.com/reference')",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import CodeDocsSearchTool\n\n# To search any code documentation content \n# if the URL is known or discovered during its execution:\ntool = CodeDocsSearchTool()\n\n# OR\n\n# To specifically focus your search on a given documentation site \n# by providing its URL:\ntool = CodeDocsSearchTool(docs_url='https://docs.example.com/reference')"
    },
    {
      "content": "from crewai import Agent, Task, Crew, Process\nfrom crewai_tools import CodeInterpreterTool\n\n# Initialize the tool\ncode_interpreter = CodeInterpreterTool()\n\n# Define an agent that uses the tool\nprogrammer_agent = Agent(\n    role=\"Python Programmer\",\n    goal=\"Write and execute Python code to solve problems\",\n    backstory=\"An expert Python programmer who can write efficient code to solve complex problems.\",\n    tools=[code_interpreter],\n    verbose=True,\n)\n\n# Example task to generate and execute code\ncoding_task = Task(\n    description=\"Write a Python function to calculate the Fibonacci sequence up to the 10th number and print the result.\",\n    expected_output=\"The Fibonacci sequence up to the 10th number.\",\n    agent=programmer_agent,\n)\n\n# Create and run the crew\ncrew = Crew(\n    agents=[programmer_agent],\n    tasks=[coding_task],\n    verbose=True,\n    process=Process.sequential,\n)\nresult = crew.kickoff()",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai import Agent, Task, Crew, Process\nfrom crewai_tools import CodeInterpreterTool\n\n# Initialize the tool\ncode_interpreter = CodeInterpreterTool()\n\n# Define an agent that uses the tool\nprogrammer_agent = Agent(\n    role=\"Python Programmer\",\n    goal=\"Write and execute Python code to solve problems\",\n    backstory=\"An expert Python programmer who can write efficient code to solve complex problems.\",\n    tools=[code_interpreter],\n    verbose=True,\n)\n\n# Example task to generate and execute code\ncoding_task = Task(\n    description=\"Write a Python function to calculate the Fibonacci sequence up to the 10th number and print the result.\",\n    expected_output=\"The Fibonacci sequence up to the 10th number.\",\n    agent=programmer_agent,\n)\n\n# Create and run the crew\ncrew = Crew(\n    agents=[programmer_agent],\n    tasks=[coding_task],\n    verbose=True,\n    process=Process.sequential,\n)\nresult = crew.kickoff()",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai import Agent, Task, Crew, Process\nfrom crewai_tools import CodeInterpreterTool\n\n# Initialize the tool\ncode_interpreter = CodeInterpreterTool()\n\n# Define an agent that uses the tool\nprogrammer_agent = Agent(\n    role=\"Python Programmer\",\n    goal=\"Write and execute Python code to solve problems\",\n    backstory=\"An expert Python programmer who can write efficient code to solve complex problems.\",\n    tools=[code_interpreter],\n    verbose=True,\n)\n\n# Example task to generate and execute code\ncoding_task = Task(\n    description=\"Write a Python function to calculate the Fibonacci sequence up to the 10th number and print the result.\",\n    expected_output=\"The Fibonacci sequence up to the 10th number.\",\n    agent=programmer_agent,\n)\n\n# Create and run the crew\ncrew = Crew(\n    agents=[programmer_agent],\n    tasks=[coding_task],\n    verbose=True,\n    process=Process.sequential,\n)\nresult = crew.kickoff()"
    },
    {
      "content": "from crewai import Agent\n\n# Create an agent with code execution enabled\nprogrammer_agent = Agent(\n    role=\"Python Programmer\",\n    goal=\"Write and execute Python code to solve problems\",\n    backstory=\"An expert Python programmer who can write efficient code to solve complex problems.\",\n    allow_code_execution=True,  # This automatically adds the CodeInterpreterTool\n    verbose=True,\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai import Agent\n\n# Create an agent with code execution enabled\nprogrammer_agent = Agent(\n    role=\"Python Programmer\",\n    goal=\"Write and execute Python code to solve problems\",\n    backstory=\"An expert Python programmer who can write efficient code to solve complex problems.\",\n    allow_code_execution=True,  # This automatically adds the CodeInterpreterTool\n    verbose=True,\n)",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai import Agent\n\n# Create an agent with code execution enabled\nprogrammer_agent = Agent(\n    role=\"Python Programmer\",\n    goal=\"Write and execute Python code to solve problems\",\n    backstory=\"An expert Python programmer who can write efficient code to solve complex problems.\",\n    allow_code_execution=True,  # This automatically adds the CodeInterpreterTool\n    verbose=True,\n)"
    },
    {
      "content": "from composio_crewai import ComposioToolSet, App, Action\nfrom crewai import Agent, Task, Crew\n\ntoolset = ComposioToolSet()",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom composio_crewai import ComposioToolSet, App, Action\nfrom crewai import Agent, Task, Crew\n\ntoolset = ComposioToolSet()",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom composio_crewai import ComposioToolSet, App, Action\nfrom crewai import Agent, Task, Crew\n\ntoolset = ComposioToolSet()"
    },
    {
      "content": "request = toolset.initiate_connection(app=App.GITHUB)\nprint(f\"Open this URL to authenticate: {request.redirectUrl}\")",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nrequest = toolset.initiate_connection(app=App.GITHUB)\nprint(f\"Open this URL to authenticate: {request.redirectUrl}\")",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nrequest = toolset.initiate_connection(app=App.GITHUB)\nprint(f\"Open this URL to authenticate: {request.redirectUrl}\")"
    },
    {
      "content": "tools = toolset.get_tools(apps=[App.GITHUB])",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\ntools = toolset.get_tools(apps=[App.GITHUB])",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\ntools = toolset.get_tools(apps=[App.GITHUB])"
    },
    {
      "content": "tag = \"users\"\n\nfiltered_action_enums = toolset.find_actions_by_tags(\n    App.GITHUB,\n    tags=[tag], \n)\n\ntools = toolset.get_tools(actions=filtered_action_enums)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\ntag = \"users\"\n\nfiltered_action_enums = toolset.find_actions_by_tags(\n    App.GITHUB,\n    tags=[tag], \n)\n\ntools = toolset.get_tools(actions=filtered_action_enums)",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\ntag = \"users\"\n\nfiltered_action_enums = toolset.find_actions_by_tags(\n    App.GITHUB,\n    tags=[tag], \n)\n\ntools = toolset.get_tools(actions=filtered_action_enums)"
    },
    {
      "content": "use_case = \"Star a repository on GitHub\"\n\nfiltered_action_enums = toolset.find_actions_by_use_case(\n    App.GITHUB, use_case=use_case, advanced=False\n)\n\ntools = toolset.get_tools(actions=filtered_action_enums)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nuse_case = \"Star a repository on GitHub\"\n\nfiltered_action_enums = toolset.find_actions_by_use_case(\n    App.GITHUB, use_case=use_case, advanced=False\n)\n\ntools = toolset.get_tools(actions=filtered_action_enums)",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nuse_case = \"Star a repository on GitHub\"\n\nfiltered_action_enums = toolset.find_actions_by_use_case(\n    App.GITHUB, use_case=use_case, advanced=False\n)\n\ntools = toolset.get_tools(actions=filtered_action_enums)"
    },
    {
      "content": "tools = toolset.get_tools(\n    actions=[Action.GITHUB_STAR_A_REPOSITORY_FOR_THE_AUTHENTICATED_USER]\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\ntools = toolset.get_tools(\n    actions=[Action.GITHUB_STAR_A_REPOSITORY_FOR_THE_AUTHENTICATED_USER]\n)",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\ntools = toolset.get_tools(\n    actions=[Action.GITHUB_STAR_A_REPOSITORY_FOR_THE_AUTHENTICATED_USER]\n)"
    },
    {
      "content": "crewai_agent = Agent(\n    role=\"GitHub Agent\",\n    goal=\"You take action on GitHub using GitHub APIs\",\n    backstory=\"You are AI agent that is responsible for taking actions on GitHub on behalf of users using GitHub APIs\",\n    verbose=True,\n    tools=tools,\n    llm= # pass an llm\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\ncrewai_agent = Agent(\n    role=\"GitHub Agent\",\n    goal=\"You take action on GitHub using GitHub APIs\",\n    backstory=\"You are AI agent that is responsible for taking actions on GitHub on behalf of users using GitHub APIs\",\n    verbose=True,\n    tools=tools,\n    llm= # pass an llm\n)",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\ncrewai_agent = Agent(\n    role=\"GitHub Agent\",\n    goal=\"You take action on GitHub using GitHub APIs\",\n    backstory=\"You are AI agent that is responsible for taking actions on GitHub on behalf of users using GitHub APIs\",\n    verbose=True,\n    tools=tools,\n    llm= # pass an llm\n)"
    },
    {
      "content": "task = Task(\n    description=\"Star a repo composiohq/composio on GitHub\",\n    agent=crewai_agent,\n    expected_output=\"Status of the operation\",\n)\n\ncrew = Crew(agents=[crewai_agent], tasks=[task])\n\ncrew.kickoff()",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\ntask = Task(\n    description=\"Star a repo composiohq/composio on GitHub\",\n    agent=crewai_agent,\n    expected_output=\"Status of the operation\",\n)\n\ncrew = Crew(agents=[crewai_agent], tasks=[task])\n\ncrew.kickoff()",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\ntask = Task(\n    description=\"Star a repo composiohq/composio on GitHub\",\n    agent=crewai_agent,\n    expected_output=\"Status of the operation\",\n)\n\ncrew = Crew(agents=[crewai_agent], tasks=[task])\n\ncrew.kickoff()"
    },
    {
      "content": "from crewai_tools import CSVSearchTool\n\n# Initialize the tool with a specific CSV file. \n# This setup allows the agent to only search the given CSV file.\ntool = CSVSearchTool(csv='path/to/your/csvfile.csv')\n\n# OR\n\n# Initialize the tool without a specific CSV file. \n# Agent will need to provide the CSV path at runtime.\ntool = CSVSearchTool()",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import CSVSearchTool\n\n# Initialize the tool with a specific CSV file. \n# This setup allows the agent to only search the given CSV file.\ntool = CSVSearchTool(csv='path/to/your/csvfile.csv')\n\n# OR\n\n# Initialize the tool without a specific CSV file. \n# Agent will need to provide the CSV path at runtime.\ntool = CSVSearchTool()",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import CSVSearchTool\n\n# Initialize the tool with a specific CSV file. \n# This setup allows the agent to only search the given CSV file.\ntool = CSVSearchTool(csv='path/to/your/csvfile.csv')\n\n# OR\n\n# Initialize the tool without a specific CSV file. \n# Agent will need to provide the CSV path at runtime.\ntool = CSVSearchTool()"
    },
    {
      "content": "from crewai_tools import DallETool\n\nAgent(\n    ...\n    tools=[DallETool()],\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import DallETool\n\nAgent(\n    ...\n    tools=[DallETool()],\n)",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import DallETool\n\nAgent(\n    ...\n    tools=[DallETool()],\n)"
    },
    {
      "content": "from crewai_tools import DallETool\n\ndalle_tool = DallETool(model=\"dall-e-3\",\n                       size=\"1024x1024\",\n                       quality=\"standard\",\n                       n=1)\n\nAgent(\n    ...\n    tools=[dalle_tool]\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import DallETool\n\ndalle_tool = DallETool(model=\"dall-e-3\",\n                       size=\"1024x1024\",\n                       quality=\"standard\",\n                       n=1)\n\nAgent(\n    ...\n    tools=[dalle_tool]\n)",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import DallETool\n\ndalle_tool = DallETool(model=\"dall-e-3\",\n                       size=\"1024x1024\",\n                       quality=\"standard\",\n                       n=1)\n\nAgent(\n    ...\n    tools=[dalle_tool]\n)"
    },
    {
      "content": "from crewai_tools import DirectoryReadTool\n\n# Initialize the tool so the agent can read any directory's content \n# it learns about during execution\ntool = DirectoryReadTool()\n\n# OR\n\n# Initialize the tool with a specific directory, \n# so the agent can only read the content of the specified directory\ntool = DirectoryReadTool(directory='/path/to/your/directory')",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import DirectoryReadTool\n\n# Initialize the tool so the agent can read any directory's content \n# it learns about during execution\ntool = DirectoryReadTool()\n\n# OR\n\n# Initialize the tool with a specific directory, \n# so the agent can only read the content of the specified directory\ntool = DirectoryReadTool(directory='/path/to/your/directory')",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import DirectoryReadTool\n\n# Initialize the tool so the agent can read any directory's content \n# it learns about during execution\ntool = DirectoryReadTool()\n\n# OR\n\n# Initialize the tool with a specific directory, \n# so the agent can only read the content of the specified directory\ntool = DirectoryReadTool(directory='/path/to/your/directory')"
    },
    {
      "content": "from crewai_tools import DOCXSearchTool\n\n# Initialize the tool to search within any DOCX file's content\ntool = DOCXSearchTool()\n\n# OR\n\n# Initialize the tool with a specific DOCX file, \n# so the agent can only search the content of the specified DOCX file\ntool = DOCXSearchTool(docx='path/to/your/document.docx')",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import DOCXSearchTool\n\n# Initialize the tool to search within any DOCX file's content\ntool = DOCXSearchTool()\n\n# OR\n\n# Initialize the tool with a specific DOCX file, \n# so the agent can only search the content of the specified DOCX file\ntool = DOCXSearchTool(docx='path/to/your/document.docx')",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import DOCXSearchTool\n\n# Initialize the tool to search within any DOCX file's content\ntool = DOCXSearchTool()\n\n# OR\n\n# Initialize the tool with a specific DOCX file, \n# so the agent can only search the content of the specified DOCX file\ntool = DOCXSearchTool(docx='path/to/your/document.docx')"
    },
    {
      "content": "from crewai_tools import EXASearchTool\n\n# Initialize the tool for internet searching capabilities\ntool = EXASearchTool()",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import EXASearchTool\n\n# Initialize the tool for internet searching capabilities\ntool = EXASearchTool()",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import EXASearchTool\n\n# Initialize the tool for internet searching capabilities\ntool = EXASearchTool()"
    },
    {
      "content": "from crewai_tools import FileWriterTool\n\n# Initialize the tool\nfile_writer_tool = FileWriterTool()\n\n# Write content to a file in a specified directory\nresult = file_writer_tool._run('example.txt', 'This is a test content.', 'test_directory')\nprint(result)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import FileWriterTool\n\n# Initialize the tool\nfile_writer_tool = FileWriterTool()\n\n# Write content to a file in a specified directory\nresult = file_writer_tool._run('example.txt', 'This is a test content.', 'test_directory')\nprint(result)",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import FileWriterTool\n\n# Initialize the tool\nfile_writer_tool = FileWriterTool()\n\n# Write content to a file in a specified directory\nresult = file_writer_tool._run('example.txt', 'This is a test content.', 'test_directory')\nprint(result)"
    },
    {
      "content": "from crewai_tools import FirecrawlCrawlWebsiteTool\n\ntool = FirecrawlCrawlWebsiteTool(url='firecrawl.dev')",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import FirecrawlCrawlWebsiteTool\n\ntool = FirecrawlCrawlWebsiteTool(url='firecrawl.dev')",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import FirecrawlCrawlWebsiteTool\n\ntool = FirecrawlCrawlWebsiteTool(url='firecrawl.dev')"
    },
    {
      "content": "from crewai_tools import FirecrawlScrapeWebsiteTool\n\ntool = FirecrawlScrapeWebsiteTool(url='firecrawl.dev')",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import FirecrawlScrapeWebsiteTool\n\ntool = FirecrawlScrapeWebsiteTool(url='firecrawl.dev')",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import FirecrawlScrapeWebsiteTool\n\ntool = FirecrawlScrapeWebsiteTool(url='firecrawl.dev')"
    },
    {
      "content": "from crewai_tools import FirecrawlSearchTool\n\ntool = FirecrawlSearchTool(query='what is firecrawl?')",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import FirecrawlSearchTool\n\ntool = FirecrawlSearchTool(query='what is firecrawl?')",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import FirecrawlSearchTool\n\ntool = FirecrawlSearchTool(query='what is firecrawl?')"
    },
    {
      "content": "from crewai_tools import GithubSearchTool\n\n# Initialize the tool for semantic searches within a specific GitHub repository\ntool = GithubSearchTool(\n\tgithub_repo='https://github.com/example/repo',\n\tgh_token='your_github_personal_access_token',\n\tcontent_types=['code', 'issue'] # Options: code, repo, pr, issue\n)\n\n# OR\n\n# Initialize the tool for semantic searches within a specific GitHub repository, so the agent can search any repository if it learns about during its execution\ntool = GithubSearchTool(\n\tgh_token='your_github_personal_access_token',\n\tcontent_types=['code', 'issue'] # Options: code, repo, pr, issue\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import GithubSearchTool\n\n# Initialize the tool for semantic searches within a specific GitHub repository\ntool = GithubSearchTool(\n\tgithub_repo='https://github.com/example/repo',\n\tgh_token='your_github_personal_access_token',\n\tcontent_types=['code', 'issue'] # Options: code, repo, pr, issue\n)\n\n# OR\n\n# Initialize the tool for semantic searches within a specific GitHub repository, so the agent can search any repository if it learns about during its execution\ntool = GithubSearchTool(\n\tgh_token='your_github_personal_access_token',\n\tcontent_types=['code', 'issue'] # Options: code, repo, pr, issue\n)",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import GithubSearchTool\n\n# Initialize the tool for semantic searches within a specific GitHub repository\ntool = GithubSearchTool(\n\tgithub_repo='https://github.com/example/repo',\n\tgh_token='your_github_personal_access_token',\n\tcontent_types=['code', 'issue'] # Options: code, repo, pr, issue\n)\n\n# OR\n\n# Initialize the tool for semantic searches within a specific GitHub repository, so the agent can search any repository if it learns about during its execution\ntool = GithubSearchTool(\n\tgh_token='your_github_personal_access_token',\n\tcontent_types=['code', 'issue'] # Options: code, repo, pr, issue\n)"
    },
    {
      "content": "from crewai_tools import HyperbrowserLoadTool\nfrom crewai import Agent\n\n# Initialize the tool with your API key\ntool = HyperbrowserLoadTool(api_key=\"your_api_key\")  # Or use environment variable\n\n# Define an agent that uses the tool\n@agent\ndef web_researcher(self) -> Agent:\n    '''\n    This agent uses the HyperbrowserLoadTool to scrape websites\n    and extract information.\n    '''\n    return Agent(\n        config=self.agents_config[\"web_researcher\"],\n        tools=[tool]\n    )",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import HyperbrowserLoadTool\nfrom crewai import Agent\n\n# Initialize the tool with your API key\ntool = HyperbrowserLoadTool(api_key=\"your_api_key\")  # Or use environment variable\n\n# Define an agent that uses the tool\n@agent\ndef web_researcher(self) -> Agent:\n    '''\n    This agent uses the HyperbrowserLoadTool to scrape websites\n    and extract information.\n    '''\n    return Agent(\n        config=self.agents_config[\"web_researcher\"],\n        tools=[tool]\n    )",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import HyperbrowserLoadTool\nfrom crewai import Agent\n\n# Initialize the tool with your API key\ntool = HyperbrowserLoadTool(api_key=\"your_api_key\")  # Or use environment variable\n\n# Define an agent that uses the tool\n@agent\ndef web_researcher(self) -> Agent:\n    '''\n    This agent uses the HyperbrowserLoadTool to scrape websites\n    and extract information.\n    '''\n    return Agent(\n        config=self.agents_config[\"web_researcher\"],\n        tools=[tool]\n    )"
    },
    {
      "content": "from crewai_tools import LinkupSearchTool\nfrom crewai import Agent\nimport os\n\n# Initialize the tool with your API key\nlinkup_tool = LinkupSearchTool(api_key=os.getenv(\"LINKUP_API_KEY\"))\n\n# Define an agent that uses the tool\n@agent\ndef researcher(self) -> Agent:\n    '''\n    This agent uses the LinkupSearchTool to retrieve contextual information\n    from the Linkup API.\n    '''\n    return Agent(\n        config=self.agents_config[\"researcher\"],\n        tools=[linkup_tool]\n    )",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import LinkupSearchTool\nfrom crewai import Agent\nimport os\n\n# Initialize the tool with your API key\nlinkup_tool = LinkupSearchTool(api_key=os.getenv(\"LINKUP_API_KEY\"))\n\n# Define an agent that uses the tool\n@agent\ndef researcher(self) -> Agent:\n    '''\n    This agent uses the LinkupSearchTool to retrieve contextual information\n    from the Linkup API.\n    '''\n    return Agent(\n        config=self.agents_config[\"researcher\"],\n        tools=[linkup_tool]\n    )",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import LinkupSearchTool\nfrom crewai import Agent\nimport os\n\n# Initialize the tool with your API key\nlinkup_tool = LinkupSearchTool(api_key=os.getenv(\"LINKUP_API_KEY\"))\n\n# Define an agent that uses the tool\n@agent\ndef researcher(self) -> Agent:\n    '''\n    This agent uses the LinkupSearchTool to retrieve contextual information\n    from the Linkup API.\n    '''\n    return Agent(\n        config=self.agents_config[\"researcher\"],\n        tools=[linkup_tool]\n    )"
    },
    {
      "content": "from crewai import Agent, Task, Crew\nfrom crewai_tools import MultiOnTool\n\n# Initialize the tool\nmultion_tool = MultiOnTool(api_key=\"YOUR_MULTION_API_KEY\", local=False)\n\n# Define an agent that uses the tool\nbrowser_agent = Agent(\n    role=\"Browser Agent\",\n    goal=\"Control web browsers using natural language\",\n    backstory=\"An expert browsing agent.\",\n    tools=[multion_tool],\n    verbose=True,\n)\n\n# Example task to search and summarize news\nbrowse_task = Task(\n    description=\"Summarize the top 3 trending AI News headlines\",\n    expected_output=\"A summary of the top 3 trending AI News headlines\",\n    agent=browser_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[browser_agent], tasks=[browse_task])\nresult = crew.kickoff()",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import MultiOnTool\n\n# Initialize the tool\nmultion_tool = MultiOnTool(api_key=\"YOUR_MULTION_API_KEY\", local=False)\n\n# Define an agent that uses the tool\nbrowser_agent = Agent(\n    role=\"Browser Agent\",\n    goal=\"Control web browsers using natural language\",\n    backstory=\"An expert browsing agent.\",\n    tools=[multion_tool],\n    verbose=True,\n)\n\n# Example task to search and summarize news\nbrowse_task = Task(\n    description=\"Summarize the top 3 trending AI News headlines\",\n    expected_output=\"A summary of the top 3 trending AI News headlines\",\n    agent=browser_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[browser_agent], tasks=[browse_task])\nresult = crew.kickoff()",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import MultiOnTool\n\n# Initialize the tool\nmultion_tool = MultiOnTool(api_key=\"YOUR_MULTION_API_KEY\", local=False)\n\n# Define an agent that uses the tool\nbrowser_agent = Agent(\n    role=\"Browser Agent\",\n    goal=\"Control web browsers using natural language\",\n    backstory=\"An expert browsing agent.\",\n    tools=[multion_tool],\n    verbose=True,\n)\n\n# Example task to search and summarize news\nbrowse_task = Task(\n    description=\"Summarize the top 3 trending AI News headlines\",\n    expected_output=\"A summary of the top 3 trending AI News headlines\",\n    agent=browser_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[browser_agent], tasks=[browse_task])\nresult = crew.kickoff()"
    },
    {
      "content": "from crewai_tools import MySQLSearchTool\n\n# Initialize the tool with the database URI and the target table name\ntool = MySQLSearchTool(\n    db_uri='mysql://user:password@localhost:3306/mydatabase',\n    table_name='employees'\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import MySQLSearchTool\n\n# Initialize the tool with the database URI and the target table name\ntool = MySQLSearchTool(\n    db_uri='mysql://user:password@localhost:3306/mydatabase',\n    table_name='employees'\n)",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import MySQLSearchTool\n\n# Initialize the tool with the database URI and the target table name\ntool = MySQLSearchTool(\n    db_uri='mysql://user:password@localhost:3306/mydatabase',\n    table_name='employees'\n)"
    },
    {
      "content": "DB -> Agent -> ... -> Agent -> DB",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nDB -> Agent -> ... -> Agent -> DB",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nDB -> Agent -> ... -> Agent -> DB"
    },
    {
      "content": "from crewai_tools import PDFSearchTool\n\n# Initialize the tool allowing for any PDF content search if the path is provided during execution\ntool = PDFSearchTool()\n\n# OR\n\n# Initialize the tool with a specific PDF path for exclusive search within that document\ntool = PDFSearchTool(pdf='path/to/your/document.pdf')",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import PDFSearchTool\n\n# Initialize the tool allowing for any PDF content search if the path is provided during execution\ntool = PDFSearchTool()\n\n# OR\n\n# Initialize the tool with a specific PDF path for exclusive search within that document\ntool = PDFSearchTool(pdf='path/to/your/document.pdf')",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import PDFSearchTool\n\n# Initialize the tool allowing for any PDF content search if the path is provided during execution\ntool = PDFSearchTool()\n\n# OR\n\n# Initialize the tool with a specific PDF path for exclusive search within that document\ntool = PDFSearchTool(pdf='path/to/your/document.pdf')"
    },
    {
      "content": "from crewai_tools import RagTool\n\n# Create a RAG tool with default settings\nrag_tool = RagTool()\n\n# Add content from a file\nrag_tool.add(data_type=\"file\", path=\"path/to/your/document.pdf\")\n\n# Add content from a web page\nrag_tool.add(data_type=\"web_page\", url=\"https://example.com\")\n\n# Define an agent with the RagTool\n@agent\ndef knowledge_expert(self) -> Agent:\n    '''\n    This agent uses the RagTool to answer questions about the knowledge base.\n    '''\n    return Agent(\n        config=self.agents_config[\"knowledge_expert\"],\n        allow_delegation=False,\n        tools=[rag_tool]\n    )",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import RagTool\n\n# Create a RAG tool with default settings\nrag_tool = RagTool()\n\n# Add content from a file\nrag_tool.add(data_type=\"file\", path=\"path/to/your/document.pdf\")\n\n# Add content from a web page\nrag_tool.add(data_type=\"web_page\", url=\"https://example.com\")\n\n# Define an agent with the RagTool\n@agent\ndef knowledge_expert(self) -> Agent:\n    '''\n    This agent uses the RagTool to answer questions about the knowledge base.\n    '''\n    return Agent(\n        config=self.agents_config[\"knowledge_expert\"],\n        allow_delegation=False,\n        tools=[rag_tool]\n    )",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import RagTool\n\n# Create a RAG tool with default settings\nrag_tool = RagTool()\n\n# Add content from a file\nrag_tool.add(data_type=\"file\", path=\"path/to/your/document.pdf\")\n\n# Add content from a web page\nrag_tool.add(data_type=\"web_page\", url=\"https://example.com\")\n\n# Define an agent with the RagTool\n@agent\ndef knowledge_expert(self) -> Agent:\n    '''\n    This agent uses the RagTool to answer questions about the knowledge base.\n    '''\n    return Agent(\n        config=self.agents_config[\"knowledge_expert\"],\n        allow_delegation=False,\n        tools=[rag_tool]\n    )"
    },
    {
      "content": "from crewai import Agent, Task, Crew\nfrom crewai_tools.aws.s3 import S3ReaderTool\n\n# Initialize the tool\ns3_reader_tool = S3ReaderTool()\n\n# Define an agent that uses the tool\nfile_reader_agent = Agent(\n    role=\"File Reader\",\n    goal=\"Read files from S3 buckets\",\n    backstory=\"An expert in retrieving and processing files from cloud storage.\",\n    tools=[s3_reader_tool],\n    verbose=True,\n)\n\n# Example task to read a configuration file\nread_task = Task(\n    description=\"Read the configuration file from {my_bucket} and summarize its contents.\",\n    expected_output=\"A summary of the configuration file contents.\",\n    agent=file_reader_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[file_reader_agent], tasks=[read_task])\nresult = crew.kickoff(inputs={\"my_bucket\": \"s3://my-bucket/config/app-config.json\"})",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools.aws.s3 import S3ReaderTool\n\n# Initialize the tool\ns3_reader_tool = S3ReaderTool()\n\n# Define an agent that uses the tool\nfile_reader_agent = Agent(\n    role=\"File Reader\",\n    goal=\"Read files from S3 buckets\",\n    backstory=\"An expert in retrieving and processing files from cloud storage.\",\n    tools=[s3_reader_tool],\n    verbose=True,\n)\n\n# Example task to read a configuration file\nread_task = Task(\n    description=\"Read the configuration file from {my_bucket} and summarize its contents.\",\n    expected_output=\"A summary of the configuration file contents.\",\n    agent=file_reader_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[file_reader_agent], tasks=[read_task])\nresult = crew.kickoff(inputs={\"my_bucket\": \"s3://my-bucket/config/app-config.json\"})",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools.aws.s3 import S3ReaderTool\n\n# Initialize the tool\ns3_reader_tool = S3ReaderTool()\n\n# Define an agent that uses the tool\nfile_reader_agent = Agent(\n    role=\"File Reader\",\n    goal=\"Read files from S3 buckets\",\n    backstory=\"An expert in retrieving and processing files from cloud storage.\",\n    tools=[s3_reader_tool],\n    verbose=True,\n)\n\n# Example task to read a configuration file\nread_task = Task(\n    description=\"Read the configuration file from {my_bucket} and summarize its contents.\",\n    expected_output=\"A summary of the configuration file contents.\",\n    agent=file_reader_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[file_reader_agent], tasks=[read_task])\nresult = crew.kickoff(inputs={\"my_bucket\": \"s3://my-bucket/config/app-config.json\"})"
    },
    {
      "content": "from crewai import Agent, Task, Crew\nfrom crewai_tools.aws.s3 import S3WriterTool\n\n# Initialize the tool\ns3_writer_tool = S3WriterTool()\n\n# Define an agent that uses the tool\nfile_writer_agent = Agent(\n    role=\"File Writer\",\n    goal=\"Write content to files in S3 buckets\",\n    backstory=\"An expert in storing and managing files in cloud storage.\",\n    tools=[s3_writer_tool],\n    verbose=True,\n)\n\n# Example task to write a report\nwrite_task = Task(\n    description=\"Generate a summary report of the quarterly sales data and save it to {my_bucket}.\",\n    expected_output=\"Confirmation that the report was successfully saved to S3.\",\n    agent=file_writer_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[file_writer_agent], tasks=[write_task])\nresult = crew.kickoff(inputs={\"my_bucket\": \"s3://my-bucket/reports/quarterly-summary.txt\"})",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools.aws.s3 import S3WriterTool\n\n# Initialize the tool\ns3_writer_tool = S3WriterTool()\n\n# Define an agent that uses the tool\nfile_writer_agent = Agent(\n    role=\"File Writer\",\n    goal=\"Write content to files in S3 buckets\",\n    backstory=\"An expert in storing and managing files in cloud storage.\",\n    tools=[s3_writer_tool],\n    verbose=True,\n)\n\n# Example task to write a report\nwrite_task = Task(\n    description=\"Generate a summary report of the quarterly sales data and save it to {my_bucket}.\",\n    expected_output=\"Confirmation that the report was successfully saved to S3.\",\n    agent=file_writer_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[file_writer_agent], tasks=[write_task])\nresult = crew.kickoff(inputs={\"my_bucket\": \"s3://my-bucket/reports/quarterly-summary.txt\"})",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools.aws.s3 import S3WriterTool\n\n# Initialize the tool\ns3_writer_tool = S3WriterTool()\n\n# Define an agent that uses the tool\nfile_writer_agent = Agent(\n    role=\"File Writer\",\n    goal=\"Write content to files in S3 buckets\",\n    backstory=\"An expert in storing and managing files in cloud storage.\",\n    tools=[s3_writer_tool],\n    verbose=True,\n)\n\n# Example task to write a report\nwrite_task = Task(\n    description=\"Generate a summary report of the quarterly sales data and save it to {my_bucket}.\",\n    expected_output=\"Confirmation that the report was successfully saved to S3.\",\n    agent=file_writer_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[file_writer_agent], tasks=[write_task])\nresult = crew.kickoff(inputs={\"my_bucket\": \"s3://my-bucket/reports/quarterly-summary.txt\"})"
    },
    {
      "content": "from crewai import Agent, Task, Crew\nfrom crewai_tools import ScrapeElementFromWebsiteTool\n\n# Initialize the tool\nscrape_tool = ScrapeElementFromWebsiteTool()\n\n# Define an agent that uses the tool\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract specific information from websites\",\n    backstory=\"An expert in web scraping who can extract targeted content from web pages.\",\n    tools=[scrape_tool],\n    verbose=True,\n)\n\n# Example task to extract headlines from a news website\nscrape_task = Task(\n    description=\"Extract the main headlines from the CNN homepage. Use the CSS selector '.headline' to target the headline elements.\",\n    expected_output=\"A list of the main headlines from CNN.\",\n    agent=web_scraper_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[web_scraper_agent], tasks=[scrape_task])\nresult = crew.kickoff()",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import ScrapeElementFromWebsiteTool\n\n# Initialize the tool\nscrape_tool = ScrapeElementFromWebsiteTool()\n\n# Define an agent that uses the tool\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract specific information from websites\",\n    backstory=\"An expert in web scraping who can extract targeted content from web pages.\",\n    tools=[scrape_tool],\n    verbose=True,\n)\n\n# Example task to extract headlines from a news website\nscrape_task = Task(\n    description=\"Extract the main headlines from the CNN homepage. Use the CSS selector '.headline' to target the headline elements.\",\n    expected_output=\"A list of the main headlines from CNN.\",\n    agent=web_scraper_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[web_scraper_agent], tasks=[scrape_task])\nresult = crew.kickoff()",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import ScrapeElementFromWebsiteTool\n\n# Initialize the tool\nscrape_tool = ScrapeElementFromWebsiteTool()\n\n# Define an agent that uses the tool\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract specific information from websites\",\n    backstory=\"An expert in web scraping who can extract targeted content from web pages.\",\n    tools=[scrape_tool],\n    verbose=True,\n)\n\n# Example task to extract headlines from a news website\nscrape_task = Task(\n    description=\"Extract the main headlines from the CNN homepage. Use the CSS selector '.headline' to target the headline elements.\",\n    expected_output=\"A list of the main headlines from CNN.\",\n    agent=web_scraper_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[web_scraper_agent], tasks=[scrape_task])\nresult = crew.kickoff()"
    },
    {
      "content": "# Initialize the tool with predefined parameters\nscrape_tool = ScrapeElementFromWebsiteTool(\n    website_url=\"https://www.example.com\",\n    css_element=\".main-content\"\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\n# Initialize the tool with predefined parameters\nscrape_tool = ScrapeElementFromWebsiteTool(\n    website_url=\"https://www.example.com\",\n    css_element=\".main-content\"\n)",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\n# Initialize the tool with predefined parameters\nscrape_tool = ScrapeElementFromWebsiteTool(\n    website_url=\"https://www.example.com\",\n    css_element=\".main-content\"\n)"
    },
    {
      "content": "from crewai import Agent, Task, Crew\nfrom crewai_tools import ScrapegraphScrapeTool\n\n# Initialize the tool\nscrape_tool = ScrapegraphScrapeTool(api_key=\"your_api_key\")\n\n# Define an agent that uses the tool\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract specific information from websites\",\n    backstory=\"An expert in web scraping who can extract targeted content from web pages.\",\n    tools=[scrape_tool],\n    verbose=True,\n)\n\n# Example task to extract product information from an e-commerce site\nscrape_task = Task(\n    description=\"Extract product names, prices, and descriptions from the featured products section of example.com.\",\n    expected_output=\"A structured list of product information including names, prices, and descriptions.\",\n    agent=web_scraper_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[web_scraper_agent], tasks=[scrape_task])\nresult = crew.kickoff()",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import ScrapegraphScrapeTool\n\n# Initialize the tool\nscrape_tool = ScrapegraphScrapeTool(api_key=\"your_api_key\")\n\n# Define an agent that uses the tool\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract specific information from websites\",\n    backstory=\"An expert in web scraping who can extract targeted content from web pages.\",\n    tools=[scrape_tool],\n    verbose=True,\n)\n\n# Example task to extract product information from an e-commerce site\nscrape_task = Task(\n    description=\"Extract product names, prices, and descriptions from the featured products section of example.com.\",\n    expected_output=\"A structured list of product information including names, prices, and descriptions.\",\n    agent=web_scraper_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[web_scraper_agent], tasks=[scrape_task])\nresult = crew.kickoff()",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import ScrapegraphScrapeTool\n\n# Initialize the tool\nscrape_tool = ScrapegraphScrapeTool(api_key=\"your_api_key\")\n\n# Define an agent that uses the tool\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract specific information from websites\",\n    backstory=\"An expert in web scraping who can extract targeted content from web pages.\",\n    tools=[scrape_tool],\n    verbose=True,\n)\n\n# Example task to extract product information from an e-commerce site\nscrape_task = Task(\n    description=\"Extract product names, prices, and descriptions from the featured products section of example.com.\",\n    expected_output=\"A structured list of product information including names, prices, and descriptions.\",\n    agent=web_scraper_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[web_scraper_agent], tasks=[scrape_task])\nresult = crew.kickoff()"
    },
    {
      "content": "# Initialize the tool with predefined parameters\nscrape_tool = ScrapegraphScrapeTool(\n    website_url=\"https://www.example.com\",\n    user_prompt=\"Extract all product prices and descriptions\",\n    api_key=\"your_api_key\"\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\n# Initialize the tool with predefined parameters\nscrape_tool = ScrapegraphScrapeTool(\n    website_url=\"https://www.example.com\",\n    user_prompt=\"Extract all product prices and descriptions\",\n    api_key=\"your_api_key\"\n)",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\n# Initialize the tool with predefined parameters\nscrape_tool = ScrapegraphScrapeTool(\n    website_url=\"https://www.example.com\",\n    user_prompt=\"Extract all product prices and descriptions\",\n    api_key=\"your_api_key\"\n)"
    },
    {
      "content": "from crewai_tools import ScrapeWebsiteTool\n\n# To enable scrapping any website it finds during it's execution\ntool = ScrapeWebsiteTool()\n\n# Initialize the tool with the website URL, \n# so the agent can only scrap the content of the specified website\ntool = ScrapeWebsiteTool(website_url='https://www.example.com')\n\n# Extract the text from the site\ntext = tool.run()\nprint(text)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import ScrapeWebsiteTool\n\n# To enable scrapping any website it finds during it's execution\ntool = ScrapeWebsiteTool()\n\n# Initialize the tool with the website URL, \n# so the agent can only scrap the content of the specified website\ntool = ScrapeWebsiteTool(website_url='https://www.example.com')\n\n# Extract the text from the site\ntext = tool.run()\nprint(text)",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import ScrapeWebsiteTool\n\n# To enable scrapping any website it finds during it's execution\ntool = ScrapeWebsiteTool()\n\n# Initialize the tool with the website URL, \n# so the agent can only scrap the content of the specified website\ntool = ScrapeWebsiteTool(website_url='https://www.example.com')\n\n# Extract the text from the site\ntext = tool.run()\nprint(text)"
    },
    {
      "content": "from crewai import Agent, Task, Crew\nfrom crewai_tools import ScrapflyScrapeWebsiteTool\n\n# Initialize the tool\nscrape_tool = ScrapflyScrapeWebsiteTool(api_key=\"your_scrapfly_api_key\")\n\n# Define an agent that uses the tool\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract information from websites\",\n    backstory=\"An expert in web scraping who can extract content from any website.\",\n    tools=[scrape_tool],\n    verbose=True,\n)\n\n# Example task to extract content from a website\nscrape_task = Task(\n    description=\"Extract the main content from the product page at https://web-scraping.dev/products and summarize the available products.\",\n    expected_output=\"A summary of the products available on the website.\",\n    agent=web_scraper_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[web_scraper_agent], tasks=[scrape_task])\nresult = crew.kickoff()",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import ScrapflyScrapeWebsiteTool\n\n# Initialize the tool\nscrape_tool = ScrapflyScrapeWebsiteTool(api_key=\"your_scrapfly_api_key\")\n\n# Define an agent that uses the tool\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract information from websites\",\n    backstory=\"An expert in web scraping who can extract content from any website.\",\n    tools=[scrape_tool],\n    verbose=True,\n)\n\n# Example task to extract content from a website\nscrape_task = Task(\n    description=\"Extract the main content from the product page at https://web-scraping.dev/products and summarize the available products.\",\n    expected_output=\"A summary of the products available on the website.\",\n    agent=web_scraper_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[web_scraper_agent], tasks=[scrape_task])\nresult = crew.kickoff()",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import ScrapflyScrapeWebsiteTool\n\n# Initialize the tool\nscrape_tool = ScrapflyScrapeWebsiteTool(api_key=\"your_scrapfly_api_key\")\n\n# Define an agent that uses the tool\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract information from websites\",\n    backstory=\"An expert in web scraping who can extract content from any website.\",\n    tools=[scrape_tool],\n    verbose=True,\n)\n\n# Example task to extract content from a website\nscrape_task = Task(\n    description=\"Extract the main content from the product page at https://web-scraping.dev/products and summarize the available products.\",\n    expected_output=\"A summary of the products available on the website.\",\n    agent=web_scraper_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[web_scraper_agent], tasks=[scrape_task])\nresult = crew.kickoff()"
    },
    {
      "content": "# Example with custom scraping parameters\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract information from websites with custom parameters\",\n    backstory=\"An expert in web scraping who can extract content from any website.\",\n    tools=[scrape_tool],\n    verbose=True,\n)\n\n# The agent will use the tool with parameters like:\n# url=\"https://web-scraping.dev/products\"\n# scrape_format=\"markdown\"\n# ignore_scrape_failures=True\n# scrape_config={\n#     \"asp\": True,  # Bypass scraping blocking solutions, like Cloudflare\n#     \"render_js\": True,  # Enable JavaScript rendering with a cloud headless browser\n#     \"proxy_pool\": \"public_residential_pool\",  # Select a proxy pool\n#     \"country\": \"us\",  # Select a proxy location\n#     \"auto_scroll\": True,  # Auto scroll the page\n# }\n\nscrape_task = Task(\n    description=\"Extract the main content from the product page at https://web-scraping.dev/products using advanced scraping options including JavaScript rendering and proxy settings.\",\n    expected_output=\"A detailed summary of the products with all available information.\",\n    agent=web_scraper_agent,\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\n# Example with custom scraping parameters\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract information from websites with custom parameters\",\n    backstory=\"An expert in web scraping who can extract content from any website.\",\n    tools=[scrape_tool],\n    verbose=True,\n)\n\n# The agent will use the tool with parameters like:\n# url=\"https://web-scraping.dev/products\"\n# scrape_format=\"markdown\"\n# ignore_scrape_failures=True\n# scrape_config={\n#     \"asp\": True,  # Bypass scraping blocking solutions, like Cloudflare\n#     \"render_js\": True,  # Enable JavaScript rendering with a cloud headless browser\n#     \"proxy_pool\": \"public_residential_pool\",  # Select a proxy pool\n#     \"country\": \"us\",  # Select a proxy location\n#     \"auto_scroll\": True,  # Auto scroll the page\n# }\n\nscrape_task = Task(\n    description=\"Extract the main content from the product page at https://web-scraping.dev/products using advanced scraping options including JavaScript rendering and proxy settings.\",\n    expected_output=\"A detailed summary of the products with all available information.\",\n    agent=web_scraper_agent,\n)",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\n# Example with custom scraping parameters\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract information from websites with custom parameters\",\n    backstory=\"An expert in web scraping who can extract content from any website.\",\n    tools=[scrape_tool],\n    verbose=True,\n)\n\n# The agent will use the tool with parameters like:\n# url=\"https://web-scraping.dev/products\"\n# scrape_format=\"markdown\"\n# ignore_scrape_failures=True\n# scrape_config={\n#     \"asp\": True,  # Bypass scraping blocking solutions, like Cloudflare\n#     \"render_js\": True,  # Enable JavaScript rendering with a cloud headless browser\n#     \"proxy_pool\": \"public_residential_pool\",  # Select a proxy pool\n#     \"country\": \"us\",  # Select a proxy location\n#     \"auto_scroll\": True,  # Auto scroll the page\n# }\n\nscrape_task = Task(\n    description=\"Extract the main content from the product page at https://web-scraping.dev/products using advanced scraping options including JavaScript rendering and proxy settings.\",\n    expected_output=\"A detailed summary of the products with all available information.\",\n    agent=web_scraper_agent,\n)"
    },
    {
      "content": "from crewai import Agent, Task, Crew, Process\nfrom crewai_tools import SeleniumScrapingTool\n\n# Initialize the tool\nselenium_tool = SeleniumScrapingTool()\n\n# Define an agent that uses the tool\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract information from websites using Selenium\",\n    backstory=\"An expert web scraper who can extract content from dynamic websites.\",\n    tools=[selenium_tool],\n    verbose=True,\n)\n\n# Example task to scrape content from a website\nscrape_task = Task(\n    description=\"Extract the main content from the homepage of example.com. Use the CSS selector 'main' to target the main content area.\",\n    expected_output=\"The main content from example.com's homepage.\",\n    agent=web_scraper_agent,\n)\n\n# Create and run the crew\ncrew = Crew(\n    agents=[web_scraper_agent],\n    tasks=[scrape_task],\n    verbose=True,\n    process=Process.sequential,\n)\nresult = crew.kickoff()",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai import Agent, Task, Crew, Process\nfrom crewai_tools import SeleniumScrapingTool\n\n# Initialize the tool\nselenium_tool = SeleniumScrapingTool()\n\n# Define an agent that uses the tool\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract information from websites using Selenium\",\n    backstory=\"An expert web scraper who can extract content from dynamic websites.\",\n    tools=[selenium_tool],\n    verbose=True,\n)\n\n# Example task to scrape content from a website\nscrape_task = Task(\n    description=\"Extract the main content from the homepage of example.com. Use the CSS selector 'main' to target the main content area.\",\n    expected_output=\"The main content from example.com's homepage.\",\n    agent=web_scraper_agent,\n)\n\n# Create and run the crew\ncrew = Crew(\n    agents=[web_scraper_agent],\n    tasks=[scrape_task],\n    verbose=True,\n    process=Process.sequential,\n)\nresult = crew.kickoff()",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai import Agent, Task, Crew, Process\nfrom crewai_tools import SeleniumScrapingTool\n\n# Initialize the tool\nselenium_tool = SeleniumScrapingTool()\n\n# Define an agent that uses the tool\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract information from websites using Selenium\",\n    backstory=\"An expert web scraper who can extract content from dynamic websites.\",\n    tools=[selenium_tool],\n    verbose=True,\n)\n\n# Example task to scrape content from a website\nscrape_task = Task(\n    description=\"Extract the main content from the homepage of example.com. Use the CSS selector 'main' to target the main content area.\",\n    expected_output=\"The main content from example.com's homepage.\",\n    agent=web_scraper_agent,\n)\n\n# Create and run the crew\ncrew = Crew(\n    agents=[web_scraper_agent],\n    tasks=[scrape_task],\n    verbose=True,\n    process=Process.sequential,\n)\nresult = crew.kickoff()"
    },
    {
      "content": "# Initialize the tool with predefined parameters\nselenium_tool = SeleniumScrapingTool(\n    website_url='https://example.com',\n    css_element='.main-content',\n    wait_time=5\n)\n\n# Define an agent that uses the tool\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract information from websites using Selenium\",\n    backstory=\"An expert web scraper who can extract content from dynamic websites.\",\n    tools=[selenium_tool],\n    verbose=True,\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\n# Initialize the tool with predefined parameters\nselenium_tool = SeleniumScrapingTool(\n    website_url='https://example.com',\n    css_element='.main-content',\n    wait_time=5\n)\n\n# Define an agent that uses the tool\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract information from websites using Selenium\",\n    backstory=\"An expert web scraper who can extract content from dynamic websites.\",\n    tools=[selenium_tool],\n    verbose=True,\n)",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\n# Initialize the tool with predefined parameters\nselenium_tool = SeleniumScrapingTool(\n    website_url='https://example.com',\n    css_element='.main-content',\n    wait_time=5\n)\n\n# Define an agent that uses the tool\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract information from websites using Selenium\",\n    backstory=\"An expert web scraper who can extract content from dynamic websites.\",\n    tools=[selenium_tool],\n    verbose=True,\n)"
    },
    {
      "content": "from crewai_tools import SerperDevTool\n\n# Initialize the tool for internet searching capabilities\ntool = SerperDevTool()",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import SerperDevTool\n\n# Initialize the tool for internet searching capabilities\ntool = SerperDevTool()",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import SerperDevTool\n\n# Initialize the tool for internet searching capabilities\ntool = SerperDevTool()"
    },
    {
      "content": "from crewai import Agent, Task, Crew\nfrom crewai_tools import SnowflakeSearchTool, SnowflakeConfig\n\n# Create Snowflake configuration\nconfig = SnowflakeConfig(\n    account=\"your_account\",\n    user=\"your_username\",\n    password=\"your_password\",\n    warehouse=\"COMPUTE_WH\",\n    database=\"your_database\",\n    snowflake_schema=\"your_schema\"\n)\n\n# Initialize the tool\nsnowflake_tool = SnowflakeSearchTool(config=config)\n\n# Define an agent that uses the tool\ndata_analyst_agent = Agent(\n    role=\"Data Analyst\",\n    goal=\"Analyze data from Snowflake database\",\n    backstory=\"An expert data analyst who can extract insights from enterprise data.\",\n    tools=[snowflake_tool],\n    verbose=True,\n)\n\n# Example task to query sales data\nquery_task = Task(\n    description=\"Query the sales data for the last quarter and summarize the top 5 products by revenue.\",\n    expected_output=\"A summary of the top 5 products by revenue for the last quarter.\",\n    agent=data_analyst_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[data_analyst_agent], \n            tasks=[query_task])\nresult = crew.kickoff()",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import SnowflakeSearchTool, SnowflakeConfig\n\n# Create Snowflake configuration\nconfig = SnowflakeConfig(\n    account=\"your_account\",\n    user=\"your_username\",\n    password=\"your_password\",\n    warehouse=\"COMPUTE_WH\",\n    database=\"your_database\",\n    snowflake_schema=\"your_schema\"\n)\n\n# Initialize the tool\nsnowflake_tool = SnowflakeSearchTool(config=config)\n\n# Define an agent that uses the tool\ndata_analyst_agent = Agent(\n    role=\"Data Analyst\",\n    goal=\"Analyze data from Snowflake database\",\n    backstory=\"An expert data analyst who can extract insights from enterprise data.\",\n    tools=[snowflake_tool],\n    verbose=True,\n)\n\n# Example task to query sales data\nquery_task = Task(\n    description=\"Query the sales data for the last quarter and summarize the top 5 products by revenue.\",\n    expected_output=\"A summary of the top 5 products by revenue for the last quarter.\",\n    agent=data_analyst_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[data_analyst_agent], \n            tasks=[query_task])\nresult = crew.kickoff()",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import SnowflakeSearchTool, SnowflakeConfig\n\n# Create Snowflake configuration\nconfig = SnowflakeConfig(\n    account=\"your_account\",\n    user=\"your_username\",\n    password=\"your_password\",\n    warehouse=\"COMPUTE_WH\",\n    database=\"your_database\",\n    snowflake_schema=\"your_schema\"\n)\n\n# Initialize the tool\nsnowflake_tool = SnowflakeSearchTool(config=config)\n\n# Define an agent that uses the tool\ndata_analyst_agent = Agent(\n    role=\"Data Analyst\",\n    goal=\"Analyze data from Snowflake database\",\n    backstory=\"An expert data analyst who can extract insights from enterprise data.\",\n    tools=[snowflake_tool],\n    verbose=True,\n)\n\n# Example task to query sales data\nquery_task = Task(\n    description=\"Query the sales data for the last quarter and summarize the top 5 products by revenue.\",\n    expected_output=\"A summary of the top 5 products by revenue for the last quarter.\",\n    agent=data_analyst_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[data_analyst_agent], \n            tasks=[query_task])\nresult = crew.kickoff()"
    },
    {
      "content": "# Initialize the tool with custom parameters\nsnowflake_tool = SnowflakeSearchTool(\n    config=config,\n    pool_size=10,\n    max_retries=5,\n    retry_delay=2.0,\n    enable_caching=True\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\n# Initialize the tool with custom parameters\nsnowflake_tool = SnowflakeSearchTool(\n    config=config,\n    pool_size=10,\n    max_retries=5,\n    retry_delay=2.0,\n    enable_caching=True\n)",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\n# Initialize the tool with custom parameters\nsnowflake_tool = SnowflakeSearchTool(\n    config=config,\n    pool_size=10,\n    max_retries=5,\n    retry_delay=2.0,\n    enable_caching=True\n)"
    },
    {
      "content": "from crewai_tools import SpiderTool\n\ndef main():\n    spider_tool = SpiderTool()\n\n    searcher = Agent(\n        role=\"Web Research Expert\",\n        goal=\"Find related information from specific URL's\",\n        backstory=\"An expert web researcher that uses the web extremely well\",\n        tools=[spider_tool],\n        verbose=True,\n    )\n\n    return_metadata = Task(\n        description=\"Scrape https://spider.cloud with a limit of 1 and enable metadata\",\n        expected_output=\"Metadata and 10 word summary of spider.cloud\",\n        agent=searcher\n    )\n\n    crew = Crew(\n        agents=[searcher],\n        tasks=[\n            return_metadata,\n        ],\n        verbose=2\n    )\n\n    crew.kickoff()\n\nif __name__ == \"__main__\":\n    main()",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import SpiderTool\n\ndef main():\n    spider_tool = SpiderTool()\n\n    searcher = Agent(\n        role=\"Web Research Expert\",\n        goal=\"Find related information from specific URL's\",\n        backstory=\"An expert web researcher that uses the web extremely well\",\n        tools=[spider_tool],\n        verbose=True,\n    )\n\n    return_metadata = Task(\n        description=\"Scrape https://spider.cloud with a limit of 1 and enable metadata\",\n        expected_output=\"Metadata and 10 word summary of spider.cloud\",\n        agent=searcher\n    )\n\n    crew = Crew(\n        agents=[searcher],\n        tasks=[\n            return_metadata,\n        ],\n        verbose=2\n    )\n\n    crew.kickoff()\n\nif __name__ == \"__main__\":\n    main()",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import SpiderTool\n\ndef main():\n    spider_tool = SpiderTool()\n\n    searcher = Agent(\n        role=\"Web Research Expert\",\n        goal=\"Find related information from specific URL's\",\n        backstory=\"An expert web researcher that uses the web extremely well\",\n        tools=[spider_tool],\n        verbose=True,\n    )\n\n    return_metadata = Task(\n        description=\"Scrape https://spider.cloud with a limit of 1 and enable metadata\",\n        expected_output=\"Metadata and 10 word summary of spider.cloud\",\n        agent=searcher\n    )\n\n    crew = Crew(\n        agents=[searcher],\n        tasks=[\n            return_metadata,\n        ],\n        verbose=2\n    )\n\n    crew.kickoff()\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "content": "from crewai_tools import TXTSearchTool\n\n# Initialize the tool to search within any text file's content \n# the agent learns about during its execution\ntool = TXTSearchTool()\n\n# OR\n\n# Initialize the tool with a specific text file, \n# so the agent can search within the given text file's content\ntool = TXTSearchTool(txt='path/to/text/file.txt')",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import TXTSearchTool\n\n# Initialize the tool to search within any text file's content \n# the agent learns about during its execution\ntool = TXTSearchTool()\n\n# OR\n\n# Initialize the tool with a specific text file, \n# so the agent can search within the given text file's content\ntool = TXTSearchTool(txt='path/to/text/file.txt')",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import TXTSearchTool\n\n# Initialize the tool to search within any text file's content \n# the agent learns about during its execution\ntool = TXTSearchTool()\n\n# OR\n\n# Initialize the tool with a specific text file, \n# so the agent can search within the given text file's content\ntool = TXTSearchTool(txt='path/to/text/file.txt')"
    },
    {
      "content": "from crewai_tools import WeaviateVectorSearchTool\n\n# Initialize the tool\ntool = WeaviateVectorSearchTool(\n    collection_name='example_collections',\n    limit=3,\n    weaviate_cluster_url=\"https://your-weaviate-cluster-url.com\",\n    weaviate_api_key=\"your-weaviate-api-key\",\n)\n\n@agent\ndef search_agent(self) -> Agent:\n    '''\n    This agent uses the WeaviateVectorSearchTool to search for \n    semantically similar documents in a Weaviate vector database.\n    '''\n    return Agent(\n        config=self.agents_config[\"search_agent\"],\n        tools=[tool]\n    )",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import WeaviateVectorSearchTool\n\n# Initialize the tool\ntool = WeaviateVectorSearchTool(\n    collection_name='example_collections',\n    limit=3,\n    weaviate_cluster_url=\"https://your-weaviate-cluster-url.com\",\n    weaviate_api_key=\"your-weaviate-api-key\",\n)\n\n@agent\ndef search_agent(self) -> Agent:\n    '''\n    This agent uses the WeaviateVectorSearchTool to search for \n    semantically similar documents in a Weaviate vector database.\n    '''\n    return Agent(\n        config=self.agents_config[\"search_agent\"],\n        tools=[tool]\n    )",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import WeaviateVectorSearchTool\n\n# Initialize the tool\ntool = WeaviateVectorSearchTool(\n    collection_name='example_collections',\n    limit=3,\n    weaviate_cluster_url=\"https://your-weaviate-cluster-url.com\",\n    weaviate_api_key=\"your-weaviate-api-key\",\n)\n\n@agent\ndef search_agent(self) -> Agent:\n    '''\n    This agent uses the WeaviateVectorSearchTool to search for \n    semantically similar documents in a Weaviate vector database.\n    '''\n    return Agent(\n        config=self.agents_config[\"search_agent\"],\n        tools=[tool]\n    )"
    },
    {
      "content": "from crewai_tools import XMLSearchTool\n\n# Allow agents to search within any XML file's content \n#as it learns about their paths during execution\ntool = XMLSearchTool()\n\n# OR\n\n# Initialize the tool with a specific XML file path \n#for exclusive search within that document\ntool = XMLSearchTool(xml='path/to/your/xmlfile.xml')",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import XMLSearchTool\n\n# Allow agents to search within any XML file's content \n#as it learns about their paths during execution\ntool = XMLSearchTool()\n\n# OR\n\n# Initialize the tool with a specific XML file path \n#for exclusive search within that document\ntool = XMLSearchTool(xml='path/to/your/xmlfile.xml')",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai_tools import XMLSearchTool\n\n# Allow agents to search within any XML file's content \n#as it learns about their paths during execution\ntool = XMLSearchTool()\n\n# OR\n\n# Initialize the tool with a specific XML file path \n#for exclusive search within that document\ntool = XMLSearchTool(xml='path/to/your/xmlfile.xml')"
    },
    {
      "content": "from crewai import Agent, Task, Crew\nfrom crewai_tools import YoutubeChannelSearchTool\n\n# Initialize the tool for general YouTube channel searches\nyoutube_channel_tool = YoutubeChannelSearchTool()\n\n# Define an agent that uses the tool\nchannel_researcher = Agent(\n    role=\"Channel Researcher\",\n    goal=\"Extract relevant information from YouTube channels\",\n    backstory=\"An expert researcher who specializes in analyzing YouTube channel content.\",\n    tools=[youtube_channel_tool],\n    verbose=True,\n)\n\n# Example task to search for information in a specific channel\nresearch_task = Task(\n    description=\"Search for information about machine learning tutorials in the YouTube channel {youtube_channel_handle}\",\n    expected_output=\"A summary of the key machine learning tutorials available on the channel.\",\n    agent=channel_researcher,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[channel_researcher], tasks=[research_task])\nresult = crew.kickoff(inputs={\"youtube_channel_handle\": \"@exampleChannel\"})",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import YoutubeChannelSearchTool\n\n# Initialize the tool for general YouTube channel searches\nyoutube_channel_tool = YoutubeChannelSearchTool()\n\n# Define an agent that uses the tool\nchannel_researcher = Agent(\n    role=\"Channel Researcher\",\n    goal=\"Extract relevant information from YouTube channels\",\n    backstory=\"An expert researcher who specializes in analyzing YouTube channel content.\",\n    tools=[youtube_channel_tool],\n    verbose=True,\n)\n\n# Example task to search for information in a specific channel\nresearch_task = Task(\n    description=\"Search for information about machine learning tutorials in the YouTube channel {youtube_channel_handle}\",\n    expected_output=\"A summary of the key machine learning tutorials available on the channel.\",\n    agent=channel_researcher,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[channel_researcher], tasks=[research_task])\nresult = crew.kickoff(inputs={\"youtube_channel_handle\": \"@exampleChannel\"})",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import YoutubeChannelSearchTool\n\n# Initialize the tool for general YouTube channel searches\nyoutube_channel_tool = YoutubeChannelSearchTool()\n\n# Define an agent that uses the tool\nchannel_researcher = Agent(\n    role=\"Channel Researcher\",\n    goal=\"Extract relevant information from YouTube channels\",\n    backstory=\"An expert researcher who specializes in analyzing YouTube channel content.\",\n    tools=[youtube_channel_tool],\n    verbose=True,\n)\n\n# Example task to search for information in a specific channel\nresearch_task = Task(\n    description=\"Search for information about machine learning tutorials in the YouTube channel {youtube_channel_handle}\",\n    expected_output=\"A summary of the key machine learning tutorials available on the channel.\",\n    agent=channel_researcher,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[channel_researcher], tasks=[research_task])\nresult = crew.kickoff(inputs={\"youtube_channel_handle\": \"@exampleChannel\"})"
    },
    {
      "content": "# Initialize the tool with a specific YouTube channel handle\nyoutube_channel_tool = YoutubeChannelSearchTool(\n    youtube_channel_handle='@exampleChannel'\n)\n\n# Define an agent that uses the tool\nchannel_researcher = Agent(\n    role=\"Channel Researcher\",\n    goal=\"Extract relevant information from a specific YouTube channel\",\n    backstory=\"An expert researcher who specializes in analyzing YouTube channel content.\",\n    tools=[youtube_channel_tool],\n    verbose=True,\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\n# Initialize the tool with a specific YouTube channel handle\nyoutube_channel_tool = YoutubeChannelSearchTool(\n    youtube_channel_handle='@exampleChannel'\n)\n\n# Define an agent that uses the tool\nchannel_researcher = Agent(\n    role=\"Channel Researcher\",\n    goal=\"Extract relevant information from a specific YouTube channel\",\n    backstory=\"An expert researcher who specializes in analyzing YouTube channel content.\",\n    tools=[youtube_channel_tool],\n    verbose=True,\n)",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\n# Initialize the tool with a specific YouTube channel handle\nyoutube_channel_tool = YoutubeChannelSearchTool(\n    youtube_channel_handle='@exampleChannel'\n)\n\n# Define an agent that uses the tool\nchannel_researcher = Agent(\n    role=\"Channel Researcher\",\n    goal=\"Extract relevant information from a specific YouTube channel\",\n    backstory=\"An expert researcher who specializes in analyzing YouTube channel content.\",\n    tools=[youtube_channel_tool],\n    verbose=True,\n)"
    },
    {
      "content": "from crewai import Agent, Task, Crew\nfrom crewai_tools import YoutubeVideoSearchTool\n\n# Initialize the tool for general YouTube video searches\nyoutube_search_tool = YoutubeVideoSearchTool()\n\n# Define an agent that uses the tool\nvideo_researcher = Agent(\n    role=\"Video Researcher\",\n    goal=\"Extract relevant information from YouTube videos\",\n    backstory=\"An expert researcher who specializes in analyzing video content.\",\n    tools=[youtube_search_tool],\n    verbose=True,\n)\n\n# Example task to search for information in a specific video\nresearch_task = Task(\n    description=\"Search for information about machine learning frameworks in the YouTube video at {youtube_video_url}\",\n    expected_output=\"A summary of the key machine learning frameworks mentioned in the video.\",\n    agent=video_researcher,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[video_researcher], tasks=[research_task])\nresult = crew.kickoff(inputs={\"youtube_video_url\": \"https://youtube.com/watch?v=example\"})",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import YoutubeVideoSearchTool\n\n# Initialize the tool for general YouTube video searches\nyoutube_search_tool = YoutubeVideoSearchTool()\n\n# Define an agent that uses the tool\nvideo_researcher = Agent(\n    role=\"Video Researcher\",\n    goal=\"Extract relevant information from YouTube videos\",\n    backstory=\"An expert researcher who specializes in analyzing video content.\",\n    tools=[youtube_search_tool],\n    verbose=True,\n)\n\n# Example task to search for information in a specific video\nresearch_task = Task(\n    description=\"Search for information about machine learning frameworks in the YouTube video at {youtube_video_url}\",\n    expected_output=\"A summary of the key machine learning frameworks mentioned in the video.\",\n    agent=video_researcher,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[video_researcher], tasks=[research_task])\nresult = crew.kickoff(inputs={\"youtube_video_url\": \"https://youtube.com/watch?v=example\"})",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import YoutubeVideoSearchTool\n\n# Initialize the tool for general YouTube video searches\nyoutube_search_tool = YoutubeVideoSearchTool()\n\n# Define an agent that uses the tool\nvideo_researcher = Agent(\n    role=\"Video Researcher\",\n    goal=\"Extract relevant information from YouTube videos\",\n    backstory=\"An expert researcher who specializes in analyzing video content.\",\n    tools=[youtube_search_tool],\n    verbose=True,\n)\n\n# Example task to search for information in a specific video\nresearch_task = Task(\n    description=\"Search for information about machine learning frameworks in the YouTube video at {youtube_video_url}\",\n    expected_output=\"A summary of the key machine learning frameworks mentioned in the video.\",\n    agent=video_researcher,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[video_researcher], tasks=[research_task])\nresult = crew.kickoff(inputs={\"youtube_video_url\": \"https://youtube.com/watch?v=example\"})"
    },
    {
      "content": "# Initialize the tool with a specific YouTube video URL\nyoutube_search_tool = YoutubeVideoSearchTool(\n    youtube_video_url='https://youtube.com/watch?v=example'\n)\n\n# Define an agent that uses the tool\nvideo_researcher = Agent(\n    role=\"Video Researcher\",\n    goal=\"Extract relevant information from a specific YouTube video\",\n    backstory=\"An expert researcher who specializes in analyzing video content.\",\n    tools=[youtube_search_tool],\n    verbose=True,\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\n# Initialize the tool with a specific YouTube video URL\nyoutube_search_tool = YoutubeVideoSearchTool(\n    youtube_video_url='https://youtube.com/watch?v=example'\n)\n\n# Define an agent that uses the tool\nvideo_researcher = Agent(\n    role=\"Video Researcher\",\n    goal=\"Extract relevant information from a specific YouTube video\",\n    backstory=\"An expert researcher who specializes in analyzing video content.\",\n    tools=[youtube_search_tool],\n    verbose=True,\n)",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Example\n\n# Initialize the tool with a specific YouTube video URL\nyoutube_search_tool = YoutubeVideoSearchTool(\n    youtube_video_url='https://youtube.com/watch?v=example'\n)\n\n# Define an agent that uses the tool\nvideo_researcher = Agent(\n    role=\"Video Researcher\",\n    goal=\"Extract relevant information from a specific YouTube video\",\n    backstory=\"An expert researcher who specializes in analyzing video content.\",\n    tools=[youtube_search_tool],\n    verbose=True,\n)"
    },
    {
      "content": "`inputs` (dict): A dictionary containing the input data required for the tasks.\n\nThe `AIMindTool` accepts the following parameters: **api\\_key**: Optional. Your Minds API key. If not provided, it will be read from the `MINDS_API_KEY` environment variable. **datasources**: A list of dictionaries, each containing the following keys: **description**: A description of the data contained in the datasource. **engine**: The engine (or type) of the datasource. **connection\\_data**: A dictionary containing the connection parameters for the datasource. **tables**: A list of tables that the data source will use. This is optional and can be omitted if all tables in the data source are to be used. A list of supported data sources and their connection parameters can be found [here](https://docs.mdb.ai/docs/data_sources).",
      "title": "Parameters",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Parameters",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Parameters",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 1,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Parameters"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Parameters\n\n## Parameters\n\n`inputs` (dict): A dictionary containing the input data required for the tasks.\n\nThe `AIMindTool` accepts the following parameters: **api\\_key**: Optional. Your Minds API key. If not provided, it will be read from the `MINDS_API_KEY` environment variable. **datasources**: A list of dictionaries, each containing the following keys: **description**: A description of the data contained in the datasource. **engine**: The engine (or type) of the datasource. **connection\\_data**: A dictionary containing the connection parameters for the datasource. **tables**: A list of tables that the data source will use. This is optional and can be omitted if all tables in the data source are to be used. A list of supported data sources and their connection parameters can be found [here](https://docs.mdb.ai/docs/data_sources).",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Parameters",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Parameters\n\n Parameters\n\n`inputs` (dict): A dictionary containing the input data required for the tasks.\n\nThe `AIMindTool` accepts the following parameters: **api\\_key**: Optional. Your Minds API key. If not provided, it will be read from the `MINDS_API_KEY` environment variable. **datasources**: A list of dictionaries, each containing the following keys: **description**: A description of the data contained in the datasource. **engine**: The engine (or type) of the datasource. **connection\\_data**: A dictionary containing the connection parameters for the datasource. **tables**: A list of tables that the data source will use. This is optional and can be omitted if all tables in the data source are to be used. A list of supported data sources and their connection parameters can be found [here](https://docs.mdb.ai/docs/data_sources).\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "The `BraveSearchTool` accepts the following parameters: **search\\_query**: Mandatory. The search query you want to use to search the internet. **country**: Optional. Specify the country for the search results. Default is empty string. **n\\_results**: Optional. Number of search results to return. Default is `10`. **save\\_file**: Optional. Whether to save the search results to a file. Default is `False`.",
      "title": "Parameters",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Parameters",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Parameters",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Parameters"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Parameters\n\n## Parameters\n\nThe `BraveSearchTool` accepts the following parameters: **search\\_query**: Mandatory. The search query you want to use to search the internet. **country**: Optional. Specify the country for the search results. Default is empty string. **n\\_results**: Optional. Number of search results to return. Default is `10`. **save\\_file**: Optional. Whether to save the search results to a file. Default is `False`.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Parameters",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Parameters\n\n Parameters\n\nThe `BraveSearchTool` accepts the following parameters: **search\\_query**: Mandatory. The search query you want to use to search the internet. **country**: Optional. Specify the country for the search results. Default is empty string. **n\\_results**: Optional. Number of search results to return. Default is `10`. **save\\_file**: Optional. Whether to save the search results to a file. Default is `False`.\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "The `CodeInterpreterTool` accepts the following parameters during initialization: **user\\_dockerfile\\_path**: Optional. Path to a custom Dockerfile to use for the code interpreter container. **user\\_docker\\_base\\_url**: Optional. URL to the Docker daemon to use for running the container. **unsafe\\_mode**: Optional. Whether to run code directly on the host machine instead of in a Docker container. Default is `False`. Use with caution! When using the tool with an agent, the agent will need to provide: **code**: Required. The Python 3 code to execute. **libraries\\_used**: Required. A list of libraries used in the code that need to be installed.\n\nThe `HyperbrowserLoadTool` accepts the following parameters:\n\nThe `LinkupSearchTool` accepts the following parameters:",
      "title": "Parameters",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Parameters",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Parameters",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Parameters"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Parameters\n\n## Parameters\n\nThe `CodeInterpreterTool` accepts the following parameters during initialization: **user\\_dockerfile\\_path**: Optional. Path to a custom Dockerfile to use for the code interpreter container. **user\\_docker\\_base\\_url**: Optional. URL to the Docker daemon to use for running the container. **unsafe\\_mode**: Optional. Whether to run code directly on the host machine instead of in a Docker container. Default is `False`. Use with caution! When using the tool with an agent, the agent will need to provide: **code**: Required. The Python 3 code to execute. **libraries\\_used**: Required. A list of libraries used in the code that need to be installed.\n\nThe `HyperbrowserLoadTool` accepts the following parameters:\n\nThe `LinkupSearchTool` accepts the following parameters:",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Parameters",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Parameters\n\n Parameters\n\nThe `CodeInterpreterTool` accepts the following parameters during initialization: **user\\_dockerfile\\_path**: Optional. Path to a custom Dockerfile to use for the code interpreter container. **user\\_docker\\_base\\_url**: Optional. URL to the Docker daemon to use for running the container. **unsafe\\_mode**: Optional. Whether to run code directly on the host machine instead of in a Docker container. Default is `False`. Use with caution! When using the tool with an agent, the agent will need to provide: **code**: Required. The Python 3 code to execute. **libraries\\_used**: Required. A list of libraries used in the code that need to be installed.\n\nThe `HyperbrowserLoadTool` accepts the following parameters:\n\nThe `LinkupSearchTool` accepts the following parameters:\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "The `from_query_engine` method accepts the following parameters: **query\\_engine**: Required. The LlamaIndex query engine to wrap. **name**: Optional. The name of the tool. **description**: Optional. The description of the tool. **return\\_direct**: Optional. Whether to return the response directly. Default is `False`.\n\nmdx: **Optional**. Specifies the MDX file path for the search. It can be provided during initialization.\n\nThe `MultiOnTool` accepts the following parameters during initialization: **api\\_key**: Optional. Specifies the MultiOn API key. If not provided, it will look for the `MULTION_API_KEY` environment variable. **local**: Optional. Set to `True` to run the agent locally on your browser. Make sure the MultiOn browser extension is installed and API Enabled is checked. Default is `False`. **max\\_steps**: Optional. Sets the maximum number of steps the MultiOn agent can take for a command. Default is `3`.",
      "title": "Parameters",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Parameters",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Parameters",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Parameters"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Parameters\n\n## Parameters\n\nThe `from_query_engine` method accepts the following parameters: **query\\_engine**: Required. The LlamaIndex query engine to wrap. **name**: Optional. The name of the tool. **description**: Optional. The description of the tool. **return\\_direct**: Optional. Whether to return the response directly. Default is `False`.\n\nmdx: **Optional**. Specifies the MDX file path for the search. It can be provided during initialization.\n\nThe `MultiOnTool` accepts the following parameters during initialization: **api\\_key**: Optional. Specifies the MultiOn API key. If not provided, it will look for the `MULTION_API_KEY` environment variable. **local**: Optional. Set to `True` to run the agent locally on your browser. Make sure the MultiOn browser extension is installed and API Enabled is checked. Default is `False`. **max\\_steps**: Optional. Sets the maximum number of steps the MultiOn agent can take for a command. Default is `3`.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Parameters",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Parameters\n\n Parameters\n\nThe `from_query_engine` method accepts the following parameters: **query\\_engine**: Required. The LlamaIndex query engine to wrap. **name**: Optional. The name of the tool. **description**: Optional. The description of the tool. **return\\_direct**: Optional. Whether to return the response directly. Default is `False`.\n\nmdx: **Optional**. Specifies the MDX file path for the search. It can be provided during initialization.\n\nThe `MultiOnTool` accepts the following parameters during initialization: **api\\_key**: Optional. Specifies the MultiOn API key. If not provided, it will look for the `MULTION_API_KEY` environment variable. **local**: Optional. Set to `True` to run the agent locally on your browser. Make sure the MultiOn browser extension is installed and API Enabled is checked. Default is `False`. **max\\_steps**: Optional. Sets the maximum number of steps the MultiOn agent can take for a command. Default is `3`.\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "The `RagTool` accepts the following parameters: **summarize**: Optional. Whether to summarize the retrieved content. Default is `False`. **adapter**: Optional. A custom adapter for the knowledge base. If not provided, an EmbedchainAdapter will be used. **config**: Optional. Configuration for the underlying EmbedChain App.\n\nThe `S3ReaderTool` accepts the following parameter when used by an agent: **file\\_path**: Required. The S3 file path in the format `s3://bucket-name/file-name`.\n\nThe `S3WriterTool` accepts the following parameters when used by an agent: **file\\_path**: Required. The S3 file path in the format `s3://bucket-name/file-name`. **content**: Required. The content to write to the file.",
      "title": "Parameters",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Parameters",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Parameters",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Parameters"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Parameters\n\n## Parameters\n\nThe `RagTool` accepts the following parameters: **summarize**: Optional. Whether to summarize the retrieved content. Default is `False`. **adapter**: Optional. A custom adapter for the knowledge base. If not provided, an EmbedchainAdapter will be used. **config**: Optional. Configuration for the underlying EmbedChain App.\n\nThe `S3ReaderTool` accepts the following parameter when used by an agent: **file\\_path**: Required. The S3 file path in the format `s3://bucket-name/file-name`.\n\nThe `S3WriterTool` accepts the following parameters when used by an agent: **file\\_path**: Required. The S3 file path in the format `s3://bucket-name/file-name`. **content**: Required. The content to write to the file.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Parameters",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Parameters\n\n Parameters\n\nThe `RagTool` accepts the following parameters: **summarize**: Optional. Whether to summarize the retrieved content. Default is `False`. **adapter**: Optional. A custom adapter for the knowledge base. If not provided, an EmbedchainAdapter will be used. **config**: Optional. Configuration for the underlying EmbedChain App.\n\nThe `S3ReaderTool` accepts the following parameter when used by an agent: **file\\_path**: Required. The S3 file path in the format `s3://bucket-name/file-name`.\n\nThe `S3WriterTool` accepts the following parameters when used by an agent: **file\\_path**: Required. The S3 file path in the format `s3://bucket-name/file-name`. **content**: Required. The content to write to the file.\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "The `ScrapeElementFromWebsiteTool` accepts the following parameters during initialization: **website\\_url**: Optional. The URL of the website to scrape. If provided during initialization, the agent won't need to specify it when using the tool. **css\\_element**: Optional. The CSS selector for the elements to extract. If provided during initialization, the agent won't need to specify it when using the tool. **cookies**: Optional. A dictionary containing cookies to be sent with the request. This can be useful for websites that require authentication.",
      "title": "Parameters",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Parameters",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Parameters",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Parameters"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Parameters\n\n## Parameters\n\nThe `ScrapeElementFromWebsiteTool` accepts the following parameters during initialization: **website\\_url**: Optional. The URL of the website to scrape. If provided during initialization, the agent won't need to specify it when using the tool. **css\\_element**: Optional. The CSS selector for the elements to extract. If provided during initialization, the agent won't need to specify it when using the tool. **cookies**: Optional. A dictionary containing cookies to be sent with the request. This can be useful for websites that require authentication.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Parameters",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Parameters\n\n Parameters\n\nThe `ScrapeElementFromWebsiteTool` accepts the following parameters during initialization: **website\\_url**: Optional. The URL of the website to scrape. If provided during initialization, the agent won't need to specify it when using the tool. **css\\_element**: Optional. The CSS selector for the elements to extract. If provided during initialization, the agent won't need to specify it when using the tool. **cookies**: Optional. A dictionary containing cookies to be sent with the request. This can be useful for websites that require authentication.\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "The `ScrapegraphScrapeTool` accepts the following parameters during initialization: **api\\_key**: Optional. Your Scrapegraph API key. If not provided, it will look for the `SCRAPEGRAPH_API_KEY` environment variable. **website\\_url**: Optional. The URL of the website to scrape. If provided during initialization, the agent won't need to specify it when using the tool. **user\\_prompt**: Optional. Custom instructions for content extraction. If provided during initialization, the agent won't need to specify it when using the tool. **enable\\_logging**: Optional. Whether to enable logging for the Scrapegraph client. Default is `False`.\n\nThe `ScrapflyScrapeWebsiteTool` accepts the following parameters:",
      "title": "Parameters",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Parameters",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Parameters",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Parameters"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Parameters\n\n## Parameters\n\nThe `ScrapegraphScrapeTool` accepts the following parameters during initialization: **api\\_key**: Optional. Your Scrapegraph API key. If not provided, it will look for the `SCRAPEGRAPH_API_KEY` environment variable. **website\\_url**: Optional. The URL of the website to scrape. If provided during initialization, the agent won't need to specify it when using the tool. **user\\_prompt**: Optional. Custom instructions for content extraction. If provided during initialization, the agent won't need to specify it when using the tool. **enable\\_logging**: Optional. Whether to enable logging for the Scrapegraph client. Default is `False`.\n\nThe `ScrapflyScrapeWebsiteTool` accepts the following parameters:",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Parameters",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Parameters\n\n Parameters\n\nThe `ScrapegraphScrapeTool` accepts the following parameters during initialization: **api\\_key**: Optional. Your Scrapegraph API key. If not provided, it will look for the `SCRAPEGRAPH_API_KEY` environment variable. **website\\_url**: Optional. The URL of the website to scrape. If provided during initialization, the agent won't need to specify it when using the tool. **user\\_prompt**: Optional. Custom instructions for content extraction. If provided during initialization, the agent won't need to specify it when using the tool. **enable\\_logging**: Optional. Whether to enable logging for the Scrapegraph client. Default is `False`.\n\nThe `ScrapflyScrapeWebsiteTool` accepts the following parameters:\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "The `SeleniumScrapingTool` accepts the following parameters during initialization: **website\\_url**: Optional. The URL of the website to scrape. If provided during initialization, the agent won't need to specify it when using the tool. **css\\_element**: Optional. The CSS selector for the elements to extract. If provided during initialization, the agent won't need to specify it when using the tool. **cookie**: Optional. A dictionary containing cookie information, useful for simulating a logged-in session to access restricted content. **wait\\_time**: Optional. Specifies the delay (in seconds) before scraping, allowing the website and any dynamic content to fully load. Default is `3` seconds. **return\\_html**: Optional. Whether to return the HTML content instead of just the text. Default is `False`. When using the tool with an agent, the agent will need to provide the following parameters (unless they were specified during initialization): **website\\_url**: Required. The URL of the website to scrape. **css\\_element**: Required. The CSS selector for the elements to extract.",
      "title": "Parameters",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Parameters",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Parameters",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Parameters"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Parameters\n\n## Parameters\n\nThe `SeleniumScrapingTool` accepts the following parameters during initialization: **website\\_url**: Optional. The URL of the website to scrape. If provided during initialization, the agent won't need to specify it when using the tool. **css\\_element**: Optional. The CSS selector for the elements to extract. If provided during initialization, the agent won't need to specify it when using the tool. **cookie**: Optional. A dictionary containing cookie information, useful for simulating a logged-in session to access restricted content. **wait\\_time**: Optional. Specifies the delay (in seconds) before scraping, allowing the website and any dynamic content to fully load. Default is `3` seconds. **return\\_html**: Optional. Whether to return the HTML content instead of just the text. Default is `False`. When using the tool with an agent, the agent will need to provide the following parameters (unless they were specified during initialization): **website\\_url**: Required. The URL of the website to scrape. **css\\_element**: Required. The CSS selector for the elements to extract.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Parameters",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Parameters\n\n Parameters\n\nThe `SeleniumScrapingTool` accepts the following parameters during initialization: **website\\_url**: Optional. The URL of the website to scrape. If provided during initialization, the agent won't need to specify it when using the tool. **css\\_element**: Optional. The CSS selector for the elements to extract. If provided during initialization, the agent won't need to specify it when using the tool. **cookie**: Optional. A dictionary containing cookie information, useful for simulating a logged-in session to access restricted content. **wait\\_time**: Optional. Specifies the delay (in seconds) before scraping, allowing the website and any dynamic content to fully load. Default is `3` seconds. **return\\_html**: Optional. Whether to return the HTML content instead of just the text. Default is `False`. When using the tool with an agent, the agent will need to provide the following parameters (unless they were specified during initialization): **website\\_url**: Required. The URL of the website to scrape. **css\\_element**: Required. The CSS selector for the elements to extract.\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "following parameters during initialization: **website\\_url**: Optional. The URL of the website to scrape. If provided during initialization, the agent won't need to specify it when using the tool. **css\\_element**: Optional. The CSS selector for the elements to extract. If provided during initialization, the agent won't need to specify it when using the tool. **cookie**: Optional. A dictionary containing cookie information, useful for simulating a logged-in session to access restricted content. **wait\\_time**: Optional. Specifies the delay (in seconds) before scraping, allowing the website and any dynamic content to fully load. Default is `3` seconds. **return\\_html**: Optional. Whether to return the HTML content instead of just the text. Default is `False`. When using the tool with an agent, the agent will need to provide the following parameters (unless they were specified during initialization): **website\\_url**: Required. The URL of the website to scrape. **css\\_element**: Required. The CSS selector for the elements to extract.\n\nThe `SerperDevTool` comes with several parameters that will be passed to the API : **search\\_url**: The URL endpoint for the search API. (Default is `https://google.serper.dev/search`) **country**: Optional. Specify the country for the search results. **location**: Optional. Specify the location for the search results. **locale**: Optional. Specify the locale for the search results. **n\\_results**: Number of search results to return. Default is `10`. The values for `country`, `location`, `locale` and `search_url` can be found on the [Serper Playground](https://serper.dev/playground).",
      "title": "Parameters",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Parameters",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Parameters",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 1,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Parameters"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Parameters\n\n## Parameters\n\nfollowing parameters during initialization: **website\\_url**: Optional. The URL of the website to scrape. If provided during initialization, the agent won't need to specify it when using the tool. **css\\_element**: Optional. The CSS selector for the elements to extract. If provided during initialization, the agent won't need to specify it when using the tool. **cookie**: Optional. A dictionary containing cookie information, useful for simulating a logged-in session to access restricted content. **wait\\_time**: Optional. Specifies the delay (in seconds) before scraping, allowing the website and any dynamic content to fully load. Default is `3` seconds. **return\\_html**: Optional. Whether to return the HTML content instead of just the text. Default is `False`. When using the tool with an agent, the agent will need to provide the following parameters (unless they were specified during initialization): **website\\_url**: Required. The URL of the website to scrape. **css\\_element**: Required. The CSS selector for the elements to extract.\n\nThe `SerperDevTool` comes with several parameters that will be passed to the API : **search\\_url**: The URL endpoint for the search API. (Default is `https://google.serper.dev/search`) **country**: Optional. Specify the country for the search results. **location**: Optional. Specify the location for the search results. **locale**: Optional. Specify the locale for the search results. **n\\_results**: Number of search results to return. Default is `10`. The values for `country`, `location`, `locale` and `search_url` can be found on the [Serper Playground](https://serper.dev/playground).",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Parameters",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Parameters\n\n Parameters\n\nfollowing parameters during initialization: **website\\_url**: Optional. The URL of the website to scrape. If provided during initialization, the agent won't need to specify it when using the tool. **css\\_element**: Optional. The CSS selector for the elements to extract. If provided during initialization, the agent won't need to specify it when using the tool. **cookie**: Optional. A dictionary containing cookie information, useful for simulating a logged-in session to access restricted content. **wait\\_time**: Optional. Specifies the delay (in seconds) before scraping, allowing the website and any dynamic content to fully load. Default is `3` seconds. **return\\_html**: Optional. Whether to return the HTML content instead of just the text. Default is `False`. When using the tool with an agent, the agent will need to provide the following parameters (unless they were specified during initialization): **website\\_url**: Required. The URL of the website to scrape. **css\\_element**: Required. The CSS selector for the elements to extract.\n\nThe `SerperDevTool` comes with several parameters that will be passed to the API : **search\\_url**: The URL endpoint for the search API. (Default is `https://google.serper.dev/search`) **country**: Optional. Specify the country for the search results. **location**: Optional. Specify the location for the search results. **locale**: Optional. Specify the locale for the search results. **n\\_results**: Number of search results to return. Default is `10`. The values for `country`, `location`, `locale` and `search_url` can be found on the [Serper Playground](https://serper.dev/playground).\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "before scraping, allowing the website and any dynamic content to fully load. Default is `3` seconds. **return\\_html**: Optional. Whether to return the HTML content instead of just the text. Default is `False`. When using the tool with an agent, the agent will need to provide the following parameters (unless they were specified during initialization): **website\\_url**: Required. The URL of the website to scrape. **css\\_element**: Required. The CSS selector for the elements to extract. The `SerperDevTool` comes with several parameters that will be passed to the API : **search\\_url**: The URL endpoint for the search API. (Default is `https://google.serper.dev/search`) **country**: Optional. Specify the country for the search results. **location**: Optional. Specify the location for the search results. **locale**: Optional. Specify the locale for the search results. **n\\_results**: Number of search results to return. Default is `10`. The values for `country`, `location`, `locale` and `search_url` can be found on the [Serper Playground](https://serper.dev/playground).\n\nThe `WeaviateVectorSearchTool` accepts the following parameters: **collection\\_name**: Required. The name of the collection to search within. **weaviate\\_cluster\\_url**: Required. The URL of the Weaviate cluster. **weaviate\\_api\\_key**: Required. The API key for the Weaviate cluster. **limit**: Optional. The number of results to return. Default is `3`. **vectorizer**: Optional. The vectorizer to use. If not provided, it will use `text2vec_openai` with the `nomic-embed-text` model. **generative\\_model**: Optional. The generative model to use. If not provided, it will use OpenAI's `gpt-4o`.",
      "title": "Parameters",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Parameters",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Parameters",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 1,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Parameters"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Parameters\n\n## Parameters\n\nbefore scraping, allowing the website and any dynamic content to fully load. Default is `3` seconds. **return\\_html**: Optional. Whether to return the HTML content instead of just the text. Default is `False`. When using the tool with an agent, the agent will need to provide the following parameters (unless they were specified during initialization): **website\\_url**: Required. The URL of the website to scrape. **css\\_element**: Required. The CSS selector for the elements to extract. The `SerperDevTool` comes with several parameters that will be passed to the API : **search\\_url**: The URL endpoint for the search API. (Default is `https://google.serper.dev/search`) **country**: Optional. Specify the country for the search results. **location**: Optional. Specify the location for the search results. **locale**: Optional. Specify the locale for the search results. **n\\_results**: Number of search results to return. Default is `10`. The values for `country`, `location`, `locale` and `search_url` can be found on the [Serper Playground](https://serper.dev/playground).\n\nThe `WeaviateVectorSearchTool` accepts the following parameters: **collection\\_name**: Required. The name of the collection to search within. **weaviate\\_cluster\\_url**: Required. The URL of the Weaviate cluster. **weaviate\\_api\\_key**: Required. The API key for the Weaviate cluster. **limit**: Optional. The number of results to return. Default is `3`. **vectorizer**: Optional. The vectorizer to use. If not provided, it will use `text2vec_openai` with the `nomic-embed-text` model. **generative\\_model**: Optional. The generative model to use. If not provided, it will use OpenAI's `gpt-4o`.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Parameters",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Parameters\n\n Parameters\n\nbefore scraping, allowing the website and any dynamic content to fully load. Default is `3` seconds. **return\\_html**: Optional. Whether to return the HTML content instead of just the text. Default is `False`. When using the tool with an agent, the agent will need to provide the following parameters (unless they were specified during initialization): **website\\_url**: Required. The URL of the website to scrape. **css\\_element**: Required. The CSS selector for the elements to extract. The `SerperDevTool` comes with several parameters that will be passed to the API : **search\\_url**: The URL endpoint for the search API. (Default is `https://google.serper.dev/search`) **country**: Optional. Specify the country for the search results. **location**: Optional. Specify the location for the search results. **locale**: Optional. Specify the locale for the search results. **n\\_results**: Number of search results to return. Default is `10`. The values for `country`, `location`, `locale` and `search_url` can be found on the [Serper Playground](https://serper.dev/playground).\n\nThe `WeaviateVectorSearchTool` accepts the following parameters: **collection\\_name**: Required. The name of the collection to search within. **weaviate\\_cluster\\_url**: Required. The URL of the Weaviate cluster. **weaviate\\_api\\_key**: Required. The API key for the Weaviate cluster. **limit**: Optional. The number of results to return. Default is `3`. **vectorizer**: Optional. The vectorizer to use. If not provided, it will use `text2vec_openai` with the `nomic-embed-text` model. **generative\\_model**: Optional. The generative model to use. If not provided, it will use OpenAI's `gpt-4o`.\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "with several parameters that will be passed to the API : **search\\_url**: The URL endpoint for the search API. (Default is `https://google.serper.dev/search`) **country**: Optional. Specify the country for the search results. **location**: Optional. Specify the location for the search results. **locale**: Optional. Specify the locale for the search results. **n\\_results**: Number of search results to return. Default is `10`. The values for `country`, `location`, `locale` and `search_url` can be found on the [Serper Playground](https://serper.dev/playground). The `WeaviateVectorSearchTool` accepts the following parameters: **collection\\_name**: Required. The name of the collection to search within. **weaviate\\_cluster\\_url**: Required. The URL of the Weaviate cluster. **weaviate\\_api\\_key**: Required. The API key for the Weaviate cluster. **limit**: Optional. The number of results to return. Default is `3`. **vectorizer**: Optional. The vectorizer to use. If not provided, it will use `text2vec_openai` with the `nomic-embed-text` model. **generative\\_model**: Optional. The generative model to use. If not provided, it will use OpenAI's `gpt-4o`.\n\nThe `YoutubeChannelSearchTool` accepts the following parameters: **youtube\\_channel\\_handle**: Optional. The handle of the YouTube channel to search within. If provided during initialization, the agent won't need to specify it when using the tool. If the handle doesn't start with '@', it will be automatically added. **config**: Optional. Configuration for the underlying RAG system, including LLM and embedder settings. **summarize**: Optional. Whether to summarize the retrieved content. Default is `False`. When using the tool with an agent, the agent will need to provide: **search\\_query**: Required. The search query to find relevant information in the channel content. **youtube\\_channel\\_handle**: Required only if not provided during initialization. The handle of the YouTube channel to search within.",
      "title": "Parameters",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Parameters",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Parameters",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 1,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Parameters"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Parameters\n\n## Parameters\n\nwith several parameters that will be passed to the API : **search\\_url**: The URL endpoint for the search API. (Default is `https://google.serper.dev/search`) **country**: Optional. Specify the country for the search results. **location**: Optional. Specify the location for the search results. **locale**: Optional. Specify the locale for the search results. **n\\_results**: Number of search results to return. Default is `10`. The values for `country`, `location`, `locale` and `search_url` can be found on the [Serper Playground](https://serper.dev/playground). The `WeaviateVectorSearchTool` accepts the following parameters: **collection\\_name**: Required. The name of the collection to search within. **weaviate\\_cluster\\_url**: Required. The URL of the Weaviate cluster. **weaviate\\_api\\_key**: Required. The API key for the Weaviate cluster. **limit**: Optional. The number of results to return. Default is `3`. **vectorizer**: Optional. The vectorizer to use. If not provided, it will use `text2vec_openai` with the `nomic-embed-text` model. **generative\\_model**: Optional. The generative model to use. If not provided, it will use OpenAI's `gpt-4o`.\n\nThe `YoutubeChannelSearchTool` accepts the following parameters: **youtube\\_channel\\_handle**: Optional. The handle of the YouTube channel to search within. If provided during initialization, the agent won't need to specify it when using the tool. If the handle doesn't start with '@', it will be automatically added. **config**: Optional. Configuration for the underlying RAG system, including LLM and embedder settings. **summarize**: Optional. Whether to summarize the retrieved content. Default is `False`. When using the tool with an agent, the agent will need to provide: **search\\_query**: Required. The search query to find relevant information in the channel content. **youtube\\_channel\\_handle**: Required only if not provided during initialization. The handle of the YouTube channel to search within.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Parameters",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Parameters\n\n Parameters\n\nwith several parameters that will be passed to the API : **search\\_url**: The URL endpoint for the search API. (Default is `https://google.serper.dev/search`) **country**: Optional. Specify the country for the search results. **location**: Optional. Specify the location for the search results. **locale**: Optional. Specify the locale for the search results. **n\\_results**: Number of search results to return. Default is `10`. The values for `country`, `location`, `locale` and `search_url` can be found on the [Serper Playground](https://serper.dev/playground). The `WeaviateVectorSearchTool` accepts the following parameters: **collection\\_name**: Required. The name of the collection to search within. **weaviate\\_cluster\\_url**: Required. The URL of the Weaviate cluster. **weaviate\\_api\\_key**: Required. The API key for the Weaviate cluster. **limit**: Optional. The number of results to return. Default is `3`. **vectorizer**: Optional. The vectorizer to use. If not provided, it will use `text2vec_openai` with the `nomic-embed-text` model. **generative\\_model**: Optional. The generative model to use. If not provided, it will use OpenAI's `gpt-4o`.\n\nThe `YoutubeChannelSearchTool` accepts the following parameters: **youtube\\_channel\\_handle**: Optional. The handle of the YouTube channel to search within. If provided during initialization, the agent won't need to specify it when using the tool. If the handle doesn't start with '@', it will be automatically added. **config**: Optional. Configuration for the underlying RAG system, including LLM and embedder settings. **summarize**: Optional. Whether to summarize the retrieved content. Default is `False`. When using the tool with an agent, the agent will need to provide: **search\\_query**: Required. The search query to find relevant information in the channel content. **youtube\\_channel\\_handle**: Required only if not provided during initialization. The handle of the YouTube channel to search within.\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "of results to return. Default is `3`. **vectorizer**: Optional. The vectorizer to use. If not provided, it will use `text2vec_openai` with the `nomic-embed-text` model. **generative\\_model**: Optional. The generative model to use. If not provided, it will use OpenAI's `gpt-4o`. The `YoutubeChannelSearchTool` accepts the following parameters: **youtube\\_channel\\_handle**: Optional. The handle of the YouTube channel to search within. If provided during initialization, the agent won't need to specify it when using the tool. If the handle doesn't start with '@', it will be automatically added. **config**: Optional. Configuration for the underlying RAG system, including LLM and embedder settings. **summarize**: Optional. Whether to summarize the retrieved content. Default is `False`. When using the tool with an agent, the agent will need to provide: **search\\_query**: Required. The search query to find relevant information in the channel content. **youtube\\_channel\\_handle**: Required only if not provided during initialization. The handle of the YouTube channel to search within.\n\nThe `YoutubeVideoSearchTool` accepts the following parameters: **youtube\\_video\\_url**: Optional. The URL of the YouTube video to search within. If provided during initialization, the agent won't need to specify it when using the tool. **config**: Optional. Configuration for the underlying RAG system, including LLM and embedder settings. **summarize**: Optional. Whether to summarize the retrieved content. Default is `False`. When using the tool with an agent, the agent will need to provide: **search\\_query**: Required. The search query to find relevant information in the video content. **youtube\\_video\\_url**: Required only if not provided during initialization. The URL of the YouTube video to search within.",
      "title": "Parameters",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Parameters",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Parameters",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          [],
          []
        ],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Parameters"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Parameters\n\n## Parameters\n\nof results to return. Default is `3`. **vectorizer**: Optional. The vectorizer to use. If not provided, it will use `text2vec_openai` with the `nomic-embed-text` model. **generative\\_model**: Optional. The generative model to use. If not provided, it will use OpenAI's `gpt-4o`. The `YoutubeChannelSearchTool` accepts the following parameters: **youtube\\_channel\\_handle**: Optional. The handle of the YouTube channel to search within. If provided during initialization, the agent won't need to specify it when using the tool. If the handle doesn't start with '@', it will be automatically added. **config**: Optional. Configuration for the underlying RAG system, including LLM and embedder settings. **summarize**: Optional. Whether to summarize the retrieved content. Default is `False`. When using the tool with an agent, the agent will need to provide: **search\\_query**: Required. The search query to find relevant information in the channel content. **youtube\\_channel\\_handle**: Required only if not provided during initialization. The handle of the YouTube channel to search within.\n\nThe `YoutubeVideoSearchTool` accepts the following parameters: **youtube\\_video\\_url**: Optional. The URL of the YouTube video to search within. If provided during initialization, the agent won't need to specify it when using the tool. **config**: Optional. Configuration for the underlying RAG system, including LLM and embedder settings. **summarize**: Optional. Whether to summarize the retrieved content. Default is `False`. When using the tool with an agent, the agent will need to provide: **search\\_query**: Required. The search query to find relevant information in the video content. **youtube\\_video\\_url**: Required only if not provided during initialization. The URL of the YouTube video to search within.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Parameters",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Parameters\n\n Parameters\n\nof results to return. Default is `3`. **vectorizer**: Optional. The vectorizer to use. If not provided, it will use `text2vec_openai` with the `nomic-embed-text` model. **generative\\_model**: Optional. The generative model to use. If not provided, it will use OpenAI's `gpt-4o`. The `YoutubeChannelSearchTool` accepts the following parameters: **youtube\\_channel\\_handle**: Optional. The handle of the YouTube channel to search within. If provided during initialization, the agent won't need to specify it when using the tool. If the handle doesn't start with '@', it will be automatically added. **config**: Optional. Configuration for the underlying RAG system, including LLM and embedder settings. **summarize**: Optional. Whether to summarize the retrieved content. Default is `False`. When using the tool with an agent, the agent will need to provide: **search\\_query**: Required. The search query to find relevant information in the channel content. **youtube\\_channel\\_handle**: Required only if not provided during initialization. The handle of the YouTube channel to search within.\n\nThe `YoutubeVideoSearchTool` accepts the following parameters: **youtube\\_video\\_url**: Optional. The URL of the YouTube video to search within. If provided during initialization, the agent won't need to specify it when using the tool. **config**: Optional. Configuration for the underlying RAG system, including LLM and embedder settings. **summarize**: Optional. Whether to summarize the retrieved content. Default is `False`. When using the tool with an agent, the agent will need to provide: **search\\_query**: Required. The search query to find relevant information in the video content. **youtube\\_video\\_url**: Required only if not provided during initialization. The URL of the YouTube video to search within.\n\nRelated sections:\n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n- \n"
    },
    {
      "content": "tool = DirectorySearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # Options include ollama, google, anthropic, llama2, and more\n            config=dict(\n                model=\"llama2\",\n                # Additional configurations here\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Custom Model and Embeddings",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Custom Model and Embeddings",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Custom Model and Embeddings"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Custom Model and Embeddings\n\ntool = DirectorySearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # Options include ollama, google, anthropic, llama2, and more\n            config=dict(\n                model=\"llama2\",\n                # Additional configurations here\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Custom Model and Embeddings",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Custom Model and Embeddings\n\ntool = DirectorySearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # Options include ollama, google, anthropic, llama2, and more\n            config=dict(\n                model=\"llama2\",\n                # Additional configurations here\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)"
    },
    {
      "content": "tool = PGSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Custom Model and Embeddings",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Custom Model and Embeddings",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Custom Model and Embeddings"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Custom Model and Embeddings\n\ntool = PGSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Custom Model and Embeddings",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Custom Model and Embeddings\n\ntool = PGSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)"
    },
    {
      "content": "youtube_channel_tool = YoutubeChannelSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Custom Model and Embeddings",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Custom Model and Embeddings",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Custom Model and Embeddings"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Custom Model and Embeddings\n\nyoutube_channel_tool = YoutubeChannelSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Custom Model and Embeddings",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Custom Model and Embeddings\n\nyoutube_channel_tool = YoutubeChannelSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)"
    },
    {
      "content": "youtube_search_tool = YoutubeVideoSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Custom Model and Embeddings",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Custom Model and Embeddings",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Custom Model and Embeddings"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Custom Model and Embeddings\n\nyoutube_search_tool = YoutubeVideoSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Custom Model and Embeddings",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Custom Model and Embeddings\n\nyoutube_search_tool = YoutubeVideoSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)"
    },
    {
      "content": "from crewai import Agent\nfrom crewai.project import agent\nfrom crewai_tools import AIMindTool\n\n# Initialize the tool\naimind_tool = AIMindTool(\n    datasources=[\n        {\n            \"description\": \"sales data\",\n            \"engine\": \"postgres\",\n            \"connection_data\": {\n                \"user\": \"your_user\",\n                \"password\": \"your_password\",\n                \"host\": \"your_host\",\n                \"port\": 5432,\n                \"database\": \"your_db\",\n                \"schema\": \"your_schema\"\n            },\n            \"tables\": [\"sales\"]\n        }\n    ]\n)\n\n# Define an agent with the AIMindTool\n@agent\ndef data_analyst(self) -> Agent:\n    return Agent(\n        config=self.agents_config[\"data_analyst\"],\n        allow_delegation=False,\n        tools=[aimind_tool]\n    )",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Agent Integration Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Agent Integration Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Agent Integration Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Agent Integration Example\n\nfrom crewai import Agent\nfrom crewai.project import agent\nfrom crewai_tools import AIMindTool\n\n# Initialize the tool\naimind_tool = AIMindTool(\n    datasources=[\n        {\n            \"description\": \"sales data\",\n            \"engine\": \"postgres\",\n            \"connection_data\": {\n                \"user\": \"your_user\",\n                \"password\": \"your_password\",\n                \"host\": \"your_host\",\n                \"port\": 5432,\n                \"database\": \"your_db\",\n                \"schema\": \"your_schema\"\n            },\n            \"tables\": [\"sales\"]\n        }\n    ]\n)\n\n# Define an agent with the AIMindTool\n@agent\ndef data_analyst(self) -> Agent:\n    return Agent(\n        config=self.agents_config[\"data_analyst\"],\n        allow_delegation=False,\n        tools=[aimind_tool]\n    )",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Agent Integration Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Agent Integration Example\n\nfrom crewai import Agent\nfrom crewai.project import agent\nfrom crewai_tools import AIMindTool\n\n# Initialize the tool\naimind_tool = AIMindTool(\n    datasources=[\n        {\n            \"description\": \"sales data\",\n            \"engine\": \"postgres\",\n            \"connection_data\": {\n                \"user\": \"your_user\",\n                \"password\": \"your_password\",\n                \"host\": \"your_host\",\n                \"port\": 5432,\n                \"database\": \"your_db\",\n                \"schema\": \"your_schema\"\n            },\n            \"tables\": [\"sales\"]\n        }\n    ]\n)\n\n# Define an agent with the AIMindTool\n@agent\ndef data_analyst(self) -> Agent:\n    return Agent(\n        config=self.agents_config[\"data_analyst\"],\n        allow_delegation=False,\n        tools=[aimind_tool]\n    )"
    },
    {
      "content": "from crewai import Agent\nfrom crewai.project import agent\nfrom crewai_tools import BraveSearchTool\n\n# Initialize the tool\nbrave_search_tool = BraveSearchTool()\n\n# Define an agent with the BraveSearchTool\n@agent\ndef researcher(self) -> Agent:\n    return Agent(\n        config=self.agents_config[\"researcher\"],\n        allow_delegation=False,\n        tools=[brave_search_tool]\n    )",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Agent Integration Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Agent Integration Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Agent Integration Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Agent Integration Example\n\nfrom crewai import Agent\nfrom crewai.project import agent\nfrom crewai_tools import BraveSearchTool\n\n# Initialize the tool\nbrave_search_tool = BraveSearchTool()\n\n# Define an agent with the BraveSearchTool\n@agent\ndef researcher(self) -> Agent:\n    return Agent(\n        config=self.agents_config[\"researcher\"],\n        allow_delegation=False,\n        tools=[brave_search_tool]\n    )",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Agent Integration Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Agent Integration Example\n\nfrom crewai import Agent\nfrom crewai.project import agent\nfrom crewai_tools import BraveSearchTool\n\n# Initialize the tool\nbrave_search_tool = BraveSearchTool()\n\n# Define an agent with the BraveSearchTool\n@agent\ndef researcher(self) -> Agent:\n    return Agent(\n        config=self.agents_config[\"researcher\"],\n        allow_delegation=False,\n        tools=[brave_search_tool]\n    )"
    },
    {
      "content": "from crewai import Agent, Task, Crew\nfrom crewai_tools import CodeInterpreterTool\n\n# Initialize the tool\ncode_interpreter = CodeInterpreterTool()\n\n# Define an agent that uses the tool\ndata_analyst = Agent(\n    role=\"Data Analyst\",\n    goal=\"Analyze data using Python code\",\n    backstory=\"\"\"You are an expert data analyst who specializes in using Python \n    to analyze and visualize data. You can write efficient code to process \n    large datasets and extract meaningful insights.\"\"\",\n    tools=[code_interpreter],\n    verbose=True,\n)\n\n# Create a task for the agent\nanalysis_task = Task(\n    description=\"\"\"\n    Write Python code to:\n    1. Generate a random dataset of 100 points with x and y coordinates\n    2. Calculate the correlation coefficient between x and y\n    3. Create a scatter plot of the data\n    4. Print the correlation coefficient and save the plot as 'scatter.png'\n    \n    Make sure to handle any necessary imports and print the results.\n    \"\"\",\n    expected_output=\"The correlation coefficient and confirmation that the scatter plot has been saved.\",\n    agent=data_analyst,\n)\n\n# Run the task\ncrew = Crew(\n    agents=[data_analyst],\n    tasks=[analysis_task],\n    verbose=True,\n    process=Process.sequential,\n)\nresult = crew.kickoff()",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Agent Integration Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Agent Integration Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Agent Integration Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Agent Integration Example\n\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import CodeInterpreterTool\n\n# Initialize the tool\ncode_interpreter = CodeInterpreterTool()\n\n# Define an agent that uses the tool\ndata_analyst = Agent(\n    role=\"Data Analyst\",\n    goal=\"Analyze data using Python code\",\n    backstory=\"\"\"You are an expert data analyst who specializes in using Python \n    to analyze and visualize data. You can write efficient code to process \n    large datasets and extract meaningful insights.\"\"\",\n    tools=[code_interpreter],\n    verbose=True,\n)\n\n# Create a task for the agent\nanalysis_task = Task(\n    description=\"\"\"\n    Write Python code to:\n    1. Generate a random dataset of 100 points with x and y coordinates\n    2. Calculate the correlation coefficient between x and y\n    3. Create a scatter plot of the data\n    4. Print the correlation coefficient and save the plot as 'scatter.png'\n    \n    Make sure to handle any necessary imports and print the results.\n    \"\"\",\n    expected_output=\"The correlation coefficient and confirmation that the scatter plot has been saved.\",\n    agent=data_analyst,\n)\n\n# Run the task\ncrew = Crew(\n    agents=[data_analyst],\n    tasks=[analysis_task],\n    verbose=True,\n    process=Process.sequential,\n)\nresult = crew.kickoff()",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Agent Integration Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Agent Integration Example\n\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import CodeInterpreterTool\n\n# Initialize the tool\ncode_interpreter = CodeInterpreterTool()\n\n# Define an agent that uses the tool\ndata_analyst = Agent(\n    role=\"Data Analyst\",\n    goal=\"Analyze data using Python code\",\n    backstory=\"\"\"You are an expert data analyst who specializes in using Python \n    to analyze and visualize data. You can write efficient code to process \n    large datasets and extract meaningful insights.\"\"\",\n    tools=[code_interpreter],\n    verbose=True,\n)\n\n# Create a task for the agent\nanalysis_task = Task(\n    description=\"\"\"\n    Write Python code to:\n    1. Generate a random dataset of 100 points with x and y coordinates\n    2. Calculate the correlation coefficient between x and y\n    3. Create a scatter plot of the data\n    4. Print the correlation coefficient and save the plot as 'scatter.png'\n    \n    Make sure to handle any necessary imports and print the results.\n    \"\"\",\n    expected_output=\"The correlation coefficient and confirmation that the scatter plot has been saved.\",\n    agent=data_analyst,\n)\n\n# Run the task\ncrew = Crew(\n    agents=[data_analyst],\n    tasks=[analysis_task],\n    verbose=True,\n    process=Process.sequential,\n)\nresult = crew.kickoff()"
    },
    {
      "content": "from crewai import Agent\nfrom crewai.project import agent\nfrom crewai_tools import RagTool\n\n# Initialize the tool and add content\nrag_tool = RagTool()\nrag_tool.add(data_type=\"web_page\", url=\"https://docs.crewai.com\")\nrag_tool.add(data_type=\"file\", path=\"company_data.pdf\")\n\n# Define an agent with the RagTool\n@agent\ndef knowledge_expert(self) -> Agent:\n    return Agent(\n        config=self.agents_config[\"knowledge_expert\"],\n        allow_delegation=False,\n        tools=[rag_tool]\n    )",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Agent Integration Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Agent Integration Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Agent Integration Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Agent Integration Example\n\nfrom crewai import Agent\nfrom crewai.project import agent\nfrom crewai_tools import RagTool\n\n# Initialize the tool and add content\nrag_tool = RagTool()\nrag_tool.add(data_type=\"web_page\", url=\"https://docs.crewai.com\")\nrag_tool.add(data_type=\"file\", path=\"company_data.pdf\")\n\n# Define an agent with the RagTool\n@agent\ndef knowledge_expert(self) -> Agent:\n    return Agent(\n        config=self.agents_config[\"knowledge_expert\"],\n        allow_delegation=False,\n        tools=[rag_tool]\n    )",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Agent Integration Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Agent Integration Example\n\nfrom crewai import Agent\nfrom crewai.project import agent\nfrom crewai_tools import RagTool\n\n# Initialize the tool and add content\nrag_tool = RagTool()\nrag_tool.add(data_type=\"web_page\", url=\"https://docs.crewai.com\")\nrag_tool.add(data_type=\"file\", path=\"company_data.pdf\")\n\n# Define an agent with the RagTool\n@agent\ndef knowledge_expert(self) -> Agent:\n    return Agent(\n        config=self.agents_config[\"knowledge_expert\"],\n        allow_delegation=False,\n        tools=[rag_tool]\n    )"
    },
    {
      "content": "from crewai import Agent, Task, Crew, Process\nfrom crewai_tools import SeleniumScrapingTool\n\n# Initialize the tool\nselenium_tool = SeleniumScrapingTool()\n\n# Define an agent that uses the tool\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract and analyze information from dynamic websites\",\n    backstory=\"\"\"You are an expert web scraper who specializes in extracting \n    content from dynamic websites that require browser automation. You have \n    extensive knowledge of CSS selectors and can identify the right selectors \n    to target specific content on any website.\"\"\",\n    tools=[selenium_tool],\n    verbose=True,\n)\n\n# Create a task for the agent\nscrape_task = Task(\n    description=\"\"\"\n    Extract the following information from the news website at {website_url}:\n    \n    1. The headlines of all featured articles (CSS selector: '.headline')\n    2. The publication dates of these articles (CSS selector: '.pub-date')\n    3. The author names where available (CSS selector: '.author')\n    \n    Compile this information into a structured format with each article's details grouped together.\n    \"\"\",\n    expected_output=\"A structured list of articles with their headlines, publication dates, and authors.\",\n    agent=web_scraper_agent,\n)\n\n# Run the task\ncrew = Crew(\n    agents=[web_scraper_agent],\n    tasks=[scrape_task],\n    verbose=True,\n    process=Process.sequential,\n)\nresult = crew.kickoff(inputs={\"website_url\": \"https://news-example.com\"})",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Agent Integration Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Agent Integration Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Agent Integration Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Agent Integration Example\n\nfrom crewai import Agent, Task, Crew, Process\nfrom crewai_tools import SeleniumScrapingTool\n\n# Initialize the tool\nselenium_tool = SeleniumScrapingTool()\n\n# Define an agent that uses the tool\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract and analyze information from dynamic websites\",\n    backstory=\"\"\"You are an expert web scraper who specializes in extracting \n    content from dynamic websites that require browser automation. You have \n    extensive knowledge of CSS selectors and can identify the right selectors \n    to target specific content on any website.\"\"\",\n    tools=[selenium_tool],\n    verbose=True,\n)\n\n# Create a task for the agent\nscrape_task = Task(\n    description=\"\"\"\n    Extract the following information from the news website at {website_url}:\n    \n    1. The headlines of all featured articles (CSS selector: '.headline')\n    2. The publication dates of these articles (CSS selector: '.pub-date')\n    3. The author names where available (CSS selector: '.author')\n    \n    Compile this information into a structured format with each article's details grouped together.\n    \"\"\",\n    expected_output=\"A structured list of articles with their headlines, publication dates, and authors.\",\n    agent=web_scraper_agent,\n)\n\n# Run the task\ncrew = Crew(\n    agents=[web_scraper_agent],\n    tasks=[scrape_task],\n    verbose=True,\n    process=Process.sequential,\n)\nresult = crew.kickoff(inputs={\"website_url\": \"https://news-example.com\"})",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Agent Integration Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Agent Integration Example\n\nfrom crewai import Agent, Task, Crew, Process\nfrom crewai_tools import SeleniumScrapingTool\n\n# Initialize the tool\nselenium_tool = SeleniumScrapingTool()\n\n# Define an agent that uses the tool\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract and analyze information from dynamic websites\",\n    backstory=\"\"\"You are an expert web scraper who specializes in extracting \n    content from dynamic websites that require browser automation. You have \n    extensive knowledge of CSS selectors and can identify the right selectors \n    to target specific content on any website.\"\"\",\n    tools=[selenium_tool],\n    verbose=True,\n)\n\n# Create a task for the agent\nscrape_task = Task(\n    description=\"\"\"\n    Extract the following information from the news website at {website_url}:\n    \n    1. The headlines of all featured articles (CSS selector: '.headline')\n    2. The publication dates of these articles (CSS selector: '.pub-date')\n    3. The author names where available (CSS selector: '.author')\n    \n    Compile this information into a structured format with each article's details grouped together.\n    \"\"\",\n    expected_output=\"A structured list of articles with their headlines, publication dates, and authors.\",\n    agent=web_scraper_agent,\n)\n\n# Run the task\ncrew = Crew(\n    agents=[web_scraper_agent],\n    tasks=[scrape_task],\n    verbose=True,\n    process=Process.sequential,\n)\nresult = crew.kickoff(inputs={\"website_url\": \"https://news-example.com\"})"
    },
    {
      "content": "from crewai import Agent\nfrom crewai_tools import WeaviateVectorSearchTool\n\n# Initialize the tool\nweaviate_tool = WeaviateVectorSearchTool(\n    collection_name='example_collections',\n    limit=3,\n    weaviate_cluster_url=\"https://your-weaviate-cluster-url.com\",\n    weaviate_api_key=\"your-weaviate-api-key\",\n)\n\n# Create an agent with the tool\nrag_agent = Agent(\n    name=\"rag_agent\",\n    role=\"You are a helpful assistant that can answer questions with the help of the WeaviateVectorSearchTool.\",\n    llm=\"gpt-4o-mini\",\n    tools=[weaviate_tool],\n)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Agent Integration Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Agent Integration Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Agent Integration Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Agent Integration Example\n\nfrom crewai import Agent\nfrom crewai_tools import WeaviateVectorSearchTool\n\n# Initialize the tool\nweaviate_tool = WeaviateVectorSearchTool(\n    collection_name='example_collections',\n    limit=3,\n    weaviate_cluster_url=\"https://your-weaviate-cluster-url.com\",\n    weaviate_api_key=\"your-weaviate-api-key\",\n)\n\n# Create an agent with the tool\nrag_agent = Agent(\n    name=\"rag_agent\",\n    role=\"You are a helpful assistant that can answer questions with the help of the WeaviateVectorSearchTool.\",\n    llm=\"gpt-4o-mini\",\n    tools=[weaviate_tool],\n)",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Agent Integration Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Agent Integration Example\n\nfrom crewai import Agent\nfrom crewai_tools import WeaviateVectorSearchTool\n\n# Initialize the tool\nweaviate_tool = WeaviateVectorSearchTool(\n    collection_name='example_collections',\n    limit=3,\n    weaviate_cluster_url=\"https://your-weaviate-cluster-url.com\",\n    weaviate_api_key=\"your-weaviate-api-key\",\n)\n\n# Create an agent with the tool\nrag_agent = Agent(\n    name=\"rag_agent\",\n    role=\"You are a helpful assistant that can answer questions with the help of the WeaviateVectorSearchTool.\",\n    llm=\"gpt-4o-mini\",\n    tools=[weaviate_tool],\n)"
    },
    {
      "content": "from crewai import Agent, Task, Crew\nfrom crewai_tools import YoutubeChannelSearchTool\n\n# Initialize the tool\nyoutube_channel_tool = YoutubeChannelSearchTool()\n\n# Define an agent that uses the tool\nchannel_researcher = Agent(\n    role=\"Channel Researcher\",\n    goal=\"Extract and analyze information from YouTube channels\",\n    backstory=\"\"\"You are an expert channel researcher who specializes in extracting \n    and analyzing information from YouTube channels. You have a keen eye for detail \n    and can quickly identify key points and insights from video content across an entire channel.\"\"\",\n    tools=[youtube_channel_tool],\n    verbose=True,\n)\n\n# Create a task for the agent\nresearch_task = Task(\n    description=\"\"\"\n    Search for information about data science projects and tutorials \n    in the YouTube channel {youtube_channel_handle}. \n    \n    Focus on:\n    1. Key data science techniques covered\n    2. Popular tutorial series\n    3. Most viewed or recommended videos\n    \n    Provide a comprehensive summary of these points.\n    \"\"\",\n    expected_output=\"A detailed summary of data science content available on the channel.\",\n    agent=channel_researcher,\n)\n\n# Run the task\ncrew = Crew(agents=[channel_researcher], tasks=[research_task])\nresult = crew.kickoff(inputs={\"youtube_channel_handle\": \"@exampleDataScienceChannel\"})",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Agent Integration Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Agent Integration Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Agent Integration Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Agent Integration Example\n\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import YoutubeChannelSearchTool\n\n# Initialize the tool\nyoutube_channel_tool = YoutubeChannelSearchTool()\n\n# Define an agent that uses the tool\nchannel_researcher = Agent(\n    role=\"Channel Researcher\",\n    goal=\"Extract and analyze information from YouTube channels\",\n    backstory=\"\"\"You are an expert channel researcher who specializes in extracting \n    and analyzing information from YouTube channels. You have a keen eye for detail \n    and can quickly identify key points and insights from video content across an entire channel.\"\"\",\n    tools=[youtube_channel_tool],\n    verbose=True,\n)\n\n# Create a task for the agent\nresearch_task = Task(\n    description=\"\"\"\n    Search for information about data science projects and tutorials \n    in the YouTube channel {youtube_channel_handle}. \n    \n    Focus on:\n    1. Key data science techniques covered\n    2. Popular tutorial series\n    3. Most viewed or recommended videos\n    \n    Provide a comprehensive summary of these points.\n    \"\"\",\n    expected_output=\"A detailed summary of data science content available on the channel.\",\n    agent=channel_researcher,\n)\n\n# Run the task\ncrew = Crew(agents=[channel_researcher], tasks=[research_task])\nresult = crew.kickoff(inputs={\"youtube_channel_handle\": \"@exampleDataScienceChannel\"})",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Agent Integration Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Agent Integration Example\n\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import YoutubeChannelSearchTool\n\n# Initialize the tool\nyoutube_channel_tool = YoutubeChannelSearchTool()\n\n# Define an agent that uses the tool\nchannel_researcher = Agent(\n    role=\"Channel Researcher\",\n    goal=\"Extract and analyze information from YouTube channels\",\n    backstory=\"\"\"You are an expert channel researcher who specializes in extracting \n    and analyzing information from YouTube channels. You have a keen eye for detail \n    and can quickly identify key points and insights from video content across an entire channel.\"\"\",\n    tools=[youtube_channel_tool],\n    verbose=True,\n)\n\n# Create a task for the agent\nresearch_task = Task(\n    description=\"\"\"\n    Search for information about data science projects and tutorials \n    in the YouTube channel {youtube_channel_handle}. \n    \n    Focus on:\n    1. Key data science techniques covered\n    2. Popular tutorial series\n    3. Most viewed or recommended videos\n    \n    Provide a comprehensive summary of these points.\n    \"\"\",\n    expected_output=\"A detailed summary of data science content available on the channel.\",\n    agent=channel_researcher,\n)\n\n# Run the task\ncrew = Crew(agents=[channel_researcher], tasks=[research_task])\nresult = crew.kickoff(inputs={\"youtube_channel_handle\": \"@exampleDataScienceChannel\"})"
    },
    {
      "content": "from crewai import Agent, Task, Crew\nfrom crewai_tools import YoutubeVideoSearchTool\n\n# Initialize the tool\nyoutube_search_tool = YoutubeVideoSearchTool()\n\n# Define an agent that uses the tool\nvideo_researcher = Agent(\n    role=\"Video Researcher\",\n    goal=\"Extract and analyze information from YouTube videos\",\n    backstory=\"\"\"You are an expert video researcher who specializes in extracting \n    and analyzing information from YouTube videos. You have a keen eye for detail \n    and can quickly identify key points and insights from video content.\"\"\",\n    tools=[youtube_search_tool],\n    verbose=True,\n)\n\n# Create a task for the agent\nresearch_task = Task(\n    description=\"\"\"\n    Search for information about recent advancements in artificial intelligence \n    in the YouTube video at {youtube_video_url}. \n    \n    Focus on:\n    1. Key AI technologies mentioned\n    2. Real-world applications discussed\n    3. Future predictions made by the speaker\n    \n    Provide a comprehensive summary of these points.\n    \"\"\",\n    expected_output=\"A detailed summary of AI advancements, applications, and future predictions from the video.\",\n    agent=video_researcher,\n)\n\n# Run the task\ncrew = Crew(agents=[video_researcher], tasks=[research_task])\nresult = crew.kickoff(inputs={\"youtube_video_url\": \"https://youtube.com/watch?v=example\"})",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Agent Integration Example",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Agent Integration Example",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Agent Integration Example"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Agent Integration Example\n\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import YoutubeVideoSearchTool\n\n# Initialize the tool\nyoutube_search_tool = YoutubeVideoSearchTool()\n\n# Define an agent that uses the tool\nvideo_researcher = Agent(\n    role=\"Video Researcher\",\n    goal=\"Extract and analyze information from YouTube videos\",\n    backstory=\"\"\"You are an expert video researcher who specializes in extracting \n    and analyzing information from YouTube videos. You have a keen eye for detail \n    and can quickly identify key points and insights from video content.\"\"\",\n    tools=[youtube_search_tool],\n    verbose=True,\n)\n\n# Create a task for the agent\nresearch_task = Task(\n    description=\"\"\"\n    Search for information about recent advancements in artificial intelligence \n    in the YouTube video at {youtube_video_url}. \n    \n    Focus on:\n    1. Key AI technologies mentioned\n    2. Real-world applications discussed\n    3. Future predictions made by the speaker\n    \n    Provide a comprehensive summary of these points.\n    \"\"\",\n    expected_output=\"A detailed summary of AI advancements, applications, and future predictions from the video.\",\n    agent=video_researcher,\n)\n\n# Run the task\ncrew = Crew(agents=[video_researcher], tasks=[research_task])\nresult = crew.kickoff(inputs={\"youtube_video_url\": \"https://youtube.com/watch?v=example\"})",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Agent Integration Example",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Agent Integration Example\n\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import YoutubeVideoSearchTool\n\n# Initialize the tool\nyoutube_search_tool = YoutubeVideoSearchTool()\n\n# Define an agent that uses the tool\nvideo_researcher = Agent(\n    role=\"Video Researcher\",\n    goal=\"Extract and analyze information from YouTube videos\",\n    backstory=\"\"\"You are an expert video researcher who specializes in extracting \n    and analyzing information from YouTube videos. You have a keen eye for detail \n    and can quickly identify key points and insights from video content.\"\"\",\n    tools=[youtube_search_tool],\n    verbose=True,\n)\n\n# Create a task for the agent\nresearch_task = Task(\n    description=\"\"\"\n    Search for information about recent advancements in artificial intelligence \n    in the YouTube video at {youtube_video_url}. \n    \n    Focus on:\n    1. Key AI technologies mentioned\n    2. Real-world applications discussed\n    3. Future predictions made by the speaker\n    \n    Provide a comprehensive summary of these points.\n    \"\"\",\n    expected_output=\"A detailed summary of AI advancements, applications, and future predictions from the video.\",\n    agent=video_researcher,\n)\n\n# Run the task\ncrew = Crew(agents=[video_researcher], tasks=[research_task])\nresult = crew.kickoff(inputs={\"youtube_video_url\": \"https://youtube.com/watch?v=example\"})"
    },
    {
      "content": "class CodeInterpreterTool(BaseTool):\n    name: str = \"Code Interpreter\"\n    description: str = \"Interprets Python3 code strings with a final print statement.\"\n    args_schema: Type[BaseModel] = CodeInterpreterSchema\n    default_image_tag: str = \"code-interpreter:latest\"\n    \n    def _run(self, **kwargs) -> str:\n        code = kwargs.get(\"code\", self.code)\n        libraries_used = kwargs.get(\"libraries_used\", [])\n\n        if self.unsafe_mode:\n            return self.run_code_unsafe(code, libraries_used)\n        else:\n            return self.run_code_in_docker(code, libraries_used)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Implementation Details",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Implementation Details",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Implementation Details"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Implementation Details\n\nclass CodeInterpreterTool(BaseTool):\n    name: str = \"Code Interpreter\"\n    description: str = \"Interprets Python3 code strings with a final print statement.\"\n    args_schema: Type[BaseModel] = CodeInterpreterSchema\n    default_image_tag: str = \"code-interpreter:latest\"\n    \n    def _run(self, **kwargs) -> str:\n        code = kwargs.get(\"code\", self.code)\n        libraries_used = kwargs.get(\"libraries_used\", [])\n\n        if self.unsafe_mode:\n            return self.run_code_unsafe(code, libraries_used)\n        else:\n            return self.run_code_in_docker(code, libraries_used)",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Implementation Details",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Implementation Details\n\nclass CodeInterpreterTool(BaseTool):\n    name: str = \"Code Interpreter\"\n    description: str = \"Interprets Python3 code strings with a final print statement.\"\n    args_schema: Type[BaseModel] = CodeInterpreterSchema\n    default_image_tag: str = \"code-interpreter:latest\"\n    \n    def _run(self, **kwargs) -> str:\n        code = kwargs.get(\"code\", self.code)\n        libraries_used = kwargs.get(\"libraries_used\", [])\n\n        if self.unsafe_mode:\n            return self.run_code_unsafe(code, libraries_used)\n        else:\n            return self.run_code_in_docker(code, libraries_used)"
    },
    {
      "content": "class MultiOnTool(BaseTool):\n    \"\"\"Tool to wrap MultiOn Browse Capabilities.\"\"\"\n\n    name: str = \"Multion Browse Tool\"\n    description: str = \"\"\"Multion gives the ability for LLMs to control web browsers using natural language instructions.\n            If the status is 'CONTINUE', reissue the same instruction to continue execution\n        \"\"\"\n    \n    # Implementation details...\n    \n    def _run(self, cmd: str, *args: Any, **kwargs: Any) -> str:\n        \"\"\"\n        Run the Multion client with the given command.\n        \n        Args:\n            cmd (str): The detailed and specific natural language instruction for web browsing\n            *args (Any): Additional arguments to pass to the Multion client\n            **kwargs (Any): Additional keyword arguments to pass to the Multion client\n        \"\"\"\n        # Implementation details...",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Implementation Details",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Implementation Details",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Implementation Details"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Implementation Details\n\nclass MultiOnTool(BaseTool):\n    \"\"\"Tool to wrap MultiOn Browse Capabilities.\"\"\"\n\n    name: str = \"Multion Browse Tool\"\n    description: str = \"\"\"Multion gives the ability for LLMs to control web browsers using natural language instructions.\n            If the status is 'CONTINUE', reissue the same instruction to continue execution\n        \"\"\"\n    \n    # Implementation details...\n    \n    def _run(self, cmd: str, *args: Any, **kwargs: Any) -> str:\n        \"\"\"\n        Run the Multion client with the given command.\n        \n        Args:\n            cmd (str): The detailed and specific natural language instruction for web browsing\n            *args (Any): Additional arguments to pass to the Multion client\n            **kwargs (Any): Additional keyword arguments to pass to the Multion client\n        \"\"\"\n        # Implementation details...",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Implementation Details",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Implementation Details\n\nclass MultiOnTool(BaseTool):\n    \"\"\"Tool to wrap MultiOn Browse Capabilities.\"\"\"\n\n    name: str = \"Multion Browse Tool\"\n    description: str = \"\"\"Multion gives the ability for LLMs to control web browsers using natural language instructions.\n            If the status is 'CONTINUE', reissue the same instruction to continue execution\n        \"\"\"\n    \n    # Implementation details...\n    \n    def _run(self, cmd: str, *args: Any, **kwargs: Any) -> str:\n        \"\"\"\n        Run the Multion client with the given command.\n        \n        Args:\n            cmd (str): The detailed and specific natural language instruction for web browsing\n            *args (Any): Additional arguments to pass to the Multion client\n            **kwargs (Any): Additional keyword arguments to pass to the Multion client\n        \"\"\"\n        # Implementation details..."
    },
    {
      "content": "class S3ReaderTool(BaseTool):\n    name: str = \"S3 Reader Tool\"\n    description: str = \"Reads a file from Amazon S3 given an S3 file path\"\n    \n    def _run(self, file_path: str) -> str:\n        try:\n            bucket_name, object_key = self._parse_s3_path(file_path)\n\n            s3 = boto3.client(\n                's3',\n                region_name=os.getenv('CREW_AWS_REGION', 'us-east-1'),\n                aws_access_key_id=os.getenv('CREW_AWS_ACCESS_KEY_ID'),\n                aws_secret_access_key=os.getenv('CREW_AWS_SEC_ACCESS_KEY')\n            )\n\n            # Read file content from S3\n            response = s3.get_object(Bucket=bucket_name, Key=object_key)\n            file_content = response['Body'].read().decode('utf-8')\n\n            return file_content\n        except ClientError as e:\n            return f\"Error reading file from S3: {str(e)}\"",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Implementation Details",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Implementation Details",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Implementation Details"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Implementation Details\n\nclass S3ReaderTool(BaseTool):\n    name: str = \"S3 Reader Tool\"\n    description: str = \"Reads a file from Amazon S3 given an S3 file path\"\n    \n    def _run(self, file_path: str) -> str:\n        try:\n            bucket_name, object_key = self._parse_s3_path(file_path)\n\n            s3 = boto3.client(\n                's3',\n                region_name=os.getenv('CREW_AWS_REGION', 'us-east-1'),\n                aws_access_key_id=os.getenv('CREW_AWS_ACCESS_KEY_ID'),\n                aws_secret_access_key=os.getenv('CREW_AWS_SEC_ACCESS_KEY')\n            )\n\n            # Read file content from S3\n            response = s3.get_object(Bucket=bucket_name, Key=object_key)\n            file_content = response['Body'].read().decode('utf-8')\n\n            return file_content\n        except ClientError as e:\n            return f\"Error reading file from S3: {str(e)}\"",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Implementation Details",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Implementation Details\n\nclass S3ReaderTool(BaseTool):\n    name: str = \"S3 Reader Tool\"\n    description: str = \"Reads a file from Amazon S3 given an S3 file path\"\n    \n    def _run(self, file_path: str) -> str:\n        try:\n            bucket_name, object_key = self._parse_s3_path(file_path)\n\n            s3 = boto3.client(\n                's3',\n                region_name=os.getenv('CREW_AWS_REGION', 'us-east-1'),\n                aws_access_key_id=os.getenv('CREW_AWS_ACCESS_KEY_ID'),\n                aws_secret_access_key=os.getenv('CREW_AWS_SEC_ACCESS_KEY')\n            )\n\n            # Read file content from S3\n            response = s3.get_object(Bucket=bucket_name, Key=object_key)\n            file_content = response['Body'].read().decode('utf-8')\n\n            return file_content\n        except ClientError as e:\n            return f\"Error reading file from S3: {str(e)}\""
    },
    {
      "content": "class S3WriterTool(BaseTool):\n    name: str = \"S3 Writer Tool\"\n    description: str = \"Writes content to a file in Amazon S3 given an S3 file path\"\n    \n    def _run(self, file_path: str, content: str) -> str:\n        try:\n            bucket_name, object_key = self._parse_s3_path(file_path)\n\n            s3 = boto3.client(\n                's3',\n                region_name=os.getenv('CREW_AWS_REGION', 'us-east-1'),\n                aws_access_key_id=os.getenv('CREW_AWS_ACCESS_KEY_ID'),\n                aws_secret_access_key=os.getenv('CREW_AWS_SEC_ACCESS_KEY')\n            )\n\n            s3.put_object(Bucket=bucket_name, Key=object_key, Body=content.encode('utf-8'))\n            return f\"Successfully wrote content to {file_path}\"\n        except ClientError as e:\n            return f\"Error writing file to S3: {str(e)}\"",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Implementation Details",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Implementation Details",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Implementation Details"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Implementation Details\n\nclass S3WriterTool(BaseTool):\n    name: str = \"S3 Writer Tool\"\n    description: str = \"Writes content to a file in Amazon S3 given an S3 file path\"\n    \n    def _run(self, file_path: str, content: str) -> str:\n        try:\n            bucket_name, object_key = self._parse_s3_path(file_path)\n\n            s3 = boto3.client(\n                's3',\n                region_name=os.getenv('CREW_AWS_REGION', 'us-east-1'),\n                aws_access_key_id=os.getenv('CREW_AWS_ACCESS_KEY_ID'),\n                aws_secret_access_key=os.getenv('CREW_AWS_SEC_ACCESS_KEY')\n            )\n\n            s3.put_object(Bucket=bucket_name, Key=object_key, Body=content.encode('utf-8'))\n            return f\"Successfully wrote content to {file_path}\"\n        except ClientError as e:\n            return f\"Error writing file to S3: {str(e)}\"",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Implementation Details",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Implementation Details\n\nclass S3WriterTool(BaseTool):\n    name: str = \"S3 Writer Tool\"\n    description: str = \"Writes content to a file in Amazon S3 given an S3 file path\"\n    \n    def _run(self, file_path: str, content: str) -> str:\n        try:\n            bucket_name, object_key = self._parse_s3_path(file_path)\n\n            s3 = boto3.client(\n                's3',\n                region_name=os.getenv('CREW_AWS_REGION', 'us-east-1'),\n                aws_access_key_id=os.getenv('CREW_AWS_ACCESS_KEY_ID'),\n                aws_secret_access_key=os.getenv('CREW_AWS_SEC_ACCESS_KEY')\n            )\n\n            s3.put_object(Bucket=bucket_name, Key=object_key, Body=content.encode('utf-8'))\n            return f\"Successfully wrote content to {file_path}\"\n        except ClientError as e:\n            return f\"Error writing file to S3: {str(e)}\""
    },
    {
      "content": "class ScrapeElementFromWebsiteTool(BaseTool):\n    name: str = \"Read a website content\"\n    description: str = \"A tool that can be used to read a website content.\"\n    \n    # Implementation details...\n    \n    def _run(self, **kwargs: Any) -> Any:\n        website_url = kwargs.get(\"website_url\", self.website_url)\n        css_element = kwargs.get(\"css_element\", self.css_element)\n        page = requests.get(\n            website_url,\n            headers=self.headers,\n            cookies=self.cookies if self.cookies else {},\n        )\n        parsed = BeautifulSoup(page.content, \"html.parser\")\n        elements = parsed.select(css_element)\n        return \"\\n\".join([element.get_text() for element in elements])",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Implementation Details",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Implementation Details",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Implementation Details"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Implementation Details\n\nclass ScrapeElementFromWebsiteTool(BaseTool):\n    name: str = \"Read a website content\"\n    description: str = \"A tool that can be used to read a website content.\"\n    \n    # Implementation details...\n    \n    def _run(self, **kwargs: Any) -> Any:\n        website_url = kwargs.get(\"website_url\", self.website_url)\n        css_element = kwargs.get(\"css_element\", self.css_element)\n        page = requests.get(\n            website_url,\n            headers=self.headers,\n            cookies=self.cookies if self.cookies else {},\n        )\n        parsed = BeautifulSoup(page.content, \"html.parser\")\n        elements = parsed.select(css_element)\n        return \"\\n\".join([element.get_text() for element in elements])",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Implementation Details",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Implementation Details\n\nclass ScrapeElementFromWebsiteTool(BaseTool):\n    name: str = \"Read a website content\"\n    description: str = \"A tool that can be used to read a website content.\"\n    \n    # Implementation details...\n    \n    def _run(self, **kwargs: Any) -> Any:\n        website_url = kwargs.get(\"website_url\", self.website_url)\n        css_element = kwargs.get(\"css_element\", self.css_element)\n        page = requests.get(\n            website_url,\n            headers=self.headers,\n            cookies=self.cookies if self.cookies else {},\n        )\n        parsed = BeautifulSoup(page.content, \"html.parser\")\n        elements = parsed.select(css_element)\n        return \"\\n\".join([element.get_text() for element in elements])"
    },
    {
      "content": "class ScrapegraphScrapeTool(BaseTool):\n    \"\"\"\n    A tool that uses Scrapegraph AI to intelligently scrape website content.\n    \"\"\"\n    \n    # Implementation details...\n    \n    def _run(self, **kwargs: Any) -> Any:\n        website_url = kwargs.get(\"website_url\", self.website_url)\n        user_prompt = (\n            kwargs.get(\"user_prompt\", self.user_prompt)\n            or \"Extract the main content of the webpage\"\n        )\n\n        if not website_url:\n            raise ValueError(\"website_url is required\")\n\n        # Validate URL format\n        self._validate_url(website_url)\n\n        try:\n            # Make the SmartScraper request\n            response = self._client.smartscraper(\n                website_url=website_url,\n                user_prompt=user_prompt,\n            )\n\n            return response\n        # Error handling...",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Implementation Details",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Implementation Details",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Implementation Details"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Implementation Details\n\nclass ScrapegraphScrapeTool(BaseTool):\n    \"\"\"\n    A tool that uses Scrapegraph AI to intelligently scrape website content.\n    \"\"\"\n    \n    # Implementation details...\n    \n    def _run(self, **kwargs: Any) -> Any:\n        website_url = kwargs.get(\"website_url\", self.website_url)\n        user_prompt = (\n            kwargs.get(\"user_prompt\", self.user_prompt)\n            or \"Extract the main content of the webpage\"\n        )\n\n        if not website_url:\n            raise ValueError(\"website_url is required\")\n\n        # Validate URL format\n        self._validate_url(website_url)\n\n        try:\n            # Make the SmartScraper request\n            response = self._client.smartscraper(\n                website_url=website_url,\n                user_prompt=user_prompt,\n            )\n\n            return response\n        # Error handling...",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Implementation Details",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Implementation Details\n\nclass ScrapegraphScrapeTool(BaseTool):\n    \"\"\"\n    A tool that uses Scrapegraph AI to intelligently scrape website content.\n    \"\"\"\n    \n    # Implementation details...\n    \n    def _run(self, **kwargs: Any) -> Any:\n        website_url = kwargs.get(\"website_url\", self.website_url)\n        user_prompt = (\n            kwargs.get(\"user_prompt\", self.user_prompt)\n            or \"Extract the main content of the webpage\"\n        )\n\n        if not website_url:\n            raise ValueError(\"website_url is required\")\n\n        # Validate URL format\n        self._validate_url(website_url)\n\n        try:\n            # Make the SmartScraper request\n            response = self._client.smartscraper(\n                website_url=website_url,\n                user_prompt=user_prompt,\n            )\n\n            return response\n        # Error handling..."
    },
    {
      "content": "class ScrapflyScrapeWebsiteTool(BaseTool):\n    name: str = \"Scrapfly web scraping API tool\"\n    description: str = (\n        \"Scrape a webpage url using Scrapfly and return its content as markdown or text\"\n    )\n    \n    # Implementation details...\n    \n    def _run(\n        self,\n        url: str,\n        scrape_format: str = \"markdown\",\n        scrape_config: Optional[Dict[str, Any]] = None,\n        ignore_scrape_failures: Optional[bool] = None,\n    ):\n        from scrapfly import ScrapeApiResponse, ScrapeConfig\n\n        scrape_config = scrape_config if scrape_config is not None else {}\n        try:\n            response: ScrapeApiResponse = self.scrapfly.scrape(\n                ScrapeConfig(url, format=scrape_format, **scrape_config)\n            )\n            return response.scrape_result[\"content\"]\n        except Exception as e:\n            if ignore_scrape_failures:\n                logger.error(f\"Error fetching data from {url}, exception: {e}\")\n                return None\n            else:\n                raise e",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Implementation Details",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Implementation Details",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Implementation Details"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Implementation Details\n\nclass ScrapflyScrapeWebsiteTool(BaseTool):\n    name: str = \"Scrapfly web scraping API tool\"\n    description: str = (\n        \"Scrape a webpage url using Scrapfly and return its content as markdown or text\"\n    )\n    \n    # Implementation details...\n    \n    def _run(\n        self,\n        url: str,\n        scrape_format: str = \"markdown\",\n        scrape_config: Optional[Dict[str, Any]] = None,\n        ignore_scrape_failures: Optional[bool] = None,\n    ):\n        from scrapfly import ScrapeApiResponse, ScrapeConfig\n\n        scrape_config = scrape_config if scrape_config is not None else {}\n        try:\n            response: ScrapeApiResponse = self.scrapfly.scrape(\n                ScrapeConfig(url, format=scrape_format, **scrape_config)\n            )\n            return response.scrape_result[\"content\"]\n        except Exception as e:\n            if ignore_scrape_failures:\n                logger.error(f\"Error fetching data from {url}, exception: {e}\")\n                return None\n            else:\n                raise e",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Implementation Details",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Implementation Details\n\nclass ScrapflyScrapeWebsiteTool(BaseTool):\n    name: str = \"Scrapfly web scraping API tool\"\n    description: str = (\n        \"Scrape a webpage url using Scrapfly and return its content as markdown or text\"\n    )\n    \n    # Implementation details...\n    \n    def _run(\n        self,\n        url: str,\n        scrape_format: str = \"markdown\",\n        scrape_config: Optional[Dict[str, Any]] = None,\n        ignore_scrape_failures: Optional[bool] = None,\n    ):\n        from scrapfly import ScrapeApiResponse, ScrapeConfig\n\n        scrape_config = scrape_config if scrape_config is not None else {}\n        try:\n            response: ScrapeApiResponse = self.scrapfly.scrape(\n                ScrapeConfig(url, format=scrape_format, **scrape_config)\n            )\n            return response.scrape_result[\"content\"]\n        except Exception as e:\n            if ignore_scrape_failures:\n                logger.error(f\"Error fetching data from {url}, exception: {e}\")\n                return None\n            else:\n                raise e"
    },
    {
      "content": "class SeleniumScrapingTool(BaseTool):\n    name: str = \"Read a website content\"\n    description: str = \"A tool that can be used to read a website content.\"\n    args_schema: Type[BaseModel] = SeleniumScrapingToolSchema\n    \n    def _run(self, **kwargs: Any) -> Any:\n        website_url = kwargs.get(\"website_url\", self.website_url)\n        css_element = kwargs.get(\"css_element\", self.css_element)\n        return_html = kwargs.get(\"return_html\", self.return_html)\n        driver = self._create_driver(website_url, self.cookie, self.wait_time)\n\n        content = self._get_content(driver, css_element, return_html)\n        driver.close()\n\n        return \"\\n\".join(content)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Implementation Details",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Implementation Details",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Implementation Details"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Implementation Details\n\nclass SeleniumScrapingTool(BaseTool):\n    name: str = \"Read a website content\"\n    description: str = \"A tool that can be used to read a website content.\"\n    args_schema: Type[BaseModel] = SeleniumScrapingToolSchema\n    \n    def _run(self, **kwargs: Any) -> Any:\n        website_url = kwargs.get(\"website_url\", self.website_url)\n        css_element = kwargs.get(\"css_element\", self.css_element)\n        return_html = kwargs.get(\"return_html\", self.return_html)\n        driver = self._create_driver(website_url, self.cookie, self.wait_time)\n\n        content = self._get_content(driver, css_element, return_html)\n        driver.close()\n\n        return \"\\n\".join(content)",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Implementation Details",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Implementation Details\n\nclass SeleniumScrapingTool(BaseTool):\n    name: str = \"Read a website content\"\n    description: str = \"A tool that can be used to read a website content.\"\n    args_schema: Type[BaseModel] = SeleniumScrapingToolSchema\n    \n    def _run(self, **kwargs: Any) -> Any:\n        website_url = kwargs.get(\"website_url\", self.website_url)\n        css_element = kwargs.get(\"css_element\", self.css_element)\n        return_html = kwargs.get(\"return_html\", self.return_html)\n        driver = self._create_driver(website_url, self.cookie, self.wait_time)\n\n        content = self._get_content(driver, css_element, return_html)\n        driver.close()\n\n        return \"\\n\".join(content)"
    },
    {
      "content": "class YoutubeChannelSearchTool(RagTool):\n    name: str = \"Search a Youtube Channels content\"\n    description: str = \"A tool that can be used to semantic search a query from a Youtube Channels content.\"\n    args_schema: Type[BaseModel] = YoutubeChannelSearchToolSchema\n\n    def __init__(self, youtube_channel_handle: Optional[str] = None, **kwargs):\n        super().__init__(**kwargs)\n        if youtube_channel_handle is not None:\n            kwargs[\"data_type\"] = DataType.YOUTUBE_CHANNEL\n            self.add(youtube_channel_handle)\n            self.description = f\"A tool that can be used to semantic search a query the {youtube_channel_handle} Youtube Channels content.\"\n            self.args_schema = FixedYoutubeChannelSearchToolSchema\n            self._generate_description()\n\n    def add(\n        self,\n        youtube_channel_handle: str,\n        **kwargs: Any,\n    ) -> None:\n        if not youtube_channel_handle.startswith(\"@\"):\n            youtube_channel_handle = f\"@{youtube_channel_handle}\"\n        super().add(youtube_channel_handle, **kwargs)",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Implementation Details",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Implementation Details",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Implementation Details"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Implementation Details\n\nclass YoutubeChannelSearchTool(RagTool):\n    name: str = \"Search a Youtube Channels content\"\n    description: str = \"A tool that can be used to semantic search a query from a Youtube Channels content.\"\n    args_schema: Type[BaseModel] = YoutubeChannelSearchToolSchema\n\n    def __init__(self, youtube_channel_handle: Optional[str] = None, **kwargs):\n        super().__init__(**kwargs)\n        if youtube_channel_handle is not None:\n            kwargs[\"data_type\"] = DataType.YOUTUBE_CHANNEL\n            self.add(youtube_channel_handle)\n            self.description = f\"A tool that can be used to semantic search a query the {youtube_channel_handle} Youtube Channels content.\"\n            self.args_schema = FixedYoutubeChannelSearchToolSchema\n            self._generate_description()\n\n    def add(\n        self,\n        youtube_channel_handle: str,\n        **kwargs: Any,\n    ) -> None:\n        if not youtube_channel_handle.startswith(\"@\"):\n            youtube_channel_handle = f\"@{youtube_channel_handle}\"\n        super().add(youtube_channel_handle, **kwargs)",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Implementation Details",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Implementation Details\n\nclass YoutubeChannelSearchTool(RagTool):\n    name: str = \"Search a Youtube Channels content\"\n    description: str = \"A tool that can be used to semantic search a query from a Youtube Channels content.\"\n    args_schema: Type[BaseModel] = YoutubeChannelSearchToolSchema\n\n    def __init__(self, youtube_channel_handle: Optional[str] = None, **kwargs):\n        super().__init__(**kwargs)\n        if youtube_channel_handle is not None:\n            kwargs[\"data_type\"] = DataType.YOUTUBE_CHANNEL\n            self.add(youtube_channel_handle)\n            self.description = f\"A tool that can be used to semantic search a query the {youtube_channel_handle} Youtube Channels content.\"\n            self.args_schema = FixedYoutubeChannelSearchToolSchema\n            self._generate_description()\n\n    def add(\n        self,\n        youtube_channel_handle: str,\n        **kwargs: Any,\n    ) -> None:\n        if not youtube_channel_handle.startswith(\"@\"):\n            youtube_channel_handle = f\"@{youtube_channel_handle}\"\n        super().add(youtube_channel_handle, **kwargs)"
    },
    {
      "content": "class YoutubeVideoSearchTool(RagTool):\n    name: str = \"Search a Youtube Video content\"\n    description: str = \"A tool that can be used to semantic search a query from a Youtube Video content.\"\n    args_schema: Type[BaseModel] = YoutubeVideoSearchToolSchema\n\n    def __init__(self, youtube_video_url: Optional[str] = None, **kwargs):\n        super().__init__(**kwargs)\n        if youtube_video_url is not None:\n            kwargs[\"data_type\"] = DataType.YOUTUBE_VIDEO\n            self.add(youtube_video_url)\n            self.description = f\"A tool that can be used to semantic search a query the {youtube_video_url} Youtube Video content.\"\n            self.args_schema = FixedYoutubeVideoSearchToolSchema\n            self._generate_description()",
      "title": null,
      "type": "code_example",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Implementation Details",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Implementation Details",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Implementation Details"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Implementation Details\n\nclass YoutubeVideoSearchTool(RagTool):\n    name: str = \"Search a Youtube Video content\"\n    description: str = \"A tool that can be used to semantic search a query from a Youtube Video content.\"\n    args_schema: Type[BaseModel] = YoutubeVideoSearchToolSchema\n\n    def __init__(self, youtube_video_url: Optional[str] = None, **kwargs):\n        super().__init__(**kwargs)\n        if youtube_video_url is not None:\n            kwargs[\"data_type\"] = DataType.YOUTUBE_VIDEO\n            self.add(youtube_video_url)\n            self.description = f\"A tool that can be used to semantic search a query the {youtube_video_url} Youtube Video content.\"\n            self.args_schema = FixedYoutubeVideoSearchToolSchema\n            self._generate_description()",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Implementation Details",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Implementation Details\n\nclass YoutubeVideoSearchTool(RagTool):\n    name: str = \"Search a Youtube Video content\"\n    description: str = \"A tool that can be used to semantic search a query from a Youtube Video content.\"\n    args_schema: Type[BaseModel] = YoutubeVideoSearchToolSchema\n\n    def __init__(self, youtube_video_url: Optional[str] = None, **kwargs):\n        super().__init__(**kwargs)\n        if youtube_video_url is not None:\n            kwargs[\"data_type\"] = DataType.YOUTUBE_VIDEO\n            self.add(youtube_video_url)\n            self.description = f\"A tool that can be used to semantic search a query the {youtube_video_url} Youtube Video content.\"\n            self.args_schema = FixedYoutubeVideoSearchToolSchema\n            self._generate_description()"
    },
    {
      "content": "The integration of advanced attributes and functionalities into the CrewAI framework significantly enriches the agent collaboration ecosystem. These enhancements not only simplify interactions but also offer unprecedented flexibility and control, paving the way for sophisticated AI-driven solutions capable of tackling complex tasks through intelligent collaboration and delegation.\n\nPlotting your flows is a powerful feature of CrewAI that enhances your ability to design and manage complex AI workflows. Whether you choose to use the `plot()` method or the command line, generating plots will provide you with a visual representation of your workflows, aiding in both development and presentation.",
      "title": "Conclusion",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Conclusion",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Conclusion",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Conclusion"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Conclusion\n\n## Conclusion\n\nThe integration of advanced attributes and functionalities into the CrewAI framework significantly enriches the agent collaboration ecosystem. These enhancements not only simplify interactions but also offer unprecedented flexibility and control, paving the way for sophisticated AI-driven solutions capable of tackling complex tasks through intelligent collaboration and delegation.\n\nPlotting your flows is a powerful feature of CrewAI that enhances your ability to design and manage complex AI workflows. Whether you choose to use the `plot()` method or the command line, generating plots will provide you with a visual representation of your workflows, aiding in both development and presentation.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Conclusion",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Conclusion\n\n Conclusion\n\nThe integration of advanced attributes and functionalities into the CrewAI framework significantly enriches the agent collaboration ecosystem. These enhancements not only simplify interactions but also offer unprecedented flexibility and control, paving the way for sophisticated AI-driven solutions capable of tackling complex tasks through intelligent collaboration and delegation.\n\nPlotting your flows is a powerful feature of CrewAI that enhances your ability to design and manage complex AI workflows. Whether you choose to use the `plot()` method or the command line, generating plots will provide you with a visual representation of your workflows, aiding in both development and presentation."
    },
    {
      "content": "Tools are pivotal in extending the capabilities of CrewAI agents, enabling them to undertake a broad spectrum of tasks and collaborate effectively.\nWhen building solutions with CrewAI, leverage both custom and existing tools to empower your agents and enhance the AI ecosystem. Consider utilizing error handling, caching mechanisms,\nand the flexibility of tool arguments to optimize your agents' performance and capabilities.\n\nIntegrating CrewAI's memory system into your projects is straightforward. By leveraging the provided memory components and configurations,\nyou can quickly empower your agents with the ability to remember, reason, and learn from their interactions, unlocking new levels of intelligence and capability.",
      "title": "Conclusion",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Conclusion",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Conclusion",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Conclusion"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Conclusion\n\n## Conclusion\n\nTools are pivotal in extending the capabilities of CrewAI agents, enabling them to undertake a broad spectrum of tasks and collaborate effectively.\nWhen building solutions with CrewAI, leverage both custom and existing tools to empower your agents and enhance the AI ecosystem. Consider utilizing error handling, caching mechanisms,\nand the flexibility of tool arguments to optimize your agents' performance and capabilities.\n\nIntegrating CrewAI's memory system into your projects is straightforward. By leveraging the provided memory components and configurations,\nyou can quickly empower your agents with the ability to remember, reason, and learn from their interactions, unlocking new levels of intelligence and capability.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Conclusion",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Conclusion\n\n Conclusion\n\nTools are pivotal in extending the capabilities of CrewAI agents, enabling them to undertake a broad spectrum of tasks and collaborate effectively.\nWhen building solutions with CrewAI, leverage both custom and existing tools to empower your agents and enhance the AI ecosystem. Consider utilizing error handling, caching mechanisms,\nand the flexibility of tool arguments to optimize your agents' performance and capabilities.\n\nIntegrating CrewAI's memory system into your projects is straightforward. By leveraging the provided memory components and configurations,\nyou can quickly empower your agents with the ability to remember, reason, and learn from their interactions, unlocking new levels of intelligence and capability."
    },
    {
      "content": "The structured collaboration facilitated by processes within CrewAI is crucial for enabling systematic teamwork among agents.\nThis documentation has been updated to reflect the latest features, enhancements, and the planned integration of the Consensual Process, ensuring users have access to the most current and comprehensive information.\n\nTasks are the driving force behind the actions of agents in CrewAI.\nBy properly defining tasks and their outcomes, you set the stage for your AI agents to work effectively, either independently or as a collaborative unit.\nEquipping tasks with appropriate tools, understanding the execution process, and following robust validation practices are crucial for maximizing CrewAI's potential,\nensuring agents are effectively prepared for their assignments and that tasks are executed as intended.",
      "title": "Conclusion",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Conclusion",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Conclusion",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Conclusion"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Conclusion\n\n## Conclusion\n\nThe structured collaboration facilitated by processes within CrewAI is crucial for enabling systematic teamwork among agents.\nThis documentation has been updated to reflect the latest features, enhancements, and the planned integration of the Consensual Process, ensuring users have access to the most current and comprehensive information.\n\nTasks are the driving force behind the actions of agents in CrewAI.\nBy properly defining tasks and their outcomes, you set the stage for your AI agents to work effectively, either independently or as a collaborative unit.\nEquipping tasks with appropriate tools, understanding the execution process, and following robust validation practices are crucial for maximizing CrewAI's potential,\nensuring agents are effectively prepared for their assignments and that tasks are executed as intended.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Conclusion",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Conclusion\n\n Conclusion\n\nThe structured collaboration facilitated by processes within CrewAI is crucial for enabling systematic teamwork among agents.\nThis documentation has been updated to reflect the latest features, enhancements, and the planned integration of the Consensual Process, ensuring users have access to the most current and comprehensive information.\n\nTasks are the driving force behind the actions of agents in CrewAI.\nBy properly defining tasks and their outcomes, you set the stage for your AI agents to work effectively, either independently or as a collaborative unit.\nEquipping tasks with appropriate tools, understanding the execution process, and following robust validation practices are crucial for maximizing CrewAI's potential,\nensuring agents are effectively prepared for their assignments and that tasks are executed as intended."
    },
    {
      "content": "Tools are pivotal in extending the capabilities of CrewAI agents, enabling them to undertake a broad spectrum of tasks and collaborate effectively.\nWhen building solutions with CrewAI, leverage both custom and existing tools to empower your agents and enhance the AI ecosystem. Consider utilizing error handling,\ncaching mechanisms, and the flexibility of tool arguments to optimize your agents' performance and capabilities.\n\nLow-level prompt customization in CrewAI opens the door to super custom, complex use cases. By establishing well-organized prompt files (or direct inline templates), you can accommodate various models, languages, and specialized domains. This level of flexibility ensures you can craft precisely the AI behavior you need, all while knowing CrewAI still provides reliable defaults when you don\u2019t override them.",
      "title": "Conclusion",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Conclusion",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Conclusion",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Conclusion"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Conclusion\n\n## Conclusion\n\nTools are pivotal in extending the capabilities of CrewAI agents, enabling them to undertake a broad spectrum of tasks and collaborate effectively.\nWhen building solutions with CrewAI, leverage both custom and existing tools to empower your agents and enhance the AI ecosystem. Consider utilizing error handling,\ncaching mechanisms, and the flexibility of tool arguments to optimize your agents' performance and capabilities.\n\nLow-level prompt customization in CrewAI opens the door to super custom, complex use cases. By establishing well-organized prompt files (or direct inline templates), you can accommodate various models, languages, and specialized domains. This level of flexibility ensures you can craft precisely the AI behavior you need, all while knowing CrewAI still provides reliable defaults when you don\u2019t override them.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Conclusion",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Conclusion\n\n Conclusion\n\nTools are pivotal in extending the capabilities of CrewAI agents, enabling them to undertake a broad spectrum of tasks and collaborate effectively.\nWhen building solutions with CrewAI, leverage both custom and existing tools to empower your agents and enhance the AI ecosystem. Consider utilizing error handling,\ncaching mechanisms, and the flexibility of tool arguments to optimize your agents' performance and capabilities.\n\nLow-level prompt customization in CrewAI opens the door to super custom, complex use cases. By establishing well-organized prompt files (or direct inline templates), you can accommodate various models, languages, and specialized domains. This level of flexibility ensures you can craft precisely the AI behavior you need, all while knowing CrewAI still provides reliable defaults when you don\u2019t override them."
    },
    {
      "content": "Crafting effective agents is both an art and a science. By carefully defining roles, goals, and backstories that align with your specific needs, and combining them with well-designed tasks, you can create specialized AI collaborators that produce exceptional results. Remember that agent and task design is an iterative process. Start with these best practices, observe your agents in action, and refine your approach based on what you learn. And always keep in mind the 80/20 rule - focus most of your effort on creating clear, focused tasks to get the best results from your agents.",
      "title": "Conclusion",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Conclusion",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Conclusion",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Conclusion"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Conclusion\n\n## Conclusion\n\nCrafting effective agents is both an art and a science. By carefully defining roles, goals, and backstories that align with your specific needs, and combining them with well-designed tasks, you can create specialized AI collaborators that produce exceptional results. Remember that agent and task design is an iterative process. Start with these best practices, observe your agents in action, and refine your approach based on what you learn. And always keep in mind the 80/20 rule - focus most of your effort on creating clear, focused tasks to get the best results from your agents.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Conclusion",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Conclusion\n\n Conclusion\n\nCrafting effective agents is both an art and a science. By carefully defining roles, goals, and backstories that align with your specific needs, and combining them with well-designed tasks, you can create specialized AI collaborators that produce exceptional results. Remember that agent and task design is an iterative process. Start with these best practices, observe your agents in action, and refine your approach based on what you learn. And always keep in mind the 80/20 rule - focus most of your effort on creating clear, focused tasks to get the best results from your agents."
    },
    {
      "content": "Choosing between Crews and Flows\u2014or combining them\u2014is a critical architectural decision that impacts the effectiveness, maintainability, and scalability of your CrewAI application. By evaluating your use case along the dimensions of complexity and precision, you can make informed decisions that align with your specific requirements. Remember that the best approach often evolves as your application matures. Start with the simplest solution that meets your needs, and be prepared to refine your architecture as you gain experience and your requirements become clearer.",
      "title": "Conclusion",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Conclusion",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Conclusion",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Conclusion"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Conclusion\n\n## Conclusion\n\nChoosing between Crews and Flows\u2014or combining them\u2014is a critical architectural decision that impacts the effectiveness, maintainability, and scalability of your CrewAI application. By evaluating your use case along the dimensions of complexity and precision, you can make informed decisions that align with your specific requirements. Remember that the best approach often evolves as your application matures. Start with the simplest solution that meets your needs, and be prepared to refine your architecture as you gain experience and your requirements become clearer.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Conclusion",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Conclusion\n\n Conclusion\n\nChoosing between Crews and Flows\u2014or combining them\u2014is a critical architectural decision that impacts the effectiveness, maintainability, and scalability of your CrewAI application. By evaluating your use case along the dimensions of complexity and precision, you can make informed decisions that align with your specific requirements. Remember that the best approach often evolves as your application matures. Start with the simplest solution that meets your needs, and be prepared to refine your architecture as you gain experience and your requirements become clearer."
    },
    {
      "content": "Mastering state management in CrewAI Flows gives you the power to build sophisticated, robust AI applications that maintain context, make complex decisions, and deliver consistent results. Whether you choose unstructured or structured state, implementing proper state management practices will help you create flows that are maintainable, extensible, and effective at solving real-world problems. As you develop more complex flows, remember that good state management is about finding the right balance between flexibility and structure, making your code both powerful and easy to understand.\n\nCustomizing agents in CrewAI by setting their roles, goals, backstories, and tools, alongside advanced options like language model customization, memory, performance settings, and delegation preferences,\nequips a nuanced and capable AI team ready for complex challenges.",
      "title": "Conclusion",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Conclusion",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Conclusion",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Conclusion"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Conclusion\n\n## Conclusion\n\nMastering state management in CrewAI Flows gives you the power to build sophisticated, robust AI applications that maintain context, make complex decisions, and deliver consistent results. Whether you choose unstructured or structured state, implementing proper state management practices will help you create flows that are maintainable, extensible, and effective at solving real-world problems. As you develop more complex flows, remember that good state management is about finding the right balance between flexibility and structure, making your code both powerful and easy to understand.\n\nCustomizing agents in CrewAI by setting their roles, goals, backstories, and tools, alongside advanced options like language model customization, memory, performance settings, and delegation preferences,\nequips a nuanced and capable AI team ready for complex challenges.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Conclusion",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Conclusion\n\n Conclusion\n\nMastering state management in CrewAI Flows gives you the power to build sophisticated, robust AI applications that maintain context, make complex decisions, and deliver consistent results. Whether you choose unstructured or structured state, implementing proper state management practices will help you create flows that are maintainable, extensible, and effective at solving real-world problems. As you develop more complex flows, remember that good state management is about finding the right balance between flexibility and structure, making your code both powerful and easy to understand.\n\nCustomizing agents in CrewAI by setting their roles, goals, backstories, and tools, alongside advanced options like language model customization, memory, performance settings, and delegation preferences,\nequips a nuanced and capable AI team ready for complex challenges."
    },
    {
      "content": "Adopting the hierarchical process in CrewAI, with the correct configurations and understanding of the system's capabilities, facilitates an organized and efficient approach to project management.\nUtilize the advanced features and customizations to tailor the workflow to your specific needs, ensuring optimal task execution and project success.\n\nBy leveraging LiteLLM, CrewAI offers seamless integration with a vast array of LLMs. This flexibility allows you to choose the most suitable model for your specific needs, whether you prioritize performance, cost-efficiency, or local deployment. Remember to consult the [LiteLLM documentation](https://docs.litellm.ai/docs/) for the most up-to-date information on supported models and configuration options.\n\nWith the above enhancements and detailed functionality, replaying specific tasks in CrewAI has been made more efficient and robust.\nEnsure you follow the commands and steps precisely to make the most of these features.",
      "title": "Conclusion",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Conclusion",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Conclusion",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": true,
        "link_count": 1,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Conclusion"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Conclusion\n\n## Conclusion\n\nAdopting the hierarchical process in CrewAI, with the correct configurations and understanding of the system's capabilities, facilitates an organized and efficient approach to project management.\nUtilize the advanced features and customizations to tailor the workflow to your specific needs, ensuring optimal task execution and project success.\n\nBy leveraging LiteLLM, CrewAI offers seamless integration with a vast array of LLMs. This flexibility allows you to choose the most suitable model for your specific needs, whether you prioritize performance, cost-efficiency, or local deployment. Remember to consult the [LiteLLM documentation](https://docs.litellm.ai/docs/) for the most up-to-date information on supported models and configuration options.\n\nWith the above enhancements and detailed functionality, replaying specific tasks in CrewAI has been made more efficient and robust.\nEnsure you follow the commands and steps precisely to make the most of these features.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Conclusion",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Conclusion\n\n Conclusion\n\nAdopting the hierarchical process in CrewAI, with the correct configurations and understanding of the system's capabilities, facilitates an organized and efficient approach to project management.\nUtilize the advanced features and customizations to tailor the workflow to your specific needs, ensuring optimal task execution and project success.\n\nBy leveraging LiteLLM, CrewAI offers seamless integration with a vast array of LLMs. This flexibility allows you to choose the most suitable model for your specific needs, whether you prioritize performance, cost-efficiency, or local deployment. Remember to consult the [LiteLLM documentation](https://docs.litellm.ai/docs/) for the most up-to-date information on supported models and configuration options.\n\nWith the above enhancements and detailed functionality, replaying specific tasks in CrewAI has been made more efficient and robust.\nEnsure you follow the commands and steps precisely to make the most of these features."
    },
    {
      "content": "The `AIMindTool` provides a powerful way to query your data sources using natural language, making it easier to extract insights without writing complex SQL queries. By connecting to various data sources and leveraging AI-Minds technology, this tool enables agents to access and analyze data efficiently.\n\nBy integrating the `BraveSearchTool` into Python projects, users gain the ability to conduct real-time, relevant searches across the internet directly from their applications. The tool provides a simple interface to the powerful Brave Search API, making it easy to retrieve and process search results programmatically. By adhering to the setup and usage guidelines provided, incorporating this tool into projects is streamlined and straightforward.",
      "title": "Conclusion",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Conclusion",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Conclusion",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Conclusion"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Conclusion\n\n## Conclusion\n\nThe `AIMindTool` provides a powerful way to query your data sources using natural language, making it easier to extract insights without writing complex SQL queries. By connecting to various data sources and leveraging AI-Minds technology, this tool enables agents to access and analyze data efficiently.\n\nBy integrating the `BraveSearchTool` into Python projects, users gain the ability to conduct real-time, relevant searches across the internet directly from their applications. The tool provides a simple interface to the powerful Brave Search API, making it easy to retrieve and process search results programmatically. By adhering to the setup and usage guidelines provided, incorporating this tool into projects is streamlined and straightforward.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Conclusion",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Conclusion\n\n Conclusion\n\nThe `AIMindTool` provides a powerful way to query your data sources using natural language, making it easier to extract insights without writing complex SQL queries. By connecting to various data sources and leveraging AI-Minds technology, this tool enables agents to access and analyze data efficiently.\n\nBy integrating the `BraveSearchTool` into Python projects, users gain the ability to conduct real-time, relevant searches across the internet directly from their applications. The tool provides a simple interface to the powerful Brave Search API, making it easy to retrieve and process search results programmatically. By adhering to the setup and usage guidelines provided, incorporating this tool into projects is streamlined and straightforward."
    },
    {
      "content": "The `CodeInterpreterTool` provides a powerful way for CrewAI agents to execute Python code in a relatively secure environment. By enabling agents to write and run code, it significantly expands their problem-solving capabilities, especially for tasks involving data analysis, calculations, or other computational work. This tool is particularly useful for agents that need to perform complex operations that are more efficiently expressed in code than in natural language.\n\nBy integrating the `EXASearchTool` into Python projects, users gain the ability to conduct real-time, relevant searches across the internet directly from their applications.\nBy adhering to the setup and usage guidelines provided, incorporating this tool into projects is streamlined and straightforward.",
      "title": "Conclusion",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Conclusion",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Conclusion",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Conclusion"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Conclusion\n\n## Conclusion\n\nThe `CodeInterpreterTool` provides a powerful way for CrewAI agents to execute Python code in a relatively secure environment. By enabling agents to write and run code, it significantly expands their problem-solving capabilities, especially for tasks involving data analysis, calculations, or other computational work. This tool is particularly useful for agents that need to perform complex operations that are more efficiently expressed in code than in natural language.\n\nBy integrating the `EXASearchTool` into Python projects, users gain the ability to conduct real-time, relevant searches across the internet directly from their applications.\nBy adhering to the setup and usage guidelines provided, incorporating this tool into projects is streamlined and straightforward.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Conclusion",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Conclusion\n\n Conclusion\n\nThe `CodeInterpreterTool` provides a powerful way for CrewAI agents to execute Python code in a relatively secure environment. By enabling agents to write and run code, it significantly expands their problem-solving capabilities, especially for tasks involving data analysis, calculations, or other computational work. This tool is particularly useful for agents that need to perform complex operations that are more efficiently expressed in code than in natural language.\n\nBy integrating the `EXASearchTool` into Python projects, users gain the ability to conduct real-time, relevant searches across the internet directly from their applications.\nBy adhering to the setup and usage guidelines provided, incorporating this tool into projects is streamlined and straightforward."
    },
    {
      "content": "By integrating the `FileWriterTool` into your crews, the agents can reliably write content to files across different operating systems.\nThis tool is essential for tasks that require saving output data, creating structured file systems, and handling cross-platform file operations.\nIt's particularly recommended for Windows users who may encounter file writing issues with standard Python file operations. By adhering to the setup and usage guidelines provided, incorporating this tool into projects is straightforward and ensures consistent file writing behavior across all platforms.\n\nThe `HyperbrowserLoadTool` provides a powerful way to scrape and crawl websites, handling complex scenarios like anti-bot measures, CAPTCHAs, and more. By leveraging Hyperbrowser's platform, this tool enables agents to access and extract web content efficiently.",
      "title": "Conclusion",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Conclusion",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Conclusion",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Conclusion"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Conclusion\n\n## Conclusion\n\nBy integrating the `FileWriterTool` into your crews, the agents can reliably write content to files across different operating systems.\nThis tool is essential for tasks that require saving output data, creating structured file systems, and handling cross-platform file operations.\nIt's particularly recommended for Windows users who may encounter file writing issues with standard Python file operations. By adhering to the setup and usage guidelines provided, incorporating this tool into projects is straightforward and ensures consistent file writing behavior across all platforms.\n\nThe `HyperbrowserLoadTool` provides a powerful way to scrape and crawl websites, handling complex scenarios like anti-bot measures, CAPTCHAs, and more. By leveraging Hyperbrowser's platform, this tool enables agents to access and extract web content efficiently.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Conclusion",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Conclusion\n\n Conclusion\n\nBy integrating the `FileWriterTool` into your crews, the agents can reliably write content to files across different operating systems.\nThis tool is essential for tasks that require saving output data, creating structured file systems, and handling cross-platform file operations.\nIt's particularly recommended for Windows users who may encounter file writing issues with standard Python file operations. By adhering to the setup and usage guidelines provided, incorporating this tool into projects is straightforward and ensures consistent file writing behavior across all platforms.\n\nThe `HyperbrowserLoadTool` provides a powerful way to scrape and crawl websites, handling complex scenarios like anti-bot measures, CAPTCHAs, and more. By leveraging Hyperbrowser's platform, this tool enables agents to access and extract web content efficiently."
    },
    {
      "content": "The `LinkupSearchTool` provides a seamless way to integrate Linkup's contextual information retrieval capabilities into your CrewAI agents. By leveraging this tool, agents can access relevant and up-to-date information to enhance their decision-making and task execution.\n\nThe `LlamaIndexTool` provides a powerful way to integrate LlamaIndex's capabilities into CrewAI agents. By wrapping LlamaIndex tools and query engines, it enables agents to leverage sophisticated data retrieval and processing functionalities, enhancing their ability to work with complex information sources.\n\nThe `MultiOnTool` provides a powerful way to integrate web browsing capabilities into CrewAI agents. By enabling agents to interact with websites through natural language instructions, it opens up a wide range of possibilities for web-based tasks, from data collection and research to automated interactions with web services.",
      "title": "Conclusion",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Conclusion",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Conclusion",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Conclusion"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Conclusion\n\n## Conclusion\n\nThe `LinkupSearchTool` provides a seamless way to integrate Linkup's contextual information retrieval capabilities into your CrewAI agents. By leveraging this tool, agents can access relevant and up-to-date information to enhance their decision-making and task execution.\n\nThe `LlamaIndexTool` provides a powerful way to integrate LlamaIndex's capabilities into CrewAI agents. By wrapping LlamaIndex tools and query engines, it enables agents to leverage sophisticated data retrieval and processing functionalities, enhancing their ability to work with complex information sources.\n\nThe `MultiOnTool` provides a powerful way to integrate web browsing capabilities into CrewAI agents. By enabling agents to interact with websites through natural language instructions, it opens up a wide range of possibilities for web-based tasks, from data collection and research to automated interactions with web services.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Conclusion",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Conclusion\n\n Conclusion\n\nThe `LinkupSearchTool` provides a seamless way to integrate Linkup's contextual information retrieval capabilities into your CrewAI agents. By leveraging this tool, agents can access relevant and up-to-date information to enhance their decision-making and task execution.\n\nThe `LlamaIndexTool` provides a powerful way to integrate LlamaIndex's capabilities into CrewAI agents. By wrapping LlamaIndex tools and query engines, it enables agents to leverage sophisticated data retrieval and processing functionalities, enhancing their ability to work with complex information sources.\n\nThe `MultiOnTool` provides a powerful way to integrate web browsing capabilities into CrewAI agents. By enabling agents to interact with websites through natural language instructions, it opens up a wide range of possibilities for web-based tasks, from data collection and research to automated interactions with web services."
    },
    {
      "content": "The Patronus evaluation tools provide a powerful way to evaluate and score model inputs and outputs using the Patronus AI platform. By enabling agents to evaluate their own outputs or the outputs of other agents, these tools can help improve the quality and reliability of CrewAI workflows.\n\nThe `RagTool` provides a powerful way to create and query knowledge bases from various data sources. By leveraging Retrieval-Augmented Generation, it enables agents to access and retrieve relevant information efficiently, enhancing their ability to provide accurate and contextually appropriate responses.\n\nThe `S3ReaderTool` provides a straightforward way to read files from Amazon S3 buckets. By enabling agents to access content stored in S3, it facilitates workflows that require cloud-based file access. This tool is particularly useful for data processing, configuration management, and any task that involves retrieving information from AWS S3 storage.",
      "title": "Conclusion",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Conclusion",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Conclusion",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Conclusion"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Conclusion\n\n## Conclusion\n\nThe Patronus evaluation tools provide a powerful way to evaluate and score model inputs and outputs using the Patronus AI platform. By enabling agents to evaluate their own outputs or the outputs of other agents, these tools can help improve the quality and reliability of CrewAI workflows.\n\nThe `RagTool` provides a powerful way to create and query knowledge bases from various data sources. By leveraging Retrieval-Augmented Generation, it enables agents to access and retrieve relevant information efficiently, enhancing their ability to provide accurate and contextually appropriate responses.\n\nThe `S3ReaderTool` provides a straightforward way to read files from Amazon S3 buckets. By enabling agents to access content stored in S3, it facilitates workflows that require cloud-based file access. This tool is particularly useful for data processing, configuration management, and any task that involves retrieving information from AWS S3 storage.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Conclusion",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Conclusion\n\n Conclusion\n\nThe Patronus evaluation tools provide a powerful way to evaluate and score model inputs and outputs using the Patronus AI platform. By enabling agents to evaluate their own outputs or the outputs of other agents, these tools can help improve the quality and reliability of CrewAI workflows.\n\nThe `RagTool` provides a powerful way to create and query knowledge bases from various data sources. By leveraging Retrieval-Augmented Generation, it enables agents to access and retrieve relevant information efficiently, enhancing their ability to provide accurate and contextually appropriate responses.\n\nThe `S3ReaderTool` provides a straightforward way to read files from Amazon S3 buckets. By enabling agents to access content stored in S3, it facilitates workflows that require cloud-based file access. This tool is particularly useful for data processing, configuration management, and any task that involves retrieving information from AWS S3 storage."
    },
    {
      "content": "The `S3WriterTool` provides a straightforward way to write content to files in Amazon S3 buckets. By enabling agents to create and update files in S3, it facilitates workflows that require cloud-based file storage. This tool is particularly useful for data persistence, configuration management, report generation, and any task that involves storing information in AWS S3 storage.\n\nThe `ScrapeElementFromWebsiteTool` provides a powerful way to extract specific elements from websites using CSS selectors. By enabling agents to target only the content they need, it makes web scraping tasks more efficient and focused. This tool is particularly useful for data extraction, content monitoring, and research tasks where specific information needs to be extracted from web pages.",
      "title": "Conclusion",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Conclusion",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Conclusion",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Conclusion"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Conclusion\n\n## Conclusion\n\nThe `S3WriterTool` provides a straightforward way to write content to files in Amazon S3 buckets. By enabling agents to create and update files in S3, it facilitates workflows that require cloud-based file storage. This tool is particularly useful for data persistence, configuration management, report generation, and any task that involves storing information in AWS S3 storage.\n\nThe `ScrapeElementFromWebsiteTool` provides a powerful way to extract specific elements from websites using CSS selectors. By enabling agents to target only the content they need, it makes web scraping tasks more efficient and focused. This tool is particularly useful for data extraction, content monitoring, and research tasks where specific information needs to be extracted from web pages.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Conclusion",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Conclusion\n\n Conclusion\n\nThe `S3WriterTool` provides a straightforward way to write content to files in Amazon S3 buckets. By enabling agents to create and update files in S3, it facilitates workflows that require cloud-based file storage. This tool is particularly useful for data persistence, configuration management, report generation, and any task that involves storing information in AWS S3 storage.\n\nThe `ScrapeElementFromWebsiteTool` provides a powerful way to extract specific elements from websites using CSS selectors. By enabling agents to target only the content they need, it makes web scraping tasks more efficient and focused. This tool is particularly useful for data extraction, content monitoring, and research tasks where specific information needs to be extracted from web pages."
    },
    {
      "content": "The `ScrapegraphScrapeTool` provides a powerful way to extract content from websites using AI-powered understanding of web page structure. By enabling agents to target specific information using natural language prompts, it makes web scraping tasks more efficient and focused. This tool is particularly useful for data extraction, content monitoring, and research tasks where specific information needs to be extracted from web pages.\n\nThe `ScrapflyScrapeWebsiteTool` provides a powerful way to extract content from websites using Scrapfly's advanced web scraping capabilities. With features like headless browser support, proxies, and anti-bot bypass, it can handle complex websites and extract content in various formats. This tool is particularly useful for data extraction, content monitoring, and research tasks where reliable web scraping is required.",
      "title": "Conclusion",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Conclusion",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Conclusion",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Conclusion"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Conclusion\n\n## Conclusion\n\nThe `ScrapegraphScrapeTool` provides a powerful way to extract content from websites using AI-powered understanding of web page structure. By enabling agents to target specific information using natural language prompts, it makes web scraping tasks more efficient and focused. This tool is particularly useful for data extraction, content monitoring, and research tasks where specific information needs to be extracted from web pages.\n\nThe `ScrapflyScrapeWebsiteTool` provides a powerful way to extract content from websites using Scrapfly's advanced web scraping capabilities. With features like headless browser support, proxies, and anti-bot bypass, it can handle complex websites and extract content in various formats. This tool is particularly useful for data extraction, content monitoring, and research tasks where reliable web scraping is required.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Conclusion",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Conclusion\n\n Conclusion\n\nThe `ScrapegraphScrapeTool` provides a powerful way to extract content from websites using AI-powered understanding of web page structure. By enabling agents to target specific information using natural language prompts, it makes web scraping tasks more efficient and focused. This tool is particularly useful for data extraction, content monitoring, and research tasks where specific information needs to be extracted from web pages.\n\nThe `ScrapflyScrapeWebsiteTool` provides a powerful way to extract content from websites using Scrapfly's advanced web scraping capabilities. With features like headless browser support, proxies, and anti-bot bypass, it can handle complex websites and extract content in various formats. This tool is particularly useful for data extraction, content monitoring, and research tasks where reliable web scraping is required."
    },
    {
      "content": "The `SeleniumScrapingTool` provides a powerful way to extract content from websites using browser automation. By enabling agents to interact with websites as a real user would, it facilitates scraping of dynamic content that would be difficult or impossible to extract using simpler methods. This tool is particularly useful for research, data collection, and monitoring tasks that involve modern web applications with JavaScript-rendered content.\n\nBy integrating the `SerperDevTool` into Python projects, users gain the ability to conduct real-time, relevant searches across the internet directly from their applications.\nThe updated parameters allow for more customized and localized search results. By adhering to the setup and usage guidelines provided, incorporating this tool into projects is streamlined and straightforward.",
      "title": "Conclusion",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Conclusion",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Conclusion",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Conclusion"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Conclusion\n\n## Conclusion\n\nThe `SeleniumScrapingTool` provides a powerful way to extract content from websites using browser automation. By enabling agents to interact with websites as a real user would, it facilitates scraping of dynamic content that would be difficult or impossible to extract using simpler methods. This tool is particularly useful for research, data collection, and monitoring tasks that involve modern web applications with JavaScript-rendered content.\n\nBy integrating the `SerperDevTool` into Python projects, users gain the ability to conduct real-time, relevant searches across the internet directly from their applications.\nThe updated parameters allow for more customized and localized search results. By adhering to the setup and usage guidelines provided, incorporating this tool into projects is streamlined and straightforward.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Conclusion",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Conclusion\n\n Conclusion\n\nThe `SeleniumScrapingTool` provides a powerful way to extract content from websites using browser automation. By enabling agents to interact with websites as a real user would, it facilitates scraping of dynamic content that would be difficult or impossible to extract using simpler methods. This tool is particularly useful for research, data collection, and monitoring tasks that involve modern web applications with JavaScript-rendered content.\n\nBy integrating the `SerperDevTool` into Python projects, users gain the ability to conduct real-time, relevant searches across the internet directly from their applications.\nThe updated parameters allow for more customized and localized search results. By adhering to the setup and usage guidelines provided, incorporating this tool into projects is streamlined and straightforward."
    },
    {
      "content": "The `SnowflakeSearchTool` provides a powerful way to integrate Snowflake data warehouses with CrewAI agents. With features like connection pooling, automatic retries, and query caching, it enables efficient and reliable access to enterprise data. This tool is particularly useful for data analysis, reporting, and business intelligence tasks that require access to structured data stored in Snowflake.\n\nThe `WeaviateVectorSearchTool` provides a powerful way to search for semantically similar documents in a Weaviate vector database. By leveraging vector embeddings, it enables more accurate and contextually relevant search results compared to traditional keyword-based searches. This tool is particularly useful for applications that require finding information based on meaning rather than exact matches.",
      "title": "Conclusion",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Conclusion",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Conclusion",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Conclusion"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Conclusion\n\n## Conclusion\n\nThe `SnowflakeSearchTool` provides a powerful way to integrate Snowflake data warehouses with CrewAI agents. With features like connection pooling, automatic retries, and query caching, it enables efficient and reliable access to enterprise data. This tool is particularly useful for data analysis, reporting, and business intelligence tasks that require access to structured data stored in Snowflake.\n\nThe `WeaviateVectorSearchTool` provides a powerful way to search for semantically similar documents in a Weaviate vector database. By leveraging vector embeddings, it enables more accurate and contextually relevant search results compared to traditional keyword-based searches. This tool is particularly useful for applications that require finding information based on meaning rather than exact matches.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Conclusion",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Conclusion\n\n Conclusion\n\nThe `SnowflakeSearchTool` provides a powerful way to integrate Snowflake data warehouses with CrewAI agents. With features like connection pooling, automatic retries, and query caching, it enables efficient and reliable access to enterprise data. This tool is particularly useful for data analysis, reporting, and business intelligence tasks that require access to structured data stored in Snowflake.\n\nThe `WeaviateVectorSearchTool` provides a powerful way to search for semantically similar documents in a Weaviate vector database. By leveraging vector embeddings, it enables more accurate and contextually relevant search results compared to traditional keyword-based searches. This tool is particularly useful for applications that require finding information based on meaning rather than exact matches."
    },
    {
      "content": "The `YoutubeChannelSearchTool` provides a powerful way to search and extract information from YouTube channel content using RAG techniques. By enabling agents to search across an entire channel's videos, it facilitates information extraction and analysis tasks that would otherwise be difficult to perform. This tool is particularly useful for research, content analysis, and knowledge extraction from YouTube channels.\n\nThe `YoutubeVideoSearchTool` provides a powerful way to search and extract information from YouTube video content using RAG techniques. By enabling agents to search within video content, it facilitates information extraction and analysis tasks that would otherwise be difficult to perform. This tool is particularly useful for research, content analysis, and knowledge extraction from video sources.",
      "title": "Conclusion",
      "type": "descriptive_text",
      "hierarchy_path": [
        {
          "title": "Changelog",
          "level": 0
        },
        {
          "title": "`YoutubeVideoSearchTool`",
          "level": 1
        },
        {
          "title": "Conclusion",
          "level": 2
        }
      ],
      "metadata": {
        "section_type": "General",
        "hierarchy_path": [
          {
            "title": "Changelog",
            "level": 0
          },
          {
            "title": "`YoutubeVideoSearchTool`",
            "level": 1
          },
          {
            "title": "Conclusion",
            "level": 2
          }
        ],
        "content_type": "unknown",
        "related_sections": [],
        "document_position": 0.0,
        "header_level": 0,
        "contains_links": false,
        "link_count": 0,
        "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Conclusion"
      },
      "enhanced_content": "Context: Changelog > `YoutubeVideoSearchTool` > Conclusion\n\n## Conclusion\n\nThe `YoutubeChannelSearchTool` provides a powerful way to search and extract information from YouTube channel content using RAG techniques. By enabling agents to search across an entire channel's videos, it facilitates information extraction and analysis tasks that would otherwise be difficult to perform. This tool is particularly useful for research, content analysis, and knowledge extraction from YouTube channels.\n\nThe `YoutubeVideoSearchTool` provides a powerful way to search and extract information from YouTube video content using RAG techniques. By enabling agents to search within video content, it facilitates information extraction and analysis tasks that would otherwise be difficult to perform. This tool is particularly useful for research, content analysis, and knowledge extraction from video sources.",
      "formatted_path": "Changelog > `YoutubeVideoSearchTool` > Conclusion",
      "enhanced_text": "Context: Changelog > `YoutubeVideoSearchTool` > Conclusion\n\n Conclusion\n\nThe `YoutubeChannelSearchTool` provides a powerful way to search and extract information from YouTube channel content using RAG techniques. By enabling agents to search across an entire channel's videos, it facilitates information extraction and analysis tasks that would otherwise be difficult to perform. This tool is particularly useful for research, content analysis, and knowledge extraction from YouTube channels.\n\nThe `YoutubeVideoSearchTool` provides a powerful way to search and extract information from YouTube video content using RAG techniques. By enabling agents to search within video content, it facilitates information extraction and analysis tasks that would otherwise be difficult to perform. This tool is particularly useful for research, content analysis, and knowledge extraction from video sources."
    }
  ],
  {
    "type": "document",
    "title": "Changelog",
    "content": [],
    "metadata": {
      "section_type": "root",
      "content_type": null
    },
    "children": [
      {
        "type": "header",
        "title": "Changelog",
        "level": 1,
        "content": "Source: https://docs.crewai.com/changelog View the latest updates and changes to CrewAI Converted tabs to spaces in `crew.py` template Enhanced LLM Streaming Response Handling and Event System Included `model_name` Enhanced Event Listener with rich visualization and improved logging Added fingerprints **Bug Fixes** Fixed Mistral issues Fixed a bug in documentation Fixed type check error in fingerprint property **Documentation Updates** Improved tool documentation Updated installation guide for the `uv` tool package Added instructions for upgrading crewAI with the `uv` tool Added documentation for `ApifyActorsTool`\n</Update> Fixed issues with missing template variables and user memory configuration Improved async flow support and addressed agent response formatting Enhanced memory reset functionality and fixed CLI memory commands Fixed type issues, tool calling properties, and telemetry decoupling **New Features & Enhancements** Added Flow state export and improved state utilities Enhanced agent knowledge setup with optional crew embedder Introduced event emitter for better observability and LLM call tracking Added support for Python 3.10 and ChatOllama from langchain\\_ollama Integrated context window size support for the o3-mini model Added support for multiple router calls **Documentation & Guides** Improved documentation layout and hierarchical structure Added QdrantVectorSearchTool guide and clarified event listener usage Fixed typos in prompts and updated Amazon Bedrock model listings\n</Update> Enhanced LLM Support: Improved structured LLM output, parameter handling, and formatting for Anthropic models Crew & Agent Stability: Fixed issues with cloning agents/crews using knowledge sources, multiple task outputs in conditional tasks, and ignored Crew task callbacks Memory & Storage Fixes: Fixed short-term memory handling with Bedrock, ensured correct embedder initialization, and added a reset memories function in the crew class Training & Execution Reliability: Fixed broken training and interpolation issues with dict and list input types **New Features & Enhancements** Advanced Knowledge Management: Improved naming conventions and enhanced embedding configuration with custom embedder support Expanded Logging & Observability: Added JSON format support for logging and integrated MLflow tracing documentation Data Handling Improvements: Updated excel\\_knowledge\\_source.py to process multi-tab files General Performance & Codebase Clean-Up: Streamlined enterprise code alignment and resolved linting issues Adding new tool: `QdrantVectorSearchTool` **Documentation & Guides** Updated AI & Memory Docs: Improved Bedrock, Google AI, and long-term memory documentation Task & Workflow Clarity: Added \"Human Input\" row to Task Attributes, Langfuse guide, and FileWriterTool documentation Fixed Various Typos & Formatting Issues\n</Update> Add Composio docs Add SageMaker as a LLM provider **Fixes** Overall LLM connection issues Using safe accessors on training Add version check to crew\\_chat.py **Documentation** New docs for crewai chat Improve formatting and clarity in CLI and Composio Tool docs\n</Update> Conversation crew v1 Add unique ID to flow states Add @persist decorator with FlowPersistence interface **Integrations** Add SambaNova integration Add NVIDIA NIM provider in cli Introducing VoyageAI **Fixes** Fix API Key Behavior and Entity Handling in Mem0 Integration Fixed core invoke loop logic and relevant tests Make tool inputs actual objects and not strings Add important missing parts to creating tools Drop litellm version to prevent windows issue Before kickoff if inputs are none Fixed typos, nested pydantic model issue, and docling issues\n</Update> Adding Multimodal Abilities to Crew Programatic Guardrails HITL multiple rounds Gemini 2.0 Support CrewAI Flows Improvements Add Workflow Permissions Add support for langfuse with litellm Portkey Integration with CrewAI Add interpolate\\_only method and improve error handling Docling Support Weviate Support **Fixes** output\\_file not respecting system path disk I/O error when resetting short-term memory CrewJSONEncoder now accepts enums Python max version Interpolation for output\\_file in Task Handle coworker role name case/whitespace properly Add tiktoken as explicit dependency and document Rust requirement Include agent knowledge in planning process Change storage initialization to None for KnowledgeStorage Fix optional storage checks include event emitter in flows Docstring, Error Handling, and Type Hints Improvements Suppressed userWarnings from litellm pydantic issues\n</Update> Remove all references to pipeline and pipeline router Add Nvidia NIM as provider in Custom LLM Add knowledge demo + improve knowledge docs Add HITL multiple rounds of followup New docs about yaml crew with decorators Simplify template crew\n</Update> Added knowledge to agent level Feat/remove langchain Improve typed task outputs Log in to Tool Repository on crewai login **Fixes** Fixes issues with result as answer not properly exiting LLM loop Fix missing key name when running with ollama provider Fix spelling issue found **Documentation** Update readme for running mypy Add knowledge to mint.json Update Github actions Update Agents docs to include two approaches for creating an agent Improvements to LLM Configuration and Usage\n</Update> New before\\_kickoff and after\\_kickoff crew callbacks Support to pre-seed agents with Knowledge Add support for retrieving user preferences and memories using Mem0 **Fixes** Fix Async Execution Upgrade chroma and adjust embedder function generator Update CLI Watson supported models + docs Reduce level for Bandit Fixing all tests **Documentation** Update Docs\n</Update> Fixing Tokens callback replacement bug Fixing Step callback issue Add cached prompt tokens info on usage metrics Fix crew\\_train\\_success test\n</Update>",
        "metadata": {
          "section_type": "General",
          "content_type": "descriptive_text"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "Agents",
        "level": 1,
        "content": "Source: https://docs.crewai.com/concepts/agents Detailed guide on creating and managing agents within the CrewAI framework.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": [
          {
            "type": "header",
            "title": "Overview of an Agent",
            "level": 2,
            "content": "In the CrewAI framework, an `Agent` is an autonomous unit that can: Perform specific tasks Make decisions based on its role and goal Use tools to accomplish objectives Communicate and collaborate with other agents Maintain memory of interactions Delegate tasks when allowed",
            "metadata": {
              "section_type": "Concepts documentation",
              "content_type": "short_description"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Agent Attributes",
            "level": 2,
            "content": "| Attribute                               | Parameter                | Type                                  | Description                                                                                              |\n| :-------------------------------------- | :----------------------- | :------------------------------------ | :------------------------------------------------------------------------------------------------------- |\n| **Role**                                | `role`                   | `str`                                 | Defines the agent's function and expertise within the crew.                                              |\n| **Goal**                                | `goal`                   | `str`                                 | The individual objective that guides the agent's decision-making.                                        |\n| **Backstory**                           | `backstory`              | `str`                                 | Provides context and personality to the agent, enriching interactions.                                   |\n| **LLM** *(optional)*                    | `llm`                    | `Union[str, LLM, Any]`                | Language model that powers the agent. Defaults to the model specified in `OPENAI_MODEL_NAME` or \"gpt-4\". |\n| **Tools** *(optional)*                  | `tools`                  | `List[BaseTool]`                      | Capabilities or functions available to the agent. Defaults to an empty list.                             |\n| **Function Calling LLM** *(optional)*   | `function_calling_llm`   | `Optional[Any]`                       | Language model for tool calling, overrides crew's LLM if specified.                                      |\n| **Max Iterations** *(optional)*         | `max_iter`               | `int`                                 | Maximum iterations before the agent must provide its best answer. Default is 20.                         |\n| **Max RPM** *(optional)*                | `max_rpm`                | `Optional[int]`                       | Maximum requests per minute to avoid rate limits.                                                        |\n| **Max Execution Time** *(optional)*     | `max_execution_time`     | `Optional[int]`                       | Maximum time (in seconds) for task execution.                                                            |\n| **Memory** *(optional)*                 | `memory`                 | `bool`                                | Whether the agent should maintain memory of interactions. Default is True.                               |\n| **Verbose** *(optional)*                | `verbose`                | `bool`                                | Enable detailed execution logs for debugging. Default is False.                                          |\n| **Allow Delegation** *(optional)*       | `allow_delegation`       | `bool`                                | Allow the agent to delegate tasks to other agents. Default is False.                                     |\n| **Step Callback** *(optional)*          | `step_callback`          | `Optional[Any]`                       | Function called after each agent step, overrides crew callback.                                          |\n| **Cache** *(optional)*                  | `cache`                  | `bool`                                | Enable caching for tool usage. Default is True.                                                          |\n| **System Template** *(optional)*        | `system_template`        | `Optional[str]`                       | Custom system prompt template for the agent.                                                             |\n| **Prompt Template** *(optional)*        | `prompt_template`        | `Optional[str]`                       | Custom prompt template for the agent.                                                                    |\n| **Response Template** *(optional)*      | `response_template`      | `Optional[str]`                       | Custom response template for the agent.                                                                  |\n| **Allow Code Execution** *(optional)*   | `allow_code_execution`   | `Optional[bool]`                      | Enable code execution for the agent. Default is False.                                                   |\n| **Max Retry Limit** *(optional)*        | `max_retry_limit`        | `int`                                 | Maximum number of retries when an error occurs. Default is 2.                                            |\n| **Respect Context Window** *(optional)* | `respect_context_window` | `bool`                                | Keep messages under context window size by summarizing. Default is True.                                 |\n| **Code Execution Mode** *(optional)*    | `code_execution_mode`    | `Literal[\"safe\", \"unsafe\"]`           | Mode for code execution: 'safe' (using Docker) or 'unsafe' (direct). Default is 'safe'.                  |\n| **Embedder** *(optional)*               | `embedder`               | `Optional[Dict[str, Any]]`            | Configuration for the embedder used by the agent.                                                        |\n| **Knowledge Sources** *(optional)*      | `knowledge_sources`      | `Optional[List[BaseKnowledgeSource]]` | Knowledge sources available to the agent.                                                                |\n| **Use System Prompt** *(optional)*      | `use_system_prompt`      | `Optional[bool]`                      | Whether to use system prompt (for o1 model support). Default is True.                                    |",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Creating Agents",
            "level": 2,
            "content": "There are two ways to create agents in CrewAI: using **YAML configuration (recommended)** or defining them **directly in code**.",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": [
              {
                "type": "header",
                "title": "YAML Configuration (Recommended)",
                "level": 3,
                "content": "",
                "metadata": {
                  "section_type": "General",
                  "content_type": null
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Direct Code Definition",
                "level": 3,
                "content": "You can create agents directly in code by instantiating the `Agent` class. Here's a comprehensive example showing all available parameters:\n```\nfrom crewai import Agent\nfrom crewai_tools import SerperDevTool\n\n# Create an agent with all available parameters\nagent = Agent(\n    role=\"Senior Data Scientist\",\n    goal=\"Analyze and interpret complex datasets to provide actionable insights\",\n    backstory=\"With over 10 years of experience in data science and machine learning, \"\n              \"you excel at finding patterns in complex datasets.\",\n    llm=\"gpt-4\",  # Default: OPENAI_MODEL_NAME or \"gpt-4\"\n    function_calling_llm=None,  # Optional: Separate LLM for tool calling\n    memory=True,  # Default: True\n    verbose=False,  # Default: False\n    allow_delegation=False,  # Default: False\n    max_iter=20,  # Default: 20 iterations\n    max_rpm=None,  # Optional: Rate limit for API calls\n    max_execution_time=None,  # Optional: Maximum execution time in seconds\n    max_retry_limit=2,  # Default: 2 retries on error\n    allow_code_execution=False,  # Default: False\n    code_execution_mode=\"safe\",  # Default: \"safe\" (options: \"safe\", \"unsafe\")\n    respect_context_window=True,  # Default: True\n    use_system_prompt=True,  # Default: True\n    tools=[SerperDevTool()],  # Optional: List of tools\n    knowledge_sources=None,  # Optional: List of knowledge sources\n    embedder=None,  # Optional: Custom embedder configuration\n    system_template=None,  # Optional: Custom system prompt template\n    prompt_template=None,  # Optional: Custom prompt template\n    response_template=None,  # Optional: Custom response template\n    step_callback=None,  # Optional: Callback function for monitoring\n)\n```\nLet's break down some key parameter combinations for common use cases:",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [
                  {
                    "type": "header",
                    "title": "Basic Research Agent",
                    "level": 4,
                    "content": "```\nresearch_agent = Agent(\n    role=\"Research Analyst\",\n    goal=\"Find and summarize information about specific topics\",\n    backstory=\"You are an experienced researcher with attention to detail\",\n    tools=[SerperDevTool()],\n    verbose=True  # Enable logging for debugging\n)\n```",
                    "metadata": {
                      "section_type": "General",
                      "content_type": "code_example"
                    },
                    "children": [],
                    "code_blocks": [
                      {
                        "type": "code_block",
                        "language": "python Code",
                        "content": "research_agent = Agent(\n    role=\"Research Analyst\",\n    goal=\"Find and summarize information about specific topics\",\n    backstory=\"You are an experienced researcher with attention to detail\",\n    tools=[SerperDevTool()],\n    verbose=True  # Enable logging for debugging\n)",
                        "metadata": {
                          "section_type": "code",
                          "content_type": "code_example"
                        },
                        "children": []
                      }
                    ]
                  },
                  {
                    "type": "header",
                    "title": "Code Development Agent",
                    "level": 4,
                    "content": "```\ndev_agent = Agent(\n    role=\"Senior Python Developer\",\n    goal=\"Write and debug Python code\",\n    backstory=\"Expert Python developer with 10 years of experience\",\n    allow_code_execution=True,\n    code_execution_mode=\"safe\",  # Uses Docker for safety\n    max_execution_time=300,  # 5-minute timeout\n    max_retry_limit=3  # More retries for complex code tasks\n)\n```",
                    "metadata": {
                      "section_type": "General",
                      "content_type": "code_example"
                    },
                    "children": [],
                    "code_blocks": [
                      {
                        "type": "code_block",
                        "language": "python Code",
                        "content": "dev_agent = Agent(\n    role=\"Senior Python Developer\",\n    goal=\"Write and debug Python code\",\n    backstory=\"Expert Python developer with 10 years of experience\",\n    allow_code_execution=True,\n    code_execution_mode=\"safe\",  # Uses Docker for safety\n    max_execution_time=300,  # 5-minute timeout\n    max_retry_limit=3  # More retries for complex code tasks\n)",
                        "metadata": {
                          "section_type": "code",
                          "content_type": "code_example"
                        },
                        "children": []
                      }
                    ]
                  },
                  {
                    "type": "header",
                    "title": "Long-Running Analysis Agent",
                    "level": 4,
                    "content": "```\nanalysis_agent = Agent(\n    role=\"Data Analyst\",\n    goal=\"Perform deep analysis of large datasets\",\n    backstory=\"Specialized in big data analysis and pattern recognition\",\n    memory=True,\n    respect_context_window=True,\n    max_rpm=10,  # Limit API calls\n    function_calling_llm=\"gpt-4o-mini\"  # Cheaper model for tool calls\n)\n```",
                    "metadata": {
                      "section_type": "General",
                      "content_type": "code_example"
                    },
                    "children": [],
                    "code_blocks": [
                      {
                        "type": "code_block",
                        "language": "python Code",
                        "content": "analysis_agent = Agent(\n    role=\"Data Analyst\",\n    goal=\"Perform deep analysis of large datasets\",\n    backstory=\"Specialized in big data analysis and pattern recognition\",\n    memory=True,\n    respect_context_window=True,\n    max_rpm=10,  # Limit API calls\n    function_calling_llm=\"gpt-4o-mini\"  # Cheaper model for tool calls\n)",
                        "metadata": {
                          "section_type": "code",
                          "content_type": "code_example"
                        },
                        "children": []
                      }
                    ]
                  },
                  {
                    "type": "header",
                    "title": "Custom Template Agent",
                    "level": 4,
                    "content": "```\ncustom_agent = Agent(\n    role=\"Customer Service Representative\",\n    goal=\"Assist customers with their inquiries\",\n    backstory=\"Experienced in customer support with a focus on satisfaction\",\n    system_template=\"\"\"<|start_header_id|>system<|end_header_id|>\n                        {{ .System }}<|eot_id|>\"\"\",\n    prompt_template=\"\"\"<|start_header_id|>user<|end_header_id|>\n                        {{ .Prompt }}<|eot_id|>\"\"\",\n    response_template=\"\"\"<|start_header_id|>assistant<|end_header_id|>\n                        {{ .Response }}<|eot_id|>\"\"\",\n)\n```",
                    "metadata": {
                      "section_type": "General",
                      "content_type": "code_example"
                    },
                    "children": [],
                    "code_blocks": [
                      {
                        "type": "code_block",
                        "language": "python Code",
                        "content": "custom_agent = Agent(\n    role=\"Customer Service Representative\",\n    goal=\"Assist customers with their inquiries\",\n    backstory=\"Experienced in customer support with a focus on satisfaction\",\n    system_template=\"\"\"<|start_header_id|>system<|end_header_id|>\n                        {{ .System }}<|eot_id|>\"\"\",\n    prompt_template=\"\"\"<|start_header_id|>user<|end_header_id|>\n                        {{ .Prompt }}<|eot_id|>\"\"\",\n    response_template=\"\"\"<|start_header_id|>assistant<|end_header_id|>\n                        {{ .Response }}<|eot_id|>\"\"\",\n)",
                        "metadata": {
                          "section_type": "code",
                          "content_type": "code_example"
                        },
                        "children": []
                      }
                    ]
                  }
                ],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "from crewai import Agent\nfrom crewai_tools import SerperDevTool\n\n# Create an agent with all available parameters\nagent = Agent(\n    role=\"Senior Data Scientist\",\n    goal=\"Analyze and interpret complex datasets to provide actionable insights\",\n    backstory=\"With over 10 years of experience in data science and machine learning, \"\n              \"you excel at finding patterns in complex datasets.\",\n    llm=\"gpt-4\",  # Default: OPENAI_MODEL_NAME or \"gpt-4\"\n    function_calling_llm=None,  # Optional: Separate LLM for tool calling\n    memory=True,  # Default: True\n    verbose=False,  # Default: False\n    allow_delegation=False,  # Default: False\n    max_iter=20,  # Default: 20 iterations\n    max_rpm=None,  # Optional: Rate limit for API calls\n    max_execution_time=None,  # Optional: Maximum execution time in seconds\n    max_retry_limit=2,  # Default: 2 retries on error\n    allow_code_execution=False,  # Default: False\n    code_execution_mode=\"safe\",  # Default: \"safe\" (options: \"safe\", \"unsafe\")\n    respect_context_window=True,  # Default: True\n    use_system_prompt=True,  # Default: True\n    tools=[SerperDevTool()],  # Optional: List of tools\n    knowledge_sources=None,  # Optional: List of knowledge sources\n    embedder=None,  # Optional: Custom embedder configuration\n    system_template=None,  # Optional: Custom system prompt template\n    prompt_template=None,  # Optional: Custom prompt template\n    response_template=None,  # Optional: Custom response template\n    step_callback=None,  # Optional: Callback function for monitoring\n)",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Parameter Details",
                "level": 3,
                "content": "",
                "metadata": {
                  "section_type": "General",
                  "content_type": null
                },
                "children": [
                  {
                    "type": "header",
                    "title": "Critical Parameters",
                    "level": 4,
                    "content": "`role`, `goal`, and `backstory` are required and shape the agent's behavior `llm` determines the language model used (default: OpenAI's GPT-4)",
                    "metadata": {
                      "section_type": "General",
                      "content_type": "code_example"
                    },
                    "children": []
                  },
                  {
                    "type": "header",
                    "title": "Memory and Context",
                    "level": 4,
                    "content": "`memory`: Enable to maintain conversation history `respect_context_window`: Prevents token limit issues `knowledge_sources`: Add domain-specific knowledge bases",
                    "metadata": {
                      "section_type": "General",
                      "content_type": "code_example"
                    },
                    "children": []
                  },
                  {
                    "type": "header",
                    "title": "Execution Control",
                    "level": 4,
                    "content": "`max_iter`: Maximum attempts before giving best answer `max_execution_time`: Timeout in seconds `max_rpm`: Rate limiting for API calls `max_retry_limit`: Retries on error",
                    "metadata": {
                      "section_type": "General",
                      "content_type": "code_example"
                    },
                    "children": []
                  },
                  {
                    "type": "header",
                    "title": "Code Execution",
                    "level": 4,
                    "content": "`allow_code_execution`: Must be True to run code `code_execution_mode`: `\"safe\"`: Uses Docker (recommended for production) `\"unsafe\"`: Direct execution (use only in trusted environments)",
                    "metadata": {
                      "section_type": "General",
                      "content_type": "code_example"
                    },
                    "children": []
                  },
                  {
                    "type": "header",
                    "title": "Templates",
                    "level": 4,
                    "content": "`system_template`: Defines agent's core behavior `prompt_template`: Structures input format `response_template`: Formats agent responses",
                    "metadata": {
                      "section_type": "General",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              }
            ]
          },
          {
            "type": "header",
            "title": "Agent Tools",
            "level": 2,
            "content": "Agents can be equipped with various tools to enhance their capabilities. CrewAI supports tools from: [CrewAI Toolkit](https://github.com/joaomdmoura/crewai-tools) [LangChain Tools](https://python.langchain.com/docs/integrations/tools) Here's how to add tools to an agent:\n```\nfrom crewai import Agent\nfrom crewai_tools import SerperDevTool, WikipediaTools\n\n# Create tools\nsearch_tool = SerperDevTool()\nwiki_tool = WikipediaTools()\n\n# Add tools to agent\nresearcher = Agent(\n    role=\"AI Technology Researcher\",\n    goal=\"Research the latest AI developments\",\n    tools=[search_tool, wiki_tool],\n    verbose=True\n)\n```",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai import Agent\nfrom crewai_tools import SerperDevTool, WikipediaTools\n\n# Create tools\nsearch_tool = SerperDevTool()\nwiki_tool = WikipediaTools()\n\n# Add tools to agent\nresearcher = Agent(\n    role=\"AI Technology Researcher\",\n    goal=\"Research the latest AI developments\",\n    tools=[search_tool, wiki_tool],\n    verbose=True\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Agent Memory and Context",
            "level": 2,
            "content": "Agents can maintain memory of their interactions and use context from previous tasks. This is particularly useful for complex workflows where information needs to be retained across multiple tasks.\n```\nfrom crewai import Agent\n\nanalyst = Agent(\n    role=\"Data Analyst\",\n    goal=\"Analyze and remember complex data patterns\",\n    memory=True,  # Enable memory\n    verbose=True\n)\n```",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai import Agent\n\nanalyst = Agent(\n    role=\"Data Analyst\",\n    goal=\"Analyze and remember complex data patterns\",\n    memory=True,  # Enable memory\n    verbose=True\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Important Considerations and Best Practices",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": [
              {
                "type": "header",
                "title": "Security and Code Execution",
                "level": 3,
                "content": "When using `allow_code_execution`, be cautious with user input and always validate it Use `code_execution_mode: \"safe\"` (Docker) in production environments Consider setting appropriate `max_execution_time` limits to prevent infinite loops",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Performance Optimization",
                "level": 3,
                "content": "Use `respect_context_window: true` to prevent token limit issues Set appropriate `max_rpm` to avoid rate limiting Enable `cache: true` to improve performance for repetitive tasks Adjust `max_iter` and `max_retry_limit` based on task complexity",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Memory and Context Management",
                "level": 3,
                "content": "Use `memory: true` for tasks requiring historical context Leverage `knowledge_sources` for domain-specific information Configure `embedder_config` when using custom embedding models Use custom templates (`system_template`, `prompt_template`, `response_template`) for fine-grained control over agent behavior",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Agent Collaboration",
                "level": 3,
                "content": "Enable `allow_delegation: true` when agents need to work together Use `step_callback` to monitor and log agent interactions Consider using different LLMs for different purposes: Main `llm` for complex reasoning `function_calling_llm` for efficient tool usage",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Model Compatibility",
                "level": 3,
                "content": "Set `use_system_prompt: false` for older models that don't support system messages Ensure your chosen `llm` supports the features you need (like function calling)",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Troubleshooting Common Issues",
            "level": 2,
            "content": "**Rate Limiting**: If you're hitting API rate limits: Implement appropriate `max_rpm` Use caching for repetitive operations Consider batching requests **Context Window Errors**: If you're exceeding context limits: Enable `respect_context_window` Use more efficient prompts Clear agent memory periodically **Code Execution Issues**: If code execution fails: Verify Docker is installed for safe mode Check execution permissions Review code sandbox settings **Memory Issues**: If agent responses seem inconsistent: Verify memory is enabled Check knowledge source configuration Review conversation history management Remember that agents are most effective when configured according to their specific use case. Take time to understand your requirements and adjust these parameters accordingly.",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "CLI",
        "level": 1,
        "content": "Source: https://docs.crewai.com/concepts/cli Learn how to use the CrewAI CLI to interact with CrewAI.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "CrewAI CLI Documentation",
        "level": 1,
        "content": "The CrewAI CLI provides a set of commands to interact with CrewAI, allowing you to create, train, run, and manage crews & flows.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": [
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Basic Usage",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Available Commands",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": [
              {
                "type": "header",
                "title": "1. Create",
                "level": 3,
                "content": "Create a new crew or flow.\n```\ncrewai create [OPTIONS] TYPE NAME\n```\n`TYPE`: Choose between \"crew\" or \"flow\" `NAME`: Name of the crew or flow Example:\n```\ncrewai create crew my_new_crew\ncrewai create flow my_new_flow\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "shell Terminal",
                    "content": "crewai create [OPTIONS] TYPE NAME",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  },
                  {
                    "type": "code_block",
                    "language": "shell Terminal",
                    "content": "crewai create crew my_new_crew\ncrewai create flow my_new_flow",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "2. Version",
                "level": 3,
                "content": "Show the installed version of CrewAI.\n```\ncrewai version [OPTIONS]\n```\n`--tools`: (Optional) Show the installed version of CrewAI tools Example:\n```\ncrewai version\ncrewai version --tools\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "shell Terminal",
                    "content": "crewai version [OPTIONS]",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  },
                  {
                    "type": "code_block",
                    "language": "shell Terminal",
                    "content": "crewai version\ncrewai version --tools",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "3. Train",
                "level": 3,
                "content": "Train the crew for a specified number of iterations.\n```\ncrewai train [OPTIONS]\n```\n`-n, --n_iterations INTEGER`: Number of iterations to train the crew (default: 5) `-f, --filename TEXT`: Path to a custom file for training (default: \"trained\\_agents\\_data.pkl\") Example:\n```\ncrewai train -n 10 -f my_training_data.pkl\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "shell Terminal",
                    "content": "crewai train [OPTIONS]",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  },
                  {
                    "type": "code_block",
                    "language": "shell Terminal",
                    "content": "crewai train -n 10 -f my_training_data.pkl",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "4. Replay",
                "level": 3,
                "content": "Replay the crew execution from a specific task.\n```\ncrewai replay [OPTIONS]\n```\n`-t, --task_id TEXT`: Replay the crew from this task ID, including all subsequent tasks Example:\n```\ncrewai replay -t task_123456\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "shell Terminal",
                    "content": "crewai replay [OPTIONS]",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  },
                  {
                    "type": "code_block",
                    "language": "shell Terminal",
                    "content": "crewai replay -t task_123456",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "5. Log-tasks-outputs",
                "level": 3,
                "content": "Retrieve your latest crew\\.kickoff() task outputs.\n```\ncrewai log-tasks-outputs\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "shell Terminal",
                    "content": "crewai log-tasks-outputs",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "6. Reset-memories",
                "level": 3,
                "content": "Reset the crew memories (long, short, entity, latest\\_crew\\_kickoff\\_outputs).\n```\ncrewai reset-memories [OPTIONS]\n```\n`-l, --long`: Reset LONG TERM memory `-s, --short`: Reset SHORT TERM memory `-e, --entities`: Reset ENTITIES memory `-k, --kickoff-outputs`: Reset LATEST KICKOFF TASK OUTPUTS `-a, --all`: Reset ALL memories Example:\n```\ncrewai reset-memories --long --short\ncrewai reset-memories --all\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "shell Terminal",
                    "content": "crewai reset-memories [OPTIONS]",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  },
                  {
                    "type": "code_block",
                    "language": "shell Terminal",
                    "content": "crewai reset-memories --long --short\ncrewai reset-memories --all",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "7. Test",
                "level": 3,
                "content": "Test the crew and evaluate the results.\n```\ncrewai test [OPTIONS]\n```\n`-n, --n_iterations INTEGER`: Number of iterations to test the crew (default: 3) `-m, --model TEXT`: LLM Model to run the tests on the Crew (default: \"gpt-4o-mini\") Example:\n```\ncrewai test -n 5 -m gpt-3.5-turbo\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "shell Terminal",
                    "content": "crewai test [OPTIONS]",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  },
                  {
                    "type": "code_block",
                    "language": "shell Terminal",
                    "content": "crewai test -n 5 -m gpt-3.5-turbo",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "8. Run",
                "level": 3,
                "content": "Run the crew or flow.\n```\ncrewai run\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "shell Terminal",
                    "content": "crewai run",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "9. Chat",
                "level": 3,
                "content": "Starting in version `0.98.0`, when you run the `crewai chat` command, you start an interactive session with your crew. The AI assistant will guide you by asking for necessary inputs to execute the crew. Once all inputs are provided, the crew will execute its tasks. After receiving the results, you can continue interacting with the assistant for further instructions or questions.\n```\ncrewai chat\n```\n\n```\n@crew\ndef crew(self) -> Crew:\n    return Crew(\n        agents=self.agents,\n        tasks=self.tasks,\n        process=Process.sequential,\n        verbose=True,\n        chat_llm=\"gpt-4o\",  # LLM for chat orchestration\n    )\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "shell Terminal",
                    "content": "crewai chat",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  },
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "@crew\ndef crew(self) -> Crew:\n    return Crew(\n        agents=self.agents,\n        tasks=self.tasks,\n        process=Process.sequential,\n        verbose=True,\n        chat_llm=\"gpt-4o\",  # LLM for chat orchestration\n    )",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "10. API Keys",
                "level": 3,
                "content": "When running `crewai create crew` command, the CLI will first show you the top 5 most common LLM providers and ask you to select one. Once you've selected an LLM provider, you will be prompted for API keys.",
                "metadata": {
                  "section_type": "API documentation",
                  "content_type": "short_description"
                },
                "children": [
                  {
                    "type": "header",
                    "title": "Initial API key providers",
                    "level": 4,
                    "content": "The CLI will initially prompt for API keys for the following services: OpenAI Groq Anthropic Google Gemini SambaNova When you select a provider, the CLI will prompt you to enter your API key.",
                    "metadata": {
                      "section_type": "API documentation",
                      "content_type": "short_description"
                    },
                    "children": []
                  },
                  {
                    "type": "header",
                    "title": "Other Options",
                    "level": 4,
                    "content": "If you select option 6, you will be able to select from a list of LiteLLM supported providers. When you select a provider, the CLI will prompt you to enter the Key name and the API key. See the following link for each provider's key name: [LiteLLM Providers](https://docs.litellm.ai/docs/providers)",
                    "metadata": {
                      "section_type": "General",
                      "content_type": "link_list"
                    },
                    "children": []
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type": "header",
        "title": "Collaboration",
        "level": 1,
        "content": "Source: https://docs.crewai.com/concepts/collaboration Exploring the dynamics of agent collaboration within the CrewAI framework, focusing on the newly integrated features for enhanced functionality.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": [
          {
            "type": "header",
            "title": "Collaboration Fundamentals",
            "level": 2,
            "content": "Collaboration in CrewAI is fundamental, enabling agents to combine their skills, share information, and assist each other in task execution, embodying a truly cooperative ecosystem. **Information Sharing**: Ensures all agents are well-informed and can contribute effectively by sharing data and findings. **Task Assistance**: Allows agents to seek help from peers with the required expertise for specific tasks. **Resource Allocation**: Optimizes task execution through the efficient distribution and sharing of resources among agents.",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Enhanced Attributes for Improved Collaboration",
            "level": 2,
            "content": "The `Crew` class has been enriched with several attributes to support advanced functionalities: | Feature                                                               | Description                                                                                                                                                                                              |\n| :-------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Language Model Management** (`manager_llm`, `function_calling_llm`) | Manages language models for executing tasks and tools. `manager_llm` is required for hierarchical processes, while `function_calling_llm` is optional with a default value for streamlined interactions. |\n| **Custom Manager Agent** (`manager_agent`)                            | Specifies a custom agent as the manager, replacing the default CrewAI manager.                                                                                                                           |\n| **Process Flow** (`process`)                                          | Defines execution logic (e.g., sequential, hierarchical) for task distribution.                                                                                                                          |\n| **Verbose Logging** (`verbose`)                                       | Provides detailed logging for monitoring and debugging. Accepts integer and boolean values to control verbosity level.                                                                                   |\n| **Rate Limiting** (`max_rpm`)                                         | Limits requests per minute to optimize resource usage. Setting guidelines depend on task complexity and load.                                                                                            |\n| **Internationalization / Customization** (`language`, `prompt_file`)  | Supports prompt customization for global usability. [Example of file](https://github.com/joaomdmoura/crewAI/blob/main/src/crewai/translations/en.json)                                                   |\n| **Execution and Output Handling** (`full_output`)                     | Controls output granularity, distinguishing between full and final outputs.                                                                                                                              |\n| **Callback and Telemetry** (`step_callback`, `task_callback`)         | Enables step-wise and task-level execution monitoring and telemetry for performance analytics.                                                                                                           |\n| **Crew Sharing** (`share_crew`)                                       | Allows sharing crew data with CrewAI for model improvement. Privacy implications and benefits should be considered.                                                                                      |\n| **Usage Metrics** (`usage_metrics`)                                   | Logs all LLM usage metrics during task execution for performance insights.                                                                                                                               |\n| **Memory Usage** (`memory`)                                           | Enables memory for storing execution history, aiding in agent learning and task efficiency.                                                                                                              |\n| **Embedder Configuration** (`embedder`)                               | Configures the embedder for language understanding and generation, with support for provider customization.                                                                                              |\n| **Cache Management** (`cache`)                                        | Specifies whether to cache tool execution results, enhancing performance.                                                                                                                                |\n| **Output Logging** (`output_log_file`)                                | Defines the file path for logging crew execution output.                                                                                                                                                 |\n| **Planning Mode** (`planning`)                                        | Enables action planning before task execution. Set `planning=True` to activate.                                                                                                                          |\n| **Replay Feature** (`replay`)                                         | Provides CLI for listing tasks from the last run and replaying from specific tasks, aiding in task management and troubleshooting.                                                                       |",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Delegation (Dividing to Conquer)",
            "level": 2,
            "content": "Delegation enhances functionality by allowing agents to intelligently assign tasks or seek help, thereby amplifying the crew's overall capability.",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Implementing Collaboration and Delegation",
            "level": 2,
            "content": "Setting up a crew involves defining the roles and capabilities of each agent. CrewAI seamlessly manages their interactions, ensuring efficient collaboration and delegation, with enhanced customization and monitoring features to adapt to various operational needs.",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example Scenario",
            "level": 2,
            "content": "Consider a crew with a researcher agent tasked with data gathering and a writer agent responsible for compiling reports. The integration of advanced language model management and process flow attributes allows for more sophisticated interactions, such as the writer delegating complex research tasks to the researcher or querying specific information, thereby facilitating a seamless workflow.",
            "metadata": {
              "section_type": "Examples",
              "content_type": "descriptive_text"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Conclusion",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Crews",
        "level": 1,
        "content": "Source: https://docs.crewai.com/concepts/crews Understanding and utilizing crews in the crewAI framework with comprehensive attributes and functionalities.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": [
          {
            "type": "header",
            "title": "What is a Crew?",
            "level": 2,
            "content": "A crew in crewAI represents a collaborative group of agents working together to achieve a set of tasks. Each crew defines the strategy for task execution, agent collaboration, and the overall workflow.",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Crew Attributes",
            "level": 2,
            "content": "| Attribute                             | Parameters             | Description                                                                                                                                                                                           |\n| :------------------------------------ | :--------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Tasks**                             | `tasks`                | A list of tasks assigned to the crew.                                                                                                                                                                 |\n| **Agents**                            | `agents`               | A list of agents that are part of the crew.                                                                                                                                                           |\n| **Process** *(optional)*              | `process`              | The process flow (e.g., sequential, hierarchical) the crew follows. Default is `sequential`.                                                                                                          |\n| **Verbose** *(optional)*              | `verbose`              | The verbosity level for logging during execution. Defaults to `False`.                                                                                                                                |\n| **Manager LLM** *(optional)*          | `manager_llm`          | The language model used by the manager agent in a hierarchical process. **Required when using a hierarchical process.**                                                                               |\n| **Function Calling LLM** *(optional)* | `function_calling_llm` | If passed, the crew will use this LLM to do function calling for tools for all agents in the crew. Each agent can have its own LLM, which overrides the crew's LLM for function calling.              |\n| **Config** *(optional)*               | `config`               | Optional configuration settings for the crew, in `Json` or `Dict[str, Any]` format.                                                                                                                   |\n| **Max RPM** *(optional)*              | `max_rpm`              | Maximum requests per minute the crew adheres to during execution. Defaults to `None`.                                                                                                                 |\n| **Language** *(optional)*             | `language`             | Language used for the crew, defaults to English.                                                                                                                                                      |\n| **Language File** *(optional)*        | `language_file`        | Path to the language file to be used for the crew.                                                                                                                                                    |\n| **Memory** *(optional)*               | `memory`               | Utilized for storing execution memories (short-term, long-term, entity memory).                                                                                                                       |\n| **Memory Config** *(optional)*        | `memory_config`        | Configuration for the memory provider to be used by the crew.                                                                                                                                         |\n| **Cache** *(optional)*                | `cache`                | Specifies whether to use a cache for storing the results of tools' execution. Defaults to `True`.                                                                                                     |\n| **Embedder** *(optional)*             | `embedder`             | Configuration for the embedder to be used by the crew. Mostly used by memory for now. Default is `{\"provider\": \"openai\"}`.                                                                            |\n| **Full Output** *(optional)*          | `full_output`          | Whether the crew should return the full output with all tasks outputs or just the final output. Defaults to `False`.                                                                                  |\n| **Step Callback** *(optional)*        | `step_callback`        | A function that is called after each step of every agent. This can be used to log the agent's actions or to perform other operations; it won't override the agent-specific `step_callback`.           |\n| **Task Callback** *(optional)*        | `task_callback`        | A function that is called after the completion of each task. Useful for monitoring or additional operations post-task execution.                                                                      |\n| **Share Crew** *(optional)*           | `share_crew`           | Whether you want to share the complete crew information and execution with the crewAI team to make the library better, and allow us to train models.                                                  |\n| **Output Log File** *(optional)*      | `output_log_file`      | Set to True to save logs as logs.txt in the current directory or provide a file path. Logs will be in JSON format if the filename ends in .json, otherwise .txt. Defautls to `None`.                  |\n| **Manager Agent** *(optional)*        | `manager_agent`        | `manager` sets a custom agent that will be used as a manager.                                                                                                                                         |\n| **Prompt File** *(optional)*          | `prompt_file`          | Path to the prompt JSON file to be used for the crew.                                                                                                                                                 |\n| **Planning** *(optional)*             | `planning`             | Adds planning ability to the Crew. When activated before each Crew iteration, all Crew data is sent to an AgentPlanner that will plan the tasks and this plan will be added to each task description. |\n| **Planning LLM** *(optional)*         | `planning_llm`         | The language model used by the AgentPlanner in a planning process.                                                                                                                                    |",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Creating Crews",
            "level": 2,
            "content": "There are two ways to create crews in CrewAI: using **YAML configuration (recommended)** or defining them **directly in code**.",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": [
              {
                "type": "header",
                "title": "YAML Configuration (Recommended)",
                "level": 3,
                "content": "",
                "metadata": {
                  "section_type": "General",
                  "content_type": null
                },
                "children": [
                  {
                    "type": "header",
                    "title": "Example Crew Class with Decorators",
                    "level": 4,
                    "content": "```\nfrom crewai import Agent, Crew, Task, Process\nfrom crewai.project import CrewBase, agent, task, crew, before_kickoff, after_kickoff\n\n\n@CrewBase\nclass YourCrewName:\n    \"\"\"Description of your crew\"\"\"\n\n    # Paths to your YAML configuration files\n    # To see an example agent and task defined in YAML, checkout the following:\n    # - Task: https://docs.crewai.com/concepts/tasks#yaml-configuration-recommended\n    # - Agents: https://docs.crewai.com/concepts/agents#yaml-configuration-recommended\n    agents_config = 'config/agents.yaml' \n    tasks_config = 'config/tasks.yaml' \n\n    @before_kickoff\n    def prepare_inputs(self, inputs):\n        # Modify inputs before the crew starts\n        inputs['additional_data'] = \"Some extra information\"\n        return inputs\n\n    @after_kickoff\n    def process_output(self, output):\n        # Modify output after the crew finishes\n        output.raw += \"\\nProcessed after kickoff.\"\n        return output\n\n    @agent\n    def agent_one(self) -> Agent:\n        return Agent(\n            config=self.agents_config['agent_one'],\n            verbose=True\n        )\n\n    @agent\n    def agent_two(self) -> Agent:\n        return Agent(\n            config=self.agents_config['agent_two'],\n            verbose=True\n        )\n\n    @task\n    def task_one(self) -> Task:\n        return Task(\n            config=self.tasks_config['task_one']\n        )\n\n    @task\n    def task_two(self) -> Task:\n        return Task(\n            config=self.tasks_config['task_two']\n        )\n\n    @crew\n    def crew(self) -> Crew:\n        return Crew(\n            agents=self.agents,  # Automatically collected by the @agent decorator\n            tasks=self.tasks,    # Automatically collected by the @task decorator. \n            process=Process.sequential,\n            verbose=True,\n        )\n```\nThe `CrewBase` class, along with these decorators, automates the collection of agents and tasks, reducing the need for manual management.",
                    "metadata": {
                      "section_type": "Examples",
                      "content_type": "code_example"
                    },
                    "children": [],
                    "code_blocks": [
                      {
                        "type": "code_block",
                        "language": "python code",
                        "content": "from crewai import Agent, Crew, Task, Process\nfrom crewai.project import CrewBase, agent, task, crew, before_kickoff, after_kickoff\n\n\n@CrewBase\nclass YourCrewName:\n    \"\"\"Description of your crew\"\"\"\n\n    # Paths to your YAML configuration files\n    # To see an example agent and task defined in YAML, checkout the following:\n    # - Task: https://docs.crewai.com/concepts/tasks#yaml-configuration-recommended\n    # - Agents: https://docs.crewai.com/concepts/agents#yaml-configuration-recommended\n    agents_config = 'config/agents.yaml' \n    tasks_config = 'config/tasks.yaml' \n\n    @before_kickoff\n    def prepare_inputs(self, inputs):\n        # Modify inputs before the crew starts\n        inputs['additional_data'] = \"Some extra information\"\n        return inputs\n\n    @after_kickoff\n    def process_output(self, output):\n        # Modify output after the crew finishes\n        output.raw += \"\\nProcessed after kickoff.\"\n        return output\n\n    @agent\n    def agent_one(self) -> Agent:\n        return Agent(\n            config=self.agents_config['agent_one'],\n            verbose=True\n        )\n\n    @agent\n    def agent_two(self) -> Agent:\n        return Agent(\n            config=self.agents_config['agent_two'],\n            verbose=True\n        )\n\n    @task\n    def task_one(self) -> Task:\n        return Task(\n            config=self.tasks_config['task_one']\n        )\n\n    @task\n    def task_two(self) -> Task:\n        return Task(\n            config=self.tasks_config['task_two']\n        )\n\n    @crew\n    def crew(self) -> Crew:\n        return Crew(\n            agents=self.agents,  # Automatically collected by the @agent decorator\n            tasks=self.tasks,    # Automatically collected by the @task decorator. \n            process=Process.sequential,\n            verbose=True,\n        )",
                        "metadata": {
                          "section_type": "code",
                          "content_type": "code_example"
                        },
                        "children": []
                      }
                    ]
                  },
                  {
                    "type": "header",
                    "title": "Decorators overview from `annotations.py`",
                    "level": 4,
                    "content": "CrewAI provides several decorators in the `annotations.py` file that are used to mark methods within your crew class for special handling: `@CrewBase`: Marks the class as a crew base class. `@agent`: Denotes a method that returns an `Agent` object. `@task`: Denotes a method that returns a `Task` object. `@crew`: Denotes the method that returns the `Crew` object. `@before_kickoff`: (Optional) Marks a method to be executed before the crew starts. `@after_kickoff`: (Optional) Marks a method to be executed after the crew finishes. These decorators help in organizing your crew's structure and automatically collecting agents and tasks without manually listing them.",
                    "metadata": {
                      "section_type": "Concepts documentation",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Direct Code Definition (Alternative)",
                "level": 3,
                "content": "",
                "metadata": {
                  "section_type": "General",
                  "content_type": null
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Crew Output",
            "level": 2,
            "content": "The output of a crew in the CrewAI framework is encapsulated within the `CrewOutput` class.\nThis class provides a structured way to access results of the crew's execution, including various formats such as raw strings, JSON, and Pydantic models.\nThe `CrewOutput` includes the results from the final task output, token usage, and individual task outputs.",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": [
              {
                "type": "header",
                "title": "Crew Output Attributes",
                "level": 3,
                "content": "| Attribute        | Parameters     | Type                       | Description                                                                                          |\n| :--------------- | :------------- | :------------------------- | :--------------------------------------------------------------------------------------------------- |\n| **Raw**          | `raw`          | `str`                      | The raw output of the crew. This is the default format for the output.                               |\n| **Pydantic**     | `pydantic`     | `Optional[BaseModel]`      | A Pydantic model object representing the structured output of the crew.                              |\n| **JSON Dict**    | `json_dict`    | `Optional[Dict[str, Any]]` | A dictionary representing the JSON output of the crew.                                               |\n| **Tasks Output** | `tasks_output` | `List[TaskOutput]`         | A list of `TaskOutput` objects, each representing the output of a task in the crew.                  |\n| **Token Usage**  | `token_usage`  | `Dict[str, Any]`           | A summary of token usage, providing insights into the language model's performance during execution. |",
                "metadata": {
                  "section_type": "General",
                  "content_type": "descriptive_text"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Crew Output Methods and Properties",
                "level": 3,
                "content": "| Method/Property | Description                                                                                       |\n| :-------------- | :------------------------------------------------------------------------------------------------ |\n| **json**        | Returns the JSON string representation of the crew output if the output format is JSON.           |\n| **to\\_dict**    | Converts the JSON and Pydantic outputs to a dictionary.                                           |\n| \\***\\*str\\*\\*** | Returns the string representation of the crew output, prioritizing Pydantic, then JSON, then raw. |",
                "metadata": {
                  "section_type": "General",
                  "content_type": "descriptive_text"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Accessing Crew Outputs",
                "level": 3,
                "content": "Once a crew has been executed, its output can be accessed through the `output` attribute of the `Crew` object. The `CrewOutput` class provides various ways to interact with and present this output.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": [
                  {
                    "type": "header",
                    "title": "Example",
                    "level": 4,
                    "content": "",
                    "metadata": {
                      "section_type": "Examples",
                      "content_type": null
                    },
                    "children": []
                  }
                ]
              }
            ]
          },
          {
            "type": "header",
            "title": "Accessing Crew Logs",
            "level": 2,
            "content": "You can see real time log of the crew execution, by setting `output_log_file` as a `True(Boolean)` or a `file_name(str)`. Supports logging of events as both `file_name.txt` and `file_name.json`.\nIn case of `True(Boolean)` will save as `logs.txt`. In case of `output_log_file` is set as `False(Booelan)` or `None`, the logs will not be populated.\n```\n# Save crew logs\ncrew = Crew(output_log_file = True)  # Logs will be saved as logs.txt\ncrew = Crew(output_log_file = file_name)  # Logs will be saved as file_name.txt\ncrew = Crew(output_log_file = file_name.txt)  # Logs will be saved as file_name.txt\ncrew = Crew(output_log_file = file_name.json)  # Logs will be saved as file_name.json\n```",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "# Save crew logs\ncrew = Crew(output_log_file = True)  # Logs will be saved as logs.txt\ncrew = Crew(output_log_file = file_name)  # Logs will be saved as file_name.txt\ncrew = Crew(output_log_file = file_name.txt)  # Logs will be saved as file_name.txt\ncrew = Crew(output_log_file = file_name.json)  # Logs will be saved as file_name.json",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Memory Utilization",
            "level": 2,
            "content": "Crews can utilize memory (short-term, long-term, and entity memory) to enhance their execution and learning over time. This feature allows crews to store and recall execution memories, aiding in decision-making and task execution strategies.",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Cache Utilization",
            "level": 2,
            "content": "Caches can be employed to store the results of tools' execution, making the process more efficient by reducing the need to re-execute identical tasks.",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Crew Usage Metrics",
            "level": 2,
            "content": "After the crew execution, you can access the `usage_metrics` attribute to view the language model (LLM) usage metrics for all tasks executed by the crew. This provides insights into operational efficiency and areas for improvement.\n```\n# Access the crew's usage metrics\ncrew = Crew(agents=[agent1, agent2], tasks=[task1, task2])\ncrew.kickoff()\nprint(crew.usage_metrics)\n```",
            "metadata": {
              "section_type": "Examples",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "# Access the crew's usage metrics\ncrew = Crew(agents=[agent1, agent2], tasks=[task1, task2])\ncrew.kickoff()\nprint(crew.usage_metrics)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Crew Execution Process",
            "level": 2,
            "content": "**Sequential Process**: Tasks are executed one after another, allowing for a linear flow of work. **Hierarchical Process**: A manager agent coordinates the crew, delegating tasks and validating outcomes before proceeding. **Note**: A `manager_llm` or `manager_agent` is required for this process and it's essential for validating the process flow.",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": [
              {
                "type": "header",
                "title": "Kicking Off a Crew",
                "level": 3,
                "content": "Once your crew is assembled, initiate the workflow with the `kickoff()` method. This starts the execution process according to the defined process flow.\n```\n# Start the crew's task execution\nresult = my_crew.kickoff()\nprint(result)\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "# Start the crew's task execution\nresult = my_crew.kickoff()\nprint(result)",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Different Ways to Kick Off a Crew",
                "level": 3,
                "content": "Once your crew is assembled, initiate the workflow with the appropriate kickoff method. CrewAI provides several methods for better control over the kickoff process: `kickoff()`, `kickoff_for_each()`, `kickoff_async()`, and `kickoff_for_each_async()`. `kickoff()`: Starts the execution process according to the defined process flow. `kickoff_for_each()`: Executes tasks sequentially for each provided input event or item in the collection. `kickoff_async()`: Initiates the workflow asynchronously. `kickoff_for_each_async()`: Executes tasks concurrently for each provided input event or item, leveraging asynchronous processing.\n```\n# Start the crew's task execution\nresult = my_crew.kickoff()\nprint(result)\n\n# Example of using kickoff_for_each\ninputs_array = [{'topic': 'AI in healthcare'}, {'topic': 'AI in finance'}]\nresults = my_crew.kickoff_for_each(inputs=inputs_array)\nfor result in results:\n    print(result)\n\n# Example of using kickoff_async\ninputs = {'topic': 'AI in healthcare'}\nasync_result = my_crew.kickoff_async(inputs=inputs)\nprint(async_result)\n\n# Example of using kickoff_for_each_async\ninputs_array = [{'topic': 'AI in healthcare'}, {'topic': 'AI in finance'}]\nasync_results = my_crew.kickoff_for_each_async(inputs=inputs_array)\nfor async_result in async_results:\n    print(async_result)\n```\nThese methods provide flexibility in how you manage and execute tasks within your crew, allowing for both synchronous and asynchronous workflows tailored to your needs.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "# Start the crew's task execution\nresult = my_crew.kickoff()\nprint(result)\n\n# Example of using kickoff_for_each\ninputs_array = [{'topic': 'AI in healthcare'}, {'topic': 'AI in finance'}]\nresults = my_crew.kickoff_for_each(inputs=inputs_array)\nfor result in results:\n    print(result)\n\n# Example of using kickoff_async\ninputs = {'topic': 'AI in healthcare'}\nasync_result = my_crew.kickoff_async(inputs=inputs)\nprint(async_result)\n\n# Example of using kickoff_for_each_async\ninputs_array = [{'topic': 'AI in healthcare'}, {'topic': 'AI in finance'}]\nasync_results = my_crew.kickoff_for_each_async(inputs=inputs_array)\nfor async_result in async_results:\n    print(async_result)",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Replaying from a Specific Task",
                "level": 3,
                "content": "You can now replay from a specific task using our CLI command `replay`. The replay feature in CrewAI allows you to replay from a specific task using the command-line interface (CLI). By running the command `crewai replay -t <task_id>`, you can specify the `task_id` for the replay process. Kickoffs will now save the latest kickoffs returned task outputs locally for you to be able to replay from.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "descriptive_text"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Replaying from a Specific Task Using the CLI",
                "level": 3,
                "content": "To use the replay feature, follow these steps: Open your terminal or command prompt. Navigate to the directory where your CrewAI project is located. Run the following command: To view the latest kickoff task IDs, use:\n```\ncrewai log-tasks-outputs\n```\nThen, to replay from a specific task, use:\n```\ncrewai replay -t <task_id>\n```\nThese commands let you replay from your latest kickoff tasks, still retaining context from previously executed tasks.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "shell",
                    "content": "crewai log-tasks-outputs",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  },
                  {
                    "type": "code_block",
                    "language": "shell",
                    "content": "crewai replay -t <task_id>",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type": "header",
        "title": "Event Listeners",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": []
      },
      {
        "type": "header",
        "title": "Event Listeners",
        "level": 1,
        "content": "Source: https://docs.crewai.com/concepts/event-listener Tap into CrewAI events to build custom integrations and monitoring\n\nCrewAI provides a powerful event system that allows you to listen for and react to various events that occur during the execution of your Crew. This feature enables you to build custom integrations, monitoring solutions, logging systems, or any other functionality that needs to be triggered based on CrewAI's internal events.",
        "metadata": {
          "section_type": "General",
          "content_type": "descriptive_text"
        },
        "children": [
          {
            "type": "header",
            "title": "How It Works",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Creating a Custom Event Listener",
            "level": 2,
            "content": "To create a custom event listener, you need to: Create a class that inherits from `BaseEventListener` Implement the `setup_listeners` method Register handlers for the events you're interested in Create an instance of your listener in the appropriate file Here's a simple example of a custom event listener class:\n```\nfrom crewai.utilities.events import (\n    CrewKickoffStartedEvent,\n    CrewKickoffCompletedEvent,\n    AgentExecutionCompletedEvent,\n)\nfrom crewai.utilities.events.base_event_listener import BaseEventListener\n\nclass MyCustomListener(BaseEventListener):\n    def __init__(self):\n        super().__init__()\n    \n    def setup_listeners(self, crewai_event_bus):\n        @crewai_event_bus.on(CrewKickoffStartedEvent)\n        def on_crew_started(source, event):\n            print(f\"Crew '{event.crew_name}' has started execution!\")\n        \n        @crewai_event_bus.on(CrewKickoffCompletedEvent)\n        def on_crew_completed(source, event):\n            print(f\"Crew '{event.crew_name}' has completed execution!\")\n            print(f\"Output: {event.output}\")\n        \n        @crewai_event_bus.on(AgentExecutionCompletedEvent)\n        def on_agent_execution_completed(source, event):\n            print(f\"Agent '{event.agent.role}' completed task\")\n            print(f\"Output: {event.output}\")\n```",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python",
                "content": "from crewai.utilities.events import (\n    CrewKickoffStartedEvent,\n    CrewKickoffCompletedEvent,\n    AgentExecutionCompletedEvent,\n)\nfrom crewai.utilities.events.base_event_listener import BaseEventListener\n\nclass MyCustomListener(BaseEventListener):\n    def __init__(self):\n        super().__init__()\n    \n    def setup_listeners(self, crewai_event_bus):\n        @crewai_event_bus.on(CrewKickoffStartedEvent)\n        def on_crew_started(source, event):\n            print(f\"Crew '{event.crew_name}' has started execution!\")\n        \n        @crewai_event_bus.on(CrewKickoffCompletedEvent)\n        def on_crew_completed(source, event):\n            print(f\"Crew '{event.crew_name}' has completed execution!\")\n            print(f\"Output: {event.output}\")\n        \n        @crewai_event_bus.on(AgentExecutionCompletedEvent)\n        def on_agent_execution_completed(source, event):\n            print(f\"Agent '{event.agent.role}' completed task\")\n            print(f\"Output: {event.output}\")",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Properly Registering Your Listener",
            "level": 2,
            "content": "Simply defining your listener class isn't enough. You need to create an instance of it and ensure it's imported in your application. This ensures that: The event handlers are registered with the event bus The listener instance remains in memory (not garbage collected) The listener is active when events are emitted",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": [
              {
                "type": "header",
                "title": "Option 1: Import and Instantiate in Your Crew or Flow Implementation",
                "level": 3,
                "content": "The most important thing is to create an instance of your listener in the file where your Crew or Flow is defined and executed:",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": [
                  {
                    "type": "header",
                    "title": "For Crew-based Applications",
                    "level": 4,
                    "content": "Create and import your listener at the top of your Crew implementation file:\n```\n# In your crew.py file\nfrom crewai import Agent, Crew, Task\nfrom my_listeners import MyCustomListener\n\n# Create an instance of your listener\nmy_listener = MyCustomListener()\n\nclass MyCustomCrew:\n    # Your crew implementation...\n    \n    def crew(self):\n        return Crew(\n            agents=[...],\n            tasks=[...],\n            # ...\n        )\n```",
                    "metadata": {
                      "section_type": "General",
                      "content_type": "code_example"
                    },
                    "children": [],
                    "code_blocks": [
                      {
                        "type": "code_block",
                        "language": "python",
                        "content": "# In your crew.py file\nfrom crewai import Agent, Crew, Task\nfrom my_listeners import MyCustomListener\n\n# Create an instance of your listener\nmy_listener = MyCustomListener()\n\nclass MyCustomCrew:\n    # Your crew implementation...\n    \n    def crew(self):\n        return Crew(\n            agents=[...],\n            tasks=[...],\n            # ...\n        )",
                        "metadata": {
                          "section_type": "code",
                          "content_type": "code_example"
                        },
                        "children": []
                      }
                    ]
                  },
                  {
                    "type": "header",
                    "title": "For Flow-based Applications",
                    "level": 4,
                    "content": "Create and import your listener at the top of your Flow implementation file:\n```\n# In your main.py or flow.py file\nfrom crewai.flow import Flow, listen, start\nfrom my_listeners import MyCustomListener\n\n# Create an instance of your listener\nmy_listener = MyCustomListener()\n\nclass MyCustomFlow(Flow):\n    # Your flow implementation...\n    \n    @start()\n    def first_step(self):\n        # ...\n```\nThis ensures that your listener is loaded and active when your Crew or Flow is executed.",
                    "metadata": {
                      "section_type": "General",
                      "content_type": "code_example"
                    },
                    "children": [],
                    "code_blocks": [
                      {
                        "type": "code_block",
                        "language": "python",
                        "content": "# In your main.py or flow.py file\nfrom crewai.flow import Flow, listen, start\nfrom my_listeners import MyCustomListener\n\n# Create an instance of your listener\nmy_listener = MyCustomListener()\n\nclass MyCustomFlow(Flow):\n    # Your flow implementation...\n    \n    @start()\n    def first_step(self):\n        # ...",
                        "metadata": {
                          "section_type": "code",
                          "content_type": "code_example"
                        },
                        "children": []
                      }
                    ]
                  }
                ]
              },
              {
                "type": "header",
                "title": "Option 2: Create a Package for Your Listeners",
                "level": 3,
                "content": "For a more structured approach, especially if you have multiple listeners: Create a package for your listeners:\n```\nmy_project/\n  \u251c\u2500\u2500 listeners/\n  \u2502   \u251c\u2500\u2500 __init__.py\n  \u2502   \u251c\u2500\u2500 my_custom_listener.py\n  \u2502   \u2514\u2500\u2500 another_listener.py\n```\nIn `my_custom_listener.py`, define your listener class and create an instance:\n```\n# my_custom_listener.py\nfrom crewai.utilities.events.base_event_listener import BaseEventListener\n# ... import events ...\n\nclass MyCustomListener(BaseEventListener):\n    # ... implementation ...\n\n# Create an instance of your listener\nmy_custom_listener = MyCustomListener()\n```\nIn `__init__.py`, import the listener instances to ensure they're loaded:\n```\n# __init__.py\nfrom .my_custom_listener import my_custom_listener\nfrom .another_listener import another_listener\n\n# Optionally export them if you need to access them elsewhere\n__all__ = ['my_custom_listener', 'another_listener']\n```\nImport your listeners package in your Crew or Flow file:\n```\n# In your crew.py or flow.py file\nimport my_project.listeners  # This loads all your listeners\n\nclass MyCustomCrew:\n    # Your crew implementation...\n```\nThis is exactly how CrewAI's built-in `agentops_listener` is registered. In the CrewAI codebase, you'll find:\n```\n# src/crewai/utilities/events/third_party/__init__.py\nfrom .agentops_listener import agentops_listener\n```\nThis ensures the `agentops_listener` is loaded when the `crewai.utilities.events` package is imported.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": null,
                    "content": "my_project/\n  \u251c\u2500\u2500 listeners/\n  \u2502   \u251c\u2500\u2500 __init__.py\n  \u2502   \u251c\u2500\u2500 my_custom_listener.py\n  \u2502   \u2514\u2500\u2500 another_listener.py",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  },
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "# my_custom_listener.py\nfrom crewai.utilities.events.base_event_listener import BaseEventListener\n# ... import events ...\n\nclass MyCustomListener(BaseEventListener):\n    # ... implementation ...\n\n# Create an instance of your listener\nmy_custom_listener = MyCustomListener()",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  },
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "# __init__.py\nfrom .my_custom_listener import my_custom_listener\nfrom .another_listener import another_listener\n\n# Optionally export them if you need to access them elsewhere\n__all__ = ['my_custom_listener', 'another_listener']",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  },
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "# In your crew.py or flow.py file\nimport my_project.listeners  # This loads all your listeners\n\nclass MyCustomCrew:\n    # Your crew implementation...",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  },
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "# src/crewai/utilities/events/third_party/__init__.py\nfrom .agentops_listener import agentops_listener",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              }
            ]
          },
          {
            "type": "header",
            "title": "Available Event Types",
            "level": 2,
            "content": "CrewAI provides a wide range of events that you can listen for:",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": [
              {
                "type": "header",
                "title": "Crew Events",
                "level": 3,
                "content": "**CrewKickoffStartedEvent**: Emitted when a Crew starts execution **CrewKickoffCompletedEvent**: Emitted when a Crew completes execution **CrewKickoffFailedEvent**: Emitted when a Crew fails to complete execution **CrewTestStartedEvent**: Emitted when a Crew starts testing **CrewTestCompletedEvent**: Emitted when a Crew completes testing **CrewTestFailedEvent**: Emitted when a Crew fails to complete testing **CrewTrainStartedEvent**: Emitted when a Crew starts training **CrewTrainCompletedEvent**: Emitted when a Crew completes training **CrewTrainFailedEvent**: Emitted when a Crew fails to complete training",
                "metadata": {
                  "section_type": "General",
                  "content_type": "descriptive_text"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Agent Events",
                "level": 3,
                "content": "**AgentExecutionStartedEvent**: Emitted when an Agent starts executing a task **AgentExecutionCompletedEvent**: Emitted when an Agent completes executing a task **AgentExecutionErrorEvent**: Emitted when an Agent encounters an error during execution",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Task Events",
                "level": 3,
                "content": "**TaskStartedEvent**: Emitted when a Task starts execution **TaskCompletedEvent**: Emitted when a Task completes execution **TaskFailedEvent**: Emitted when a Task fails to complete execution **TaskEvaluationEvent**: Emitted when a Task is evaluated",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Tool Usage Events",
                "level": 3,
                "content": "**ToolUsageStartedEvent**: Emitted when a tool execution is started **ToolUsageFinishedEvent**: Emitted when a tool execution is completed **ToolUsageErrorEvent**: Emitted when a tool execution encounters an error **ToolValidateInputErrorEvent**: Emitted when a tool input validation encounters an error **ToolExecutionErrorEvent**: Emitted when a tool execution encounters an error **ToolSelectionErrorEvent**: Emitted when there's an error selecting a tool",
                "metadata": {
                  "section_type": "Examples",
                  "content_type": "descriptive_text"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Flow Events",
                "level": 3,
                "content": "**FlowCreatedEvent**: Emitted when a Flow is created **FlowStartedEvent**: Emitted when a Flow starts execution **FlowFinishedEvent**: Emitted when a Flow completes execution **FlowPlotEvent**: Emitted when a Flow is plotted **MethodExecutionStartedEvent**: Emitted when a Flow method starts execution **MethodExecutionFinishedEvent**: Emitted when a Flow method completes execution **MethodExecutionFailedEvent**: Emitted when a Flow method fails to complete execution",
                "metadata": {
                  "section_type": "General",
                  "content_type": "descriptive_text"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "LLM Events",
                "level": 3,
                "content": "**LLMCallStartedEvent**: Emitted when an LLM call starts **LLMCallCompletedEvent**: Emitted when an LLM call completes **LLMCallFailedEvent**: Emitted when an LLM call fails **LLMStreamChunkEvent**: Emitted for each chunk received during streaming LLM responses",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Event Handler Structure",
            "level": 2,
            "content": "Each event handler receives two parameters: **source**: The object that emitted the event **event**: The event instance, containing event-specific data The structure of the event object depends on the event type, but all events inherit from `CrewEvent` and include: **timestamp**: The time when the event was emitted **type**: A string identifier for the event type Additional fields vary by event type. For example, `CrewKickoffCompletedEvent` includes `crew_name` and `output` fields.",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Real-World Example: Integration with AgentOps",
            "level": 2,
            "content": "CrewAI includes an example of a third-party integration with [AgentOps](https://github.com/AgentOps-AI/agentops), a monitoring and observability platform for AI agents. Here's how it's implemented:\n```\nfrom typing import Optional\n\nfrom crewai.utilities.events import (\n    CrewKickoffCompletedEvent,\n    ToolUsageErrorEvent,\n    ToolUsageStartedEvent,\n)\nfrom crewai.utilities.events.base_event_listener import BaseEventListener\nfrom crewai.utilities.events.crew_events import CrewKickoffStartedEvent\nfrom crewai.utilities.events.task_events import TaskEvaluationEvent\n\ntry:\n    import agentops\n    AGENTOPS_INSTALLED = True\nexcept ImportError:\n    AGENTOPS_INSTALLED = False\n\nclass AgentOpsListener(BaseEventListener):\n    tool_event: Optional[\"agentops.ToolEvent\"] = None\n    session: Optional[\"agentops.Session\"] = None\n\n    def __init__(self):\n        super().__init__()\n\n    def setup_listeners(self, crewai_event_bus):\n        if not AGENTOPS_INSTALLED:\n            return\n\n        @crewai_event_bus.on(CrewKickoffStartedEvent)\n        def on_crew_kickoff_started(source, event: CrewKickoffStartedEvent):\n            self.session = agentops.init()\n            for agent in source.agents:\n                if self.session:\n                    self.session.create_agent(\n                        name=agent.role,\n                        agent_id=str(agent.id),\n                    )\n\n        @crewai_event_bus.on(CrewKickoffCompletedEvent)\n        def on_crew_kickoff_completed(source, event: CrewKickoffCompletedEvent):\n            if self.session:\n                self.session.end_session(\n                    end_state=\"Success\",\n                    end_state_reason=\"Finished Execution\",\n                )\n\n        @crewai_event_bus.on(ToolUsageStartedEvent)\n        def on_tool_usage_started(source, event: ToolUsageStartedEvent):\n            self.tool_event = agentops.ToolEvent(name=event.tool_name)\n            if self.session:\n                self.session.record(self.tool_event)\n\n        @crewai_event_bus.on(ToolUsageErrorEvent)\n        def on_tool_usage_error(source, event: ToolUsageErrorEvent):\n            agentops.ErrorEvent(exception=event.error, trigger_event=self.tool_event)\n```\nThis listener initializes an AgentOps session when a Crew starts, registers agents with AgentOps, tracks tool usage, and ends the session when the Crew completes. The AgentOps listener is registered in CrewAI's event system through the import in `src/crewai/utilities/events/third_party/__init__.py`:\n```\nfrom .agentops_listener import agentops_listener\n```\nThis ensures the `agentops_listener` is loaded when the `crewai.utilities.events` package is imported.",
            "metadata": {
              "section_type": "Examples",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python",
                "content": "from typing import Optional\n\nfrom crewai.utilities.events import (\n    CrewKickoffCompletedEvent,\n    ToolUsageErrorEvent,\n    ToolUsageStartedEvent,\n)\nfrom crewai.utilities.events.base_event_listener import BaseEventListener\nfrom crewai.utilities.events.crew_events import CrewKickoffStartedEvent\nfrom crewai.utilities.events.task_events import TaskEvaluationEvent\n\ntry:\n    import agentops\n    AGENTOPS_INSTALLED = True\nexcept ImportError:\n    AGENTOPS_INSTALLED = False\n\nclass AgentOpsListener(BaseEventListener):\n    tool_event: Optional[\"agentops.ToolEvent\"] = None\n    session: Optional[\"agentops.Session\"] = None\n\n    def __init__(self):\n        super().__init__()\n\n    def setup_listeners(self, crewai_event_bus):\n        if not AGENTOPS_INSTALLED:\n            return\n\n        @crewai_event_bus.on(CrewKickoffStartedEvent)\n        def on_crew_kickoff_started(source, event: CrewKickoffStartedEvent):\n            self.session = agentops.init()\n            for agent in source.agents:\n                if self.session:\n                    self.session.create_agent(\n                        name=agent.role,\n                        agent_id=str(agent.id),\n                    )\n\n        @crewai_event_bus.on(CrewKickoffCompletedEvent)\n        def on_crew_kickoff_completed(source, event: CrewKickoffCompletedEvent):\n            if self.session:\n                self.session.end_session(\n                    end_state=\"Success\",\n                    end_state_reason=\"Finished Execution\",\n                )\n\n        @crewai_event_bus.on(ToolUsageStartedEvent)\n        def on_tool_usage_started(source, event: ToolUsageStartedEvent):\n            self.tool_event = agentops.ToolEvent(name=event.tool_name)\n            if self.session:\n                self.session.record(self.tool_event)\n\n        @crewai_event_bus.on(ToolUsageErrorEvent)\n        def on_tool_usage_error(source, event: ToolUsageErrorEvent):\n            agentops.ErrorEvent(exception=event.error, trigger_event=self.tool_event)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python",
                "content": "from .agentops_listener import agentops_listener",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Advanced Usage: Scoped Handlers",
            "level": 2,
            "content": "For temporary event handling (useful for testing or specific operations), you can use the `scoped_handlers` context manager:\n```\nfrom crewai.utilities.events import crewai_event_bus, CrewKickoffStartedEvent\n\nwith crewai_event_bus.scoped_handlers():\n    @crewai_event_bus.on(CrewKickoffStartedEvent)\n    def temp_handler(source, event):\n        print(\"This handler only exists within this context\")\n    \n    # Do something that emits events\n    \n# Outside the context, the temporary handler is removed\n```",
            "metadata": {
              "section_type": "Examples",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python",
                "content": "from crewai.utilities.events import crewai_event_bus, CrewKickoffStartedEvent\n\nwith crewai_event_bus.scoped_handlers():\n    @crewai_event_bus.on(CrewKickoffStartedEvent)\n    def temp_handler(source, event):\n        print(\"This handler only exists within this context\")\n    \n    # Do something that emits events\n    \n# Outside the context, the temporary handler is removed",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Use Cases",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Best Practices",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Flows",
        "level": 1,
        "content": "Source: https://docs.crewai.com/concepts/flows Learn how to create and manage AI workflows using CrewAI Flows.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": [
          {
            "type": "header",
            "title": "Introduction",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Getting Started",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": [
              {
                "type": "header",
                "title": "@start()",
                "level": 3,
                "content": "The `@start()` decorator is used to mark a method as the starting point of a Flow. When a Flow is started, all the methods decorated with `@start()` are executed in parallel. You can have multiple start methods in a Flow, and they will all be executed when the Flow is started.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "descriptive_text"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "@listen()",
                "level": 3,
                "content": "The `@listen()` decorator is used to mark a method as a listener for the output of another task in the Flow. The method decorated with `@listen()` will be executed when the specified task emits an output. The method can access the output of the task it is listening to as an argument.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "descriptive_text"
                },
                "children": [
                  {
                    "type": "header",
                    "title": "Usage",
                    "level": 4,
                    "content": "",
                    "metadata": {
                      "section_type": "Examples",
                      "content_type": null
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Flow Output",
                "level": 3,
                "content": "Accessing and handling the output of a Flow is essential for integrating your AI workflows into larger applications or systems. CrewAI Flows provide straightforward mechanisms to retrieve the final output, access intermediate results, and manage the overall state of your Flow.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": [
                  {
                    "type": "header",
                    "title": "Retrieving the Final Output",
                    "level": 4,
                    "content": "When you run a Flow, the final output is determined by the last method that completes. The `kickoff()` method returns the output of this final method. Here's how you can access the final output: class OutputExampleFlow(Flow):\n      @start()\n      def first_method(self):\n          return \"Output from first_method\" flow = OutputExampleFlow()\n  final_output = flow.kickoff() print(\"---- Final Output ----\")\n  print(final_output)\n```\n\n```text Output\n---- Final Output ----\nSecond method received: Output from first_method\n```\nIn this example, the `second_method` is the last method to complete, so its output will be the final output of the Flow.\nThe `kickoff()` method will return the final output, which is then printed to the console.",
                    "metadata": {
                      "section_type": "General",
                      "content_type": "code_example"
                    },
                    "children": [],
                    "code_blocks": [
                      {
                        "type": "code_block",
                        "language": null,
                        "content": "```text Output\n---- Final Output ----\nSecond method received: Output from first_method",
                        "metadata": {
                          "section_type": "code",
                          "content_type": "code_example"
                        },
                        "children": []
                      }
                    ]
                  },
                  {
                    "type": "header",
                    "title": "Accessing and Updating State",
                    "level": 4,
                    "content": "In addition to retrieving the final output, you can also access and update the state within your Flow. The state can be used to store and share data between different methods in the Flow. After the Flow has run, you can access the state to retrieve any information that was added or updated during the execution. Here's an example of how to update and access the state: class ExampleState(BaseModel):\n      counter: int = 0\n      message: str = \"\" class StateExampleFlow(Flow[ExampleState]): flow = StateExampleFlow()\n  final_output = flow.kickoff()\n  print(f\"Final Output: {final_output}\")\n  print(\"Final State:\")\n  print(flow.state)\n```\n\n```text Output\nFinal Output: Hello from first_method - updated by second_method\nFinal State:\ncounter=2 message='Hello from first_method - updated by second_method'\n```\nIn this example, the state is updated by both `first_method` and `second_method`.\nAfter the Flow has run, you can access the final state to see the updates made by these methods. By ensuring that the final method's output is returned and providing access to the state, CrewAI Flows make it easy to integrate the results of your AI workflows into larger applications or systems,\nwhile also maintaining and accessing the state throughout the Flow's execution.",
                    "metadata": {
                      "section_type": "General",
                      "content_type": "code_example"
                    },
                    "children": [],
                    "code_blocks": [
                      {
                        "type": "code_block",
                        "language": null,
                        "content": "```text Output\nFinal Output: Hello from first_method - updated by second_method\nFinal State:\ncounter=2 message='Hello from first_method - updated by second_method'",
                        "metadata": {
                          "section_type": "code",
                          "content_type": "code_example"
                        },
                        "children": []
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "header",
            "title": "Flow State Management",
            "level": 2,
            "content": "Managing state effectively is crucial for building reliable and maintainable AI workflows. CrewAI Flows provides robust mechanisms for both unstructured and structured state management,\nallowing developers to choose the approach that best fits their application's needs.",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": [
              {
                "type": "header",
                "title": "Unstructured State Management",
                "level": 3,
                "content": "",
                "metadata": {
                  "section_type": "General",
                  "content_type": null
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Structured State Management",
                "level": 3,
                "content": "",
                "metadata": {
                  "section_type": "General",
                  "content_type": null
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Choosing Between Unstructured and Structured State Management",
                "level": 3,
                "content": "**Use Unstructured State Management when:** The workflow's state is simple or highly dynamic. Flexibility is prioritized over strict state definitions. Rapid prototyping is required without the overhead of defining schemas. **Use Structured State Management when:** The workflow requires a well-defined and consistent state structure. Type safety and validation are important for your application's reliability. You want to leverage IDE features like auto-completion and type checking for better developer experience. By providing both unstructured and structured state management options, CrewAI Flows empowers developers to build AI workflows that are both flexible and robust, catering to a wide range of application requirements.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "descriptive_text"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Flow Persistence",
            "level": 2,
            "content": "The @persist decorator enables automatic state persistence in CrewAI Flows, allowing you to maintain flow state across restarts or different workflow executions. This decorator can be applied at either the class level or method level, providing flexibility in how you manage state persistence.",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": [
              {
                "type": "header",
                "title": "Class-Level Persistence",
                "level": 3,
                "content": "",
                "metadata": {
                  "section_type": "General",
                  "content_type": null
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Method-Level Persistence",
                "level": 3,
                "content": "",
                "metadata": {
                  "section_type": "General",
                  "content_type": null
                },
                "children": []
              },
              {
                "type": "header",
                "title": "How It Works",
                "level": 3,
                "content": "",
                "metadata": {
                  "section_type": "General",
                  "content_type": null
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Important Considerations",
                "level": 3,
                "content": "",
                "metadata": {
                  "section_type": "General",
                  "content_type": null
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Technical Advantages",
                "level": 3,
                "content": "**Precise Control Through Low-Level Access** Direct access to persistence operations for advanced use cases Fine-grained control via method-level persistence decorators Built-in state inspection and debugging capabilities Full visibility into state changes and persistence operations **Enhanced Reliability** Automatic state recovery after system failures or restarts Transaction-based state updates for data integrity Comprehensive error handling with clear error messages Robust validation during state save and load operations **Extensible Architecture** Customizable persistence backend through FlowPersistence interface Support for specialized storage solutions beyond SQLite Compatible with both structured (Pydantic) and unstructured (dict) states Seamless integration with existing CrewAI flow patterns The persistence system's architecture emphasizes technical precision and customization options, allowing developers to maintain full control over state management while benefiting from built-in reliability features.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "descriptive_text"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Flow Control",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": [
              {
                "type": "header",
                "title": "Conditional Logic: `or`",
                "level": 3,
                "content": "The `or_` function in Flows allows you to listen to multiple methods and trigger the listener method when any of the specified methods emit an output. class OrExampleFlow(Flow): flow = OrExampleFlow()\n  flow.kickoff()\n```\n\n```text Output\nLogger: Hello from the start method\nLogger: Hello from the second method\n```\nWhen you run this Flow, the `logger` method will be triggered by the output of either the `start_method` or the `second_method`.\nThe `or_` function is used to listen to multiple methods and trigger the listener method when any of the specified methods emit an output.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": null,
                    "content": "```text Output\nLogger: Hello from the start method\nLogger: Hello from the second method",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Conditional Logic: `and`",
                "level": 3,
                "content": "The `and_` function in Flows allows you to listen to multiple methods and trigger the listener method only when all the specified methods emit an output. class AndExampleFlow(Flow): flow = AndExampleFlow()\n  flow.kickoff()\n```\n\n```text Output\n---- Logger ----\n{'greeting': 'Hello from the start method', 'joke': 'What do computers eat? Microchips.'}\n```\nWhen you run this Flow, the `logger` method will be triggered only when both the `start_method` and the `second_method` emit an output.\nThe `and_` function is used to listen to multiple methods and trigger the listener method only when all the specified methods emit an output.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": null,
                    "content": "```text Output\n---- Logger ----\n{'greeting': 'Hello from the start method', 'joke': 'What do computers eat? Microchips.'}",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Router",
                "level": 3,
                "content": "The `@router()` decorator in Flows allows you to define conditional routing logic based on the output of a method.\nYou can specify different routes based on the output of the method, allowing you to control the flow of execution dynamically. class ExampleState(BaseModel):\n      success_flag: bool = False class RouterFlow(Flow[ExampleState]): flow = RouterFlow()\n  flow.kickoff()\n```\n\n```text Output\nStarting the structured flow\nThird method running\nFourth method running\n```\nIn the above example, the `start_method` generates a random boolean value and sets it in the state.\nThe `second_method` uses the `@router()` decorator to define conditional routing logic based on the value of the boolean.\nIf the boolean is `True`, the method returns `\"success\"`, and if it is `False`, the method returns `\"failed\"`.\nThe `third_method` and `fourth_method` listen to the output of the `second_method` and execute based on the returned value. When you run this Flow, the output will change based on the random boolean value generated by the `start_method`.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": null,
                    "content": "```text Output\nStarting the structured flow\nThird method running\nFourth method running",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              }
            ]
          },
          {
            "type": "header",
            "title": "Adding Crews to Flows",
            "level": 2,
            "content": "Creating a flow with multiple crews in CrewAI is straightforward. You can generate a new CrewAI project that includes all the scaffolding needed to create a flow with multiple crews by running the following command:\n```\ncrewai create flow name_of_flow\n```\nThis command will generate a new CrewAI project with the necessary folder structure. The generated project includes a prebuilt crew called `poem_crew` that is already working. You can use this crew as a template by copying, pasting, and editing it to create other crews.",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [
              {
                "type": "header",
                "title": "Folder Structure",
                "level": 3,
                "content": "After running the `crewai create flow name_of_flow` command, you will see a folder structure similar to the following: | Directory/File         | Description                                                         |\n| :--------------------- | :------------------------------------------------------------------ |\n| `name_of_flow/`        | Root directory for the flow.                                        |\n| \u251c\u2500\u2500 `crews/`           | Contains directories for specific crews.                            |\n| \u2502 \u2514\u2500\u2500 `poem_crew/`     | Directory for the \"poem\\_crew\" with its configurations and scripts. |\n| \u2502 \u251c\u2500\u2500 `config/`        | Configuration files directory for the \"poem\\_crew\".                 |\n| \u2502 \u2502 \u251c\u2500\u2500 `agents.yaml`  | YAML file defining the agents for \"poem\\_crew\".                     |\n| \u2502 \u2502 \u2514\u2500\u2500 `tasks.yaml`   | YAML file defining the tasks for \"poem\\_crew\".                      |\n| \u2502 \u251c\u2500\u2500 `poem_crew.py`   | Script for \"poem\\_crew\" functionality.                              |\n| \u251c\u2500\u2500 `tools/`           | Directory for additional tools used in the flow.                    |\n| \u2502 \u2514\u2500\u2500 `custom_tool.py` | Custom tool implementation.                                         |\n| \u251c\u2500\u2500 `main.py`          | Main script for running the flow.                                   |\n| \u251c\u2500\u2500 `README.md`        | Project description and instructions.                               |\n| \u251c\u2500\u2500 `pyproject.toml`   | Configuration file for project dependencies and settings.           |\n| \u2514\u2500\u2500 `.gitignore`       | Specifies files and directories to ignore in version control.       |",
                "metadata": {
                  "section_type": "General",
                  "content_type": "descriptive_text"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Building Your Crews",
                "level": 3,
                "content": "In the `crews` folder, you can define multiple crews. Each crew will have its own folder containing configuration files and the crew definition file. For example, the `poem_crew` folder contains: `config/agents.yaml`: Defines the agents for the crew. `config/tasks.yaml`: Defines the tasks for the crew. `poem_crew.py`: Contains the crew definition, including agents, tasks, and the crew itself. You can copy, paste, and edit the `poem_crew` to create other crews.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "descriptive_text"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Connecting Crews in `main.py`",
                "level": 3,
                "content": "The `main.py` file is where you create your flow and connect the crews together. You can define your flow by using the `Flow` class and the decorators `@start` and `@listen` to specify the flow of execution. Here's an example of how you can connect the `poem_crew` in the `main.py` file:\n```\n#!/usr/bin/env python\nfrom random import randint\n\nfrom pydantic import BaseModel\nfrom crewai.flow.flow import Flow, listen, start\nfrom .crews.poem_crew.poem_crew import PoemCrew\n\nclass PoemState(BaseModel):\n    sentence_count: int = 1\n    poem: str = \"\"\n\nclass PoemFlow(Flow[PoemState]):\n\n    @start()\n    def generate_sentence_count(self):\n        print(\"Generating sentence count\")\n        self.state.sentence_count = randint(1, 5)\n\n    @listen(generate_sentence_count)\n    def generate_poem(self):\n        print(\"Generating poem\")\n        result = PoemCrew().crew().kickoff(inputs={\"sentence_count\": self.state.sentence_count})\n\n        print(\"Poem generated\", result.raw)\n        self.state.poem = result.raw\n\n    @listen(generate_poem)\n    def save_poem(self):\n        print(\"Saving poem\")\n        with open(\"poem.txt\", \"w\") as f:\n            f.write(self.state.poem)\n\ndef kickoff():\n    poem_flow = PoemFlow()\n    poem_flow.kickoff()\n\n\ndef plot():\n    poem_flow = PoemFlow()\n    poem_flow.plot()\n\nif __name__ == \"__main__\":\n    kickoff()\n```\nIn this example, the `PoemFlow` class defines a flow that generates a sentence count, uses the `PoemCrew` to generate a poem, and then saves the poem to a file. The flow is kicked off by calling the `kickoff()` method.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "#!/usr/bin/env python\nfrom random import randint\n\nfrom pydantic import BaseModel\nfrom crewai.flow.flow import Flow, listen, start\nfrom .crews.poem_crew.poem_crew import PoemCrew\n\nclass PoemState(BaseModel):\n    sentence_count: int = 1\n    poem: str = \"\"\n\nclass PoemFlow(Flow[PoemState]):\n\n    @start()\n    def generate_sentence_count(self):\n        print(\"Generating sentence count\")\n        self.state.sentence_count = randint(1, 5)\n\n    @listen(generate_sentence_count)\n    def generate_poem(self):\n        print(\"Generating poem\")\n        result = PoemCrew().crew().kickoff(inputs={\"sentence_count\": self.state.sentence_count})\n\n        print(\"Poem generated\", result.raw)\n        self.state.poem = result.raw\n\n    @listen(generate_poem)\n    def save_poem(self):\n        print(\"Saving poem\")\n        with open(\"poem.txt\", \"w\") as f:\n            f.write(self.state.poem)\n\ndef kickoff():\n    poem_flow = PoemFlow()\n    poem_flow.kickoff()\n\n\ndef plot():\n    poem_flow = PoemFlow()\n    poem_flow.plot()\n\nif __name__ == \"__main__\":\n    kickoff()",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Running the Flow",
                "level": 3,
                "content": "(Optional) Before running the flow, you can install the dependencies by running:\n```\ncrewai install\n```\nOnce all of the dependencies are installed, you need to activate the virtual environment by running:\n```\nsource .venv/bin/activate\n```\nAfter activating the virtual environment, you can run the flow by executing one of the following commands:\n```\ncrewai flow kickoff\n```\nor\n```\nuv run kickoff\n```\nThe flow will execute, and you should see the output in the console.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "bash",
                    "content": "crewai install",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  },
                  {
                    "type": "code_block",
                    "language": "bash",
                    "content": "source .venv/bin/activate",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  },
                  {
                    "type": "code_block",
                    "language": "bash",
                    "content": "crewai flow kickoff",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  },
                  {
                    "type": "code_block",
                    "language": "bash",
                    "content": "uv run kickoff",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              }
            ],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "bash",
                "content": "crewai create flow name_of_flow",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Plot Flows",
            "level": 2,
            "content": "Visualizing your AI workflows can provide valuable insights into the structure and execution paths of your flows. CrewAI offers a powerful visualization tool that allows you to generate interactive plots of your flows, making it easier to understand and optimize your AI workflows.",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": [
              {
                "type": "header",
                "title": "What are Plots?",
                "level": 3,
                "content": "Plots in CrewAI are graphical representations of your AI workflows. They display the various tasks, their connections, and the flow of data between them. This visualization helps in understanding the sequence of operations, identifying bottlenecks, and ensuring that the workflow logic aligns with your expectations.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "How to Generate a Plot",
                "level": 3,
                "content": "CrewAI provides two convenient methods to generate plots of your flows:",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": [
                  {
                    "type": "header",
                    "title": "Option 1: Using the `plot()` Method",
                    "level": 4,
                    "content": "If you are working directly with a flow instance, you can generate a plot by calling the `plot()` method on your flow object. This method will create an HTML file containing the interactive plot of your flow.\n```\n# Assuming you have a flow instance\nflow.plot(\"my_flow_plot\")\n```\nThis will generate a file named `my_flow_plot.html` in your current directory. You can open this file in a web browser to view the interactive plot.",
                    "metadata": {
                      "section_type": "General",
                      "content_type": "code_example"
                    },
                    "children": [],
                    "code_blocks": [
                      {
                        "type": "code_block",
                        "language": "python Code",
                        "content": "# Assuming you have a flow instance\nflow.plot(\"my_flow_plot\")",
                        "metadata": {
                          "section_type": "code",
                          "content_type": "code_example"
                        },
                        "children": []
                      }
                    ]
                  },
                  {
                    "type": "header",
                    "title": "Option 2: Using the Command Line",
                    "level": 4,
                    "content": "If you are working within a structured CrewAI project, you can generate a plot using the command line. This is particularly useful for larger projects where you want to visualize the entire flow setup.\n```\ncrewai flow plot\n```\nThis command will generate an HTML file with the plot of your flow, similar to the `plot()` method. The file will be saved in your project directory, and you can open it in a web browser to explore the flow.",
                    "metadata": {
                      "section_type": "General",
                      "content_type": "code_example"
                    },
                    "children": [],
                    "code_blocks": [
                      {
                        "type": "code_block",
                        "language": "bash",
                        "content": "crewai flow plot",
                        "metadata": {
                          "section_type": "code",
                          "content_type": "code_example"
                        },
                        "children": []
                      }
                    ]
                  }
                ]
              },
              {
                "type": "header",
                "title": "Understanding the Plot",
                "level": 3,
                "content": "The generated plot will display nodes representing the tasks in your flow, with directed edges indicating the flow of execution. The plot is interactive, allowing you to zoom in and out, and hover over nodes to see additional details. By visualizing your flows, you can gain a clearer understanding of the workflow's structure, making it easier to debug, optimize, and communicate your AI processes to others.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "descriptive_text"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Conclusion",
                "level": 3,
                "content": "",
                "metadata": {
                  "section_type": "General",
                  "content_type": null
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Next Steps",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Running Flows",
            "level": 2,
            "content": "There are two ways to run a flow:",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": [
              {
                "type": "header",
                "title": "Using the Flow API",
                "level": 3,
                "content": "You can run a flow programmatically by creating an instance of your flow class and calling the `kickoff()` method:\n```\nflow = ExampleFlow()\nresult = flow.kickoff()\n```",
                "metadata": {
                  "section_type": "API documentation",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "flow = ExampleFlow()\nresult = flow.kickoff()",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Using the CLI",
                "level": 3,
                "content": "Starting from version 0.103.0, you can run flows using the `crewai run` command:\n```\ncrewai run\n```\nThis command automatically detects if your project is a flow (based on the `type = \"flow\"` setting in your pyproject.toml) and runs it accordingly. This is the recommended way to run flows from the command line. For backward compatibility, you can also use:\n```\ncrewai flow kickoff\n```\nHowever, the `crewai run` command is now the preferred method as it works for both crews and flows.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "shell",
                    "content": "crewai run",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  },
                  {
                    "type": "code_block",
                    "language": "shell",
                    "content": "crewai flow kickoff",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type": "header",
        "title": "Knowledge",
        "level": 1,
        "content": "Source: https://docs.crewai.com/concepts/knowledge What is knowledge in CrewAI and how to use it.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": [
          {
            "type": "header",
            "title": "What is Knowledge?",
            "level": 2,
            "content": "Knowledge in CrewAI is a powerful system that allows AI agents to access and utilize external information sources during their tasks.\nThink of it as giving your agents a reference library they can consult while working. Enhance agents with domain-specific information Support decisions with real-world data Maintain context across conversations Ground responses in factual information\n</Info>",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Supported Knowledge Sources",
            "level": 2,
            "content": "CrewAI supports various types of knowledge sources out of the box:",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Supported Knowledge Parameters",
            "level": 2,
            "content": "| Parameter         | Type                            | Required | Description                                                                                                                                       |\n| :---------------- | :------------------------------ | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------ |\n| `sources`         | **List\\[BaseKnowledgeSource]**  | Yes      | List of knowledge sources that provide content to be stored and queried. Can include PDF, CSV, Excel, JSON, text files, or string content.        |\n| `collection_name` | **str**                         | No       | Name of the collection where the knowledge will be stored. Used to identify different sets of knowledge. Defaults to \"knowledge\" if not provided. |\n| `storage`         | **Optional\\[KnowledgeStorage]** | No       | Custom storage configuration for managing how the knowledge is stored and retrieved. If not provided, a default storage will be created.          |",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Quickstart Example",
            "level": 2,
            "content": "Here's an example using string-based knowledge:\n```\nfrom crewai import Agent, Task, Crew, Process, LLM\nfrom crewai.knowledge.source.string_knowledge_source import StringKnowledgeSource\n\n# Create a knowledge source\ncontent = \"Users name is John. He is 30 years old and lives in San Francisco.\"\nstring_source = StringKnowledgeSource(\n    content=content,\n)\n\n# Create an LLM with a temperature of 0 to ensure deterministic outputs\nllm = LLM(model=\"gpt-4o-mini\", temperature=0)\n\n# Create an agent with the knowledge store\nagent = Agent(\n    role=\"About User\",\n    goal=\"You know everything about the user.\",\n    backstory=\"\"\"You are a master at understanding people and their preferences.\"\"\",\n    verbose=True,\n    allow_delegation=False,\n    llm=llm,\n)\ntask = Task(\n    description=\"Answer the following questions about the user: {question}\",\n    expected_output=\"An answer to the question.\",\n    agent=agent,\n)\n\ncrew = Crew(\n    agents=[agent],\n    tasks=[task],\n    verbose=True,\n    process=Process.sequential,\n    knowledge_sources=[string_source], # Enable knowledge by adding the sources here. You can also add more sources to the sources list.\n)\n\nresult = crew.kickoff(inputs={\"question\": \"What city does John live in and how old is he?\"})\n```\nHere's another example with the `CrewDoclingSource`. The CrewDoclingSource is actually quite versatile and can handle multiple file formats including MD, PDF, DOCX, HTML, and more.\n```\nfrom crewai import LLM, Agent, Crew, Process, Task\nfrom crewai.knowledge.source.crew_docling_source import CrewDoclingSource\n\n# Create a knowledge source\ncontent_source = CrewDoclingSource(\n    file_paths=[\n        \"https://lilianweng.github.io/posts/2024-11-28-reward-hacking\",\n        \"https://lilianweng.github.io/posts/2024-07-07-hallucination\",\n    ],\n)\n\n# Create an LLM with a temperature of 0 to ensure deterministic outputs\nllm = LLM(model=\"gpt-4o-mini\", temperature=0)\n\n# Create an agent with the knowledge store\nagent = Agent(\n    role=\"About papers\",\n    goal=\"You know everything about the papers.\",\n    backstory=\"\"\"You are a master at understanding papers and their content.\"\"\",\n    verbose=True,\n    allow_delegation=False,\n    llm=llm,\n)\ntask = Task(\n    description=\"Answer the following questions about the papers: {question}\",\n    expected_output=\"An answer to the question.\",\n    agent=agent,\n)\n\ncrew = Crew(\n    agents=[agent],\n    tasks=[task],\n    verbose=True,\n    process=Process.sequential,\n    knowledge_sources=[\n        content_source\n    ],  # Enable knowledge by adding the sources here. You can also add more sources to the sources list.\n)\n\nresult = crew.kickoff(\n    inputs={\n        \"question\": \"What is the reward hacking paper about? Be sure to provide sources.\"\n    }\n)\n```",
            "metadata": {
              "section_type": "Examples",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai import Agent, Task, Crew, Process, LLM\nfrom crewai.knowledge.source.string_knowledge_source import StringKnowledgeSource\n\n# Create a knowledge source\ncontent = \"Users name is John. He is 30 years old and lives in San Francisco.\"\nstring_source = StringKnowledgeSource(\n    content=content,\n)\n\n# Create an LLM with a temperature of 0 to ensure deterministic outputs\nllm = LLM(model=\"gpt-4o-mini\", temperature=0)\n\n# Create an agent with the knowledge store\nagent = Agent(\n    role=\"About User\",\n    goal=\"You know everything about the user.\",\n    backstory=\"\"\"You are a master at understanding people and their preferences.\"\"\",\n    verbose=True,\n    allow_delegation=False,\n    llm=llm,\n)\ntask = Task(\n    description=\"Answer the following questions about the user: {question}\",\n    expected_output=\"An answer to the question.\",\n    agent=agent,\n)\n\ncrew = Crew(\n    agents=[agent],\n    tasks=[task],\n    verbose=True,\n    process=Process.sequential,\n    knowledge_sources=[string_source], # Enable knowledge by adding the sources here. You can also add more sources to the sources list.\n)\n\nresult = crew.kickoff(inputs={\"question\": \"What city does John live in and how old is he?\"})",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai import LLM, Agent, Crew, Process, Task\nfrom crewai.knowledge.source.crew_docling_source import CrewDoclingSource\n\n# Create a knowledge source\ncontent_source = CrewDoclingSource(\n    file_paths=[\n        \"https://lilianweng.github.io/posts/2024-11-28-reward-hacking\",\n        \"https://lilianweng.github.io/posts/2024-07-07-hallucination\",\n    ],\n)\n\n# Create an LLM with a temperature of 0 to ensure deterministic outputs\nllm = LLM(model=\"gpt-4o-mini\", temperature=0)\n\n# Create an agent with the knowledge store\nagent = Agent(\n    role=\"About papers\",\n    goal=\"You know everything about the papers.\",\n    backstory=\"\"\"You are a master at understanding papers and their content.\"\"\",\n    verbose=True,\n    allow_delegation=False,\n    llm=llm,\n)\ntask = Task(\n    description=\"Answer the following questions about the papers: {question}\",\n    expected_output=\"An answer to the question.\",\n    agent=agent,\n)\n\ncrew = Crew(\n    agents=[agent],\n    tasks=[task],\n    verbose=True,\n    process=Process.sequential,\n    knowledge_sources=[\n        content_source\n    ],  # Enable knowledge by adding the sources here. You can also add more sources to the sources list.\n)\n\nresult = crew.kickoff(\n    inputs={\n        \"question\": \"What is the reward hacking paper about? Be sure to provide sources.\"\n    }\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "More Examples",
            "level": 2,
            "content": "Here are examples of how to use different types of knowledge sources: Note: Please ensure that you create the ./knowldge folder. All source files (e.g., .txt, .pdf, .xlsx, .json) should be placed in this folder for centralized management.",
            "metadata": {
              "section_type": "Examples",
              "content_type": "short_description"
            },
            "children": [
              {
                "type": "header",
                "title": "Text File Knowledge Source",
                "level": 3,
                "content": "```\nfrom crewai.knowledge.source.text_file_knowledge_source import TextFileKnowledgeSource\n\n# Create a text file knowledge source\ntext_source = TextFileKnowledgeSource(\n    file_paths=[\"document.txt\", \"another.txt\"]\n)\n\n# Create crew with text file source on agents or crew level\nagent = Agent(\n    ...\n    knowledge_sources=[text_source]\n)\n\ncrew = Crew(\n    ...\n    knowledge_sources=[text_source]\n)\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "from crewai.knowledge.source.text_file_knowledge_source import TextFileKnowledgeSource\n\n# Create a text file knowledge source\ntext_source = TextFileKnowledgeSource(\n    file_paths=[\"document.txt\", \"another.txt\"]\n)\n\n# Create crew with text file source on agents or crew level\nagent = Agent(\n    ...\n    knowledge_sources=[text_source]\n)\n\ncrew = Crew(\n    ...\n    knowledge_sources=[text_source]\n)",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "PDF Knowledge Source",
                "level": 3,
                "content": "```\nfrom crewai.knowledge.source.pdf_knowledge_source import PDFKnowledgeSource\n\n# Create a PDF knowledge source\npdf_source = PDFKnowledgeSource(\n    file_paths=[\"document.pdf\", \"another.pdf\"]\n)\n\n# Create crew with PDF knowledge source on agents or crew level\nagent = Agent(\n    ...\n    knowledge_sources=[pdf_source]\n)\n\ncrew = Crew(\n    ...\n    knowledge_sources=[pdf_source]\n)\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "from crewai.knowledge.source.pdf_knowledge_source import PDFKnowledgeSource\n\n# Create a PDF knowledge source\npdf_source = PDFKnowledgeSource(\n    file_paths=[\"document.pdf\", \"another.pdf\"]\n)\n\n# Create crew with PDF knowledge source on agents or crew level\nagent = Agent(\n    ...\n    knowledge_sources=[pdf_source]\n)\n\ncrew = Crew(\n    ...\n    knowledge_sources=[pdf_source]\n)",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "CSV Knowledge Source",
                "level": 3,
                "content": "```\nfrom crewai.knowledge.source.csv_knowledge_source import CSVKnowledgeSource\n\n# Create a CSV knowledge source\ncsv_source = CSVKnowledgeSource(\n    file_paths=[\"data.csv\"]\n)\n\n# Create crew with CSV knowledge source or on agent level\nagent = Agent(\n    ...\n    knowledge_sources=[csv_source]\n)\n\ncrew = Crew(\n    ...\n    knowledge_sources=[csv_source]\n)\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "from crewai.knowledge.source.csv_knowledge_source import CSVKnowledgeSource\n\n# Create a CSV knowledge source\ncsv_source = CSVKnowledgeSource(\n    file_paths=[\"data.csv\"]\n)\n\n# Create crew with CSV knowledge source or on agent level\nagent = Agent(\n    ...\n    knowledge_sources=[csv_source]\n)\n\ncrew = Crew(\n    ...\n    knowledge_sources=[csv_source]\n)",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Excel Knowledge Source",
                "level": 3,
                "content": "```\nfrom crewai.knowledge.source.excel_knowledge_source import ExcelKnowledgeSource\n\n# Create an Excel knowledge source\nexcel_source = ExcelKnowledgeSource(\n    file_paths=[\"spreadsheet.xlsx\"]\n)\n\n# Create crew with Excel knowledge source on agents or crew level\nagent = Agent(\n    ...\n    knowledge_sources=[excel_source]\n)\n\ncrew = Crew(\n    ...\n    knowledge_sources=[excel_source]\n)\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "from crewai.knowledge.source.excel_knowledge_source import ExcelKnowledgeSource\n\n# Create an Excel knowledge source\nexcel_source = ExcelKnowledgeSource(\n    file_paths=[\"spreadsheet.xlsx\"]\n)\n\n# Create crew with Excel knowledge source on agents or crew level\nagent = Agent(\n    ...\n    knowledge_sources=[excel_source]\n)\n\ncrew = Crew(\n    ...\n    knowledge_sources=[excel_source]\n)",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "JSON Knowledge Source",
                "level": 3,
                "content": "```\nfrom crewai.knowledge.source.json_knowledge_source import JSONKnowledgeSource\n\n# Create a JSON knowledge source\njson_source = JSONKnowledgeSource(\n    file_paths=[\"data.json\"]\n)\n\n# Create crew with JSON knowledge source on agents or crew level\nagent = Agent(\n    ...\n    knowledge_sources=[json_source]\n)\n\ncrew = Crew(\n    ...\n    knowledge_sources=[json_source]\n)\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "from crewai.knowledge.source.json_knowledge_source import JSONKnowledgeSource\n\n# Create a JSON knowledge source\njson_source = JSONKnowledgeSource(\n    file_paths=[\"data.json\"]\n)\n\n# Create crew with JSON knowledge source on agents or crew level\nagent = Agent(\n    ...\n    knowledge_sources=[json_source]\n)\n\ncrew = Crew(\n    ...\n    knowledge_sources=[json_source]\n)",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              }
            ]
          },
          {
            "type": "header",
            "title": "Knowledge Configuration",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": [
              {
                "type": "header",
                "title": "Chunking Configuration",
                "level": 3,
                "content": "Knowledge sources automatically chunk content for better processing.\nYou can configure chunking behavior in your knowledge sources:\n```\nfrom crewai.knowledge.source.string_knowledge_source import StringKnowledgeSource\n\nsource = StringKnowledgeSource(\n    content=\"Your content here\",\n    chunk_size=4000,      # Maximum size of each chunk (default: 4000)\n    chunk_overlap=200     # Overlap between chunks (default: 200)\n)\n```\nThe chunking configuration helps in: Breaking down large documents into manageable pieces Maintaining context through chunk overlap Optimizing retrieval accuracy",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "from crewai.knowledge.source.string_knowledge_source import StringKnowledgeSource\n\nsource = StringKnowledgeSource(\n    content=\"Your content here\",\n    chunk_size=4000,      # Maximum size of each chunk (default: 4000)\n    chunk_overlap=200     # Overlap between chunks (default: 200)\n)",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Embeddings Configuration",
                "level": 3,
                "content": "You can also configure the embedder for the knowledge store.\nThis is useful if you want to use a different embedder for the knowledge store than the one used for the agents.\nThe `embedder` parameter supports various embedding model providers that include: `openai`: OpenAI's embedding models `google`: Google's text embedding models `azure`: Azure OpenAI embeddings `ollama`: Local embeddings with Ollama `vertexai`: Google Cloud VertexAI embeddings `cohere`: Cohere's embedding models `voyageai`: VoyageAI's embedding models `bedrock`: AWS Bedrock embeddings `huggingface`: Hugging Face models `watson`: IBM Watson embeddings Here's an example of how to configure the embedder for the knowledge store using Google's `text-embedding-004` model:",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          }
        ]
      },
      {
        "type": "header",
        "title": "Get the GEMINI API key",
        "level": 1,
        "content": "GEMINI_API_KEY = os.environ.get(\"GEMINI_API_KEY\")",
        "metadata": {
          "section_type": "API documentation",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "Create a knowledge source",
        "level": 1,
        "content": "content = \"Users name is John. He is 30 years old and lives in San Francisco.\"\n  string_source = StringKnowledgeSource(\n      content=content,\n  )",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "Create an LLM with a temperature of 0 to ensure deterministic outputs",
        "level": 1,
        "content": "gemini_llm = LLM(\n      model=\"gemini/gemini-1.5-pro-002\",\n      api_key=GEMINI_API_KEY,\n      temperature=0,\n  )",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "Create an agent with the knowledge store",
        "level": 1,
        "content": "agent = Agent(\n      role=\"About User\",\n      goal=\"You know everything about the user.\",\n      backstory=\"\"\"You are a master at understanding people and their preferences.\"\"\",\n      verbose=True,\n      allow_delegation=False,\n      llm=gemini_llm,\n      embedder={\n          \"provider\": \"google\",\n          \"config\": {\n              \"model\": \"models/text-embedding-004\",\n              \"api_key\": GEMINI_API_KEY,\n          }\n      }\n  ) task = Task(\n      description=\"Answer the following questions about the user: {question}\",\n      expected_output=\"An answer to the question.\",\n      agent=agent,\n  ) crew = Crew(\n      agents=[agent],\n      tasks=[task],\n      verbose=True,\n      process=Process.sequential,\n      knowledge_sources=[string_source],\n      embedder={\n          \"provider\": \"google\",\n          \"config\": {\n              \"model\": \"models/text-embedding-004\",\n              \"api_key\": GEMINI_API_KEY,\n          }\n      }\n  ) result = crew.kickoff(inputs={\"question\": \"What city does John live in and how old is he?\"})\n```\n\n```text Output\n# Agent: About User\n## Task: Answer the following questions about the user: What city does John live in and how old is he?\n\n# Agent: About User\n## Final Answer: \nJohn is 30 years old and lives in San Francisco.\n```",
        "metadata": {
          "section_type": "General",
          "content_type": "code_example"
        },
        "children": [
          {
            "type": "header",
            "title": "Clearing Knowledge",
            "level": 2,
            "content": "If you need to clear the knowledge stored in CrewAI, you can use the `crewai reset-memories` command with the `--knowledge` option.\n```\ncrewai reset-memories --knowledge\n```\nThis is useful when you've updated your knowledge sources and want to ensure that the agents are using the most recent information.",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "bash Command",
                "content": "crewai reset-memories --knowledge",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Agent-Specific Knowledge",
            "level": 2,
            "content": "While knowledge can be provided at the crew level using `crew.knowledge_sources`, individual agents can also have their own knowledge sources using the `knowledge_sources` parameter:\n```\nfrom crewai import Agent, Task, Crew\nfrom crewai.knowledge.source.string_knowledge_source import StringKnowledgeSource\n\n# Create agent-specific knowledge about a product\nproduct_specs = StringKnowledgeSource(\n    content=\"\"\"The XPS 13 laptop features:\n    - 13.4-inch 4K display\n    - Intel Core i7 processor\n    - 16GB RAM\n    - 512GB SSD storage\n    - 12-hour battery life\"\"\",\n    metadata={\"category\": \"product_specs\"}\n)\n\n# Create a support agent with product knowledge\nsupport_agent = Agent(\n    role=\"Technical Support Specialist\",\n    goal=\"Provide accurate product information and support.\",\n    backstory=\"You are an expert on our laptop products and specifications.\",\n    knowledge_sources=[product_specs]  # Agent-specific knowledge\n)\n\n# Create a task that requires product knowledge\nsupport_task = Task(\n    description=\"Answer this customer question: {question}\",\n    agent=support_agent\n)\n\n# Create and run the crew\ncrew = Crew(\n    agents=[support_agent],\n    tasks=[support_task]\n)\n\n# Get answer about the laptop's specifications\nresult = crew.kickoff(\n    inputs={\"question\": \"What is the storage capacity of the XPS 13?\"}\n)\n```\nGive agents specialized information for their roles Maintain separation of concerns between agents Combine with crew-level knowledge for layered information access\n</Info>",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai import Agent, Task, Crew\nfrom crewai.knowledge.source.string_knowledge_source import StringKnowledgeSource\n\n# Create agent-specific knowledge about a product\nproduct_specs = StringKnowledgeSource(\n    content=\"\"\"The XPS 13 laptop features:\n    - 13.4-inch 4K display\n    - Intel Core i7 processor\n    - 16GB RAM\n    - 512GB SSD storage\n    - 12-hour battery life\"\"\",\n    metadata={\"category\": \"product_specs\"}\n)\n\n# Create a support agent with product knowledge\nsupport_agent = Agent(\n    role=\"Technical Support Specialist\",\n    goal=\"Provide accurate product information and support.\",\n    backstory=\"You are an expert on our laptop products and specifications.\",\n    knowledge_sources=[product_specs]  # Agent-specific knowledge\n)\n\n# Create a task that requires product knowledge\nsupport_task = Task(\n    description=\"Answer this customer question: {question}\",\n    agent=support_agent\n)\n\n# Create and run the crew\ncrew = Crew(\n    agents=[support_agent],\n    tasks=[support_task]\n)\n\n# Get answer about the laptop's specifications\nresult = crew.kickoff(\n    inputs={\"question\": \"What is the storage capacity of the XPS 13?\"}\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Custom Knowledge Sources",
            "level": 2,
            "content": "CrewAI allows you to create custom knowledge sources for any type of data by extending the `BaseKnowledgeSource` class. Let's create a practical example that fetches and processes space news articles.",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": [
              {
                "type": "header",
                "title": "Space News Knowledge Source Example",
                "level": 4,
                "content": "class SpaceNewsKnowledgeSource(BaseKnowledgeSource):\n      \"\"\"Knowledge source that fetches data from Space News API.\"\"\"",
                "metadata": {
                  "section_type": "Examples",
                  "content_type": "short_description"
                },
                "children": []
              }
            ]
          }
        ],
        "code_blocks": [
          {
            "type": "code_block",
            "language": null,
            "content": "```text Output\n# Agent: About User\n## Task: Answer the following questions about the user: What city does John live in and how old is he?\n\n# Agent: About User\n## Final Answer: \nJohn is 30 years old and lives in San Francisco.",
            "metadata": {
              "section_type": "code",
              "content_type": "code_example"
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Create knowledge source",
        "level": 1,
        "content": "recent_news = SpaceNewsKnowledgeSource(\n      api_endpoint=\"https://api.spaceflightnewsapi.net/v4/articles\",\n      limit=10,\n  )",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "Create specialized agent",
        "level": 1,
        "content": "space_analyst = Agent(\n      role=\"Space News Analyst\",\n      goal=\"Answer questions about space news accurately and comprehensively\",\n      backstory=\"\"\"You are a space industry analyst with expertise in space exploration,\n      satellite technology, and space industry trends. You excel at answering questions\n      about space news and providing detailed, accurate information.\"\"\",\n      knowledge_sources=[recent_news],\n      llm=LLM(model=\"gpt-4\", temperature=0.0)\n  )",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "Create task that handles user questions",
        "level": 1,
        "content": "analysis_task = Task(\n      description=\"Answer this question about space news: {user_question}\",\n      expected_output=\"A detailed answer based on the recent space news articles\",\n      agent=space_analyst\n  )",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "Create and run the crew",
        "level": 1,
        "content": "crew = Crew(\n      agents=[space_analyst],\n      tasks=[analysis_task],\n      verbose=True,\n      process=Process.sequential\n  )",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "Example usage",
        "level": 1,
        "content": "result = crew.kickoff(\n      inputs={\"user_question\": \"What are the latest developments in space exploration?\"}\n  )\n```\n\n```output Output\n# Agent: Space News Analyst\n## Task: Answer this question about space news: What are the latest developments in space exploration?\n\n\n# Agent: Space News Analyst\n## Final Answer:\nThe latest developments in space exploration, based on recent space news articles, include the following:\n\n1. SpaceX has received the final regulatory approvals to proceed with the second integrated Starship/Super Heavy launch, scheduled for as soon as the morning of Nov. 17, 2023. This is a significant step in SpaceX's ambitious plans for space exploration and colonization. [Source: SpaceNews](https://spacenews.com/starship-cleared-for-nov-17-launch/)\n\n2. SpaceX has also informed the US Federal Communications Commission (FCC) that it plans to begin launching its first next-generation Starlink Gen2 satellites. This represents a major upgrade to the Starlink satellite internet service, which aims to provide high-speed internet access worldwide. [Source: Teslarati](https://www.teslarati.com/spacex-first-starlink-gen2-satellite-launch-2022/)\n\n3. AI startup Synthetaic has raised $15 million in Series B funding. The company uses artificial intelligence to analyze data from space and air sensors, which could have significant applications in space exploration and satellite technology. [Source: SpaceNews](https://spacenews.com/ai-startup-synthetaic-raises-15-million-in-series-b-funding/)\n\n4. The Space Force has formally established a unit within the U.S. Indo-Pacific Command, marking a permanent presence in the Indo-Pacific region. This could have significant implications for space security and geopolitics. [Source: SpaceNews](https://spacenews.com/space-force-establishes-permanent-presence-in-indo-pacific-region/)\n\n5. Slingshot Aerospace, a space tracking and data analytics company, is expanding its network of ground-based optical telescopes to increase coverage of low Earth orbit. This could improve our ability to track and analyze objects in low Earth orbit, including satellites and space debris. [Source: SpaceNews](https://spacenews.com/slingshots-space-tracking-network-to-extend-coverage-of-low-earth-orbit/)\n\n6. The National Natural Science Foundation of China has outlined a five-year project for researchers to study the assembly of ultra-large spacecraft. This could lead to significant advancements in spacecraft technology and space exploration capabilities. [Source: SpaceNews](https://spacenews.com/china-researching-challenges-of-kilometer-scale-ultra-large-spacecraft/)\n\n7. The Center for AEroSpace Autonomy Research (CAESAR) at Stanford University is focusing on spacecraft autonomy. The center held a kickoff event on May 22, 2024, to highlight the industry, academia, and government collaboration it seeks to foster. This could lead to significant advancements in autonomous spacecraft technology. [Source: SpaceNews](https://spacenews.com/stanford-center-focuses-on-spacecraft-autonomy/)\n```",
        "metadata": {
          "section_type": "Examples",
          "content_type": "code_example"
        },
        "children": [
          {
            "type": "header",
            "title": "Key Components Explained",
            "level": 4,
            "content": "**Custom Knowledge Source (`SpaceNewsKnowledgeSource`)**: Extends `BaseKnowledgeSource` for integration with CrewAI Configurable API endpoint and article limit Implements three key methods: `load_content()`: Fetches articles from the API `_format_articles()`: Structures the articles into readable text `add()`: Processes and stores the content **Agent Configuration**: Specialized role as a Space News Analyst Uses the knowledge source to access space news **Task Setup**: Takes a user question as input through `{user_question}` Designed to provide detailed answers based on the knowledge source **Crew Orchestration**: Manages the workflow between agent and task Handles input/output through the kickoff method This example demonstrates how to: Create a custom knowledge source that fetches real-time data Process and format external data for AI consumption Use the knowledge source to answer specific user questions Integrate everything seamlessly with CrewAI's agent system",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "About the Spaceflight News API",
            "level": 4,
            "content": "The example uses the [Spaceflight News API](https://api.spaceflightnewsapi.net/v4/docs/), which: Provides free access to space-related news articles Requires no authentication Returns structured data about space news Supports pagination and filtering You can customize the API query by modifying the endpoint URL:\n```\n# Fetch more articles\nrecent_news = SpaceNewsKnowledgeSource(\n    api_endpoint=\"https://api.spaceflightnewsapi.net/v4/articles\",\n    limit=20,  # Increase the number of articles\n)\n\n# Add search parameters\nrecent_news = SpaceNewsKnowledgeSource(\n    api_endpoint=\"https://api.spaceflightnewsapi.net/v4/articles?search=NASA\", # Search for NASA news\n    limit=10,\n)\n```",
            "metadata": {
              "section_type": "API documentation",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python",
                "content": "# Fetch more articles\nrecent_news = SpaceNewsKnowledgeSource(\n    api_endpoint=\"https://api.spaceflightnewsapi.net/v4/articles\",\n    limit=20,  # Increase the number of articles\n)\n\n# Add search parameters\nrecent_news = SpaceNewsKnowledgeSource(\n    api_endpoint=\"https://api.spaceflightnewsapi.net/v4/articles?search=NASA\", # Search for NASA news\n    limit=10,\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Best Practices",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ],
        "code_blocks": [
          {
            "type": "code_block",
            "language": null,
            "content": "```output Output\n# Agent: Space News Analyst\n## Task: Answer this question about space news: What are the latest developments in space exploration?\n\n\n# Agent: Space News Analyst\n## Final Answer:\nThe latest developments in space exploration, based on recent space news articles, include the following:\n\n1. SpaceX has received the final regulatory approvals to proceed with the second integrated Starship/Super Heavy launch, scheduled for as soon as the morning of Nov. 17, 2023. This is a significant step in SpaceX's ambitious plans for space exploration and colonization. [Source: SpaceNews](https://spacenews.com/starship-cleared-for-nov-17-launch/)\n\n2. SpaceX has also informed the US Federal Communications Commission (FCC) that it plans to begin launching its first next-generation Starlink Gen2 satellites. This represents a major upgrade to the Starlink satellite internet service, which aims to provide high-speed internet access worldwide. [Source: Teslarati](https://www.teslarati.com/spacex-first-starlink-gen2-satellite-launch-2022/)\n\n3. AI startup Synthetaic has raised $15 million in Series B funding. The company uses artificial intelligence to analyze data from space and air sensors, which could have significant applications in space exploration and satellite technology. [Source: SpaceNews](https://spacenews.com/ai-startup-synthetaic-raises-15-million-in-series-b-funding/)\n\n4. The Space Force has formally established a unit within the U.S. Indo-Pacific Command, marking a permanent presence in the Indo-Pacific region. This could have significant implications for space security and geopolitics. [Source: SpaceNews](https://spacenews.com/space-force-establishes-permanent-presence-in-indo-pacific-region/)\n\n5. Slingshot Aerospace, a space tracking and data analytics company, is expanding its network of ground-based optical telescopes to increase coverage of low Earth orbit. This could improve our ability to track and analyze objects in low Earth orbit, including satellites and space debris. [Source: SpaceNews](https://spacenews.com/slingshots-space-tracking-network-to-extend-coverage-of-low-earth-orbit/)\n\n6. The National Natural Science Foundation of China has outlined a five-year project for researchers to study the assembly of ultra-large spacecraft. This could lead to significant advancements in spacecraft technology and space exploration capabilities. [Source: SpaceNews](https://spacenews.com/china-researching-challenges-of-kilometer-scale-ultra-large-spacecraft/)\n\n7. The Center for AEroSpace Autonomy Research (CAESAR) at Stanford University is focusing on spacecraft autonomy. The center held a kickoff event on May 22, 2024, to highlight the industry, academia, and government collaboration it seeks to foster. This could lead to significant advancements in autonomous spacecraft technology. [Source: SpaceNews](https://spacenews.com/stanford-center-focuses-on-spacecraft-autonomy/)",
            "metadata": {
              "section_type": "code",
              "content_type": "code_example"
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Using LangChain Tools",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Using LangChain Tools",
            "level": 2,
            "content": "Source: https://docs.crewai.com/concepts/langchain-tools Learn how to integrate LangChain tools with CrewAI agents to enhance search-based queries and more.\n\n```\nimport os\nfrom dotenv import load_dotenv\nfrom crewai import Agent, Task, Crew\nfrom crewai.tools import BaseTool\nfrom pydantic import Field\nfrom langchain_community.utilities import GoogleSerperAPIWrapper\n\n# Set up your SERPER_API_KEY key in an .env file, eg:\n# SERPER_API_KEY=<your api key>\nload_dotenv()\n\nsearch = GoogleSerperAPIWrapper()\n\nclass SearchTool(BaseTool):\n    name: str = \"Search\"\n    description: str = \"Useful for search-based queries. Use this to find current information about markets, companies, and trends.\"\n    search: GoogleSerperAPIWrapper = Field(default_factory=GoogleSerperAPIWrapper)\n\n    def _run(self, query: str) -> str:\n        \"\"\"Execute the search query and return results\"\"\"\n        try:\n            return self.search.run(query)\n        except Exception as e:\n            return f\"Error performing search: {str(e)}\"\n\n# Create Agents\nresearcher = Agent(\n    role='Research Analyst',\n    goal='Gather current market data and trends',\n    backstory=\"\"\"You are an expert research analyst with years of experience in\n    gathering market intelligence. You're known for your ability to find\n    relevant and up-to-date market information and present it in a clear,\n    actionable format.\"\"\",\n    tools=[SearchTool()],\n    verbose=True\n)\n\n# rest of the code ...\n```",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "import os\nfrom dotenv import load_dotenv\nfrom crewai import Agent, Task, Crew\nfrom crewai.tools import BaseTool\nfrom pydantic import Field\nfrom langchain_community.utilities import GoogleSerperAPIWrapper\n\n# Set up your SERPER_API_KEY key in an .env file, eg:\n# SERPER_API_KEY=<your api key>\nload_dotenv()\n\nsearch = GoogleSerperAPIWrapper()\n\nclass SearchTool(BaseTool):\n    name: str = \"Search\"\n    description: str = \"Useful for search-based queries. Use this to find current information about markets, companies, and trends.\"\n    search: GoogleSerperAPIWrapper = Field(default_factory=GoogleSerperAPIWrapper)\n\n    def _run(self, query: str) -> str:\n        \"\"\"Execute the search query and return results\"\"\"\n        try:\n            return self.search.run(query)\n        except Exception as e:\n            return f\"Error performing search: {str(e)}\"\n\n# Create Agents\nresearcher = Agent(\n    role='Research Analyst',\n    goal='Gather current market data and trends',\n    backstory=\"\"\"You are an expert research analyst with years of experience in\n    gathering market intelligence. You're known for your ability to find\n    relevant and up-to-date market information and present it in a clear,\n    actionable format.\"\"\",\n    tools=[SearchTool()],\n    verbose=True\n)\n\n# rest of the code ...",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Conclusion",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Using LlamaIndex Tools",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Using LlamaIndex Tools",
            "level": 2,
            "content": "Source: https://docs.crewai.com/concepts/llamaindex-tools Learn how to integrate LlamaIndex tools with CrewAI agents to enhance search-based queries and more.\n\nHere are the available built-in tools offered by LlamaIndex.\n```\nfrom crewai import Agent\nfrom crewai_tools import LlamaIndexTool\n\n# Example 1: Initialize from FunctionTool\nfrom llama_index.core.tools import FunctionTool\n\nyour_python_function = lambda ...: ...\nog_tool = FunctionTool.from_defaults(\n    your_python_function, \n    name=\"<name>\", \n    description='<description>'\n)\ntool = LlamaIndexTool.from_tool(og_tool)\n\n# Example 2: Initialize from LlamaHub Tools\nfrom llama_index.tools.wolfram_alpha import WolframAlphaToolSpec\nwolfram_spec = WolframAlphaToolSpec(app_id=\"<app_id>\")\nwolfram_tools = wolfram_spec.to_tool_list()\ntools = [LlamaIndexTool.from_tool(t) for t in wolfram_tools]\n\n# Example 3: Initialize Tool from a LlamaIndex Query Engine\nquery_engine = index.as_query_engine()\nquery_tool = LlamaIndexTool.from_query_engine(\n    query_engine,\n    name=\"Uber 2019 10K Query Tool\",\n    description=\"Use this tool to lookup the 2019 Uber 10K Annual Report\"\n)\n\n# Create and assign the tools to an agent\nagent = Agent(\n    role='Research Analyst',\n    goal='Provide up-to-date market analysis',\n    backstory='An expert analyst with a keen eye for market trends.',\n    tools=[tool, *tools, query_tool]\n)\n\n# rest of the code ...\n```",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai import Agent\nfrom crewai_tools import LlamaIndexTool\n\n# Example 1: Initialize from FunctionTool\nfrom llama_index.core.tools import FunctionTool\n\nyour_python_function = lambda ...: ...\nog_tool = FunctionTool.from_defaults(\n    your_python_function, \n    name=\"<name>\", \n    description='<description>'\n)\ntool = LlamaIndexTool.from_tool(og_tool)\n\n# Example 2: Initialize from LlamaHub Tools\nfrom llama_index.tools.wolfram_alpha import WolframAlphaToolSpec\nwolfram_spec = WolframAlphaToolSpec(app_id=\"<app_id>\")\nwolfram_tools = wolfram_spec.to_tool_list()\ntools = [LlamaIndexTool.from_tool(t) for t in wolfram_tools]\n\n# Example 3: Initialize Tool from a LlamaIndex Query Engine\nquery_engine = index.as_query_engine()\nquery_tool = LlamaIndexTool.from_query_engine(\n    query_engine,\n    name=\"Uber 2019 10K Query Tool\",\n    description=\"Use this tool to lookup the 2019 Uber 10K Annual Report\"\n)\n\n# Create and assign the tools to an agent\nagent = Agent(\n    role='Research Analyst',\n    goal='Provide up-to-date market analysis',\n    backstory='An expert analyst with a keen eye for market trends.',\n    tools=[tool, *tools, query_tool]\n)\n\n# rest of the code ...",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Steps to Get Started",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "LLMs",
        "level": 1,
        "content": "Source: https://docs.crewai.com/concepts/llms A comprehensive guide to configuring and using Large Language Models (LLMs) in your CrewAI projects",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": [
          {
            "type": "header",
            "title": "What are LLMs?",
            "level": 2,
            "content": "Large Language Models (LLMs) are the core intelligence behind CrewAI agents. They enable agents to understand context, make decisions, and generate human-like responses. Here's what you need to know:",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Setting Up Your LLM",
            "level": 2,
            "content": "There are three ways to configure LLMs in CrewAI. Choose the method that best fits your workflow:",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Provider Configuration Examples",
            "level": 2,
            "content": "CrewAI supports a multitude of LLM providers, each offering unique features, authentication methods, and model capabilities.\nIn this section, you'll find detailed examples that help you select, configure, and optimize the LLM that best fits your project's needs.",
            "metadata": {
              "section_type": "Examples",
              "content_type": "short_description"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Streaming Responses",
            "level": 2,
            "content": "CrewAI supports streaming responses from LLMs, allowing your application to receive and process outputs in real-time as they're generated.",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Structured LLM Calls",
            "level": 2,
            "content": "CrewAI supports structured responses from LLM calls by allowing you to define a `response_format` using a Pydantic model. This enables the framework to automatically parse and validate the output, making it easier to integrate the response into your application without manual post-processing. For example, you can define a Pydantic model to represent the expected response structure and pass it as the `response_format` when instantiating the LLM. The model will then be used to convert the LLM output into a structured Python object.\n```\nfrom crewai import LLM\n\nclass Dog(BaseModel):\n    name: str\n    age: int\n    breed: str\n\n\nllm = LLM(model=\"gpt-4o\", response_format=Dog)\n\nresponse = llm.call(\n    \"Analyze the following messages and return the name, age, and breed. \"\n    \"Meet Kona! She is 3 years old and is a black german shepherd.\"\n)\nprint(response)\n\n# Output:\n# Dog(name='Kona', age=3, breed='black german shepherd')\n```",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai import LLM\n\nclass Dog(BaseModel):\n    name: str\n    age: int\n    breed: str\n\n\nllm = LLM(model=\"gpt-4o\", response_format=Dog)\n\nresponse = llm.call(\n    \"Analyze the following messages and return the name, age, and breed. \"\n    \"Meet Kona! She is 3 years old and is a black german shepherd.\"\n)\nprint(response)\n\n# Output:\n# Dog(name='Kona', age=3, breed='black german shepherd')",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Advanced Features and Optimization",
            "level": 2,
            "content": "Learn how to get the most out of your LLM configuration:",
            "metadata": {
              "section_type": "Internals/Advanced",
              "content_type": "short_description"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Common Issues and Solutions",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Memory",
        "level": 1,
        "content": "Source: https://docs.crewai.com/concepts/memory Leveraging memory systems in the CrewAI framework to enhance agent capabilities.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": [
          {
            "type": "header",
            "title": "Introduction to Memory Systems in CrewAI",
            "level": 2,
            "content": "The crewAI framework introduces a sophisticated memory system designed to significantly enhance the capabilities of AI agents.\nThis system comprises `short-term memory`, `long-term memory`, `entity memory`, and `contextual memory`, each serving a unique purpose in aiding agents to remember,\nreason, and learn from past interactions.",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Memory System Components",
            "level": 2,
            "content": "| Component             | Description                                                                                                                                                                                                      |\n| :-------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Short-Term Memory** | Temporarily stores recent interactions and outcomes using `RAG`, enabling agents to recall and utilize information relevant to their current context during the current executions.                              |\n| **Long-Term Memory**  | Preserves valuable insights and learnings from past executions, allowing agents to build and refine their knowledge over time.                                                                                   |\n| **Entity Memory**     | Captures and organizes information about entities (people, places, concepts) encountered during tasks, facilitating deeper understanding and relationship mapping. Uses `RAG` for storing entity information.    |\n| **Contextual Memory** | Maintains the context of interactions by combining `ShortTermMemory`, `LongTermMemory`, and `EntityMemory`, aiding in the coherence and relevance of agent responses over a sequence of tasks or a conversation. |\n| **User Memory**       | Stores user-specific information and preferences, enhancing personalization and user experience.                                                                                                                 |",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "How Memory Systems Empower Agents",
            "level": 2,
            "content": "**Contextual Awareness**: With short-term and contextual memory, agents gain the ability to maintain context over a conversation or task sequence, leading to more coherent and relevant responses. **Experience Accumulation**: Long-term memory allows agents to accumulate experiences, learning from past actions to improve future decision-making and problem-solving. **Entity Understanding**: By maintaining entity memory, agents can recognize and remember key entities, enhancing their ability to process and interact with complex information.",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Implementing Memory in Your Crew",
            "level": 2,
            "content": "When configuring a crew, you can enable and customize each memory component to suit the crew's objectives and the nature of tasks it will perform.\nBy default, the memory system is disabled, and you can ensure it is active by setting `memory=True` in the crew configuration.\nThe memory will use OpenAI embeddings by default, but you can change it by setting `embedder` to a different model.\nIt's also possible to initialize the memory instance with your own instance. The 'embedder' only applies to **Short-Term Memory** which uses Chroma for RAG.\nThe **Long-Term Memory** uses SQLite3 to store task results. Currently, there is no way to override these storage implementations.\nThe data storage files are saved into a platform-specific location found using the appdirs package,\nand the name of the project can be overridden using the **CREWAI\\_STORAGE\\_DIR** environment variable.",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": [
              {
                "type": "header",
                "title": "Example: Configuring Memory for a Crew",
                "level": 3,
                "content": "```\nfrom crewai import Crew, Agent, Task, Process\n\n# Assemble your crew with memory capabilities\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True\n)\n```",
                "metadata": {
                  "section_type": "Examples",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "from crewai import Crew, Agent, Task, Process\n\n# Assemble your crew with memory capabilities\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True\n)",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Example: Use Custom Memory Instances e.g FAISS as the VectorDB",
                "level": 3,
                "content": "```\nfrom crewai import Crew, Process\nfrom crewai.memory import LongTermMemory, ShortTermMemory, EntityMemory\nfrom crewai.memory.storage.rag_storage import RAGStorage\nfrom crewai.memory.storage.ltm_sqlite_storage import LTMSQLiteStorage\nfrom typing import List, Optional\n\n# Assemble your crew with memory capabilities\nmy_crew: Crew = Crew(\n    agents = [...],\n    tasks = [...],\n    process = Process.sequential,\n    memory = True,\n    # Long-term memory for persistent storage across sessions\n    long_term_memory = LongTermMemory(\n        storage=LTMSQLiteStorage(\n            db_path=\"/my_crew1/long_term_memory_storage.db\"\n        )\n    ),\n    # Short-term memory for current context using RAG\n    short_term_memory = ShortTermMemory(\n        storage = RAGStorage(\n                embedder_config={\n                    \"provider\": \"openai\",\n                    \"config\": {\n                        \"model\": 'text-embedding-3-small'\n                    }\n                },\n                type=\"short_term\",\n                path=\"/my_crew1/\"\n            )\n        ),\n    ),\n    # Entity memory for tracking key information about entities\n    entity_memory = EntityMemory(\n        storage=RAGStorage(\n            embedder_config={\n                \"provider\": \"openai\",\n                \"config\": {\n                    \"model\": 'text-embedding-3-small'\n                }\n            },\n            type=\"short_term\",\n            path=\"/my_crew1/\"\n        )\n    ),\n    verbose=True,\n)\n```",
                "metadata": {
                  "section_type": "Examples",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "from crewai import Crew, Process\nfrom crewai.memory import LongTermMemory, ShortTermMemory, EntityMemory\nfrom crewai.memory.storage.rag_storage import RAGStorage\nfrom crewai.memory.storage.ltm_sqlite_storage import LTMSQLiteStorage\nfrom typing import List, Optional\n\n# Assemble your crew with memory capabilities\nmy_crew: Crew = Crew(\n    agents = [...],\n    tasks = [...],\n    process = Process.sequential,\n    memory = True,\n    # Long-term memory for persistent storage across sessions\n    long_term_memory = LongTermMemory(\n        storage=LTMSQLiteStorage(\n            db_path=\"/my_crew1/long_term_memory_storage.db\"\n        )\n    ),\n    # Short-term memory for current context using RAG\n    short_term_memory = ShortTermMemory(\n        storage = RAGStorage(\n                embedder_config={\n                    \"provider\": \"openai\",\n                    \"config\": {\n                        \"model\": 'text-embedding-3-small'\n                    }\n                },\n                type=\"short_term\",\n                path=\"/my_crew1/\"\n            )\n        ),\n    ),\n    # Entity memory for tracking key information about entities\n    entity_memory = EntityMemory(\n        storage=RAGStorage(\n            embedder_config={\n                \"provider\": \"openai\",\n                \"config\": {\n                    \"model\": 'text-embedding-3-small'\n                }\n            },\n            type=\"short_term\",\n            path=\"/my_crew1/\"\n        )\n    ),\n    verbose=True,\n)",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              }
            ]
          },
          {
            "type": "header",
            "title": "Security Considerations",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Configuration Examples",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": [
              {
                "type": "header",
                "title": "Basic Memory Configuration",
                "level": 3,
                "content": "```\nfrom crewai import Crew\nfrom crewai.memory import LongTermMemory\n\n# Simple memory configuration\ncrew = Crew(memory=True)  # Uses default storage locations\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "from crewai import Crew\nfrom crewai.memory import LongTermMemory\n\n# Simple memory configuration\ncrew = Crew(memory=True)  # Uses default storage locations",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Custom Storage Configuration",
                "level": 3,
                "content": "```\nfrom crewai import Crew\nfrom crewai.memory import LongTermMemory\nfrom crewai.memory.storage.ltm_sqlite_storage import LTMSQLiteStorage\n\n# Configure custom storage paths\ncrew = Crew(\n    memory=True,\n    long_term_memory=LongTermMemory(\n        storage=LTMSQLiteStorage(db_path=\"./memory.db\")\n    )\n)\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "from crewai import Crew\nfrom crewai.memory import LongTermMemory\nfrom crewai.memory.storage.ltm_sqlite_storage import LTMSQLiteStorage\n\n# Configure custom storage paths\ncrew = Crew(\n    memory=True,\n    long_term_memory=LongTermMemory(\n        storage=LTMSQLiteStorage(db_path=\"./memory.db\")\n    )\n)",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              }
            ]
          },
          {
            "type": "header",
            "title": "Integrating Mem0 for Enhanced User Memory",
            "level": 2,
            "content": "[Mem0](https://mem0.ai/) is a self-improving memory layer for LLM applications, enabling personalized AI experiences. To include user-specific memory you can get your API key [here](https://app.mem0.ai/dashboard/api-keys) and refer the [docs](https://docs.mem0.ai/platform/quickstart#4-1-create-memories) for adding user preferences.\n```\nimport os\nfrom crewai import Crew, Process\nfrom mem0 import MemoryClient\n\n# Set environment variables for Mem0\nos.environ[\"MEM0_API_KEY\"] = \"m0-xx\"\n\n# Step 1: Record preferences based on past conversation or user input\nclient = MemoryClient()\nmessages = [\n    {\"role\": \"user\", \"content\": \"Hi there! I'm planning a vacation and could use some advice.\"},\n    {\"role\": \"assistant\", \"content\": \"Hello! I'd be happy to help with your vacation planning. What kind of destination do you prefer?\"},\n    {\"role\": \"user\", \"content\": \"I am more of a beach person than a mountain person.\"},\n    {\"role\": \"assistant\", \"content\": \"That's interesting. Do you like hotels or Airbnb?\"},\n    {\"role\": \"user\", \"content\": \"I like Airbnb more.\"},\n]\nclient.add(messages, user_id=\"john\")\n\n# Step 2: Create a Crew with User Memory\n\ncrew = Crew(\n    agents=[...],\n    tasks=[...],\n    verbose=True,\n    process=Process.sequential,\n    memory=True,\n    memory_config={\n        \"provider\": \"mem0\",\n        \"config\": {\"user_id\": \"john\"},\n    },\n)\n```",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "import os\nfrom crewai import Crew, Process\nfrom mem0 import MemoryClient\n\n# Set environment variables for Mem0\nos.environ[\"MEM0_API_KEY\"] = \"m0-xx\"\n\n# Step 1: Record preferences based on past conversation or user input\nclient = MemoryClient()\nmessages = [\n    {\"role\": \"user\", \"content\": \"Hi there! I'm planning a vacation and could use some advice.\"},\n    {\"role\": \"assistant\", \"content\": \"Hello! I'd be happy to help with your vacation planning. What kind of destination do you prefer?\"},\n    {\"role\": \"user\", \"content\": \"I am more of a beach person than a mountain person.\"},\n    {\"role\": \"assistant\", \"content\": \"That's interesting. Do you like hotels or Airbnb?\"},\n    {\"role\": \"user\", \"content\": \"I like Airbnb more.\"},\n]\nclient.add(messages, user_id=\"john\")\n\n# Step 2: Create a Crew with User Memory\n\ncrew = Crew(\n    agents=[...],\n    tasks=[...],\n    verbose=True,\n    process=Process.sequential,\n    memory=True,\n    memory_config={\n        \"provider\": \"mem0\",\n        \"config\": {\"user_id\": \"john\"},\n    },\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Memory Configuration Options",
            "level": 2,
            "content": "If you want to access a specific organization and project, you can set the `org_id` and `project_id` parameters in the memory configuration.\n```\nfrom crewai import Crew\n\ncrew = Crew(\n    agents=[...],\n    tasks=[...],\n    verbose=True,\n    memory=True,\n    memory_config={\n        \"provider\": \"mem0\",\n        \"config\": {\"user_id\": \"john\", \"org_id\": \"my_org_id\", \"project_id\": \"my_project_id\"},\n    },\n)\n```",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai import Crew\n\ncrew = Crew(\n    agents=[...],\n    tasks=[...],\n    verbose=True,\n    memory=True,\n    memory_config={\n        \"provider\": \"mem0\",\n        \"config\": {\"user_id\": \"john\", \"org_id\": \"my_org_id\", \"project_id\": \"my_project_id\"},\n    },\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Additional Embedding Providers",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": [
              {
                "type": "header",
                "title": "Using OpenAI embeddings (already default)",
                "level": 3,
                "content": "```\nfrom crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"openai\",\n        \"config\": {\n            \"model\": 'text-embedding-3-small'\n        }\n    }\n)\n```\nAlternatively, you can directly pass the OpenAIEmbeddingFunction to the embedder parameter. Example:\n```\nfrom crewai import Crew, Agent, Task, Process\nfrom chromadb.utils.embedding_functions import OpenAIEmbeddingFunction\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"openai\",\n        \"config\": {\n            \"model\": 'text-embedding-3-small'\n        }\n    }\n)\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "from crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"openai\",\n        \"config\": {\n            \"model\": 'text-embedding-3-small'\n        }\n    }\n)",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  },
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "from crewai import Crew, Agent, Task, Process\nfrom chromadb.utils.embedding_functions import OpenAIEmbeddingFunction\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"openai\",\n        \"config\": {\n            \"model\": 'text-embedding-3-small'\n        }\n    }\n)",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Using Ollama embeddings",
                "level": 3,
                "content": "```\nfrom crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"ollama\",\n        \"config\": {\n            \"model\": \"mxbai-embed-large\"\n        }\n    }\n)\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "from crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"ollama\",\n        \"config\": {\n            \"model\": \"mxbai-embed-large\"\n        }\n    }\n)",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Using Google AI embeddings",
                "level": 3,
                "content": "",
                "metadata": {
                  "section_type": "General",
                  "content_type": null
                },
                "children": [
                  {
                    "type": "header",
                    "title": "Prerequisites",
                    "level": 4,
                    "content": "",
                    "metadata": {
                      "section_type": "General",
                      "content_type": null
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Using Azure OpenAI embeddings",
                "level": 3,
                "content": "```\nfrom chromadb.utils.embedding_functions import OpenAIEmbeddingFunction\nfrom crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"openai\",\n        \"config\": {\n            \"api_key\": \"YOUR_API_KEY\",\n            \"api_base\": \"YOUR_API_BASE_PATH\",\n            \"api_version\": \"YOUR_API_VERSION\",\n            \"model_name\": 'text-embedding-3-small'\n        }\n    }\n)\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "from chromadb.utils.embedding_functions import OpenAIEmbeddingFunction\nfrom crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"openai\",\n        \"config\": {\n            \"api_key\": \"YOUR_API_KEY\",\n            \"api_base\": \"YOUR_API_BASE_PATH\",\n            \"api_version\": \"YOUR_API_VERSION\",\n            \"model_name\": 'text-embedding-3-small'\n        }\n    }\n)",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Using Vertex AI embeddings",
                "level": 3,
                "content": "```\nfrom chromadb.utils.embedding_functions import GoogleVertexEmbeddingFunction\nfrom crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"vertexai\",\n        \"config\": {\n            \"project_id\"=\"YOUR_PROJECT_ID\",\n            \"region\"=\"YOUR_REGION\",\n            \"api_key\"=\"YOUR_API_KEY\",\n            \"model_name\"=\"textembedding-gecko\"\n        }\n    }\n)\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "from chromadb.utils.embedding_functions import GoogleVertexEmbeddingFunction\nfrom crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"vertexai\",\n        \"config\": {\n            \"project_id\"=\"YOUR_PROJECT_ID\",\n            \"region\"=\"YOUR_REGION\",\n            \"api_key\"=\"YOUR_API_KEY\",\n            \"model_name\"=\"textembedding-gecko\"\n        }\n    }\n)",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Using Cohere embeddings",
                "level": 3,
                "content": "```\nfrom crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"cohere\",\n        \"config\": {\n            \"api_key\": \"YOUR_API_KEY\",\n            \"model\": \"<model_name>\"\n        }\n    }\n)\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "from crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"cohere\",\n        \"config\": {\n            \"api_key\": \"YOUR_API_KEY\",\n            \"model\": \"<model_name>\"\n        }\n    }\n)",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Using VoyageAI embeddings",
                "level": 3,
                "content": "```\nfrom crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"voyageai\",\n        \"config\": {\n            \"api_key\": \"YOUR_API_KEY\",\n            \"model\": \"<model_name>\"\n        }\n    }\n)\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "from crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"voyageai\",\n        \"config\": {\n            \"api_key\": \"YOUR_API_KEY\",\n            \"model\": \"<model_name>\"\n        }\n    }\n)",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Using HuggingFace embeddings",
                "level": 3,
                "content": "```\nfrom crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"huggingface\",\n        \"config\": {\n            \"api_url\": \"<api_url>\",\n        }\n    }\n)\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "from crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"huggingface\",\n        \"config\": {\n            \"api_url\": \"<api_url>\",\n        }\n    }\n)",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Using Watson embeddings",
                "level": 3,
                "content": "```\nfrom crewai import Crew, Agent, Task, Process\n\n# Note: Ensure you have installed and imported `ibm_watsonx_ai` for Watson embeddings to work.\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"watson\",\n        \"config\": {\n            \"model\": \"<model_name>\",\n            \"api_url\": \"<api_url>\",\n            \"api_key\": \"<YOUR_API_KEY>\",\n            \"project_id\": \"<YOUR_PROJECT_ID>\",\n        }\n    }\n)\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "from crewai import Crew, Agent, Task, Process\n\n# Note: Ensure you have installed and imported `ibm_watsonx_ai` for Watson embeddings to work.\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"watson\",\n        \"config\": {\n            \"model\": \"<model_name>\",\n            \"api_url\": \"<api_url>\",\n            \"api_key\": \"<YOUR_API_KEY>\",\n            \"project_id\": \"<YOUR_PROJECT_ID>\",\n        }\n    }\n)",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Using Amazon Bedrock embeddings",
                "level": 3,
                "content": "```\n# Note: Ensure you have installed `boto3` for Bedrock embeddings to work.\n\nimport os\nimport boto3\nfrom crewai import Crew, Agent, Task, Process\n\nboto3_session = boto3.Session(\n    region_name=os.environ.get(\"AWS_REGION_NAME\"),\n    aws_access_key_id=os.environ.get(\"AWS_ACCESS_KEY_ID\"),\n    aws_secret_access_key=os.environ.get(\"AWS_SECRET_ACCESS_KEY\")\n)\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    embedder={\n    \"provider\": \"bedrock\",\n        \"config\":{\n            \"session\": boto3_session,\n            \"model\": \"amazon.titan-embed-text-v2:0\",\n            \"vector_dimension\": 1024\n        }\n    }\n    verbose=True\n)\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "# Note: Ensure you have installed `boto3` for Bedrock embeddings to work.\n\nimport os\nimport boto3\nfrom crewai import Crew, Agent, Task, Process\n\nboto3_session = boto3.Session(\n    region_name=os.environ.get(\"AWS_REGION_NAME\"),\n    aws_access_key_id=os.environ.get(\"AWS_ACCESS_KEY_ID\"),\n    aws_secret_access_key=os.environ.get(\"AWS_SECRET_ACCESS_KEY\")\n)\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    embedder={\n    \"provider\": \"bedrock\",\n        \"config\":{\n            \"session\": boto3_session,\n            \"model\": \"amazon.titan-embed-text-v2:0\",\n            \"vector_dimension\": 1024\n        }\n    }\n    verbose=True\n)",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Adding Custom Embedding Function",
                "level": 3,
                "content": "```\nfrom crewai import Crew, Agent, Task, Process\nfrom chromadb import Documents, EmbeddingFunction, Embeddings\n\n# Create a custom embedding function\nclass CustomEmbedder(EmbeddingFunction):\n    def __call__(self, input: Documents) -> Embeddings:\n        # generate embeddings\n        return [1, 2, 3] # this is a dummy embedding\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"custom\",\n        \"config\": {\n            \"embedder\": CustomEmbedder()\n        }\n    }\n)\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "from crewai import Crew, Agent, Task, Process\nfrom chromadb import Documents, EmbeddingFunction, Embeddings\n\n# Create a custom embedding function\nclass CustomEmbedder(EmbeddingFunction):\n    def __call__(self, input: Documents) -> Embeddings:\n        # generate embeddings\n        return [1, 2, 3] # this is a dummy embedding\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"custom\",\n        \"config\": {\n            \"embedder\": CustomEmbedder()\n        }\n    }\n)",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Resetting Memory via cli",
                "level": 3,
                "content": "```\ncrewai reset-memories [OPTIONS]\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [
                  {
                    "type": "header",
                    "title": "Resetting Memory Options",
                    "level": 4,
                    "content": "",
                    "metadata": {
                      "section_type": "General",
                      "content_type": null
                    },
                    "children": []
                  }
                ],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "shell",
                    "content": "crewai reset-memories [OPTIONS]",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Resetting Memory via crew object",
                "level": 3,
                "content": "```\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"custom\",\n        \"config\": {\n            \"embedder\": CustomEmbedder()\n        }\n    }\n)\n\nmy_crew.reset_memories(command_type = 'all') # Resets all the memory\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [
                  {
                    "type": "header",
                    "title": "Resetting Memory Options",
                    "level": 4,
                    "content": "| Option                    | Description                        | Type           | Default |\n| :------------------------ | :--------------------------------- | :------------- | :------ |\n| `-l`, `--long`            | Reset LONG TERM memory.            | Flag (boolean) | False   |\n| `-s`, `--short`           | Reset SHORT TERM memory.           | Flag (boolean) | False   |\n| `-e`, `--entities`        | Reset ENTITIES memory.             | Flag (boolean) | False   |\n| `-k`, `--kickoff-outputs` | Reset LATEST KICKOFF TASK OUTPUTS. | Flag (boolean) | False   |\n| `-kn`, `--knowledge`      | Reset KNOWLEDEGE storage           | Flag (boolean) | False   |\n| `-a`, `--all`             | Reset ALL memories.                | Flag (boolean) | False   | Note: To use the cli command you need to have your crew in a file called crew\\.py in the same directory.\n\n| Command Type      | Description                        |\n| :---------------- | :--------------------------------- |\n| `long`            | Reset LONG TERM memory.            |\n| `short`           | Reset SHORT TERM memory.           |\n| `entities`        | Reset ENTITIES memory.             |\n| `kickoff_outputs` | Reset LATEST KICKOFF TASK OUTPUTS. |\n| `knowledge`       | Reset KNOWLEDGE memory.            |\n| `all`             | Reset ALL memories.                |",
                    "metadata": {
                      "section_type": "General",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "my_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"custom\",\n        \"config\": {\n            \"embedder\": CustomEmbedder()\n        }\n    }\n)\n\nmy_crew.reset_memories(command_type = 'all') # Resets all the memory",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              }
            ]
          },
          {
            "type": "header",
            "title": "Benefits of Using CrewAI's Memory System",
            "level": 2,
            "content": "\ud83e\uddbe **Adaptive Learning:** Crews become more efficient over time, adapting to new information and refining their approach to tasks. \ud83e\udee1 **Enhanced Personalization:** Memory enables agents to remember user preferences and historical interactions, leading to personalized experiences. \ud83e\udde0 **Improved Problem Solving:** Access to a rich memory store aids agents in making more informed decisions, drawing on past learnings and contextual insights.",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Conclusion",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Planning",
        "level": 1,
        "content": "Source: https://docs.crewai.com/concepts/planning Learn how to add planning to your CrewAI Crew and improve their performance.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": [
          {
            "type": "header",
            "title": "Introduction",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": [
              {
                "type": "header",
                "title": "Using the Planning Feature",
                "level": 3,
                "content": "Getting started with the planning feature is very easy, the only step required is to add `planning=True` to your Crew:",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              }
            ]
          }
        ]
      },
      {
        "type": "header",
        "title": "Assemble your crew with planning capabilities",
        "level": 1,
        "content": "my_crew = Crew(\n      agents=self.agents,\n      tasks=self.tasks,\n      process=Process.sequential,\n      planning=True,\n  )\n```\n</CodeGroup>\n\nFrom this point on, your crew will have planning enabled, and the tasks will be planned before each iteration.\n\n#### Planning LLM\n\nNow you can define the LLM that will be used to plan the tasks.\n\nWhen running the base case example, you will see something like the output below, which represents the output of the `AgentPlanner`\nresponsible for creating the step-by-step logic to add to the Agents' tasks.\n\n<CodeGroup>\n```python Code\nfrom crewai import Crew, Agent, Task, Process\n\n# Assemble your crew with planning capabilities and custom LLM\nmy_crew = Crew(\n    agents=self.agents,\n    tasks=self.tasks,\n    process=Process.sequential,\n    planning=True,\n    planning_llm=\"gpt-4o\"\n)\n\n# Run the crew\nmy_crew.kickoff()\n```\n\n```\n[2024-07-15 16:49:11][INFO]: Planning the crew execution\n**Step-by-Step Plan for Task Execution**\n\n**Task Number 1: Conduct a thorough research about AI LLMs**\n\n**Agent:** AI LLMs Senior Data Researcher\n\n**Agent Goal:** Uncover cutting-edge developments in AI LLMs\n\n**Task Expected Output:** A list with 10 bullet points of the most relevant information about AI LLMs\n\n**Task Tools:** None specified\n\n**Agent Tools:** None specified\n\n**Step-by-Step Plan:**\n\n1. **Define Research Scope:**\n\n   - Determine the specific areas of AI LLMs to focus on, such as advancements in architecture, use cases, ethical considerations, and performance metrics.\n\n2. **Identify Reliable Sources:**\n\n   - List reputable sources for AI research, including academic journals, industry reports, conferences (e.g., NeurIPS, ACL), AI research labs (e.g., OpenAI, Google AI), and online databases (e.g., IEEE Xplore, arXiv).\n\n3. **Collect Data:**\n\n   - Search for the latest papers, articles, and reports published in 2024 and early 2025.\n   - Use keywords like \"Large Language Models 2025\", \"AI LLM advancements\", \"AI ethics 2025\", etc.\n\n4. **Analyze Findings:**\n\n   - Read and summarize the key points from each source.\n   - Highlight new techniques, models, and applications introduced in the past year.\n\n5. **Organize Information:**\n\n   - Categorize the information into relevant topics (e.g., new architectures, ethical implications, real-world applications).\n   - Ensure each bullet point is concise but informative.\n\n6. **Create the List:**\n\n   - Compile the 10 most relevant pieces of information into a bullet point list.\n   - Review the list to ensure clarity and relevance.\n\n**Expected Output:**\n\nA list with 10 bullet points of the most relevant information about AI LLMs.\n\n---\n\n**Task Number 2: Review the context you got and expand each topic into a full section for a report**\n\n**Agent:** AI LLMs Reporting Analyst\n\n**Agent Goal:** Create detailed reports based on AI LLMs data analysis and research findings\n\n**Task Expected Output:** A fully fledged report with the main topics, each with a full section of information. Formatted as markdown without '```'\n\n**Task Tools:** None specified\n\n**Agent Tools:** None specified\n\n**Step-by-Step Plan:**\n\n1. **Review the Bullet Points:**\n   - Carefully read through the list of 10 bullet points provided by the AI LLMs Senior Data Researcher.\n\n2. **Outline the Report:**\n   - Create an outline with each bullet point as a main section heading.\n   - Plan sub-sections under each main heading to cover different aspects of the topic.\n\n3. **Research Further Details:**\n   - For each bullet point, conduct additional research if necessary to gather more detailed information.\n   - Look for case studies, examples, and statistical data to support each section.\n\n4. **Write Detailed Sections:**\n   - Expand each bullet point into a comprehensive section.\n   - Ensure each section includes an introduction, detailed explanation, examples, and a conclusion.\n   - Use markdown formatting for headings, subheadings, lists, and emphasis.\n\n5. **Review and Edit:**\n   - Proofread the report for clarity, coherence, and correctness.\n   - Make sure the report flows logically from one section to the next.\n   - Format the report according to markdown standards.\n\n6. **Finalize the Report:**\n   - Ensure the report is complete with all sections expanded and detailed.\n   - Double-check formatting and make any necessary adjustments.\n\n**Expected Output:**\nA fully fledged report with the main topics, each with a full section of information. Formatted as markdown without '```'.\n```",
        "metadata": {
          "section_type": "General",
          "content_type": "code_example"
        },
        "children": [],
        "code_blocks": [
          {
            "type": "code_block",
            "language": null,
            "content": "</CodeGroup>\n\nFrom this point on, your crew will have planning enabled, and the tasks will be planned before each iteration.\n\n#### Planning LLM\n\nNow you can define the LLM that will be used to plan the tasks.\n\nWhen running the base case example, you will see something like the output below, which represents the output of the `AgentPlanner`\nresponsible for creating the step-by-step logic to add to the Agents' tasks.\n\n<CodeGroup>\n```python Code\nfrom crewai import Crew, Agent, Task, Process\n\n# Assemble your crew with planning capabilities and custom LLM\nmy_crew = Crew(\n    agents=self.agents,\n    tasks=self.tasks,\n    process=Process.sequential,\n    planning=True,\n    planning_llm=\"gpt-4o\"\n)\n\n# Run the crew\nmy_crew.kickoff()",
            "metadata": {
              "section_type": "code",
              "content_type": "code_example"
            },
            "children": []
          },
          {
            "type": "code_block",
            "language": "markdown Result",
            "content": "[2024-07-15 16:49:11][INFO]: Planning the crew execution\n**Step-by-Step Plan for Task Execution**\n\n**Task Number 1: Conduct a thorough research about AI LLMs**\n\n**Agent:** AI LLMs Senior Data Researcher\n\n**Agent Goal:** Uncover cutting-edge developments in AI LLMs\n\n**Task Expected Output:** A list with 10 bullet points of the most relevant information about AI LLMs\n\n**Task Tools:** None specified\n\n**Agent Tools:** None specified\n\n**Step-by-Step Plan:**\n\n1. **Define Research Scope:**\n\n   - Determine the specific areas of AI LLMs to focus on, such as advancements in architecture, use cases, ethical considerations, and performance metrics.\n\n2. **Identify Reliable Sources:**\n\n   - List reputable sources for AI research, including academic journals, industry reports, conferences (e.g., NeurIPS, ACL), AI research labs (e.g., OpenAI, Google AI), and online databases (e.g., IEEE Xplore, arXiv).\n\n3. **Collect Data:**\n\n   - Search for the latest papers, articles, and reports published in 2024 and early 2025.\n   - Use keywords like \"Large Language Models 2025\", \"AI LLM advancements\", \"AI ethics 2025\", etc.\n\n4. **Analyze Findings:**\n\n   - Read and summarize the key points from each source.\n   - Highlight new techniques, models, and applications introduced in the past year.\n\n5. **Organize Information:**\n\n   - Categorize the information into relevant topics (e.g., new architectures, ethical implications, real-world applications).\n   - Ensure each bullet point is concise but informative.\n\n6. **Create the List:**\n\n   - Compile the 10 most relevant pieces of information into a bullet point list.\n   - Review the list to ensure clarity and relevance.\n\n**Expected Output:**\n\nA list with 10 bullet points of the most relevant information about AI LLMs.\n\n---\n\n**Task Number 2: Review the context you got and expand each topic into a full section for a report**\n\n**Agent:** AI LLMs Reporting Analyst\n\n**Agent Goal:** Create detailed reports based on AI LLMs data analysis and research findings\n\n**Task Expected Output:** A fully fledged report with the main topics, each with a full section of information. Formatted as markdown without '```'\n\n**Task Tools:** None specified\n\n**Agent Tools:** None specified\n\n**Step-by-Step Plan:**\n\n1. **Review the Bullet Points:**\n   - Carefully read through the list of 10 bullet points provided by the AI LLMs Senior Data Researcher.\n\n2. **Outline the Report:**\n   - Create an outline with each bullet point as a main section heading.\n   - Plan sub-sections under each main heading to cover different aspects of the topic.\n\n3. **Research Further Details:**\n   - For each bullet point, conduct additional research if necessary to gather more detailed information.\n   - Look for case studies, examples, and statistical data to support each section.\n\n4. **Write Detailed Sections:**\n   - Expand each bullet point into a comprehensive section.\n   - Ensure each section includes an introduction, detailed explanation, examples, and a conclusion.\n   - Use markdown formatting for headings, subheadings, lists, and emphasis.\n\n5. **Review and Edit:**\n   - Proofread the report for clarity, coherence, and correctness.\n   - Make sure the report flows logically from one section to the next.\n   - Format the report according to markdown standards.\n\n6. **Finalize the Report:**\n   - Ensure the report is complete with all sections expanded and detailed.\n   - Double-check formatting and make any necessary adjustments.\n\n**Expected Output:**\nA fully fledged report with the main topics, each with a full section of information. Formatted as markdown without '```'.",
            "metadata": {
              "section_type": "code",
              "content_type": "code_example"
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Processes",
        "level": 1,
        "content": "Source: https://docs.crewai.com/concepts/processes Detailed guide on workflow management through processes in CrewAI, with updated implementation details.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": [
          {
            "type": "header",
            "title": "Understanding Processes",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Process Implementations",
            "level": 2,
            "content": "**Sequential**: Executes tasks sequentially, ensuring tasks are completed in an orderly progression. **Hierarchical**: Organizes tasks in a managerial hierarchy, where tasks are delegated and executed based on a structured chain of command. A manager language model (`manager_llm`) or a custom manager agent (`manager_agent`) must be specified in the crew to enable the hierarchical process, facilitating the creation and management of tasks by the manager. **Consensual Process (Planned)**: Aiming for collaborative decision-making among agents on task execution, this process type introduces a democratic approach to task management within CrewAI. It is planned for future development and is not currently implemented in the codebase.",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "The Role of Processes in Teamwork",
            "level": 2,
            "content": "Processes enable individual agents to operate as a cohesive unit, streamlining their efforts to achieve common objectives with efficiency and coherence.",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Assigning Processes to a Crew",
            "level": 2,
            "content": "To assign a process to a crew, specify the process type upon crew creation to set the execution strategy. For a hierarchical process, ensure to define `manager_llm` or `manager_agent` for the manager agent.\n```\nfrom crewai import Crew, Process\n\n# Example: Creating a crew with a sequential process\ncrew = Crew(\n    agents=my_agents,\n    tasks=my_tasks,\n    process=Process.sequential\n)\n\n# Example: Creating a crew with a hierarchical process\n# Ensure to provide a manager_llm or manager_agent\ncrew = Crew(\n    agents=my_agents,\n    tasks=my_tasks,\n    process=Process.hierarchical,\n    manager_llm=\"gpt-4o\"\n    # or\n    # manager_agent=my_manager_agent\n)\n```\n**Note:** Ensure `my_agents` and `my_tasks` are defined prior to creating a `Crew` object, and for the hierarchical process, either `manager_llm` or `manager_agent` is also required.",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python",
                "content": "from crewai import Crew, Process\n\n# Example: Creating a crew with a sequential process\ncrew = Crew(\n    agents=my_agents,\n    tasks=my_tasks,\n    process=Process.sequential\n)\n\n# Example: Creating a crew with a hierarchical process\n# Ensure to provide a manager_llm or manager_agent\ncrew = Crew(\n    agents=my_agents,\n    tasks=my_tasks,\n    process=Process.hierarchical,\n    manager_llm=\"gpt-4o\"\n    # or\n    # manager_agent=my_manager_agent\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Sequential Process",
            "level": 2,
            "content": "This method mirrors dynamic team workflows, progressing through tasks in a thoughtful and systematic manner. Task execution follows the predefined order in the task list, with the output of one task serving as context for the next. To customize task context, utilize the `context` parameter in the `Task` class to specify outputs that should be used as context for subsequent tasks.",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Hierarchical Process",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Process Class: Detailed Overview",
            "level": 2,
            "content": "The `Process` class is implemented as an enumeration (`Enum`), ensuring type safety and restricting process values to the defined types (`sequential`, `hierarchical`). The consensual process is planned for future inclusion, emphasizing our commitment to continuous development and innovation.",
            "metadata": {
              "section_type": "Concepts documentation",
              "content_type": "code_example"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Conclusion",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Tasks",
        "level": 1,
        "content": "Source: https://docs.crewai.com/concepts/tasks Detailed guide on managing and creating tasks within the CrewAI framework.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": [
          {
            "type": "header",
            "title": "Overview of a Task",
            "level": 2,
            "content": "In the CrewAI framework, a `Task` is a specific assignment completed by an `Agent`. Tasks provide all necessary details for execution, such as a description, the agent responsible, required tools, and more, facilitating a wide range of action complexities. Tasks within CrewAI can be collaborative, requiring multiple agents to work together. This is managed through the task properties and orchestrated by the Crew's process, enhancing teamwork and efficiency.",
            "metadata": {
              "section_type": "Concepts documentation",
              "content_type": "descriptive_text"
            },
            "children": [
              {
                "type": "header",
                "title": "Task Execution Flow",
                "level": 3,
                "content": "Tasks can be executed in two ways: **Sequential**: Tasks are executed in the order they are defined **Hierarchical**: Tasks are assigned to agents based on their roles and expertise The execution flow is defined when creating the crew:\n```\ncrew = Crew(\n    agents=[agent1, agent2],\n    tasks=[task1, task2],\n    process=Process.sequential  # or Process.hierarchical\n)\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "crew = Crew(\n    agents=[agent1, agent2],\n    tasks=[task1, task2],\n    process=Process.sequential  # or Process.hierarchical\n)",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              }
            ]
          },
          {
            "type": "header",
            "title": "Task Attributes",
            "level": 2,
            "content": "| Attribute                        | Parameters        | Type                        | Description                                                                                   |\n| :------------------------------- | :---------------- | :-------------------------- | :-------------------------------------------------------------------------------------------- |\n| **Description**                  | `description`     | `str`                       | A clear, concise statement of what the task entails.                                          |\n| **Expected Output**              | `expected_output` | `str`                       | A detailed description of what the task's completion looks like.                              |\n| **Name** *(optional)*            | `name`            | `Optional[str]`             | A name identifier for the task.                                                               |\n| **Agent** *(optional)*           | `agent`           | `Optional[BaseAgent]`       | The agent responsible for executing the task.                                                 |\n| **Tools** *(optional)*           | `tools`           | `List[BaseTool]`            | The tools/resources the agent is limited to use for this task.                                |\n| **Context** *(optional)*         | `context`         | `Optional[List[\"Task\"]]`    | Other tasks whose outputs will be used as context for this task.                              |\n| **Async Execution** *(optional)* | `async_execution` | `Optional[bool]`            | Whether the task should be executed asynchronously. Defaults to False.                        |\n| **Human Input** *(optional)*     | `human_input`     | `Optional[bool]`            | Whether the task should have a human review the final answer of the agent. Defaults to False. |\n| **Config** *(optional)*          | `config`          | `Optional[Dict[str, Any]]`  | Task-specific configuration parameters.                                                       |\n| **Output File** *(optional)*     | `output_file`     | `Optional[str]`             | File path for storing the task output.                                                        |\n| **Output JSON** *(optional)*     | `output_json`     | `Optional[Type[BaseModel]]` | A Pydantic model to structure the JSON output.                                                |\n| **Output Pydantic** *(optional)* | `output_pydantic` | `Optional[Type[BaseModel]]` | A Pydantic model for task output.                                                             |\n| **Callback** *(optional)*        | `callback`        | `Optional[Any]`             | Function/object to be executed after task completion.                                         |",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Creating Tasks",
            "level": 2,
            "content": "There are two ways to create tasks in CrewAI: using **YAML configuration (recommended)** or defining them **directly in code**.",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": [
              {
                "type": "header",
                "title": "YAML Configuration (Recommended)",
                "level": 3,
                "content": "Using YAML configuration provides a cleaner, more maintainable way to define agents. We strongly recommend using this approach in your CrewAI projects. After creating your CrewAI project as outlined in the [Installation](/installation) section, navigate to the `src/latest_ai_development/config/agents.yaml` file and modify the template to match your requirements.\n```\ncrew.kickoff(inputs={'topic': 'AI Agents'})\n```\nHere's an example of how to configure agents using YAML:\n```\n# src/latest_ai_development/config/agents.yaml\nresearcher:\n  role: >\n    {topic} Senior Data Researcher\n  goal: >\n    Uncover cutting-edge developments in {topic}\n  backstory: >\n    You're a seasoned researcher with a knack for uncovering the latest\n    developments in {topic}. Known for your ability to find the most relevant\n    information and present it in a clear and concise manner.\n\nreporting_analyst:\n  role: >\n    {topic} Reporting Analyst\n  goal: >\n    Create detailed reports based on {topic} data analysis and research findings\n  backstory: >\n    You're a meticulous analyst with a keen eye for detail. You're known for\n    your ability to turn complex data into clear and concise reports, making\n    it easy for others to understand and act on the information you provide.\n```\nTo use this YAML configuration in your code, create a crew class that inherits from `CrewBase`:\n```\n# src/latest_ai_development/crew.py\nfrom crewai import Agent, Crew, Process\nfrom crewai.project import CrewBase, agent, crew\nfrom crewai_tools import SerperDevTool\n\n@CrewBase\nclass LatestAiDevelopmentCrew():\n  \"\"\"LatestAiDevelopment crew\"\"\"\n\n  agents_config = \"config/agents.yaml\"\n\n  @agent\n  def researcher(self) -> Agent:\n    return Agent(\n      config=self.agents_config['researcher'],\n      verbose=True,\n      tools=[SerperDevTool()]\n    )\n\n  @agent\n  def reporting_analyst(self) -> Agent:\n    return Agent(\n      config=self.agents_config['reporting_analyst'],\n      verbose=True\n    )\n```\n\nUsing YAML configuration provides a cleaner, more maintainable way to define crews and is consistent with how agents and tasks are defined in CrewAI projects. After creating your CrewAI project as outlined in the [Installation](/installation) section, you can define your crew in a class that inherits from `CrewBase` and uses decorators to define agents, tasks, and the crew itself.\n\nUsing YAML configuration provides a cleaner, more maintainable way to define tasks. We strongly recommend using this approach to define tasks in your CrewAI projects. After creating your CrewAI project as outlined in the [Installation](/installation) section, navigate to the `src/latest_ai_development/config/tasks.yaml` file and modify the template to match your specific task requirements.\n```\ncrew.kickoff(inputs={'topic': 'AI Agents'})\n```\nHere's an example of how to configure tasks using YAML:\n```\nresearch_task:\n  description: >\n    Conduct a thorough research about {topic}\n    Make sure you find any interesting and relevant information given\n    the current year is 2025.\n  expected_output: >\n    A list with 10 bullet points of the most relevant information about {topic}\n  agent: researcher\n\nreporting_task:\n  description: >\n    Review the context you got and expand each topic into a full section for a report.\n    Make sure the report is detailed and contains any and all relevant information.\n  expected_output: >\n    A fully fledge reports with the mains topics, each with a full section of information.\n    Formatted as markdown without '```'\n  agent: reporting_analyst\n  output_file: report.md\n```\nTo use this YAML configuration in your code, create a crew class that inherits from `CrewBase`:\n```\n# src/latest_ai_development/crew.py\n\nfrom crewai import Agent, Crew, Process, Task\nfrom crewai.project import CrewBase, agent, crew, task\nfrom crewai_tools import SerperDevTool\n\n@CrewBase\nclass LatestAiDevelopmentCrew():\n  \"\"\"LatestAiDevelopment crew\"\"\"\n\n  @agent\n  def researcher(self) -> Agent:\n    return Agent(\n      config=self.agents_config['researcher'],\n      verbose=True,\n      tools=[SerperDevTool()]\n    )\n\n  @agent\n  def reporting_analyst(self) -> Agent:\n    return Agent(\n      config=self.agents_config['reporting_analyst'],\n      verbose=True\n    )\n\n  @task\n  def research_task(self) -> Task:\n    return Task(\n      config=self.tasks_config['research_task']\n    )\n\n  @task\n  def reporting_task(self) -> Task:\n    return Task(\n      config=self.tasks_config['reporting_task']\n    )\n\n  @crew\n  def crew(self) -> Crew:\n    return Crew(\n      agents=[\n        self.researcher(),\n        self.reporting_analyst()\n      ],\n      tasks=[\n        self.research_task(),\n        self.reporting_task()\n      ],\n      process=Process.sequential\n    )\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "crew.kickoff(inputs={'topic': 'AI Agents'})",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  },
                  {
                    "type": "code_block",
                    "language": "yaml agents.yaml",
                    "content": "# src/latest_ai_development/config/agents.yaml\nresearcher:\n  role: >\n    {topic} Senior Data Researcher\n  goal: >\n    Uncover cutting-edge developments in {topic}\n  backstory: >\n    You're a seasoned researcher with a knack for uncovering the latest\n    developments in {topic}. Known for your ability to find the most relevant\n    information and present it in a clear and concise manner.\n\nreporting_analyst:\n  role: >\n    {topic} Reporting Analyst\n  goal: >\n    Create detailed reports based on {topic} data analysis and research findings\n  backstory: >\n    You're a meticulous analyst with a keen eye for detail. You're known for\n    your ability to turn complex data into clear and concise reports, making\n    it easy for others to understand and act on the information you provide.",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  },
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "# src/latest_ai_development/crew.py\nfrom crewai import Agent, Crew, Process\nfrom crewai.project import CrewBase, agent, crew\nfrom crewai_tools import SerperDevTool\n\n@CrewBase\nclass LatestAiDevelopmentCrew():\n  \"\"\"LatestAiDevelopment crew\"\"\"\n\n  agents_config = \"config/agents.yaml\"\n\n  @agent\n  def researcher(self) -> Agent:\n    return Agent(\n      config=self.agents_config['researcher'],\n      verbose=True,\n      tools=[SerperDevTool()]\n    )\n\n  @agent\n  def reporting_analyst(self) -> Agent:\n    return Agent(\n      config=self.agents_config['reporting_analyst'],\n      verbose=True\n    )",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  },
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "crew.kickoff(inputs={'topic': 'AI Agents'})",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  },
                  {
                    "type": "code_block",
                    "language": "yaml tasks.yaml",
                    "content": "research_task:\n  description: >\n    Conduct a thorough research about {topic}\n    Make sure you find any interesting and relevant information given\n    the current year is 2025.\n  expected_output: >\n    A list with 10 bullet points of the most relevant information about {topic}\n  agent: researcher\n\nreporting_task:\n  description: >\n    Review the context you got and expand each topic into a full section for a report.\n    Make sure the report is detailed and contains any and all relevant information.\n  expected_output: >\n    A fully fledge reports with the mains topics, each with a full section of information.\n    Formatted as markdown without '```'\n  agent: reporting_analyst\n  output_file: report.md",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  },
                  {
                    "type": "code_block",
                    "language": "python crew.py",
                    "content": "# src/latest_ai_development/crew.py\n\nfrom crewai import Agent, Crew, Process, Task\nfrom crewai.project import CrewBase, agent, crew, task\nfrom crewai_tools import SerperDevTool\n\n@CrewBase\nclass LatestAiDevelopmentCrew():\n  \"\"\"LatestAiDevelopment crew\"\"\"\n\n  @agent\n  def researcher(self) -> Agent:\n    return Agent(\n      config=self.agents_config['researcher'],\n      verbose=True,\n      tools=[SerperDevTool()]\n    )\n\n  @agent\n  def reporting_analyst(self) -> Agent:\n    return Agent(\n      config=self.agents_config['reporting_analyst'],\n      verbose=True\n    )\n\n  @task\n  def research_task(self) -> Task:\n    return Task(\n      config=self.tasks_config['research_task']\n    )\n\n  @task\n  def reporting_task(self) -> Task:\n    return Task(\n      config=self.tasks_config['reporting_task']\n    )\n\n  @crew\n  def crew(self) -> Crew:\n    return Crew(\n      agents=[\n        self.researcher(),\n        self.reporting_analyst()\n      ],\n      tasks=[\n        self.research_task(),\n        self.reporting_task()\n      ],\n      process=Process.sequential\n    )",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Direct Code Definition (Alternative)",
                "level": 3,
                "content": "Alternatively, you can define the crew directly in code without using YAML configuration files.\n```\nfrom crewai import Agent, Crew, Task, Process\nfrom crewai_tools import YourCustomTool\n\nclass YourCrewName:\n    def agent_one(self) -> Agent:\n        return Agent(\n            role=\"Data Analyst\",\n            goal=\"Analyze data trends in the market\",\n            backstory=\"An experienced data analyst with a background in economics\",\n            verbose=True,\n            tools=[YourCustomTool()]\n        )\n\n    def agent_two(self) -> Agent:\n        return Agent(\n            role=\"Market Researcher\",\n            goal=\"Gather information on market dynamics\",\n            backstory=\"A diligent researcher with a keen eye for detail\",\n            verbose=True\n        )\n\n    def task_one(self) -> Task:\n        return Task(\n            description=\"Collect recent market data and identify trends.\",\n            expected_output=\"A report summarizing key trends in the market.\",\n            agent=self.agent_one()\n        )\n\n    def task_two(self) -> Task:\n        return Task(\n            description=\"Research factors affecting market dynamics.\",\n            expected_output=\"An analysis of factors influencing the market.\",\n            agent=self.agent_two()\n        )\n\n    def crew(self) -> Crew:\n        return Crew(\n            agents=[self.agent_one(), self.agent_two()],\n            tasks=[self.task_one(), self.task_two()],\n            process=Process.sequential,\n            verbose=True\n        )\n```\nIn this example: Agents and tasks are defined directly within the class without decorators. We manually create and manage the list of agents and tasks. This approach provides more control but can be less maintainable for larger projects.\n\nAlternatively, you can define tasks directly in your code without using YAML configuration:\n```\nfrom crewai import Task\n\nresearch_task = Task(\n    description=\"\"\"\n        Conduct a thorough research about AI Agents.\n        Make sure you find any interesting and relevant information given\n        the current year is 2025.\n    \"\"\",\n    expected_output=\"\"\"\n        A list with 10 bullet points of the most relevant information about AI Agents\n    \"\"\",\n    agent=researcher\n)\n\nreporting_task = Task(\n    description=\"\"\"\n        Review the context you got and expand each topic into a full section for a report.\n        Make sure the report is detailed and contains any and all relevant information.\n    \"\"\",\n    expected_output=\"\"\"\n        A fully fledge reports with the mains topics, each with a full section of information.\n        Formatted as markdown without '```'\n    \"\"\",\n    agent=reporting_analyst,\n    output_file=\"report.md\"\n)\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python code",
                    "content": "from crewai import Agent, Crew, Task, Process\nfrom crewai_tools import YourCustomTool\n\nclass YourCrewName:\n    def agent_one(self) -> Agent:\n        return Agent(\n            role=\"Data Analyst\",\n            goal=\"Analyze data trends in the market\",\n            backstory=\"An experienced data analyst with a background in economics\",\n            verbose=True,\n            tools=[YourCustomTool()]\n        )\n\n    def agent_two(self) -> Agent:\n        return Agent(\n            role=\"Market Researcher\",\n            goal=\"Gather information on market dynamics\",\n            backstory=\"A diligent researcher with a keen eye for detail\",\n            verbose=True\n        )\n\n    def task_one(self) -> Task:\n        return Task(\n            description=\"Collect recent market data and identify trends.\",\n            expected_output=\"A report summarizing key trends in the market.\",\n            agent=self.agent_one()\n        )\n\n    def task_two(self) -> Task:\n        return Task(\n            description=\"Research factors affecting market dynamics.\",\n            expected_output=\"An analysis of factors influencing the market.\",\n            agent=self.agent_two()\n        )\n\n    def crew(self) -> Crew:\n        return Crew(\n            agents=[self.agent_one(), self.agent_two()],\n            tasks=[self.task_one(), self.task_two()],\n            process=Process.sequential,\n            verbose=True\n        )",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  },
                  {
                    "type": "code_block",
                    "language": "python task.py",
                    "content": "from crewai import Task\n\nresearch_task = Task(\n    description=\"\"\"\n        Conduct a thorough research about AI Agents.\n        Make sure you find any interesting and relevant information given\n        the current year is 2025.\n    \"\"\",\n    expected_output=\"\"\"\n        A list with 10 bullet points of the most relevant information about AI Agents\n    \"\"\",\n    agent=researcher\n)\n\nreporting_task = Task(\n    description=\"\"\"\n        Review the context you got and expand each topic into a full section for a report.\n        Make sure the report is detailed and contains any and all relevant information.\n    \"\"\",\n    expected_output=\"\"\"\n        A fully fledge reports with the mains topics, each with a full section of information.\n        Formatted as markdown without '```'\n    \"\"\",\n    agent=reporting_analyst,\n    output_file=\"report.md\"\n)",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              }
            ]
          },
          {
            "type": "header",
            "title": "Task Output",
            "level": 2,
            "content": "Understanding task outputs is crucial for building effective AI workflows. CrewAI provides a structured way to handle task results through the `TaskOutput` class, which supports multiple output formats and can be easily passed between tasks. The output of a task in CrewAI framework is encapsulated within the `TaskOutput` class. This class provides a structured way to access results of a task, including various formats such as raw output, JSON, and Pydantic models. By default, the `TaskOutput` will only include the `raw` output. A `TaskOutput` will only include the `pydantic` or `json_dict` output if the original `Task` object was configured with `output_pydantic` or `output_json`, respectively.",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": [
              {
                "type": "header",
                "title": "Task Output Attributes",
                "level": 3,
                "content": "| Attribute         | Parameters      | Type                       | Description                                                                                        |\n| :---------------- | :-------------- | :------------------------- | :------------------------------------------------------------------------------------------------- |\n| **Description**   | `description`   | `str`                      | Description of the task.                                                                           |\n| **Summary**       | `summary`       | `Optional[str]`            | Summary of the task, auto-generated from the first 10 words of the description.                    |\n| **Raw**           | `raw`           | `str`                      | The raw output of the task. This is the default format for the output.                             |\n| **Pydantic**      | `pydantic`      | `Optional[BaseModel]`      | A Pydantic model object representing the structured output of the task.                            |\n| **JSON Dict**     | `json_dict`     | `Optional[Dict[str, Any]]` | A dictionary representing the JSON output of the task.                                             |\n| **Agent**         | `agent`         | `str`                      | The agent that executed the task.                                                                  |\n| **Output Format** | `output_format` | `OutputFormat`             | The format of the task output, with options including RAW, JSON, and Pydantic. The default is RAW. |",
                "metadata": {
                  "section_type": "General",
                  "content_type": "descriptive_text"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Task Methods and Properties",
                "level": 3,
                "content": "| Method/Property | Description                                                                                       |\n| :-------------- | :------------------------------------------------------------------------------------------------ |\n| **json**        | Returns the JSON string representation of the task output if the output format is JSON.           |\n| **to\\_dict**    | Converts the JSON and Pydantic outputs to a dictionary.                                           |\n| **str**         | Returns the string representation of the task output, prioritizing Pydantic, then JSON, then raw. |",
                "metadata": {
                  "section_type": "General",
                  "content_type": "descriptive_text"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Accessing Task Outputs",
                "level": 3,
                "content": "Once a task has been executed, its output can be accessed through the `output` attribute of the `Task` object. The `TaskOutput` class provides various ways to interact with and present this output.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": [
                  {
                    "type": "header",
                    "title": "Example",
                    "level": 4,
                    "content": "",
                    "metadata": {
                      "section_type": "Examples",
                      "content_type": null
                    },
                    "children": []
                  }
                ]
              }
            ]
          },
          {
            "type": "header",
            "title": "Task Dependencies and Context",
            "level": 2,
            "content": "Tasks can depend on the output of other tasks using the `context` attribute. For example:\n```\nresearch_task = Task(\n    description=\"Research the latest developments in AI\",\n    expected_output=\"A list of recent AI developments\",\n    agent=researcher\n)\n\nanalysis_task = Task(\n    description=\"Analyze the research findings and identify key trends\",\n    expected_output=\"Analysis report of AI trends\",\n    agent=analyst,\n    context=[research_task]  # This task will wait for research_task to complete\n)\n```",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "research_task = Task(\n    description=\"Research the latest developments in AI\",\n    expected_output=\"A list of recent AI developments\",\n    agent=researcher\n)\n\nanalysis_task = Task(\n    description=\"Analyze the research findings and identify key trends\",\n    expected_output=\"Analysis report of AI trends\",\n    agent=analyst,\n    context=[research_task]  # This task will wait for research_task to complete\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Task Guardrails",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": [
              {
                "type": "header",
                "title": "Using Task Guardrails",
                "level": 3,
                "content": "To add a guardrail to a task, provide a validation function through the `guardrail` parameter:\n```\nfrom typing import Tuple, Union, Dict, Any\n\ndef validate_blog_content(result: str) -> Tuple[bool, Union[Dict[str, Any], str]]:\n    \"\"\"Validate blog content meets requirements.\"\"\"\n    try:\n        # Check word count\n        word_count = len(result.split())\n        if word_count > 200:\n            return (False, {\n                \"error\": \"Blog content exceeds 200 words\",\n                \"code\": \"WORD_COUNT_ERROR\",\n                \"context\": {\"word_count\": word_count}\n            })\n\n        # Additional validation logic here\n        return (True, result.strip())\n    except Exception as e:\n        return (False, {\n            \"error\": \"Unexpected error during validation\",\n            \"code\": \"SYSTEM_ERROR\"\n        })\n\nblog_task = Task(\n    description=\"Write a blog post about AI\",\n    expected_output=\"A blog post under 200 words\",\n    agent=blog_agent,\n    guardrail=validate_blog_content  # Add the guardrail function\n)\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "from typing import Tuple, Union, Dict, Any\n\ndef validate_blog_content(result: str) -> Tuple[bool, Union[Dict[str, Any], str]]:\n    \"\"\"Validate blog content meets requirements.\"\"\"\n    try:\n        # Check word count\n        word_count = len(result.split())\n        if word_count > 200:\n            return (False, {\n                \"error\": \"Blog content exceeds 200 words\",\n                \"code\": \"WORD_COUNT_ERROR\",\n                \"context\": {\"word_count\": word_count}\n            })\n\n        # Additional validation logic here\n        return (True, result.strip())\n    except Exception as e:\n        return (False, {\n            \"error\": \"Unexpected error during validation\",\n            \"code\": \"SYSTEM_ERROR\"\n        })\n\nblog_task = Task(\n    description=\"Write a blog post about AI\",\n    expected_output=\"A blog post under 200 words\",\n    agent=blog_agent,\n    guardrail=validate_blog_content  # Add the guardrail function\n)",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Guardrail Function Requirements",
                "level": 3,
                "content": "**Function Signature**: Must accept exactly one parameter (the task output) Should return a tuple of `(bool, Any)` Type hints are recommended but optional **Return Values**: Success: Return `(True, validated_result)` Failure: Return `(False, error_details)`",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Error Handling Best Practices",
                "level": 3,
                "content": "**Structured Error Responses**:\n```\ndef validate_with_context(result: str) -> Tuple[bool, Union[Dict[str, Any], str]]:\n    try:\n        # Main validation logic\n        validated_data = perform_validation(result)\n        return (True, validated_data)\n    except ValidationError as e:\n        return (False, {\n            \"error\": str(e),\n            \"code\": \"VALIDATION_ERROR\",\n            \"context\": {\"input\": result}\n        })\n    except Exception as e:\n        return (False, {\n            \"error\": \"Unexpected error\",\n            \"code\": \"SYSTEM_ERROR\"\n        })\n```\n**Error Categories**: Use specific error codes Include relevant context Provide actionable feedback **Validation Chain**:\n```\nfrom typing import Any, Dict, List, Tuple, Union\n\ndef complex_validation(result: str) -> Tuple[bool, Union[str, Dict[str, Any]]]:\n    \"\"\"Chain multiple validation steps.\"\"\"\n    # Step 1: Basic validation\n    if not result:\n        return (False, {\"error\": \"Empty result\", \"code\": \"EMPTY_INPUT\"})\n\n    # Step 2: Content validation\n    try:\n        validated = validate_content(result)\n        if not validated:\n            return (False, {\"error\": \"Invalid content\", \"code\": \"CONTENT_ERROR\"})\n\n        # Step 3: Format validation\n        formatted = format_output(validated)\n        return (True, formatted)\n    except Exception as e:\n        return (False, {\n            \"error\": str(e),\n            \"code\": \"VALIDATION_ERROR\",\n            \"context\": {\"step\": \"content_validation\"}\n        })\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "def validate_with_context(result: str) -> Tuple[bool, Union[Dict[str, Any], str]]:\n    try:\n        # Main validation logic\n        validated_data = perform_validation(result)\n        return (True, validated_data)\n    except ValidationError as e:\n        return (False, {\n            \"error\": str(e),\n            \"code\": \"VALIDATION_ERROR\",\n            \"context\": {\"input\": result}\n        })\n    except Exception as e:\n        return (False, {\n            \"error\": \"Unexpected error\",\n            \"code\": \"SYSTEM_ERROR\"\n        })",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  },
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "from typing import Any, Dict, List, Tuple, Union\n\ndef complex_validation(result: str) -> Tuple[bool, Union[str, Dict[str, Any]]]:\n    \"\"\"Chain multiple validation steps.\"\"\"\n    # Step 1: Basic validation\n    if not result:\n        return (False, {\"error\": \"Empty result\", \"code\": \"EMPTY_INPUT\"})\n\n    # Step 2: Content validation\n    try:\n        validated = validate_content(result)\n        if not validated:\n            return (False, {\"error\": \"Invalid content\", \"code\": \"CONTENT_ERROR\"})\n\n        # Step 3: Format validation\n        formatted = format_output(validated)\n        return (True, formatted)\n    except Exception as e:\n        return (False, {\n            \"error\": str(e),\n            \"code\": \"VALIDATION_ERROR\",\n            \"context\": {\"step\": \"content_validation\"}\n        })",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Handling Guardrail Results",
                "level": 3,
                "content": "When a guardrail returns `(False, error)`: The error is sent back to the agent The agent attempts to fix the issue The process repeats until: The guardrail returns `(True, result)` Maximum retries are reached Example with retry handling:\n```\nfrom typing import Optional, Tuple, Union\n\ndef validate_json_output(result: str) -> Tuple[bool, Union[Dict[str, Any], str]]:\n    \"\"\"Validate and parse JSON output.\"\"\"\n    try:\n        # Try to parse as JSON\n        data = json.loads(result)\n        return (True, data)\n    except json.JSONDecodeError as e:\n        return (False, {\n            \"error\": \"Invalid JSON format\",\n            \"code\": \"JSON_ERROR\",\n            \"context\": {\"line\": e.lineno, \"column\": e.colno}\n        })\n\ntask = Task(\n    description=\"Generate a JSON report\",\n    expected_output=\"A valid JSON object\",\n    agent=analyst,\n    guardrail=validate_json_output,\n    max_retries=3  # Limit retry attempts\n)\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "from typing import Optional, Tuple, Union\n\ndef validate_json_output(result: str) -> Tuple[bool, Union[Dict[str, Any], str]]:\n    \"\"\"Validate and parse JSON output.\"\"\"\n    try:\n        # Try to parse as JSON\n        data = json.loads(result)\n        return (True, data)\n    except json.JSONDecodeError as e:\n        return (False, {\n            \"error\": \"Invalid JSON format\",\n            \"code\": \"JSON_ERROR\",\n            \"context\": {\"line\": e.lineno, \"column\": e.colno}\n        })\n\ntask = Task(\n    description=\"Generate a JSON report\",\n    expected_output=\"A valid JSON object\",\n    agent=analyst,\n    guardrail=validate_json_output,\n    max_retries=3  # Limit retry attempts\n)",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              }
            ]
          },
          {
            "type": "header",
            "title": "Getting Structured Consistent Outputs from Tasks",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": [
              {
                "type": "header",
                "title": "Using `output_pydantic`",
                "level": 3,
                "content": "The `output_pydantic` property allows you to define a Pydantic model that the task output should conform to. This ensures that the output is not only structured but also validated according to the Pydantic model. Here\u2019s an example demonstrating how to use output\\_pydantic:\n```\nimport json\n\nfrom crewai import Agent, Crew, Process, Task\nfrom pydantic import BaseModel\n\n\nclass Blog(BaseModel):\n    title: str\n    content: str\n\n\nblog_agent = Agent(\n    role=\"Blog Content Generator Agent\",\n    goal=\"Generate a blog title and content\",\n    backstory=\"\"\"You are an expert content creator, skilled in crafting engaging and informative blog posts.\"\"\",\n    verbose=False,\n    allow_delegation=False,\n    llm=\"gpt-4o\",\n)\n\ntask1 = Task(\n    description=\"\"\"Create a blog title and content on a given topic. Make sure the content is under 200 words.\"\"\",\n    expected_output=\"A compelling blog title and well-written content.\",\n    agent=blog_agent,\n    output_pydantic=Blog,\n)\n\n# Instantiate your crew with a sequential process\ncrew = Crew(\n    agents=[blog_agent],\n    tasks=[task1],\n    verbose=True,\n    process=Process.sequential,\n)\n\nresult = crew.kickoff()\n\n# Option 1: Accessing Properties Using Dictionary-Style Indexing\nprint(\"Accessing Properties - Option 1\")\ntitle = result[\"title\"]\ncontent = result[\"content\"]\nprint(\"Title:\", title)\nprint(\"Content:\", content)\n\n# Option 2: Accessing Properties Directly from the Pydantic Model\nprint(\"Accessing Properties - Option 2\")\ntitle = result.pydantic.title\ncontent = result.pydantic.content\nprint(\"Title:\", title)\nprint(\"Content:\", content)\n\n# Option 3: Accessing Properties Using the to_dict() Method\nprint(\"Accessing Properties - Option 3\")\noutput_dict = result.to_dict()\ntitle = output_dict[\"title\"]\ncontent = output_dict[\"content\"]\nprint(\"Title:\", title)\nprint(\"Content:\", content)\n\n# Option 4: Printing the Entire Blog Object\nprint(\"Accessing Properties - Option 5\")\nprint(\"Blog:\", result)\n\n```\nIn this example: A Pydantic model Blog is defined with title and content fields. The task task1 uses the output\\_pydantic property to specify that its output should conform to the Blog model. After executing the crew, you can access the structured output in multiple ways as shown.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [
                  {
                    "type": "header",
                    "title": "Explanation of Accessing the Output",
                    "level": 4,
                    "content": "",
                    "metadata": {
                      "section_type": "General",
                      "content_type": null
                    },
                    "children": []
                  }
                ],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "import json\n\nfrom crewai import Agent, Crew, Process, Task\nfrom pydantic import BaseModel\n\n\nclass Blog(BaseModel):\n    title: str\n    content: str\n\n\nblog_agent = Agent(\n    role=\"Blog Content Generator Agent\",\n    goal=\"Generate a blog title and content\",\n    backstory=\"\"\"You are an expert content creator, skilled in crafting engaging and informative blog posts.\"\"\",\n    verbose=False,\n    allow_delegation=False,\n    llm=\"gpt-4o\",\n)\n\ntask1 = Task(\n    description=\"\"\"Create a blog title and content on a given topic. Make sure the content is under 200 words.\"\"\",\n    expected_output=\"A compelling blog title and well-written content.\",\n    agent=blog_agent,\n    output_pydantic=Blog,\n)\n\n# Instantiate your crew with a sequential process\ncrew = Crew(\n    agents=[blog_agent],\n    tasks=[task1],\n    verbose=True,\n    process=Process.sequential,\n)\n\nresult = crew.kickoff()\n\n# Option 1: Accessing Properties Using Dictionary-Style Indexing\nprint(\"Accessing Properties - Option 1\")\ntitle = result[\"title\"]\ncontent = result[\"content\"]\nprint(\"Title:\", title)\nprint(\"Content:\", content)\n\n# Option 2: Accessing Properties Directly from the Pydantic Model\nprint(\"Accessing Properties - Option 2\")\ntitle = result.pydantic.title\ncontent = result.pydantic.content\nprint(\"Title:\", title)\nprint(\"Content:\", content)\n\n# Option 3: Accessing Properties Using the to_dict() Method\nprint(\"Accessing Properties - Option 3\")\noutput_dict = result.to_dict()\ntitle = output_dict[\"title\"]\ncontent = output_dict[\"content\"]\nprint(\"Title:\", title)\nprint(\"Content:\", content)\n\n# Option 4: Printing the Entire Blog Object\nprint(\"Accessing Properties - Option 5\")\nprint(\"Blog:\", result)",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Using `output_json`",
                "level": 3,
                "content": "The `output_json` property allows you to define the expected output in JSON format. This ensures that the task's output is a valid JSON structure that can be easily parsed and used in your application. Here\u2019s an example demonstrating how to use `output_json`:\n```\nimport json\n\nfrom crewai import Agent, Crew, Process, Task\nfrom pydantic import BaseModel\n\n\n# Define the Pydantic model for the blog\nclass Blog(BaseModel):\n    title: str\n    content: str\n\n\n# Define the agent\nblog_agent = Agent(\n    role=\"Blog Content Generator Agent\",\n    goal=\"Generate a blog title and content\",\n    backstory=\"\"\"You are an expert content creator, skilled in crafting engaging and informative blog posts.\"\"\",\n    verbose=False,\n    allow_delegation=False,\n    llm=\"gpt-4o\",\n)\n\n# Define the task with output_json set to the Blog model\ntask1 = Task(\n    description=\"\"\"Create a blog title and content on a given topic. Make sure the content is under 200 words.\"\"\",\n    expected_output=\"A JSON object with 'title' and 'content' fields.\",\n    agent=blog_agent,\n    output_json=Blog,\n)\n\n# Instantiate the crew with a sequential process\ncrew = Crew(\n    agents=[blog_agent],\n    tasks=[task1],\n    verbose=True,\n    process=Process.sequential,\n)\n\n# Kickoff the crew to execute the task\nresult = crew.kickoff()\n\n# Option 1: Accessing Properties Using Dictionary-Style Indexing\nprint(\"Accessing Properties - Option 1\")\ntitle = result[\"title\"]\ncontent = result[\"content\"]\nprint(\"Title:\", title)\nprint(\"Content:\", content)\n\n# Option 2: Printing the Entire Blog Object\nprint(\"Accessing Properties - Option 2\")\nprint(\"Blog:\", result)\n```\nIn this example: A Pydantic model Blog is defined with title and content fields, which is used to specify the structure of the JSON output. The task task1 uses the output\\_json property to indicate that it expects a JSON output conforming to the Blog model. After executing the crew, you can access the structured JSON output in two ways as shown.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [
                  {
                    "type": "header",
                    "title": "Explanation of Accessing the Output",
                    "level": 4,
                    "content": "Dictionary-Style Indexing: You can directly access the fields using result\\[\"field\\_name\"]. This works because the CrewOutput class implements the **getitem** method. Directly from Pydantic Model: Access the attributes directly from the result.pydantic object. Using to\\_dict() Method: Convert the output to a dictionary and access the fields. Printing the Entire Object: Simply print the result object to see the structured output.\n\nAccessing Properties Using Dictionary-Style Indexing: You can access the fields directly using result\\[\"field\\_name\"]. This is possible because the CrewOutput class implements the **getitem** method, allowing you to treat the output like a dictionary. In this option, we're retrieving the title and content from the result. Printing the Entire Blog Object: By printing result, you get the string representation of the CrewOutput object. Since the **str** method is implemented to return the JSON output, this will display the entire output as a formatted string representing the Blog object. By using output\\_pydantic or output\\_json, you ensure that your tasks produce outputs in a consistent and structured format, making it easier to process and utilize the data within your application or across multiple tasks.",
                    "metadata": {
                      "section_type": "General",
                      "content_type": "descriptive_text"
                    },
                    "children": []
                  }
                ],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "import json\n\nfrom crewai import Agent, Crew, Process, Task\nfrom pydantic import BaseModel\n\n\n# Define the Pydantic model for the blog\nclass Blog(BaseModel):\n    title: str\n    content: str\n\n\n# Define the agent\nblog_agent = Agent(\n    role=\"Blog Content Generator Agent\",\n    goal=\"Generate a blog title and content\",\n    backstory=\"\"\"You are an expert content creator, skilled in crafting engaging and informative blog posts.\"\"\",\n    verbose=False,\n    allow_delegation=False,\n    llm=\"gpt-4o\",\n)\n\n# Define the task with output_json set to the Blog model\ntask1 = Task(\n    description=\"\"\"Create a blog title and content on a given topic. Make sure the content is under 200 words.\"\"\",\n    expected_output=\"A JSON object with 'title' and 'content' fields.\",\n    agent=blog_agent,\n    output_json=Blog,\n)\n\n# Instantiate the crew with a sequential process\ncrew = Crew(\n    agents=[blog_agent],\n    tasks=[task1],\n    verbose=True,\n    process=Process.sequential,\n)\n\n# Kickoff the crew to execute the task\nresult = crew.kickoff()\n\n# Option 1: Accessing Properties Using Dictionary-Style Indexing\nprint(\"Accessing Properties - Option 1\")\ntitle = result[\"title\"]\ncontent = result[\"content\"]\nprint(\"Title:\", title)\nprint(\"Content:\", content)\n\n# Option 2: Printing the Entire Blog Object\nprint(\"Accessing Properties - Option 2\")\nprint(\"Blog:\", result)",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              }
            ]
          },
          {
            "type": "header",
            "title": "Integrating Tools with Tasks",
            "level": 2,
            "content": "Leverage tools from the [CrewAI Toolkit](https://github.com/joaomdmoura/crewai-tools) and [LangChain Tools](https://python.langchain.com/docs/integrations/tools) for enhanced task performance and agent interaction.",
            "metadata": {
              "section_type": "General",
              "content_type": "link_list"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Creating a Task with Tools",
            "level": 2,
            "content": "```\nimport os\nos.environ[\"OPENAI_API_KEY\"] = \"Your Key\"\nos.environ[\"SERPER_API_KEY\"] = \"Your Key\" # serper.dev API key\n\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import SerperDevTool\n\nresearch_agent = Agent(\n  role='Researcher',\n  goal='Find and summarize the latest AI news',\n  backstory=\"\"\"You're a researcher at a large company.\n  You're responsible for analyzing data and providing insights\n  to the business.\"\"\",\n  verbose=True\n)\n\n# to perform a semantic search for a specified query from a text's content across the internet\nsearch_tool = SerperDevTool()\n\ntask = Task(\n  description='Find and summarize the latest AI news',\n  expected_output='A bullet list summary of the top 5 most important AI news',\n  agent=research_agent,\n  tools=[search_tool]\n)\n\ncrew = Crew(\n    agents=[research_agent],\n    tasks=[task],\n    verbose=True\n)\n\nresult = crew.kickoff()\nprint(result)\n```\nThis demonstrates how tasks with specific tools can override an agent's default set for tailored task execution.",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "import os\nos.environ[\"OPENAI_API_KEY\"] = \"Your Key\"\nos.environ[\"SERPER_API_KEY\"] = \"Your Key\" # serper.dev API key\n\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import SerperDevTool\n\nresearch_agent = Agent(\n  role='Researcher',\n  goal='Find and summarize the latest AI news',\n  backstory=\"\"\"You're a researcher at a large company.\n  You're responsible for analyzing data and providing insights\n  to the business.\"\"\",\n  verbose=True\n)\n\n# to perform a semantic search for a specified query from a text's content across the internet\nsearch_tool = SerperDevTool()\n\ntask = Task(\n  description='Find and summarize the latest AI news',\n  expected_output='A bullet list summary of the top 5 most important AI news',\n  agent=research_agent,\n  tools=[search_tool]\n)\n\ncrew = Crew(\n    agents=[research_agent],\n    tasks=[task],\n    verbose=True\n)\n\nresult = crew.kickoff()\nprint(result)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Referring to Other Tasks",
            "level": 2,
            "content": "In CrewAI, the output of one task is automatically relayed into the next one, but you can specifically define what tasks' output, including multiple, should be used as context for another task. This is useful when you have a task that depends on the output of another task that is not performed immediately after it. This is done through the `context` attribute of the task:\n```\n# ...\n\nresearch_ai_task = Task(\n    description=\"Research the latest developments in AI\",\n    expected_output=\"A list of recent AI developments\",\n    async_execution=True,\n    agent=research_agent,\n    tools=[search_tool]\n)\n\nresearch_ops_task = Task(\n    description=\"Research the latest developments in AI Ops\",\n    expected_output=\"A list of recent AI Ops developments\",\n    async_execution=True,\n    agent=research_agent,\n    tools=[search_tool]\n)\n\nwrite_blog_task = Task(\n    description=\"Write a full blog post about the importance of AI and its latest news\",\n    expected_output=\"Full blog post that is 4 paragraphs long\",\n    agent=writer_agent,\n    context=[research_ai_task, research_ops_task]\n)\n\n#...\n```",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "# ...\n\nresearch_ai_task = Task(\n    description=\"Research the latest developments in AI\",\n    expected_output=\"A list of recent AI developments\",\n    async_execution=True,\n    agent=research_agent,\n    tools=[search_tool]\n)\n\nresearch_ops_task = Task(\n    description=\"Research the latest developments in AI Ops\",\n    expected_output=\"A list of recent AI Ops developments\",\n    async_execution=True,\n    agent=research_agent,\n    tools=[search_tool]\n)\n\nwrite_blog_task = Task(\n    description=\"Write a full blog post about the importance of AI and its latest news\",\n    expected_output=\"Full blog post that is 4 paragraphs long\",\n    agent=writer_agent,\n    context=[research_ai_task, research_ops_task]\n)\n\n#...",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Asynchronous Execution",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Callback Mechanism",
            "level": 2,
            "content": "The callback function is executed after the task is completed, allowing for actions or notifications to be triggered based on the task's outcome.\n```\n# ...\n\ndef callback_function(output: TaskOutput):\n    # Do something after the task is completed\n    # Example: Send an email to the manager\n    print(f\"\"\"\n        Task completed!\n        Task: {output.description}\n        Output: {output.raw}\n    \"\"\")\n\nresearch_task = Task(\n    description='Find and summarize the latest AI news',\n    expected_output='A bullet list summary of the top 5 most important AI news',\n    agent=research_agent,\n    tools=[search_tool],\n    callback=callback_function\n)\n\n#...\n```",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "# ...\n\ndef callback_function(output: TaskOutput):\n    # Do something after the task is completed\n    # Example: Send an email to the manager\n    print(f\"\"\"\n        Task completed!\n        Task: {output.description}\n        Output: {output.raw}\n    \"\"\")\n\nresearch_task = Task(\n    description='Find and summarize the latest AI news',\n    expected_output='A bullet list summary of the top 5 most important AI news',\n    agent=research_agent,\n    tools=[search_tool],\n    callback=callback_function\n)\n\n#...",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Accessing a Specific Task Output",
            "level": 2,
            "content": "Once a crew finishes running, you can access the output of a specific task by using the `output` attribute of the task object:\n```\n# ...\ntask1 = Task(\n    description='Find and summarize the latest AI news',\n    expected_output='A bullet list summary of the top 5 most important AI news',\n    agent=research_agent,\n    tools=[search_tool]\n)\n\n#...\n\ncrew = Crew(\n    agents=[research_agent],\n    tasks=[task1, task2, task3],\n    verbose=True\n)\n\nresult = crew.kickoff()\n\n# Returns a TaskOutput object with the description and results of the task\nprint(f\"\"\"\n    Task completed!\n    Task: {task1.output.description}\n    Output: {task1.output.raw}\n\"\"\")\n```",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "# ...\ntask1 = Task(\n    description='Find and summarize the latest AI news',\n    expected_output='A bullet list summary of the top 5 most important AI news',\n    agent=research_agent,\n    tools=[search_tool]\n)\n\n#...\n\ncrew = Crew(\n    agents=[research_agent],\n    tasks=[task1, task2, task3],\n    verbose=True\n)\n\nresult = crew.kickoff()\n\n# Returns a TaskOutput object with the description and results of the task\nprint(f\"\"\"\n    Task completed!\n    Task: {task1.output.description}\n    Output: {task1.output.raw}\n\"\"\")",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Tool Override Mechanism",
            "level": 2,
            "content": "Specifying tools in a task allows for dynamic adaptation of agent capabilities, emphasizing CrewAI's flexibility.",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Error Handling and Validation Mechanisms",
            "level": 2,
            "content": "While creating and executing tasks, certain validation mechanisms are in place to ensure the robustness and reliability of task attributes. These include but are not limited to: Ensuring only one output type is set per task to maintain clear output expectations. Preventing the manual assignment of the `id` attribute to uphold the integrity of the unique identifier system. These validations help in maintaining the consistency and reliability of task executions within the crewAI framework.",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Task Guardrails",
            "level": 2,
            "content": "Task guardrails provide a way to validate and transform task outputs before they\nare passed to the next task. This feature helps ensure data quality and provides\nfeedback to agents when their output doesn't meet specific criteria.\n\nTask guardrails provide a powerful way to validate, transform, or filter task outputs before they are passed to the next task. Guardrails are optional functions that execute before the next task starts, allowing you to ensure that task outputs meet specific requirements or formats.",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": [
              {
                "type": "header",
                "title": "Basic Usage",
                "level": 3,
                "content": "",
                "metadata": {
                  "section_type": "Examples",
                  "content_type": null
                },
                "children": []
              },
              {
                "type": "header",
                "title": "How Guardrails Work",
                "level": 3,
                "content": "**Optional Attribute**: Guardrails are an optional attribute at the task level, allowing you to add validation only where needed. **Execution Timing**: The guardrail function is executed before the next task starts, ensuring valid data flow between tasks. **Return Format**: Guardrails must return a tuple of `(success, data)`: If `success` is `True`, `data` is the validated/transformed result If `success` is `False`, `data` is the error message **Result Routing**: On success (`True`), the result is automatically passed to the next task On failure (`False`), the error is sent back to the agent to generate a new answer",
                "metadata": {
                  "section_type": "General",
                  "content_type": "descriptive_text"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Common Use Cases",
                "level": 3,
                "content": "",
                "metadata": {
                  "section_type": "General",
                  "content_type": null
                },
                "children": [
                  {
                    "type": "header",
                    "title": "Data Format Validation",
                    "level": 4,
                    "content": "```\ndef validate_email_format(result: str) -> Tuple[bool, Union[str, str]]:\n    \"\"\"Ensure the output contains a valid email address.\"\"\"\n    import re\n    email_pattern = r'^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$'\n    if re.match(email_pattern, result.strip()):\n        return (True, result.strip())\n    return (False, \"Output must be a valid email address\")\n```",
                    "metadata": {
                      "section_type": "General",
                      "content_type": "code_example"
                    },
                    "children": [],
                    "code_blocks": [
                      {
                        "type": "code_block",
                        "language": "python Code",
                        "content": "def validate_email_format(result: str) -> Tuple[bool, Union[str, str]]:\n    \"\"\"Ensure the output contains a valid email address.\"\"\"\n    import re\n    email_pattern = r'^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$'\n    if re.match(email_pattern, result.strip()):\n        return (True, result.strip())\n    return (False, \"Output must be a valid email address\")",
                        "metadata": {
                          "section_type": "code",
                          "content_type": "code_example"
                        },
                        "children": []
                      }
                    ]
                  },
                  {
                    "type": "header",
                    "title": "Content Filtering",
                    "level": 4,
                    "content": "```\ndef filter_sensitive_info(result: str) -> Tuple[bool, Union[str, str]]:\n    \"\"\"Remove or validate sensitive information.\"\"\"\n    sensitive_patterns = ['SSN:', 'password:', 'secret:']\n    for pattern in sensitive_patterns:\n        if pattern.lower() in result.lower():\n            return (False, f\"Output contains sensitive information ({pattern})\")\n    return (True, result)\n```",
                    "metadata": {
                      "section_type": "General",
                      "content_type": "code_example"
                    },
                    "children": [],
                    "code_blocks": [
                      {
                        "type": "code_block",
                        "language": "python Code",
                        "content": "def filter_sensitive_info(result: str) -> Tuple[bool, Union[str, str]]:\n    \"\"\"Remove or validate sensitive information.\"\"\"\n    sensitive_patterns = ['SSN:', 'password:', 'secret:']\n    for pattern in sensitive_patterns:\n        if pattern.lower() in result.lower():\n            return (False, f\"Output contains sensitive information ({pattern})\")\n    return (True, result)",
                        "metadata": {
                          "section_type": "code",
                          "content_type": "code_example"
                        },
                        "children": []
                      }
                    ]
                  },
                  {
                    "type": "header",
                    "title": "Data Transformation",
                    "level": 4,
                    "content": "```\ndef normalize_phone_number(result: str) -> Tuple[bool, Union[str, str]]:\n    \"\"\"Ensure phone numbers are in a consistent format.\"\"\"\n    import re\n    digits = re.sub(r'\\D', '', result)\n    if len(digits) == 10:\n        formatted = f\"({digits[:3]}) {digits[3:6]}-{digits[6:]}\"\n        return (True, formatted)\n    return (False, \"Output must be a 10-digit phone number\")\n```",
                    "metadata": {
                      "section_type": "General",
                      "content_type": "code_example"
                    },
                    "children": [],
                    "code_blocks": [
                      {
                        "type": "code_block",
                        "language": "python Code",
                        "content": "def normalize_phone_number(result: str) -> Tuple[bool, Union[str, str]]:\n    \"\"\"Ensure phone numbers are in a consistent format.\"\"\"\n    import re\n    digits = re.sub(r'\\D', '', result)\n    if len(digits) == 10:\n        formatted = f\"({digits[:3]}) {digits[3:6]}-{digits[6:]}\"\n        return (True, formatted)\n    return (False, \"Output must be a 10-digit phone number\")",
                        "metadata": {
                          "section_type": "code",
                          "content_type": "code_example"
                        },
                        "children": []
                      }
                    ]
                  }
                ]
              },
              {
                "type": "header",
                "title": "Advanced Features",
                "level": 3,
                "content": "",
                "metadata": {
                  "section_type": "Internals/Advanced",
                  "content_type": null
                },
                "children": [
                  {
                    "type": "header",
                    "title": "Chaining Multiple Validations",
                    "level": 4,
                    "content": "```\ndef chain_validations(*validators):\n    \"\"\"Chain multiple validators together.\"\"\"\n    def combined_validator(result):\n        for validator in validators:\n            success, data = validator(result)\n            if not success:\n                return (False, data)\n            result = data\n        return (True, result)\n    return combined_validator\n\n# Usage\ntask = Task(\n    description=\"Get user contact info\",\n    expected_output=\"Email and phone\",\n    guardrail=chain_validations(\n        validate_email_format,\n        filter_sensitive_info\n    )\n)\n```",
                    "metadata": {
                      "section_type": "General",
                      "content_type": "code_example"
                    },
                    "children": [],
                    "code_blocks": [
                      {
                        "type": "code_block",
                        "language": "python Code",
                        "content": "def chain_validations(*validators):\n    \"\"\"Chain multiple validators together.\"\"\"\n    def combined_validator(result):\n        for validator in validators:\n            success, data = validator(result)\n            if not success:\n                return (False, data)\n            result = data\n        return (True, result)\n    return combined_validator\n\n# Usage\ntask = Task(\n    description=\"Get user contact info\",\n    expected_output=\"Email and phone\",\n    guardrail=chain_validations(\n        validate_email_format,\n        filter_sensitive_info\n    )\n)",
                        "metadata": {
                          "section_type": "code",
                          "content_type": "code_example"
                        },
                        "children": []
                      }
                    ]
                  },
                  {
                    "type": "header",
                    "title": "Custom Retry Logic",
                    "level": 4,
                    "content": "```\ntask = Task(\n    description=\"Generate data\",\n    expected_output=\"Valid data\",\n    guardrail=validate_data,\n    max_retries=5  # Override default retry limit\n)\n```",
                    "metadata": {
                      "section_type": "General",
                      "content_type": "code_example"
                    },
                    "children": [],
                    "code_blocks": [
                      {
                        "type": "code_block",
                        "language": "python Code",
                        "content": "task = Task(\n    description=\"Generate data\",\n    expected_output=\"Valid data\",\n    guardrail=validate_data,\n    max_retries=5  # Override default retry limit\n)",
                        "metadata": {
                          "section_type": "code",
                          "content_type": "code_example"
                        },
                        "children": []
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "header",
            "title": "Creating Directories when Saving Files",
            "level": 2,
            "content": "You can now specify if a task should create directories when saving its output to a file. This is particularly useful for organizing outputs and ensuring that file paths are correctly structured.\n```\n# ...\n\nsave_output_task = Task(\n    description='Save the summarized AI news to a file',\n    expected_output='File saved successfully',\n    agent=research_agent,\n    tools=[file_save_tool],\n    output_file='outputs/ai_news_summary.txt',\n    create_directory=True\n)\n\n#...\n```\nCheck out the video below to see how to use structured outputs in CrewAI:",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "# ...\n\nsave_output_task = Task(\n    description='Save the summarized AI news to a file',\n    expected_output='File saved successfully',\n    agent=research_agent,\n    tools=[file_save_tool],\n    output_file='outputs/ai_news_summary.txt',\n    create_directory=True\n)\n\n#...",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Conclusion",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Testing",
        "level": 1,
        "content": "Source: https://docs.crewai.com/concepts/testing Learn how to test your CrewAI Crew and evaluate their performance.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": [
          {
            "type": "header",
            "title": "Introduction",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": [
              {
                "type": "header",
                "title": "Using the Testing Feature",
                "level": 3,
                "content": "We added the CLI command `crewai test` to make it easy to test your crew. This command will run your crew for a specified number of iterations and provide detailed performance metrics. The parameters are `n_iterations` and `model`, which are optional and default to 2 and `gpt-4o-mini` respectively. For now, the only provider available is OpenAI.\n```\ncrewai test\n```\nIf you want to run more iterations or use a different model, you can specify the parameters like this:\n```\ncrewai test --n_iterations 5 --model gpt-4o\n```\nor using the short forms:\n```\ncrewai test -n 5 -m gpt-4o\n```\nWhen you run the `crewai test` command, the crew will be executed for the specified number of iterations, and the performance metrics will be displayed at the end of the run. A table of scores at the end will show the performance of the crew in terms of the following metrics: | Tasks/Crew/Agents  | Run 1 | Run 2 | Avg. Total |            Agents            | Additional Info                |\n| :----------------- | :---: | :---: | :--------: | :--------------------------: | :----------------------------- |\n| Task 1             |  9.0  |  9.5  |   **9.2**  |     Professional Insights    |                                |\n|                    |       |       |            |          Researcher          |                                |\n| Task 2             |  9.0  |  10.0 |   **9.5**  | Company Profile Investigator |                                |\n| Task 3             |  9.0  |  9.0  |   **9.0**  |      Automation Insights     |                                |\n|                    |       |       |            |          Specialist          |                                |\n| Task 4             |  9.0  |  9.0  |   **9.0**  |     Final Report Compiler    | Automation Insights Specialist |\n| Crew               |  9.00 |  9.38 |   **9.2**  |                              |                                |\n| Execution Time (s) |  126  |  145  |   **135**  |                              |                                | The example above shows the test results for two runs of the crew with two tasks, with the average total score for each task and the crew as a whole.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "bash",
                    "content": "crewai test",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  },
                  {
                    "type": "code_block",
                    "language": "bash",
                    "content": "crewai test --n_iterations 5 --model gpt-4o",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  },
                  {
                    "type": "code_block",
                    "language": "bash",
                    "content": "crewai test -n 5 -m gpt-4o",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type": "header",
        "title": "Tools",
        "level": 1,
        "content": "Source: https://docs.crewai.com/concepts/tools Understanding and leveraging tools within the CrewAI framework for agent collaboration and task execution.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": [
          {
            "type": "header",
            "title": "Introduction",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "What is a Tool?",
            "level": 2,
            "content": "A tool in CrewAI is a skill or function that agents can utilize to perform various actions.\nThis includes tools from the [CrewAI Toolkit](https://github.com/joaomdmoura/crewai-tools) and [LangChain Tools](https://python.langchain.com/docs/integrations/tools),\nenabling everything from simple searches to complex interactions and effective teamwork among agents.",
            "metadata": {
              "section_type": "General",
              "content_type": "link_list"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Key Characteristics of Tools",
            "level": 2,
            "content": "**Utility**: Crafted for tasks such as web searching, data analysis, content generation, and agent collaboration. **Integration**: Boosts agent capabilities by seamlessly integrating tools into their workflow. **Customizability**: Provides the flexibility to develop custom tools or utilize existing ones, catering to the specific needs of agents. **Error Handling**: Incorporates robust error handling mechanisms to ensure smooth operation. **Caching Mechanism**: Features intelligent caching to optimize performance and reduce redundant operations.",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Using CrewAI Tools",
            "level": 2,
            "content": "To enhance your agents' capabilities with crewAI tools, begin by installing our extra tools package:\n```\npip install 'crewai[tools]'\n```\nHere's an example demonstrating their use:\n```\nimport os\nfrom crewai import Agent, Task, Crew\n# Importing crewAI tools\nfrom crewai_tools import (\n    DirectoryReadTool,\n    FileReadTool,\n    SerperDevTool,\n    WebsiteSearchTool\n)\n\n# Set up API keys\nos.environ[\"SERPER_API_KEY\"] = \"Your Key\" # serper.dev API key\nos.environ[\"OPENAI_API_KEY\"] = \"Your Key\"\n\n# Instantiate tools\ndocs_tool = DirectoryReadTool(directory='./blog-posts')\nfile_tool = FileReadTool()\nsearch_tool = SerperDevTool()\nweb_rag_tool = WebsiteSearchTool()\n\n# Create agents\nresearcher = Agent(\n    role='Market Research Analyst',\n    goal='Provide up-to-date market analysis of the AI industry',\n    backstory='An expert analyst with a keen eye for market trends.',\n    tools=[search_tool, web_rag_tool],\n    verbose=True\n)\n\nwriter = Agent(\n    role='Content Writer',\n    goal='Craft engaging blog posts about the AI industry',\n    backstory='A skilled writer with a passion for technology.',\n    tools=[docs_tool, file_tool],\n    verbose=True\n)\n\n# Define tasks\nresearch = Task(\n    description='Research the latest trends in the AI industry and provide a summary.',\n    expected_output='A summary of the top 3 trending developments in the AI industry with a unique perspective on their significance.',\n    agent=researcher\n)\n\nwrite = Task(\n    description='Write an engaging blog post about the AI industry, based on the research analyst\u2019s summary. Draw inspiration from the latest blog posts in the directory.',\n    expected_output='A 4-paragraph blog post formatted in markdown with engaging, informative, and accessible content, avoiding complex jargon.',\n    agent=writer,\n    output_file='blog-posts/new_post.md'  # The final blog post will be saved here\n)\n\n# Assemble a crew with planning enabled\ncrew = Crew(\n    agents=[researcher, writer],\n    tasks=[research, write],\n    verbose=True,\n    planning=True,  # Enable planning feature\n)\n\n# Execute tasks\ncrew.kickoff()\n```",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "bash",
                "content": "pip install 'crewai[tools]'",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "import os\nfrom crewai import Agent, Task, Crew\n# Importing crewAI tools\nfrom crewai_tools import (\n    DirectoryReadTool,\n    FileReadTool,\n    SerperDevTool,\n    WebsiteSearchTool\n)\n\n# Set up API keys\nos.environ[\"SERPER_API_KEY\"] = \"Your Key\" # serper.dev API key\nos.environ[\"OPENAI_API_KEY\"] = \"Your Key\"\n\n# Instantiate tools\ndocs_tool = DirectoryReadTool(directory='./blog-posts')\nfile_tool = FileReadTool()\nsearch_tool = SerperDevTool()\nweb_rag_tool = WebsiteSearchTool()\n\n# Create agents\nresearcher = Agent(\n    role='Market Research Analyst',\n    goal='Provide up-to-date market analysis of the AI industry',\n    backstory='An expert analyst with a keen eye for market trends.',\n    tools=[search_tool, web_rag_tool],\n    verbose=True\n)\n\nwriter = Agent(\n    role='Content Writer',\n    goal='Craft engaging blog posts about the AI industry',\n    backstory='A skilled writer with a passion for technology.',\n    tools=[docs_tool, file_tool],\n    verbose=True\n)\n\n# Define tasks\nresearch = Task(\n    description='Research the latest trends in the AI industry and provide a summary.',\n    expected_output='A summary of the top 3 trending developments in the AI industry with a unique perspective on their significance.',\n    agent=researcher\n)\n\nwrite = Task(\n    description='Write an engaging blog post about the AI industry, based on the research analyst\u2019s summary. Draw inspiration from the latest blog posts in the directory.',\n    expected_output='A 4-paragraph blog post formatted in markdown with engaging, informative, and accessible content, avoiding complex jargon.',\n    agent=writer,\n    output_file='blog-posts/new_post.md'  # The final blog post will be saved here\n)\n\n# Assemble a crew with planning enabled\ncrew = Crew(\n    agents=[researcher, writer],\n    tasks=[research, write],\n    verbose=True,\n    planning=True,  # Enable planning feature\n)\n\n# Execute tasks\ncrew.kickoff()",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Available CrewAI Tools",
            "level": 2,
            "content": "**Error Handling**: All tools are built with error handling capabilities, allowing agents to gracefully manage exceptions and continue their tasks. **Caching Mechanism**: All tools support caching, enabling agents to efficiently reuse previously obtained results, reducing the load on external resources and speeding up the execution time. You can also define finer control over the caching mechanism using the `cache_function` attribute on the tool. Here is a list of the available tools and their descriptions: | Tool                             | Description                                                                                    |\n| :------------------------------- | :--------------------------------------------------------------------------------------------- |\n| **ApifyActorsTool**              | A tool that integrates Apify Actors with your workflows for web scraping and automation tasks. |\n| **BrowserbaseLoadTool**          | A tool for interacting with and extracting data from web browsers.                             |\n| **CodeDocsSearchTool**           | A RAG tool optimized for searching through code documentation and related technical documents. |\n| **CodeInterpreterTool**          | A tool for interpreting python code.                                                           |\n| **ComposioTool**                 | Enables use of Composio tools.                                                                 |\n| **CSVSearchTool**                | A RAG tool designed for searching within CSV files, tailored to handle structured data.        |\n| **DALL-E Tool**                  | A tool for generating images using the DALL-E API.                                             |\n| **DirectorySearchTool**          | A RAG tool for searching within directories, useful for navigating through file systems.       |\n| **DOCXSearchTool**               | A RAG tool aimed at searching within DOCX documents, ideal for processing Word files.          |\n| **DirectoryReadTool**            | Facilitates reading and processing of directory structures and their contents.                 |\n| **EXASearchTool**                | A tool designed for performing exhaustive searches across various data sources.                |\n| **FileReadTool**                 | Enables reading and extracting data from files, supporting various file formats.               |\n| **FirecrawlSearchTool**          | A tool to search webpages using Firecrawl and return the results.                              |\n| **FirecrawlCrawlWebsiteTool**    | A tool for crawling webpages using Firecrawl.                                                  |\n| **FirecrawlScrapeWebsiteTool**   | A tool for scraping webpages URL using Firecrawl and returning its contents.                   |\n| **GithubSearchTool**             | A RAG tool for searching within GitHub repositories, useful for code and documentation search. |\n| **SerperDevTool**                | A specialized tool for development purposes, with specific functionalities under development.  |\n| **TXTSearchTool**                | A RAG tool focused on searching within text (.txt) files, suitable for unstructured data.      |\n| **JSONSearchTool**               | A RAG tool designed for searching within JSON files, catering to structured data handling.     |\n| **LlamaIndexTool**               | Enables the use of LlamaIndex tools.                                                           |\n| **MDXSearchTool**                | A RAG tool tailored for searching within Markdown (MDX) files, useful for documentation.       |\n| **PDFSearchTool**                | A RAG tool aimed at searching within PDF documents, ideal for processing scanned documents.    |\n| **PGSearchTool**                 | A RAG tool optimized for searching within PostgreSQL databases, suitable for database queries. |\n| **Vision Tool**                  | A tool for generating images using the DALL-E API.                                             |\n| **RagTool**                      | A general-purpose RAG tool capable of handling various data sources and types.                 |\n| **ScrapeElementFromWebsiteTool** | Enables scraping specific elements from websites, useful for targeted data extraction.         |\n| **ScrapeWebsiteTool**            | Facilitates scraping entire websites, ideal for comprehensive data collection.                 |\n| **WebsiteSearchTool**            | A RAG tool for searching website content, optimized for web data extraction.                   |\n| **XMLSearchTool**                | A RAG tool designed for searching within XML files, suitable for structured data formats.      |\n| **YoutubeChannelSearchTool**     | A RAG tool for searching within YouTube channels, useful for video content analysis.           |\n| **YoutubeVideoSearchTool**       | A RAG tool aimed at searching within YouTube videos, ideal for video data extraction.          |",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Creating your own Tools",
            "level": 2,
            "content": "There are two main ways for one to create a CrewAI tool:",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": [
              {
                "type": "header",
                "title": "Subclassing `BaseTool`",
                "level": 3,
                "content": "",
                "metadata": {
                  "section_type": "General",
                  "content_type": null
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Utilizing the `tool` Decorator",
                "level": 3,
                "content": "```\nfrom crewai.tools import tool\n@tool(\"Name of my tool\")\ndef my_tool(question: str) -> str:\n    \"\"\"Clear description for what this tool is useful for, your agent will need this information to use it.\"\"\"\n    # Function logic here\n    return \"Result from your custom tool\"\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "from crewai.tools import tool\n@tool(\"Name of my tool\")\ndef my_tool(question: str) -> str:\n    \"\"\"Clear description for what this tool is useful for, your agent will need this information to use it.\"\"\"\n    # Function logic here\n    return \"Result from your custom tool\"",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Structured Tools",
                "level": 3,
                "content": "The `StructuredTool` class wraps functions as tools, providing flexibility and validation while reducing boilerplate. It supports custom schemas and dynamic logic for seamless integration of complex functionalities.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": [
                  {
                    "type": "header",
                    "title": "Example:",
                    "level": 4,
                    "content": "",
                    "metadata": {
                      "section_type": "Examples",
                      "content_type": null
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Custom Caching Mechanism",
                "level": 3,
                "content": "```\nfrom crewai.tools import tool\n\n@tool\ndef multiplication_tool(first_number: int, second_number: int) -> str:\n    \"\"\"Useful for when you need to multiply two numbers together.\"\"\"\n    return first_number * second_number\n\ndef cache_func(args, result):\n    # In this case, we only cache the result if it's a multiple of 2\n    cache = result % 2 == 0\n    return cache\n\nmultiplication_tool.cache_function = cache_func\n\nwriter1 = Agent(\n        role=\"Writer\",\n        goal=\"You write lessons of math for kids.\",\n        backstory=\"You're an expert in writing and you love to teach kids but you know nothing of math.\",\n        tools=[multiplication_tool],\n        allow_delegation=False,\n    )\n    #...\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "from crewai.tools import tool\n\n@tool\ndef multiplication_tool(first_number: int, second_number: int) -> str:\n    \"\"\"Useful for when you need to multiply two numbers together.\"\"\"\n    return first_number * second_number\n\ndef cache_func(args, result):\n    # In this case, we only cache the result if it's a multiple of 2\n    cache = result % 2 == 0\n    return cache\n\nmultiplication_tool.cache_function = cache_func\n\nwriter1 = Agent(\n        role=\"Writer\",\n        goal=\"You write lessons of math for kids.\",\n        backstory=\"You're an expert in writing and you love to teach kids but you know nothing of math.\",\n        tools=[multiplication_tool],\n        allow_delegation=False,\n    )\n    #...",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              }
            ]
          },
          {
            "type": "header",
            "title": "Conclusion",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Training",
        "level": 1,
        "content": "Source: https://docs.crewai.com/concepts/training Learn how to train your CrewAI agents by giving them feedback early on and get consistent results.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": [
          {
            "type": "header",
            "title": "Introduction",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": [
              {
                "type": "header",
                "title": "Training Your Crew Using the CLI",
                "level": 3,
                "content": "To use the training feature, follow these steps: Open your terminal or command prompt. Navigate to the directory where your CrewAI project is located. Run the following command:\n```\ncrewai train -n <n_iterations> <filename> (optional)\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "shell",
                    "content": "crewai train -n <n_iterations> <filename> (optional)",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Training Your Crew Programmatically",
                "level": 3,
                "content": "To train your crew programmatically, use the following steps: Define the number of iterations for training. Specify the input parameters for the training process. Execute the training command within a try-except block to handle potential errors.\n```\nn_iterations = 2\ninputs = {\"topic\": \"CrewAI Training\"}\nfilename = \"your_model.pkl\"\n\ntry:\n    YourCrewName_Crew().crew().train(\n      n_iterations=n_iterations, \n      inputs=inputs, \n      filename=filename\n    )\n\nexcept Exception as e:\n    raise Exception(f\"An error occurred while training the crew: {e}\")\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "n_iterations = 2\ninputs = {\"topic\": \"CrewAI Training\"}\nfilename = \"your_model.pkl\"\n\ntry:\n    YourCrewName_Crew().crew().train(\n      n_iterations=n_iterations, \n      inputs=inputs, \n      filename=filename\n    )\n\nexcept Exception as e:\n    raise Exception(f\"An error occurred while training the crew: {e}\")",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Key Points to Note",
                "level": 3,
                "content": "**Positive Integer Requirement:** Ensure that the number of iterations (`n_iterations`) is a positive integer. The code will raise a `ValueError` if this condition is not met. **Filename Requirement:** Ensure that the filename ends with `.pkl`. The code will raise a `ValueError` if this condition is not met. **Error Handling:** The code handles subprocess errors and unexpected exceptions, providing error messages to the user. It is important to note that the training process may take some time, depending on the complexity of your agents and will also require your feedback on each iteration. Once the training is complete, your agents will be equipped with enhanced capabilities and knowledge, ready to tackle complex tasks and provide more consistent and valuable insights. Remember to regularly update and retrain your agents to ensure they stay up-to-date with the latest information and advancements in the field. Happy training with CrewAI! \ud83d\ude80",
                "metadata": {
                  "section_type": "General",
                  "content_type": "descriptive_text"
                },
                "children": []
              }
            ]
          }
        ]
      },
      {
        "type": "header",
        "title": "CrewAI Examples",
        "level": 1,
        "content": "Source: https://docs.crewai.com/examples/example A collection of examples that show how to use CrewAI framework to automate workflows.",
        "metadata": {
          "section_type": "Examples",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "Customizing Prompts",
        "level": 1,
        "content": "Source: https://docs.crewai.com/guides/advanced/customizing-prompts Dive deeper into low-level prompt customization for CrewAI, enabling super custom and complex use cases for different models and languages.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "Customizing Prompts at a Low Level",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Why Customize Prompts?",
            "level": 2,
            "content": "Although CrewAI's default prompts work well for many scenarios, low-level customization opens the door to significantly more flexible and powerful agent behavior. Here\u2019s why you might want to take advantage of this deeper control: **Optimize for specific LLMs** \u2013 Different models (such as GPT-4, Claude, or Llama) thrive with prompt formats tailored to their unique architectures. **Change the language** \u2013 Build agents that operate exclusively in languages beyond English, handling nuances with precision. **Specialize for complex domains** \u2013 Adapt prompts for highly specialized industries like healthcare, finance, or legal. **Adjust tone and style** \u2013 Make agents more formal, casual, creative, or analytical. **Support super custom use cases** \u2013 Utilize advanced prompt structures and formatting to meet intricate, project-specific requirements. This guide explores how to tap into CrewAI's prompts at a lower level, giving you fine-grained control over how agents think and interact.",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Understanding CrewAI's Prompt System",
            "level": 2,
            "content": "Under the hood, CrewAI employs a modular prompt system that you can customize extensively: **Agent templates** \u2013 Govern each agent\u2019s approach to their assigned role. **Prompt slices** \u2013 Control specialized behaviors such as tasks, tool usage, and output structure. **Error handling** \u2013 Direct how agents respond to failures, exceptions, or timeouts. **Tool-specific prompts** \u2013 Define detailed instructions for how tools are invoked or utilized. Check out the [original prompt templates in CrewAI's repository](https://github.com/crewAIInc/crewAI/blob/main/src/crewai/translations/en.json) to see how these elements are organized. From there, you can override or adapt them as needed to unlock advanced behaviors.",
            "metadata": {
              "section_type": "General",
              "content_type": "link_list"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Best Practices for Managing Prompt Files",
            "level": 2,
            "content": "When engaging in low-level prompt customization, follow these guidelines to keep things organized and maintainable: **Keep files separate** \u2013 Store your customized prompts in dedicated JSON files outside your main codebase. **Version control** \u2013 Track changes within your repository, ensuring clear documentation of prompt adjustments over time. **Organize by model or language** \u2013 Use naming schemes like `prompts_llama.json` or `prompts_es.json` to quickly identify specialized configurations. **Document changes** \u2013 Provide comments or maintain a README detailing the purpose and scope of your customizations. **Minimize alterations** \u2013 Only override the specific slices you genuinely need to adjust, keeping default functionality intact for everything else.",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "The Simplest Way to Customize Prompts",
            "level": 2,
            "content": "One straightforward approach is to create a JSON file for the prompts you want to override and then point your Crew at that file: Craft a JSON file with your updated prompt slices. Reference that file via the `prompt_file` parameter in your Crew. CrewAI then merges your customizations with the defaults, so you don\u2019t have to redefine every prompt. Here\u2019s how:",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": [
              {
                "type": "header",
                "title": "Example: Basic Prompt Customization",
                "level": 3,
                "content": "Create a `custom_prompts.json` file with the prompts you want to modify. Ensure you list all top-level prompts it should contain, not just your changes:\n```\n{\n  \"slices\": {\n    \"format\": \"When responding, follow this structure:\\n\\nTHOUGHTS: Your step-by-step thinking\\nACTION: Any tool you're using\\nRESULT: Your final answer or conclusion\"\n  }\n}\n```\nThen integrate it like so:\n```\nfrom crewai import Agent, Crew, Task, Process\n\n# Create agents and tasks as normal\nresearcher = Agent(\n    role=\"Research Specialist\",\n    goal=\"Find information on quantum computing\",\n    backstory=\"You are a quantum physics expert\",\n    verbose=True\n)\n\nresearch_task = Task(\n    description=\"Research quantum computing applications\",\n    expected_output=\"A summary of practical applications\",\n    agent=researcher\n)\n\n# Create a crew with your custom prompt file\ncrew = Crew(\n    agents=[researcher],\n    tasks=[research_task],\n    prompt_file=\"path/to/custom_prompts.json\",\n    verbose=True\n)\n\n# Run the crew\nresult = crew.kickoff()\n```\nWith these few edits, you gain low-level control over how your agents communicate and solve tasks.",
                "metadata": {
                  "section_type": "Examples",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "json",
                    "content": "{\n  \"slices\": {\n    \"format\": \"When responding, follow this structure:\\n\\nTHOUGHTS: Your step-by-step thinking\\nACTION: Any tool you're using\\nRESULT: Your final answer or conclusion\"\n  }\n}",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  },
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "from crewai import Agent, Crew, Task, Process\n\n# Create agents and tasks as normal\nresearcher = Agent(\n    role=\"Research Specialist\",\n    goal=\"Find information on quantum computing\",\n    backstory=\"You are a quantum physics expert\",\n    verbose=True\n)\n\nresearch_task = Task(\n    description=\"Research quantum computing applications\",\n    expected_output=\"A summary of practical applications\",\n    agent=researcher\n)\n\n# Create a crew with your custom prompt file\ncrew = Crew(\n    agents=[researcher],\n    tasks=[research_task],\n    prompt_file=\"path/to/custom_prompts.json\",\n    verbose=True\n)\n\n# Run the crew\nresult = crew.kickoff()",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              }
            ]
          },
          {
            "type": "header",
            "title": "Optimizing for Specific Models",
            "level": 2,
            "content": "Different models thrive on differently structured prompts. Making deeper adjustments can significantly boost performance by aligning your prompts with a model\u2019s nuances.",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": [
              {
                "type": "header",
                "title": "Example: Llama 3.3 Prompting Template",
                "level": 3,
                "content": "For instance, when dealing with Meta\u2019s Llama 3.3, deeper-level customization may reflect the recommended structure described at:\n[https://www.llama.com/docs/model-cards-and-prompt-formats/llama3\\_1/#prompt-template](https://www.llama.com/docs/model-cards-and-prompt-formats/llama3_1/#prompt-template) Here\u2019s an example to highlight how you might fine-tune an Agent to leverage Llama 3.3 in code:\n```\nfrom crewai import Agent, Crew, Task, Process\nfrom crewai_tools import DirectoryReadTool, FileReadTool\n\n# Define templates for system, user (prompt), and assistant (response) messages\nsystem_template = \"\"\"<|begin_of_text|><|start_header_id|>system<|end_header_id|>{{ .System }}<|eot_id|>\"\"\"\nprompt_template = \"\"\"<|start_header_id|>user<|end_header_id|>{{ .Prompt }}<|eot_id|>\"\"\"\nresponse_template = \"\"\"<|start_header_id|>assistant<|end_header_id|>{{ .Response }}<|eot_id|>\"\"\"\n\n# Create an Agent using Llama-specific layouts\nprincipal_engineer = Agent(\n    role=\"Principal Engineer\",\n    goal=\"Oversee AI architecture and make high-level decisions\",\n    backstory=\"You are the lead engineer responsible for critical AI systems\",\n    verbose=True,\n    llm=\"groq/llama-3.3-70b-versatile\",  # Using the Llama 3 model\n    system_template=system_template,\n    prompt_template=prompt_template,\n    response_template=response_template,\n    tools=[DirectoryReadTool(), FileReadTool()]\n)\n\n# Define a sample task\nengineering_task = Task(\n    description=\"Review AI implementation files for potential improvements\",\n    expected_output=\"A summary of key findings and recommendations\",\n    agent=principal_engineer\n)\n\n# Create a Crew for the task\nllama_crew = Crew(\n    agents=[principal_engineer],\n    tasks=[engineering_task],\n    process=Process.sequential,\n    verbose=True\n)\n\n# Execute the crew\nresult = llama_crew.kickoff()\nprint(result.raw)\n```\nThrough this deeper configuration, you can exercise comprehensive, low-level control over your Llama-based workflows without needing a separate JSON file.",
                "metadata": {
                  "section_type": "Examples",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "from crewai import Agent, Crew, Task, Process\nfrom crewai_tools import DirectoryReadTool, FileReadTool\n\n# Define templates for system, user (prompt), and assistant (response) messages\nsystem_template = \"\"\"<|begin_of_text|><|start_header_id|>system<|end_header_id|>{{ .System }}<|eot_id|>\"\"\"\nprompt_template = \"\"\"<|start_header_id|>user<|end_header_id|>{{ .Prompt }}<|eot_id|>\"\"\"\nresponse_template = \"\"\"<|start_header_id|>assistant<|end_header_id|>{{ .Response }}<|eot_id|>\"\"\"\n\n# Create an Agent using Llama-specific layouts\nprincipal_engineer = Agent(\n    role=\"Principal Engineer\",\n    goal=\"Oversee AI architecture and make high-level decisions\",\n    backstory=\"You are the lead engineer responsible for critical AI systems\",\n    verbose=True,\n    llm=\"groq/llama-3.3-70b-versatile\",  # Using the Llama 3 model\n    system_template=system_template,\n    prompt_template=prompt_template,\n    response_template=response_template,\n    tools=[DirectoryReadTool(), FileReadTool()]\n)\n\n# Define a sample task\nengineering_task = Task(\n    description=\"Review AI implementation files for potential improvements\",\n    expected_output=\"A summary of key findings and recommendations\",\n    agent=principal_engineer\n)\n\n# Create a Crew for the task\nllama_crew = Crew(\n    agents=[principal_engineer],\n    tasks=[engineering_task],\n    process=Process.sequential,\n    verbose=True\n)\n\n# Execute the crew\nresult = llama_crew.kickoff()\nprint(result.raw)",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              }
            ]
          },
          {
            "type": "header",
            "title": "Conclusion",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Fingerprinting",
        "level": 1,
        "content": "Source: https://docs.crewai.com/guides/advanced/fingerprinting Learn how to use CrewAI's fingerprinting system to uniquely identify and track components throughout their lifecycle.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "Fingerprinting in CrewAI",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Overview",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Concepts documentation",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "How Fingerprints Work",
            "level": 2,
            "content": "A fingerprint is an instance of the `Fingerprint` class from the `crewai.security` module. Each fingerprint contains: A UUID string: A unique identifier for the component that is automatically generated and cannot be manually set A creation timestamp: When the fingerprint was generated, automatically set and cannot be manually modified Metadata: A dictionary of additional information that can be customized Fingerprints are automatically generated and assigned when a component is created. Each component exposes its fingerprint through a read-only property.",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Basic Usage",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": [
              {
                "type": "header",
                "title": "Accessing Fingerprints",
                "level": 3,
                "content": "```\nfrom crewai import Agent, Crew, Task\n\n# Create components - fingerprints are automatically generated\nagent = Agent(\n    role=\"Data Scientist\",\n    goal=\"Analyze data\",\n    backstory=\"Expert in data analysis\"\n)\n\ncrew = Crew(\n    agents=[agent],\n    tasks=[]\n)\n\ntask = Task(\n    description=\"Analyze customer data\",\n    expected_output=\"Insights from data analysis\",\n    agent=agent\n)\n\n# Access the fingerprints\nagent_fingerprint = agent.fingerprint\ncrew_fingerprint = crew.fingerprint\ntask_fingerprint = task.fingerprint\n\n# Print the UUID strings\nprint(f\"Agent fingerprint: {agent_fingerprint.uuid_str}\")\nprint(f\"Crew fingerprint: {crew_fingerprint.uuid_str}\")\nprint(f\"Task fingerprint: {task_fingerprint.uuid_str}\")\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "from crewai import Agent, Crew, Task\n\n# Create components - fingerprints are automatically generated\nagent = Agent(\n    role=\"Data Scientist\",\n    goal=\"Analyze data\",\n    backstory=\"Expert in data analysis\"\n)\n\ncrew = Crew(\n    agents=[agent],\n    tasks=[]\n)\n\ntask = Task(\n    description=\"Analyze customer data\",\n    expected_output=\"Insights from data analysis\",\n    agent=agent\n)\n\n# Access the fingerprints\nagent_fingerprint = agent.fingerprint\ncrew_fingerprint = crew.fingerprint\ntask_fingerprint = task.fingerprint\n\n# Print the UUID strings\nprint(f\"Agent fingerprint: {agent_fingerprint.uuid_str}\")\nprint(f\"Crew fingerprint: {crew_fingerprint.uuid_str}\")\nprint(f\"Task fingerprint: {task_fingerprint.uuid_str}\")",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Working with Fingerprint Metadata",
                "level": 3,
                "content": "You can add metadata to fingerprints for additional context:\n```\n# Add metadata to the agent's fingerprint\nagent.security_config.fingerprint.metadata = {\n    \"version\": \"1.0\",\n    \"department\": \"Data Science\",\n    \"project\": \"Customer Analysis\"\n}\n\n# Access the metadata\nprint(f\"Agent metadata: {agent.fingerprint.metadata}\")\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "# Add metadata to the agent's fingerprint\nagent.security_config.fingerprint.metadata = {\n    \"version\": \"1.0\",\n    \"department\": \"Data Science\",\n    \"project\": \"Customer Analysis\"\n}\n\n# Access the metadata\nprint(f\"Agent metadata: {agent.fingerprint.metadata}\")",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              }
            ]
          },
          {
            "type": "header",
            "title": "Fingerprint Persistence",
            "level": 2,
            "content": "Fingerprints are designed to persist and remain unchanged throughout a component's lifecycle. If you modify a component, the fingerprint remains the same:\n```\noriginal_fingerprint = agent.fingerprint.uuid_str\n\n# Modify the agent\nagent.goal = \"New goal for analysis\"\n\n# The fingerprint remains unchanged\nassert agent.fingerprint.uuid_str == original_fingerprint\n```",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python",
                "content": "original_fingerprint = agent.fingerprint.uuid_str\n\n# Modify the agent\nagent.goal = \"New goal for analysis\"\n\n# The fingerprint remains unchanged\nassert agent.fingerprint.uuid_str == original_fingerprint",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Deterministic Fingerprints",
            "level": 2,
            "content": "While you cannot directly set the UUID and creation timestamp, you can create deterministic fingerprints using the `generate` method with a seed:\n```\nfrom crewai.security import Fingerprint\n\n# Create a deterministic fingerprint using a seed string\ndeterministic_fingerprint = Fingerprint.generate(seed=\"my-agent-id\")\n\n# The same seed always produces the same fingerprint\nsame_fingerprint = Fingerprint.generate(seed=\"my-agent-id\")\nassert deterministic_fingerprint.uuid_str == same_fingerprint.uuid_str\n\n# You can also set metadata\ncustom_fingerprint = Fingerprint.generate(\n    seed=\"my-agent-id\",\n    metadata={\"version\": \"1.0\"}\n)\n```",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python",
                "content": "from crewai.security import Fingerprint\n\n# Create a deterministic fingerprint using a seed string\ndeterministic_fingerprint = Fingerprint.generate(seed=\"my-agent-id\")\n\n# The same seed always produces the same fingerprint\nsame_fingerprint = Fingerprint.generate(seed=\"my-agent-id\")\nassert deterministic_fingerprint.uuid_str == same_fingerprint.uuid_str\n\n# You can also set metadata\ncustom_fingerprint = Fingerprint.generate(\n    seed=\"my-agent-id\",\n    metadata={\"version\": \"1.0\"}\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Advanced Usage",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": [
              {
                "type": "header",
                "title": "Fingerprint Structure",
                "level": 3,
                "content": "Each fingerprint has the following structure:\n```\nfrom crewai.security import Fingerprint\n\nfingerprint = agent.fingerprint\n\n# UUID string - the unique identifier (auto-generated)\nuuid_str = fingerprint.uuid_str  # e.g., \"123e4567-e89b-12d3-a456-426614174000\"\n\n# Creation timestamp (auto-generated)\ncreated_at = fingerprint.created_at  # A datetime object\n\n# Metadata - for additional information (can be customized)\nmetadata = fingerprint.metadata  # A dictionary, defaults to {}\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "from crewai.security import Fingerprint\n\nfingerprint = agent.fingerprint\n\n# UUID string - the unique identifier (auto-generated)\nuuid_str = fingerprint.uuid_str  # e.g., \"123e4567-e89b-12d3-a456-426614174000\"\n\n# Creation timestamp (auto-generated)\ncreated_at = fingerprint.created_at  # A datetime object\n\n# Metadata - for additional information (can be customized)\nmetadata = fingerprint.metadata  # A dictionary, defaults to {}",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type": "header",
        "title": "Crafting Effective Agents",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": []
      },
      {
        "type": "header",
        "title": "Crafting Effective Agents",
        "level": 1,
        "content": "Source: https://docs.crewai.com/guides/agents/crafting-effective-agents Learn best practices for designing powerful, specialized AI agents that collaborate effectively to solve complex problems.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": [
          {
            "type": "header",
            "title": "The Art and Science of Agent Design",
            "level": 2,
            "content": "At the heart of CrewAI lies the agent - a specialized AI entity designed to perform specific roles within a collaborative framework. While creating basic agents is simple, crafting truly effective agents that produce exceptional results requires understanding key design principles and best practices. This guide will help you master the art of agent design, enabling you to create specialized AI personas that collaborate effectively, think critically, and produce high-quality outputs tailored to your specific needs.",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": [
              {
                "type": "header",
                "title": "Why Agent Design Matters",
                "level": 3,
                "content": "The way you define your agents significantly impacts: **Output quality**: Well-designed agents produce more relevant, high-quality results **Collaboration effectiveness**: Agents with complementary skills work together more efficiently **Task performance**: Agents with clear roles and goals execute tasks more effectively **System scalability**: Thoughtfully designed agents can be reused across multiple crews and contexts Let's explore best practices for creating agents that excel in these dimensions.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "descriptive_text"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "The 80/20 Rule: Focus on Tasks Over Agents",
            "level": 2,
            "content": "When building effective AI systems, remember this crucial principle: **80% of your effort should go into designing tasks, and only 20% into defining agents**. Why? Because even the most perfectly defined agent will fail with poorly designed tasks, but well-designed tasks can elevate even a simple agent. This means: Spend most of your time writing clear task instructions Define detailed inputs and expected outputs Add examples and context to guide execution Dedicate the remaining time to agent role, goal, and backstory This doesn't mean agent design isn't important - it absolutely is. But task design is where most execution failures occur, so prioritize accordingly.",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Core Principles of Effective Agent Design",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": [
              {
                "type": "header",
                "title": "1. The Role-Goal-Backstory Framework",
                "level": 3,
                "content": "The most powerful agents in CrewAI are built on a strong foundation of three key elements:",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": [
                  {
                    "type": "header",
                    "title": "Role: The Agent's Specialized Function",
                    "level": 4,
                    "content": "The role defines what the agent does and their area of expertise. When crafting roles: **Be specific and specialized**: Instead of \"Writer,\" use \"Technical Documentation Specialist\" or \"Creative Storyteller\" **Align with real-world professions**: Base roles on recognizable professional archetypes **Include domain expertise**: Specify the agent's field of knowledge (e.g., \"Financial Analyst specializing in market trends\") **Examples of effective roles:**\n```\nrole: \"Senior UX Researcher specializing in user interview analysis\"\nrole: \"Full-Stack Software Architect with expertise in distributed systems\"\nrole: \"Corporate Communications Director specializing in crisis management\"\n```",
                    "metadata": {
                      "section_type": "General",
                      "content_type": "code_example"
                    },
                    "children": [],
                    "code_blocks": [
                      {
                        "type": "code_block",
                        "language": "yaml",
                        "content": "role: \"Senior UX Researcher specializing in user interview analysis\"\nrole: \"Full-Stack Software Architect with expertise in distributed systems\"\nrole: \"Corporate Communications Director specializing in crisis management\"",
                        "metadata": {
                          "section_type": "code",
                          "content_type": "code_example"
                        },
                        "children": []
                      }
                    ]
                  },
                  {
                    "type": "header",
                    "title": "Goal: The Agent's Purpose and Motivation",
                    "level": 4,
                    "content": "The goal directs the agent's efforts and shapes their decision-making process. Effective goals should: **Be clear and outcome-focused**: Define what the agent is trying to achieve **Emphasize quality standards**: Include expectations about the quality of work **Incorporate success criteria**: Help the agent understand what \"good\" looks like **Examples of effective goals:**\n```\ngoal: \"Uncover actionable user insights by analyzing interview data and identifying recurring patterns, unmet needs, and improvement opportunities\"\ngoal: \"Design robust, scalable system architectures that balance performance, maintainability, and cost-effectiveness\"\ngoal: \"Craft clear, empathetic crisis communications that address stakeholder concerns while protecting organizational reputation\"\n```",
                    "metadata": {
                      "section_type": "General",
                      "content_type": "code_example"
                    },
                    "children": [],
                    "code_blocks": [
                      {
                        "type": "code_block",
                        "language": "yaml",
                        "content": "goal: \"Uncover actionable user insights by analyzing interview data and identifying recurring patterns, unmet needs, and improvement opportunities\"\ngoal: \"Design robust, scalable system architectures that balance performance, maintainability, and cost-effectiveness\"\ngoal: \"Craft clear, empathetic crisis communications that address stakeholder concerns while protecting organizational reputation\"",
                        "metadata": {
                          "section_type": "code",
                          "content_type": "code_example"
                        },
                        "children": []
                      }
                    ]
                  },
                  {
                    "type": "header",
                    "title": "Backstory: The Agent's Experience and Perspective",
                    "level": 4,
                    "content": "The backstory gives depth to the agent, influencing how they approach problems and interact with others. Good backstories: **Establish expertise and experience**: Explain how the agent gained their skills **Define working style and values**: Describe how the agent approaches their work **Create a cohesive persona**: Ensure all elements of the backstory align with the role and goal **Examples of effective backstories:**\n```\nbackstory: \"You have spent 15 years conducting and analyzing user research for top tech companies. You have a talent for reading between the lines and identifying patterns that others miss. You believe that good UX is invisible and that the best insights come from listening to what users don't say as much as what they do say.\"\n\nbackstory: \"With 20+ years of experience building distributed systems at scale, you've developed a pragmatic approach to software architecture. You've seen both successful and failed systems and have learned valuable lessons from each. You balance theoretical best practices with practical constraints and always consider the maintenance and operational aspects of your designs.\"\n\nbackstory: \"As a seasoned communications professional who has guided multiple organizations through high-profile crises, you understand the importance of transparency, speed, and empathy in crisis response. You have a methodical approach to crafting messages that address concerns while maintaining organizational credibility.\"\n```",
                    "metadata": {
                      "section_type": "General",
                      "content_type": "code_example"
                    },
                    "children": [],
                    "code_blocks": [
                      {
                        "type": "code_block",
                        "language": "yaml",
                        "content": "backstory: \"You have spent 15 years conducting and analyzing user research for top tech companies. You have a talent for reading between the lines and identifying patterns that others miss. You believe that good UX is invisible and that the best insights come from listening to what users don't say as much as what they do say.\"\n\nbackstory: \"With 20+ years of experience building distributed systems at scale, you've developed a pragmatic approach to software architecture. You've seen both successful and failed systems and have learned valuable lessons from each. You balance theoretical best practices with practical constraints and always consider the maintenance and operational aspects of your designs.\"\n\nbackstory: \"As a seasoned communications professional who has guided multiple organizations through high-profile crises, you understand the importance of transparency, speed, and empathy in crisis response. You have a methodical approach to crafting messages that address concerns while maintaining organizational credibility.\"",
                        "metadata": {
                          "section_type": "code",
                          "content_type": "code_example"
                        },
                        "children": []
                      }
                    ]
                  }
                ]
              },
              {
                "type": "header",
                "title": "2. Specialists Over Generalists",
                "level": 3,
                "content": "Agents perform significantly better when given specialized roles rather than general ones. A highly focused agent delivers more precise, relevant outputs: **Generic (Less Effective):**\n```\nrole: \"Writer\"\n```\n**Specialized (More Effective):**\n```\nrole: \"Technical Blog Writer specializing in explaining complex AI concepts to non-technical audiences\"\n```\n**Specialist Benefits:** Clearer understanding of expected output More consistent performance Better alignment with specific tasks Improved ability to make domain-specific judgments",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "yaml",
                    "content": "role: \"Writer\"",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  },
                  {
                    "type": "code_block",
                    "language": "yaml",
                    "content": "role: \"Technical Blog Writer specializing in explaining complex AI concepts to non-technical audiences\"",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "3. Balancing Specialization and Versatility",
                "level": 3,
                "content": "Effective agents strike the right balance between specialization (doing one thing extremely well) and versatility (being adaptable to various situations): **Specialize in role, versatile in application**: Create agents with specialized skills that can be applied across multiple contexts **Avoid overly narrow definitions**: Ensure agents can handle variations within their domain of expertise **Consider the collaborative context**: Design agents whose specializations complement the other agents they'll work with",
                "metadata": {
                  "section_type": "General",
                  "content_type": "descriptive_text"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "4. Setting Appropriate Expertise Levels",
                "level": 3,
                "content": "The expertise level you assign to your agent shapes how they approach tasks: **Novice agents**: Good for straightforward tasks, brainstorming, or initial drafts **Intermediate agents**: Suitable for most standard tasks with reliable execution **Expert agents**: Best for complex, specialized tasks requiring depth and nuance **World-class agents**: Reserved for critical tasks where exceptional quality is needed Choose the appropriate expertise level based on task complexity and quality requirements. For most collaborative crews, a mix of expertise levels often works best, with higher expertise assigned to core specialized functions.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "descriptive_text"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Practical Examples: Before and After",
            "level": 2,
            "content": "Let's look at some examples of agent definitions before and after applying these best practices:",
            "metadata": {
              "section_type": "Examples",
              "content_type": "short_description"
            },
            "children": [
              {
                "type": "header",
                "title": "Example 1: Content Creation Agent",
                "level": 3,
                "content": "**Before:**\n```\nrole: \"Writer\"\ngoal: \"Write good content\"\nbackstory: \"You are a writer who creates content for websites.\"\n```\n**After:**\n```\nrole: \"B2B Technology Content Strategist\"\ngoal: \"Create compelling, technically accurate content that explains complex topics in accessible language while driving reader engagement and supporting business objectives\"\nbackstory: \"You have spent a decade creating content for leading technology companies, specializing in translating technical concepts for business audiences. You excel at research, interviewing subject matter experts, and structuring information for maximum clarity and impact. You believe that the best B2B content educates first and sells second, building trust through genuine expertise rather than marketing hype.\"\n```",
                "metadata": {
                  "section_type": "Examples",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "yaml",
                    "content": "role: \"Writer\"\ngoal: \"Write good content\"\nbackstory: \"You are a writer who creates content for websites.\"",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  },
                  {
                    "type": "code_block",
                    "language": "yaml",
                    "content": "role: \"B2B Technology Content Strategist\"\ngoal: \"Create compelling, technically accurate content that explains complex topics in accessible language while driving reader engagement and supporting business objectives\"\nbackstory: \"You have spent a decade creating content for leading technology companies, specializing in translating technical concepts for business audiences. You excel at research, interviewing subject matter experts, and structuring information for maximum clarity and impact. You believe that the best B2B content educates first and sells second, building trust through genuine expertise rather than marketing hype.\"",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Example 2: Research Agent",
                "level": 3,
                "content": "**Before:**\n```\nrole: \"Researcher\"\ngoal: \"Find information\"\nbackstory: \"You are good at finding information online.\"\n```\n**After:**\n```\nrole: \"Academic Research Specialist in Emerging Technologies\"\ngoal: \"Discover and synthesize cutting-edge research, identifying key trends, methodologies, and findings while evaluating the quality and reliability of sources\"\nbackstory: \"With a background in both computer science and library science, you've mastered the art of digital research. You've worked with research teams at prestigious universities and know how to navigate academic databases, evaluate research quality, and synthesize findings across disciplines. You're methodical in your approach, always cross-referencing information and tracing claims to primary sources before drawing conclusions.\"\n```",
                "metadata": {
                  "section_type": "Examples",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "yaml",
                    "content": "role: \"Researcher\"\ngoal: \"Find information\"\nbackstory: \"You are good at finding information online.\"",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  },
                  {
                    "type": "code_block",
                    "language": "yaml",
                    "content": "role: \"Academic Research Specialist in Emerging Technologies\"\ngoal: \"Discover and synthesize cutting-edge research, identifying key trends, methodologies, and findings while evaluating the quality and reliability of sources\"\nbackstory: \"With a background in both computer science and library science, you've mastered the art of digital research. You've worked with research teams at prestigious universities and know how to navigate academic databases, evaluate research quality, and synthesize findings across disciplines. You're methodical in your approach, always cross-referencing information and tracing claims to primary sources before drawing conclusions.\"",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              }
            ]
          },
          {
            "type": "header",
            "title": "Crafting Effective Tasks for Your Agents",
            "level": 2,
            "content": "While agent design is important, task design is critical for successful execution. Here are best practices for designing tasks that set your agents up for success:",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": [
              {
                "type": "header",
                "title": "The Anatomy of an Effective Task",
                "level": 3,
                "content": "A well-designed task has two key components that serve different purposes:",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": [
                  {
                    "type": "header",
                    "title": "Task Description: The Process",
                    "level": 4,
                    "content": "The description should focus on what to do and how to do it, including: Detailed instructions for execution Context and background information Scope and constraints Process steps to follow",
                    "metadata": {
                      "section_type": "General",
                      "content_type": "short_description"
                    },
                    "children": []
                  },
                  {
                    "type": "header",
                    "title": "Expected Output: The Deliverable",
                    "level": 4,
                    "content": "The expected output should define what the final result should look like: Format specifications (markdown, JSON, etc.) Structure requirements Quality criteria Examples of good outputs (when possible)",
                    "metadata": {
                      "section_type": "General",
                      "content_type": "short_description"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Task Design Best Practices",
                "level": 3,
                "content": "",
                "metadata": {
                  "section_type": "General",
                  "content_type": null
                },
                "children": [
                  {
                    "type": "header",
                    "title": "1. Single Purpose, Single Output",
                    "level": 4,
                    "content": "Tasks perform best when focused on one clear objective: **Bad Example (Too Broad):**\n```\ntask_description: \"Research market trends, analyze the data, and create a visualization.\"\n```\n**Good Example (Focused):**\n```\n# Task 1\nresearch_task:\n  description: \"Research the top 5 market trends in the AI industry for 2024.\"\n  expected_output: \"A markdown list of the 5 trends with supporting evidence.\"\n\n# Task 2\nanalysis_task:\n  description: \"Analyze the identified trends to determine potential business impacts.\"\n  expected_output: \"A structured analysis with impact ratings (High/Medium/Low).\"\n\n# Task 3\nvisualization_task:\n  description: \"Create a visual representation of the analyzed trends.\"\n  expected_output: \"A description of a chart showing trends and their impact ratings.\"\n```",
                    "metadata": {
                      "section_type": "General",
                      "content_type": "code_example"
                    },
                    "children": [],
                    "code_blocks": [
                      {
                        "type": "code_block",
                        "language": "yaml",
                        "content": "task_description: \"Research market trends, analyze the data, and create a visualization.\"",
                        "metadata": {
                          "section_type": "code",
                          "content_type": "code_example"
                        },
                        "children": []
                      },
                      {
                        "type": "code_block",
                        "language": "yaml",
                        "content": "# Task 1\nresearch_task:\n  description: \"Research the top 5 market trends in the AI industry for 2024.\"\n  expected_output: \"A markdown list of the 5 trends with supporting evidence.\"\n\n# Task 2\nanalysis_task:\n  description: \"Analyze the identified trends to determine potential business impacts.\"\n  expected_output: \"A structured analysis with impact ratings (High/Medium/Low).\"\n\n# Task 3\nvisualization_task:\n  description: \"Create a visual representation of the analyzed trends.\"\n  expected_output: \"A description of a chart showing trends and their impact ratings.\"",
                        "metadata": {
                          "section_type": "code",
                          "content_type": "code_example"
                        },
                        "children": []
                      }
                    ]
                  },
                  {
                    "type": "header",
                    "title": "2. Be Explicit About Inputs and Outputs",
                    "level": 4,
                    "content": "Always clearly specify what inputs the task will use and what the output should look like: **Example:**\n```\nanalysis_task:\n  description: >\n    Analyze the customer feedback data from the CSV file.\n    Focus on identifying recurring themes related to product usability.\n    Consider sentiment and frequency when determining importance.\n  expected_output: >\n    A markdown report with the following sections:\n    1. Executive summary (3-5 bullet points)\n    2. Top 3 usability issues with supporting data\n    3. Recommendations for improvement\n```",
                    "metadata": {
                      "section_type": "General",
                      "content_type": "code_example"
                    },
                    "children": [],
                    "code_blocks": [
                      {
                        "type": "code_block",
                        "language": "yaml",
                        "content": "analysis_task:\n  description: >\n    Analyze the customer feedback data from the CSV file.\n    Focus on identifying recurring themes related to product usability.\n    Consider sentiment and frequency when determining importance.\n  expected_output: >\n    A markdown report with the following sections:\n    1. Executive summary (3-5 bullet points)\n    2. Top 3 usability issues with supporting data\n    3. Recommendations for improvement",
                        "metadata": {
                          "section_type": "code",
                          "content_type": "code_example"
                        },
                        "children": []
                      }
                    ]
                  },
                  {
                    "type": "header",
                    "title": "3. Include Purpose and Context",
                    "level": 4,
                    "content": "Explain why the task matters and how it fits into the larger workflow: **Example:**\n```\ncompetitor_analysis_task:\n  description: >\n    Analyze our three main competitors' pricing strategies.\n    This analysis will inform our upcoming pricing model revision.\n    Focus on identifying patterns in how they price premium features\n    and how they structure their tiered offerings.\n```",
                    "metadata": {
                      "section_type": "General",
                      "content_type": "code_example"
                    },
                    "children": [],
                    "code_blocks": [
                      {
                        "type": "code_block",
                        "language": "yaml",
                        "content": "competitor_analysis_task:\n  description: >\n    Analyze our three main competitors' pricing strategies.\n    This analysis will inform our upcoming pricing model revision.\n    Focus on identifying patterns in how they price premium features\n    and how they structure their tiered offerings.",
                        "metadata": {
                          "section_type": "code",
                          "content_type": "code_example"
                        },
                        "children": []
                      }
                    ]
                  },
                  {
                    "type": "header",
                    "title": "4. Use Structured Output Tools",
                    "level": 4,
                    "content": "For machine-readable outputs, specify the format clearly: **Example:**\n```\ndata_extraction_task:\n  description: \"Extract key metrics from the quarterly report.\"\n  expected_output: \"JSON object with the following keys: revenue, growth_rate, customer_acquisition_cost, and retention_rate.\"\n```",
                    "metadata": {
                      "section_type": "General",
                      "content_type": "code_example"
                    },
                    "children": [],
                    "code_blocks": [
                      {
                        "type": "code_block",
                        "language": "yaml",
                        "content": "data_extraction_task:\n  description: \"Extract key metrics from the quarterly report.\"\n  expected_output: \"JSON object with the following keys: revenue, growth_rate, customer_acquisition_cost, and retention_rate.\"",
                        "metadata": {
                          "section_type": "code",
                          "content_type": "code_example"
                        },
                        "children": []
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "header",
            "title": "Common Mistakes to Avoid",
            "level": 2,
            "content": "Based on lessons learned from real-world implementations, here are the most common pitfalls in agent and task design:",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": [
              {
                "type": "header",
                "title": "1. Unclear Task Instructions",
                "level": 3,
                "content": "**Problem:** Tasks lack sufficient detail, making it difficult for agents to execute effectively. **Example of Poor Design:**\n```\nresearch_task:\n  description: \"Research AI trends.\"\n  expected_output: \"A report on AI trends.\"\n```\n**Improved Version:**\n```\nresearch_task:\n  description: >\n    Research the top emerging AI trends for 2024 with a focus on:\n    1. Enterprise adoption patterns\n    2. Technical breakthroughs in the past 6 months\n    3. Regulatory developments affecting implementation\n\n    For each trend, identify key companies, technologies, and potential business impacts.\n  expected_output: >\n    A comprehensive markdown report with:\n    - Executive summary (5 bullet points)\n    - 5-7 major trends with supporting evidence\n    - For each trend: definition, examples, and business implications\n    - References to authoritative sources\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "yaml",
                    "content": "research_task:\n  description: \"Research AI trends.\"\n  expected_output: \"A report on AI trends.\"",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  },
                  {
                    "type": "code_block",
                    "language": "yaml",
                    "content": "research_task:\n  description: >\n    Research the top emerging AI trends for 2024 with a focus on:\n    1. Enterprise adoption patterns\n    2. Technical breakthroughs in the past 6 months\n    3. Regulatory developments affecting implementation\n\n    For each trend, identify key companies, technologies, and potential business impacts.\n  expected_output: >\n    A comprehensive markdown report with:\n    - Executive summary (5 bullet points)\n    - 5-7 major trends with supporting evidence\n    - For each trend: definition, examples, and business implications\n    - References to authoritative sources",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "2. \"God Tasks\" That Try to Do Too Much",
                "level": 3,
                "content": "**Problem:** Tasks that combine multiple complex operations into one instruction set. **Example of Poor Design:**\n```\ncomprehensive_task:\n  description: \"Research market trends, analyze competitor strategies, create a marketing plan, and design a launch timeline.\"\n```\n**Improved Version:**\nBreak this into sequential, focused tasks:\n```\n# Task 1: Research\nmarket_research_task:\n  description: \"Research current market trends in the SaaS project management space.\"\n  expected_output: \"A markdown summary of key market trends.\"\n\n# Task 2: Competitive Analysis\ncompetitor_analysis_task:\n  description: \"Analyze strategies of the top 3 competitors based on the market research.\"\n  expected_output: \"A comparison table of competitor strategies.\"\n  context: [market_research_task]\n\n# Continue with additional focused tasks...\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "yaml",
                    "content": "comprehensive_task:\n  description: \"Research market trends, analyze competitor strategies, create a marketing plan, and design a launch timeline.\"",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  },
                  {
                    "type": "code_block",
                    "language": "yaml",
                    "content": "# Task 1: Research\nmarket_research_task:\n  description: \"Research current market trends in the SaaS project management space.\"\n  expected_output: \"A markdown summary of key market trends.\"\n\n# Task 2: Competitive Analysis\ncompetitor_analysis_task:\n  description: \"Analyze strategies of the top 3 competitors based on the market research.\"\n  expected_output: \"A comparison table of competitor strategies.\"\n  context: [market_research_task]\n\n# Continue with additional focused tasks...",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "3. Misaligned Description and Expected Output",
                "level": 3,
                "content": "**Problem:** The task description asks for one thing while the expected output specifies something different. **Example of Poor Design:**\n```\nanalysis_task:\n  description: \"Analyze customer feedback to find areas of improvement.\"\n  expected_output: \"A marketing plan for the next quarter.\"\n```\n**Improved Version:**\n```\nanalysis_task:\n  description: \"Analyze customer feedback to identify the top 3 areas for product improvement.\"\n  expected_output: \"A report listing the 3 priority improvement areas with supporting customer quotes and data points.\"\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "yaml",
                    "content": "analysis_task:\n  description: \"Analyze customer feedback to find areas of improvement.\"\n  expected_output: \"A marketing plan for the next quarter.\"",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  },
                  {
                    "type": "code_block",
                    "language": "yaml",
                    "content": "analysis_task:\n  description: \"Analyze customer feedback to identify the top 3 areas for product improvement.\"\n  expected_output: \"A report listing the 3 priority improvement areas with supporting customer quotes and data points.\"",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "4. Not Understanding the Process Yourself",
                "level": 3,
                "content": "**Problem:** Asking agents to execute tasks that you yourself don't fully understand. **Solution:** Try to perform the task manually first Document your process, decision points, and information sources Use this documentation as the basis for your task description",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "5. Premature Use of Hierarchical Structures",
                "level": 3,
                "content": "**Problem:** Creating unnecessarily complex agent hierarchies where sequential processes would work better. **Solution:** Start with sequential processes and only move to hierarchical models when the workflow complexity truly requires it.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "6. Vague or Generic Agent Definitions",
                "level": 3,
                "content": "**Problem:** Generic agent definitions lead to generic outputs. **Example of Poor Design:**\n```\nagent:\n  role: \"Business Analyst\"\n  goal: \"Analyze business data\"\n  backstory: \"You are good at business analysis.\"\n```\n**Improved Version:**\n```\nagent:\n  role: \"SaaS Metrics Specialist focusing on growth-stage startups\"\n  goal: \"Identify actionable insights from business data that can directly impact customer retention and revenue growth\"\n  backstory: \"With 10+ years analyzing SaaS business models, you've developed a keen eye for the metrics that truly matter for sustainable growth. You've helped numerous companies identify the leverage points that turned around their business trajectory. You believe in connecting data to specific, actionable recommendations rather than general observations.\"\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "yaml",
                    "content": "agent:\n  role: \"Business Analyst\"\n  goal: \"Analyze business data\"\n  backstory: \"You are good at business analysis.\"",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  },
                  {
                    "type": "code_block",
                    "language": "yaml",
                    "content": "agent:\n  role: \"SaaS Metrics Specialist focusing on growth-stage startups\"\n  goal: \"Identify actionable insights from business data that can directly impact customer retention and revenue growth\"\n  backstory: \"With 10+ years analyzing SaaS business models, you've developed a keen eye for the metrics that truly matter for sustainable growth. You've helped numerous companies identify the leverage points that turned around their business trajectory. You believe in connecting data to specific, actionable recommendations rather than general observations.\"",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              }
            ]
          },
          {
            "type": "header",
            "title": "Advanced Agent Design Strategies",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Internals/Advanced",
              "content_type": null
            },
            "children": [
              {
                "type": "header",
                "title": "Designing for Collaboration",
                "level": 3,
                "content": "When creating agents that will work together in a crew, consider: **Complementary skills**: Design agents with distinct but complementary abilities **Handoff points**: Define clear interfaces for how work passes between agents **Constructive tension**: Sometimes, creating agents with slightly different perspectives can lead to better outcomes through productive dialogue For example, a content creation crew might include:\n```\n# Research Agent\nrole: \"Research Specialist for technical topics\"\ngoal: \"Gather comprehensive, accurate information from authoritative sources\"\nbackstory: \"You are a meticulous researcher with a background in library science...\"\n\n# Writer Agent\nrole: \"Technical Content Writer\"\ngoal: \"Transform research into engaging, clear content that educates and informs\"\nbackstory: \"You are an experienced writer who excels at explaining complex concepts...\"\n\n# Editor Agent\nrole: \"Content Quality Editor\"\ngoal: \"Ensure content is accurate, well-structured, and polished while maintaining consistency\"\nbackstory: \"With years of experience in publishing, you have a keen eye for detail...\"\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "yaml",
                    "content": "# Research Agent\nrole: \"Research Specialist for technical topics\"\ngoal: \"Gather comprehensive, accurate information from authoritative sources\"\nbackstory: \"You are a meticulous researcher with a background in library science...\"\n\n# Writer Agent\nrole: \"Technical Content Writer\"\ngoal: \"Transform research into engaging, clear content that educates and informs\"\nbackstory: \"You are an experienced writer who excels at explaining complex concepts...\"\n\n# Editor Agent\nrole: \"Content Quality Editor\"\ngoal: \"Ensure content is accurate, well-structured, and polished while maintaining consistency\"\nbackstory: \"With years of experience in publishing, you have a keen eye for detail...\"",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Creating Specialized Tool Users",
                "level": 3,
                "content": "Some agents can be designed specifically to leverage certain tools effectively:\n```\nrole: \"Data Analysis Specialist\"\ngoal: \"Derive meaningful insights from complex datasets through statistical analysis\"\nbackstory: \"With a background in data science, you excel at working with structured and unstructured data...\"\ntools: [PythonREPLTool, DataVisualizationTool, CSVAnalysisTool]\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "yaml",
                    "content": "role: \"Data Analysis Specialist\"\ngoal: \"Derive meaningful insights from complex datasets through statistical analysis\"\nbackstory: \"With a background in data science, you excel at working with structured and unstructured data...\"\ntools: [PythonREPLTool, DataVisualizationTool, CSVAnalysisTool]",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Tailoring Agents to LLM Capabilities",
                "level": 3,
                "content": "Different LLMs have different strengths. Design your agents with these capabilities in mind:\n```\n# For complex reasoning tasks\nanalyst:\n  role: \"Data Insights Analyst\"\n  goal: \"...\"\n  backstory: \"...\"\n  llm: openai/gpt-4o\n\n# For creative content\nwriter:\n  role: \"Creative Content Writer\"\n  goal: \"...\"\n  backstory: \"...\"\n  llm: anthropic/claude-3-opus\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "yaml",
                    "content": "# For complex reasoning tasks\nanalyst:\n  role: \"Data Insights Analyst\"\n  goal: \"...\"\n  backstory: \"...\"\n  llm: openai/gpt-4o\n\n# For creative content\nwriter:\n  role: \"Creative Content Writer\"\n  goal: \"...\"\n  backstory: \"...\"\n  llm: anthropic/claude-3-opus",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              }
            ]
          },
          {
            "type": "header",
            "title": "Testing and Iterating on Agent Design",
            "level": 2,
            "content": "Agent design is often an iterative process. Here's a practical approach: **Start with a prototype**: Create an initial agent definition **Test with sample tasks**: Evaluate performance on representative tasks **Analyze outputs**: Identify strengths and weaknesses **Refine the definition**: Adjust role, goal, and backstory based on observations **Test in collaboration**: Evaluate how the agent performs in a crew setting",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Conclusion",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Next Steps",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Evaluating Use Cases for CrewAI",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": []
      },
      {
        "type": "header",
        "title": "Evaluating Use Cases for CrewAI",
        "level": 1,
        "content": "Source: https://docs.crewai.com/guides/concepts/evaluating-use-cases Learn how to assess your AI application needs and choose the right approach between Crews and Flows based on complexity and precision requirements.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": [
          {
            "type": "header",
            "title": "Understanding the Decision Framework",
            "level": 2,
            "content": "When building AI applications with CrewAI, one of the most important decisions you'll make is choosing the right approach for your specific use case. Should you use a Crew? A Flow? A combination of both? This guide will help you evaluate your requirements and make informed architectural decisions. At the heart of this decision is understanding the relationship between **complexity** and **precision** in your application: This matrix helps visualize how different approaches align with varying requirements for complexity and precision. Let's explore what each quadrant means and how it guides your architectural choices.",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "The Complexity-Precision Matrix Explained",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": [
              {
                "type": "header",
                "title": "What is Complexity?",
                "level": 3,
                "content": "In the context of CrewAI applications, **complexity** refers to: The number of distinct steps or operations required The diversity of tasks that need to be performed The interdependencies between different components The need for conditional logic and branching The sophistication of the overall workflow",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "What is Precision?",
                "level": 3,
                "content": "**Precision** in this context refers to: The accuracy required in the final output The need for structured, predictable results The importance of reproducibility The level of control needed over each step The tolerance for variation in outputs",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "The Four Quadrants",
                "level": 3,
                "content": "",
                "metadata": {
                  "section_type": "General",
                  "content_type": null
                },
                "children": [
                  {
                    "type": "header",
                    "title": "1. Low Complexity, Low Precision",
                    "level": 4,
                    "content": "**Characteristics:** Simple, straightforward tasks Tolerance for some variation in outputs Limited number of steps Creative or exploratory applications **Recommended Approach:** Simple Crews with minimal agents **Example Use Cases:** Basic content generation Idea brainstorming Simple summarization tasks Creative writing assistance",
                    "metadata": {
                      "section_type": "General",
                      "content_type": "short_description"
                    },
                    "children": []
                  },
                  {
                    "type": "header",
                    "title": "2. Low Complexity, High Precision",
                    "level": 4,
                    "content": "**Characteristics:** Simple workflows that require exact, structured outputs Need for reproducible results Limited steps but high accuracy requirements Often involves data processing or transformation **Recommended Approach:** Flows with direct LLM calls or simple Crews with structured outputs **Example Use Cases:** Data extraction and transformation Form filling and validation Structured content generation (JSON, XML) Simple classification tasks",
                    "metadata": {
                      "section_type": "General",
                      "content_type": "descriptive_text"
                    },
                    "children": []
                  },
                  {
                    "type": "header",
                    "title": "3. High Complexity, Low Precision",
                    "level": 4,
                    "content": "**Characteristics:** Multi-stage processes with many steps Creative or exploratory outputs Complex interactions between components Tolerance for variation in final results **Recommended Approach:** Complex Crews with multiple specialized agents **Example Use Cases:** Research and analysis Content creation pipelines Exploratory data analysis Creative problem-solving",
                    "metadata": {
                      "section_type": "General",
                      "content_type": "short_description"
                    },
                    "children": []
                  },
                  {
                    "type": "header",
                    "title": "4. High Complexity, High Precision",
                    "level": 4,
                    "content": "**Characteristics:** Complex workflows requiring structured outputs Multiple interdependent steps with strict accuracy requirements Need for both sophisticated processing and precise results Often mission-critical applications **Recommended Approach:** Flows orchestrating multiple Crews with validation steps **Example Use Cases:** Enterprise decision support systems Complex data processing pipelines Multi-stage document processing Regulated industry applications",
                    "metadata": {
                      "section_type": "General",
                      "content_type": "descriptive_text"
                    },
                    "children": []
                  }
                ]
              }
            ]
          },
          {
            "type": "header",
            "title": "Choosing Between Crews and Flows",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": [
              {
                "type": "header",
                "title": "When to Choose Crews",
                "level": 3,
                "content": "Crews are ideal when: **You need collaborative intelligence** - Multiple agents with different specializations need to work together **The problem requires emergent thinking** - The solution benefits from different perspectives and approaches **The task is primarily creative or analytical** - The work involves research, content creation, or analysis **You value adaptability over strict structure** - The workflow can benefit from agent autonomy **The output format can be somewhat flexible** - Some variation in output structure is acceptable\n```\n# Example: Research Crew for market analysis\nfrom crewai import Agent, Crew, Process, Task\n\n# Create specialized agents\nresearcher = Agent(\n    role=\"Market Research Specialist\",\n    goal=\"Find comprehensive market data on emerging technologies\",\n    backstory=\"You are an expert at discovering market trends and gathering data.\"\n)\n\nanalyst = Agent(\n    role=\"Market Analyst\",\n    goal=\"Analyze market data and identify key opportunities\",\n    backstory=\"You excel at interpreting market data and spotting valuable insights.\"\n)\n\n# Define their tasks\nresearch_task = Task(\n    description=\"Research the current market landscape for AI-powered healthcare solutions\",\n    expected_output=\"Comprehensive market data including key players, market size, and growth trends\",\n    agent=researcher\n)\n\nanalysis_task = Task(\n    description=\"Analyze the market data and identify the top 3 investment opportunities\",\n    expected_output=\"Analysis report with 3 recommended investment opportunities and rationale\",\n    agent=analyst,\n    context=[research_task]\n)\n\n# Create the crew\nmarket_analysis_crew = Crew(\n    agents=[researcher, analyst],\n    tasks=[research_task, analysis_task],\n    process=Process.sequential,\n    verbose=True\n)\n\n# Run the crew\nresult = market_analysis_crew.kickoff()\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "# Example: Research Crew for market analysis\nfrom crewai import Agent, Crew, Process, Task\n\n# Create specialized agents\nresearcher = Agent(\n    role=\"Market Research Specialist\",\n    goal=\"Find comprehensive market data on emerging technologies\",\n    backstory=\"You are an expert at discovering market trends and gathering data.\"\n)\n\nanalyst = Agent(\n    role=\"Market Analyst\",\n    goal=\"Analyze market data and identify key opportunities\",\n    backstory=\"You excel at interpreting market data and spotting valuable insights.\"\n)\n\n# Define their tasks\nresearch_task = Task(\n    description=\"Research the current market landscape for AI-powered healthcare solutions\",\n    expected_output=\"Comprehensive market data including key players, market size, and growth trends\",\n    agent=researcher\n)\n\nanalysis_task = Task(\n    description=\"Analyze the market data and identify the top 3 investment opportunities\",\n    expected_output=\"Analysis report with 3 recommended investment opportunities and rationale\",\n    agent=analyst,\n    context=[research_task]\n)\n\n# Create the crew\nmarket_analysis_crew = Crew(\n    agents=[researcher, analyst],\n    tasks=[research_task, analysis_task],\n    process=Process.sequential,\n    verbose=True\n)\n\n# Run the crew\nresult = market_analysis_crew.kickoff()",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "When to Choose Flows",
                "level": 3,
                "content": "Flows are ideal when: **You need precise control over execution** - The workflow requires exact sequencing and state management **The application has complex state requirements** - You need to maintain and transform state across multiple steps **You need structured, predictable outputs** - The application requires consistent, formatted results **The workflow involves conditional logic** - Different paths need to be taken based on intermediate results **You need to combine AI with procedural code** - The solution requires both AI capabilities and traditional programming\n```\n# Example: Customer Support Flow with structured processing\nfrom crewai.flow.flow import Flow, listen, router, start\nfrom pydantic import BaseModel\nfrom typing import List, Dict\n\n# Define structured state\nclass SupportTicketState(BaseModel):\n    ticket_id: str = \"\"\n    customer_name: str = \"\"\n    issue_description: str = \"\"\n    category: str = \"\"\n    priority: str = \"medium\"\n    resolution: str = \"\"\n    satisfaction_score: int = 0\n\nclass CustomerSupportFlow(Flow[SupportTicketState]):\n    @start()\n    def receive_ticket(self):\n        # In a real app, this might come from an API\n        self.state.ticket_id = \"TKT-12345\"\n        self.state.customer_name = \"Alex Johnson\"\n        self.state.issue_description = \"Unable to access premium features after payment\"\n        return \"Ticket received\"\n\n    @listen(receive_ticket)\n    def categorize_ticket(self, _):\n        # Use a direct LLM call for categorization\n        from crewai import LLM\n        llm = LLM(model=\"openai/gpt-4o-mini\")\n\n        prompt = f\"\"\"\n        Categorize the following customer support issue into one of these categories:\n        - Billing\n        - Account Access\n        - Technical Issue\n        - Feature Request\n        - Other\n\n        Issue: {self.state.issue_description}\n\n        Return only the category name.\n        \"\"\"\n\n        self.state.category = llm.call(prompt).strip()\n        return self.state.category\n\n    @router(categorize_ticket)\n    def route_by_category(self, category):\n        # Route to different handlers based on category\n        return category.lower().replace(\" \", \"_\")\n\n    @listen(\"billing\")\n    def handle_billing_issue(self):\n        # Handle billing-specific logic\n        self.state.priority = \"high\"\n        # More billing-specific processing...\n        return \"Billing issue handled\"\n\n    @listen(\"account_access\")\n    def handle_access_issue(self):\n        # Handle access-specific logic\n        self.state.priority = \"high\"\n        # More access-specific processing...\n        return \"Access issue handled\"\n\n    # Additional category handlers...\n\n    @listen(\"billing\", \"account_access\", \"technical_issue\", \"feature_request\", \"other\")\n    def resolve_ticket(self, resolution_info):\n        # Final resolution step\n        self.state.resolution = f\"Issue resolved: {resolution_info}\"\n        return self.state.resolution\n\n# Run the flow\nsupport_flow = CustomerSupportFlow()\nresult = support_flow.kickoff()\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "# Example: Customer Support Flow with structured processing\nfrom crewai.flow.flow import Flow, listen, router, start\nfrom pydantic import BaseModel\nfrom typing import List, Dict\n\n# Define structured state\nclass SupportTicketState(BaseModel):\n    ticket_id: str = \"\"\n    customer_name: str = \"\"\n    issue_description: str = \"\"\n    category: str = \"\"\n    priority: str = \"medium\"\n    resolution: str = \"\"\n    satisfaction_score: int = 0\n\nclass CustomerSupportFlow(Flow[SupportTicketState]):\n    @start()\n    def receive_ticket(self):\n        # In a real app, this might come from an API\n        self.state.ticket_id = \"TKT-12345\"\n        self.state.customer_name = \"Alex Johnson\"\n        self.state.issue_description = \"Unable to access premium features after payment\"\n        return \"Ticket received\"\n\n    @listen(receive_ticket)\n    def categorize_ticket(self, _):\n        # Use a direct LLM call for categorization\n        from crewai import LLM\n        llm = LLM(model=\"openai/gpt-4o-mini\")\n\n        prompt = f\"\"\"\n        Categorize the following customer support issue into one of these categories:\n        - Billing\n        - Account Access\n        - Technical Issue\n        - Feature Request\n        - Other\n\n        Issue: {self.state.issue_description}\n\n        Return only the category name.\n        \"\"\"\n\n        self.state.category = llm.call(prompt).strip()\n        return self.state.category\n\n    @router(categorize_ticket)\n    def route_by_category(self, category):\n        # Route to different handlers based on category\n        return category.lower().replace(\" \", \"_\")\n\n    @listen(\"billing\")\n    def handle_billing_issue(self):\n        # Handle billing-specific logic\n        self.state.priority = \"high\"\n        # More billing-specific processing...\n        return \"Billing issue handled\"\n\n    @listen(\"account_access\")\n    def handle_access_issue(self):\n        # Handle access-specific logic\n        self.state.priority = \"high\"\n        # More access-specific processing...\n        return \"Access issue handled\"\n\n    # Additional category handlers...\n\n    @listen(\"billing\", \"account_access\", \"technical_issue\", \"feature_request\", \"other\")\n    def resolve_ticket(self, resolution_info):\n        # Final resolution step\n        self.state.resolution = f\"Issue resolved: {resolution_info}\"\n        return self.state.resolution\n\n# Run the flow\nsupport_flow = CustomerSupportFlow()\nresult = support_flow.kickoff()",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "When to Combine Crews and Flows",
                "level": 3,
                "content": "The most sophisticated applications often benefit from combining Crews and Flows: **Complex multi-stage processes** - Use Flows to orchestrate the overall process and Crews for complex subtasks **Applications requiring both creativity and structure** - Use Crews for creative tasks and Flows for structured processing **Enterprise-grade AI applications** - Use Flows to manage state and process flow while leveraging Crews for specialized work\n```\n# Example: Content Production Pipeline combining Crews and Flows\nfrom crewai.flow.flow import Flow, listen, start\nfrom crewai import Agent, Crew, Process, Task\nfrom pydantic import BaseModel\nfrom typing import List, Dict\n\nclass ContentState(BaseModel):\n    topic: str = \"\"\n    target_audience: str = \"\"\n    content_type: str = \"\"\n    outline: Dict = {}\n    draft_content: str = \"\"\n    final_content: str = \"\"\n    seo_score: int = 0\n\nclass ContentProductionFlow(Flow[ContentState]):\n    @start()\n    def initialize_project(self):\n        # Set initial parameters\n        self.state.topic = \"Sustainable Investing\"\n        self.state.target_audience = \"Millennial Investors\"\n        self.state.content_type = \"Blog Post\"\n        return \"Project initialized\"\n\n    @listen(initialize_project)\n    def create_outline(self, _):\n        # Use a research crew to create an outline\n        researcher = Agent(\n            role=\"Content Researcher\",\n            goal=f\"Research {self.state.topic} for {self.state.target_audience}\",\n            backstory=\"You are an expert researcher with deep knowledge of content creation.\"\n        )\n\n        outliner = Agent(\n            role=\"Content Strategist\",\n            goal=f\"Create an engaging outline for a {self.state.content_type}\",\n            backstory=\"You excel at structuring content for maximum engagement.\"\n        )\n\n        research_task = Task(\n            description=f\"Research {self.state.topic} focusing on what would interest {self.state.target_audience}\",\n            expected_output=\"Comprehensive research notes with key points and statistics\",\n            agent=researcher\n        )\n\n        outline_task = Task(\n            description=f\"Create an outline for a {self.state.content_type} about {self.state.topic}\",\n            expected_output=\"Detailed content outline with sections and key points\",\n            agent=outliner,\n            context=[research_task]\n        )\n\n        outline_crew = Crew(\n            agents=[researcher, outliner],\n            tasks=[research_task, outline_task],\n            process=Process.sequential,\n            verbose=True\n        )\n\n        # Run the crew and store the result\n        result = outline_crew.kickoff()\n\n        # Parse the outline (in a real app, you might use a more robust parsing approach)\n        import json\n        try:\n            self.state.outline = json.loads(result.raw)\n        except:\n            # Fallback if not valid JSON\n            self.state.outline = {\"sections\": result.raw}\n\n        return \"Outline created\"\n\n    @listen(create_outline)\n    def write_content(self, _):\n        # Use a writing crew to create the content\n        writer = Agent(\n            role=\"Content Writer\",\n            goal=f\"Write engaging content for {self.state.target_audience}\",\n            backstory=\"You are a skilled writer who creates compelling content.\"\n        )\n\n        editor = Agent(\n            role=\"Content Editor\",\n            goal=\"Ensure content is polished, accurate, and engaging\",\n            backstory=\"You have a keen eye for detail and a talent for improving content.\"\n        )\n\n        writing_task = Task(\n            description=f\"Write a {self.state.content_type} about {self.state.topic} following this outline: {self.state.outline}\",\n            expected_output=\"Complete draft content in markdown format\",\n            agent=writer\n        )\n\n        editing_task = Task(\n            description=\"Edit and improve the draft content for clarity, engagement, and accuracy\",\n            expected_output=\"Polished final content in markdown format\",\n            agent=editor,\n            context=[writing_task]\n        )\n\n        writing_crew = Crew(\n            agents=[writer, editor],\n            tasks=[writing_task, editing_task],\n            process=Process.sequential,\n            verbose=True\n        )\n\n        # Run the crew and store the result\n        result = writing_crew.kickoff()\n        self.state.final_content = result.raw\n\n        return \"Content created\"\n\n    @listen(write_content)\n    def optimize_for_seo(self, _):\n        # Use a direct LLM call for SEO optimization\n        from crewai import LLM\n        llm = LLM(model=\"openai/gpt-4o-mini\")\n\n        prompt = f\"\"\"\n        Analyze this content for SEO effectiveness for the keyword \"{self.state.topic}\".\n        Rate it on a scale of 1-100 and provide 3 specific recommendations for improvement.\n\n        Content: {self.state.final_content[:1000]}... (truncated for brevity)\n\n        Format your response as JSON with the following structure:\n        {{\n            \"score\": 85,\n            \"recommendations\": [\n                \"Recommendation 1\",\n                \"Recommendation 2\",\n                \"Recommendation 3\"\n            ]\n        }}\n        \"\"\"\n\n        seo_analysis = llm.call(prompt)\n\n        # Parse the SEO analysis\n        import json\n        try:\n            analysis = json.loads(seo_analysis)\n            self.state.seo_score = analysis.get(\"score\", 0)\n            return analysis\n        except:\n            self.state.seo_score = 50\n            return {\"score\": 50, \"recommendations\": [\"Unable to parse SEO analysis\"]}\n\n# Run the flow\ncontent_flow = ContentProductionFlow()\nresult = content_flow.kickoff()\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "# Example: Content Production Pipeline combining Crews and Flows\nfrom crewai.flow.flow import Flow, listen, start\nfrom crewai import Agent, Crew, Process, Task\nfrom pydantic import BaseModel\nfrom typing import List, Dict\n\nclass ContentState(BaseModel):\n    topic: str = \"\"\n    target_audience: str = \"\"\n    content_type: str = \"\"\n    outline: Dict = {}\n    draft_content: str = \"\"\n    final_content: str = \"\"\n    seo_score: int = 0\n\nclass ContentProductionFlow(Flow[ContentState]):\n    @start()\n    def initialize_project(self):\n        # Set initial parameters\n        self.state.topic = \"Sustainable Investing\"\n        self.state.target_audience = \"Millennial Investors\"\n        self.state.content_type = \"Blog Post\"\n        return \"Project initialized\"\n\n    @listen(initialize_project)\n    def create_outline(self, _):\n        # Use a research crew to create an outline\n        researcher = Agent(\n            role=\"Content Researcher\",\n            goal=f\"Research {self.state.topic} for {self.state.target_audience}\",\n            backstory=\"You are an expert researcher with deep knowledge of content creation.\"\n        )\n\n        outliner = Agent(\n            role=\"Content Strategist\",\n            goal=f\"Create an engaging outline for a {self.state.content_type}\",\n            backstory=\"You excel at structuring content for maximum engagement.\"\n        )\n\n        research_task = Task(\n            description=f\"Research {self.state.topic} focusing on what would interest {self.state.target_audience}\",\n            expected_output=\"Comprehensive research notes with key points and statistics\",\n            agent=researcher\n        )\n\n        outline_task = Task(\n            description=f\"Create an outline for a {self.state.content_type} about {self.state.topic}\",\n            expected_output=\"Detailed content outline with sections and key points\",\n            agent=outliner,\n            context=[research_task]\n        )\n\n        outline_crew = Crew(\n            agents=[researcher, outliner],\n            tasks=[research_task, outline_task],\n            process=Process.sequential,\n            verbose=True\n        )\n\n        # Run the crew and store the result\n        result = outline_crew.kickoff()\n\n        # Parse the outline (in a real app, you might use a more robust parsing approach)\n        import json\n        try:\n            self.state.outline = json.loads(result.raw)\n        except:\n            # Fallback if not valid JSON\n            self.state.outline = {\"sections\": result.raw}\n\n        return \"Outline created\"\n\n    @listen(create_outline)\n    def write_content(self, _):\n        # Use a writing crew to create the content\n        writer = Agent(\n            role=\"Content Writer\",\n            goal=f\"Write engaging content for {self.state.target_audience}\",\n            backstory=\"You are a skilled writer who creates compelling content.\"\n        )\n\n        editor = Agent(\n            role=\"Content Editor\",\n            goal=\"Ensure content is polished, accurate, and engaging\",\n            backstory=\"You have a keen eye for detail and a talent for improving content.\"\n        )\n\n        writing_task = Task(\n            description=f\"Write a {self.state.content_type} about {self.state.topic} following this outline: {self.state.outline}\",\n            expected_output=\"Complete draft content in markdown format\",\n            agent=writer\n        )\n\n        editing_task = Task(\n            description=\"Edit and improve the draft content for clarity, engagement, and accuracy\",\n            expected_output=\"Polished final content in markdown format\",\n            agent=editor,\n            context=[writing_task]\n        )\n\n        writing_crew = Crew(\n            agents=[writer, editor],\n            tasks=[writing_task, editing_task],\n            process=Process.sequential,\n            verbose=True\n        )\n\n        # Run the crew and store the result\n        result = writing_crew.kickoff()\n        self.state.final_content = result.raw\n\n        return \"Content created\"\n\n    @listen(write_content)\n    def optimize_for_seo(self, _):\n        # Use a direct LLM call for SEO optimization\n        from crewai import LLM\n        llm = LLM(model=\"openai/gpt-4o-mini\")\n\n        prompt = f\"\"\"\n        Analyze this content for SEO effectiveness for the keyword \"{self.state.topic}\".\n        Rate it on a scale of 1-100 and provide 3 specific recommendations for improvement.\n\n        Content: {self.state.final_content[:1000]}... (truncated for brevity)\n\n        Format your response as JSON with the following structure:\n        {{\n            \"score\": 85,\n            \"recommendations\": [\n                \"Recommendation 1\",\n                \"Recommendation 2\",\n                \"Recommendation 3\"\n            ]\n        }}\n        \"\"\"\n\n        seo_analysis = llm.call(prompt)\n\n        # Parse the SEO analysis\n        import json\n        try:\n            analysis = json.loads(seo_analysis)\n            self.state.seo_score = analysis.get(\"score\", 0)\n            return analysis\n        except:\n            self.state.seo_score = 50\n            return {\"score\": 50, \"recommendations\": [\"Unable to parse SEO analysis\"]}\n\n# Run the flow\ncontent_flow = ContentProductionFlow()\nresult = content_flow.kickoff()",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              }
            ]
          },
          {
            "type": "header",
            "title": "Practical Evaluation Framework",
            "level": 2,
            "content": "To determine the right approach for your specific use case, follow this step-by-step evaluation framework:",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": [
              {
                "type": "header",
                "title": "Step 1: Assess Complexity",
                "level": 3,
                "content": "Rate your application's complexity on a scale of 1-10 by considering: **Number of steps**: How many distinct operations are required? 1-3 steps: Low complexity (1-3) 4-7 steps: Medium complexity (4-7) 8+ steps: High complexity (8-10) **Interdependencies**: How interconnected are the different parts? Few dependencies: Low complexity (1-3) Some dependencies: Medium complexity (4-7) Many complex dependencies: High complexity (8-10) **Conditional logic**: How much branching and decision-making is needed? Linear process: Low complexity (1-3) Some branching: Medium complexity (4-7) Complex decision trees: High complexity (8-10) **Domain knowledge**: How specialized is the knowledge required? General knowledge: Low complexity (1-3) Some specialized knowledge: Medium complexity (4-7) Deep expertise in multiple domains: High complexity (8-10) Calculate your average score to determine overall complexity.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "descriptive_text"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Step 2: Assess Precision Requirements",
                "level": 3,
                "content": "Rate your precision requirements on a scale of 1-10 by considering: **Output structure**: How structured must the output be? Free-form text: Low precision (1-3) Semi-structured: Medium precision (4-7) Strictly formatted (JSON, XML): High precision (8-10) **Accuracy needs**: How important is factual accuracy? Creative content: Low precision (1-3) Informational content: Medium precision (4-7) Critical information: High precision (8-10) **Reproducibility**: How consistent must results be across runs? Variation acceptable: Low precision (1-3) Some consistency needed: Medium precision (4-7) Exact reproducibility required: High precision (8-10) **Error tolerance**: What is the impact of errors? Low impact: Low precision (1-3) Moderate impact: Medium precision (4-7) High impact: High precision (8-10) Calculate your average score to determine overall precision requirements.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "descriptive_text"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Step 3: Map to the Matrix",
                "level": 3,
                "content": "Plot your complexity and precision scores on the matrix: **Low Complexity (1-4), Low Precision (1-4)**: Simple Crews **Low Complexity (1-4), High Precision (5-10)**: Flows with direct LLM calls **High Complexity (5-10), Low Precision (1-4)**: Complex Crews **High Complexity (5-10), High Precision (5-10)**: Flows orchestrating Crews",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Step 4: Consider Additional Factors",
                "level": 3,
                "content": "Beyond complexity and precision, consider: **Development time**: Crews are often faster to prototype **Maintenance needs**: Flows provide better long-term maintainability **Team expertise**: Consider your team's familiarity with different approaches **Scalability requirements**: Flows typically scale better for complex applications **Integration needs**: Consider how the solution will integrate with existing systems",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Conclusion",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Next Steps",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Build Your First Crew",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": []
      },
      {
        "type": "header",
        "title": "Build Your First Crew",
        "level": 1,
        "content": "Source: https://docs.crewai.com/guides/crews/first-crew Step-by-step tutorial to create a collaborative AI team that works together to solve complex problems.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": [
          {
            "type": "header",
            "title": "Unleashing the Power of Collaborative AI",
            "level": 2,
            "content": "Imagine having a team of specialized AI agents working together seamlessly to solve complex problems, each contributing their unique skills to achieve a common goal. This is the power of CrewAI - a framework that enables you to create collaborative AI systems that can accomplish tasks far beyond what a single AI could achieve alone. In this guide, we'll walk through creating a research crew that will help us research and analyze a topic, then create a comprehensive report. This practical example demonstrates how AI agents can collaborate to accomplish complex tasks, but it's just the beginning of what's possible with CrewAI.",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": [
              {
                "type": "header",
                "title": "What You'll Build and Learn",
                "level": 3,
                "content": "",
                "metadata": {
                  "section_type": "General",
                  "content_type": null
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Prerequisites",
                "level": 3,
                "content": "",
                "metadata": {
                  "section_type": "General",
                  "content_type": null
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Step 1: Create a New CrewAI Project",
            "level": 2,
            "content": "First, let's create a new CrewAI project using the CLI. This command will set up a complete project structure with all the necessary files, allowing you to focus on defining your agents and their tasks rather than setting up boilerplate code.\n```\ncrewai create crew research_crew\ncd research_crew\n```\nThis will generate a project with the basic structure needed for your crew. The CLI automatically creates: A project directory with the necessary files Configuration files for agents and tasks A basic crew implementation A main script to run the crew",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "bash",
                "content": "crewai create crew research_crew\ncd research_crew",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Step 2: Explore the Project Structure",
            "level": 2,
            "content": "Let's take a moment to understand the project structure created by the CLI. CrewAI follows best practices for Python projects, making it easy to maintain and extend your code as your crews become more complex.\n```\nresearch_crew/\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 .env\n\u2514\u2500\u2500 src/\n    \u2514\u2500\u2500 research_crew/\n        \u251c\u2500\u2500 __init__.py\n        \u251c\u2500\u2500 main.py\n        \u251c\u2500\u2500 crew.py\n        \u251c\u2500\u2500 tools/\n        \u2502   \u251c\u2500\u2500 custom_tool.py\n        \u2502   \u2514\u2500\u2500 __init__.py\n        \u2514\u2500\u2500 config/\n            \u251c\u2500\u2500 agents.yaml\n            \u2514\u2500\u2500 tasks.yaml\n```\nThis structure follows best practices for Python projects and makes it easy to organize your code. The separation of configuration files (in YAML) from implementation code (in Python) makes it easy to modify your crew's behavior without changing the underlying code.",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": null,
                "content": "research_crew/\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 .env\n\u2514\u2500\u2500 src/\n    \u2514\u2500\u2500 research_crew/\n        \u251c\u2500\u2500 __init__.py\n        \u251c\u2500\u2500 main.py\n        \u251c\u2500\u2500 crew.py\n        \u251c\u2500\u2500 tools/\n        \u2502   \u251c\u2500\u2500 custom_tool.py\n        \u2502   \u2514\u2500\u2500 __init__.py\n        \u2514\u2500\u2500 config/\n            \u251c\u2500\u2500 agents.yaml\n            \u2514\u2500\u2500 tasks.yaml",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Step 3: Configure Your Agents",
            "level": 2,
            "content": "Now comes the fun part - defining your AI agents! In CrewAI, agents are specialized entities with specific roles, goals, and backstories that shape their behavior. Think of them as characters in a play, each with their own personality and purpose. For our research crew, we'll create two agents: A **researcher** who excels at finding and organizing information An **analyst** who can interpret research findings and create insightful reports Let's modify the `agents.yaml` file to define these specialized agents:\n```\n# src/research_crew/config/agents.yaml\nresearcher:\n  role: >\n    Senior Research Specialist for {topic}\n  goal: >\n    Find comprehensive and accurate information about {topic}\n    with a focus on recent developments and key insights\n  backstory: >\n    You are an experienced research specialist with a talent for\n    finding relevant information from various sources. You excel at\n    organizing information in a clear and structured manner, making\n    complex topics accessible to others.\n  llm: openai/gpt-4o-mini\n\nanalyst:\n  role: >\n    Data Analyst and Report Writer for {topic}\n  goal: >\n    Analyze research findings and create a comprehensive, well-structured\n    report that presents insights in a clear and engaging way\n  backstory: >\n    You are a skilled analyst with a background in data interpretation\n    and technical writing. You have a talent for identifying patterns\n    and extracting meaningful insights from research data, then\n    communicating those insights effectively through well-crafted reports.\n  llm: openai/gpt-4o-mini\n```\nNotice how each agent has a distinct role, goal, and backstory. These elements aren't just descriptive - they actively shape how the agent approaches its tasks. By crafting these carefully, you can create agents with specialized skills and perspectives that complement each other.",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "yaml",
                "content": "# src/research_crew/config/agents.yaml\nresearcher:\n  role: >\n    Senior Research Specialist for {topic}\n  goal: >\n    Find comprehensive and accurate information about {topic}\n    with a focus on recent developments and key insights\n  backstory: >\n    You are an experienced research specialist with a talent for\n    finding relevant information from various sources. You excel at\n    organizing information in a clear and structured manner, making\n    complex topics accessible to others.\n  llm: openai/gpt-4o-mini\n\nanalyst:\n  role: >\n    Data Analyst and Report Writer for {topic}\n  goal: >\n    Analyze research findings and create a comprehensive, well-structured\n    report that presents insights in a clear and engaging way\n  backstory: >\n    You are a skilled analyst with a background in data interpretation\n    and technical writing. You have a talent for identifying patterns\n    and extracting meaningful insights from research data, then\n    communicating those insights effectively through well-crafted reports.\n  llm: openai/gpt-4o-mini",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Step 4: Define Your Tasks",
            "level": 2,
            "content": "With our agents defined, we now need to give them specific tasks to perform. Tasks in CrewAI represent the concrete work that agents will perform, with detailed instructions and expected outputs. For our research crew, we'll define two main tasks: A **research task** for gathering comprehensive information An **analysis task** for creating an insightful report Let's modify the `tasks.yaml` file:\n```\n# src/research_crew/config/tasks.yaml\nresearch_task:\n  description: >\n    Conduct thorough research on {topic}. Focus on:\n    1. Key concepts and definitions\n    2. Historical development and recent trends\n    3. Major challenges and opportunities\n    4. Notable applications or case studies\n    5. Future outlook and potential developments\n\n    Make sure to organize your findings in a structured format with clear sections.\n  expected_output: >\n    A comprehensive research document with well-organized sections covering\n    all the requested aspects of {topic}. Include specific facts, figures,\n    and examples where relevant.\n  agent: researcher\n\nanalysis_task:\n  description: >\n    Analyze the research findings and create a comprehensive report on {topic}.\n    Your report should:\n    1. Begin with an executive summary\n    2. Include all key information from the research\n    3. Provide insightful analysis of trends and patterns\n    4. Offer recommendations or future considerations\n    5. Be formatted in a professional, easy-to-read style with clear headings\n  expected_output: >\n    A polished, professional report on {topic} that presents the research\n    findings with added analysis and insights. The report should be well-structured\n    with an executive summary, main sections, and conclusion.\n  agent: analyst\n  context:\n    - research_task\n  output_file: output/report.md\n```\nNote the `context` field in the analysis task - this is a powerful feature that allows the analyst to access the output of the research task. This creates a workflow where information flows naturally between agents, just as it would in a human team.",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "yaml",
                "content": "# src/research_crew/config/tasks.yaml\nresearch_task:\n  description: >\n    Conduct thorough research on {topic}. Focus on:\n    1. Key concepts and definitions\n    2. Historical development and recent trends\n    3. Major challenges and opportunities\n    4. Notable applications or case studies\n    5. Future outlook and potential developments\n\n    Make sure to organize your findings in a structured format with clear sections.\n  expected_output: >\n    A comprehensive research document with well-organized sections covering\n    all the requested aspects of {topic}. Include specific facts, figures,\n    and examples where relevant.\n  agent: researcher\n\nanalysis_task:\n  description: >\n    Analyze the research findings and create a comprehensive report on {topic}.\n    Your report should:\n    1. Begin with an executive summary\n    2. Include all key information from the research\n    3. Provide insightful analysis of trends and patterns\n    4. Offer recommendations or future considerations\n    5. Be formatted in a professional, easy-to-read style with clear headings\n  expected_output: >\n    A polished, professional report on {topic} that presents the research\n    findings with added analysis and insights. The report should be well-structured\n    with an executive summary, main sections, and conclusion.\n  agent: analyst\n  context:\n    - research_task\n  output_file: output/report.md",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Step 5: Configure Your Crew",
            "level": 2,
            "content": "Now it's time to bring everything together by configuring our crew. The crew is the container that orchestrates how agents work together to complete tasks. Let's modify the `crew.py` file:\n```\n# src/research_crew/crew.py\nfrom crewai import Agent, Crew, Process, Task\nfrom crewai.project import CrewBase, agent, crew, task\nfrom crewai_tools import SerperDevTool\n\n@CrewBase\nclass ResearchCrew():\n    \"\"\"Research crew for comprehensive topic analysis and reporting\"\"\"\n\n    @agent\n    def researcher(self) -> Agent:\n        return Agent(\n            config=self.agents_config['researcher'],\n            verbose=True,\n            tools=[SerperDevTool()]\n        )\n\n    @agent\n    def analyst(self) -> Agent:\n        return Agent(\n            config=self.agents_config['analyst'],\n            verbose=True\n        )\n\n    @task\n    def research_task(self) -> Task:\n        return Task(\n            config=self.tasks_config['research_task']\n        )\n\n    @task\n    def analysis_task(self) -> Task:\n        return Task(\n            config=self.tasks_config['analysis_task'],\n            output_file='output/report.md'\n        )\n\n    @crew\n    def crew(self) -> Crew:\n        \"\"\"Creates the research crew\"\"\"\n        return Crew(\n            agents=self.agents,\n            tasks=self.tasks,\n            process=Process.sequential,\n            verbose=True,\n        )\n```\nIn this code, we're: Creating the researcher agent and equipping it with the SerperDevTool to search the web Creating the analyst agent Setting up the research and analysis tasks Configuring the crew to run tasks sequentially (the analyst will wait for the researcher to finish) This is where the magic happens - with just a few lines of code, we've defined a collaborative AI system where specialized agents work together in a coordinated process.",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python",
                "content": "# src/research_crew/crew.py\nfrom crewai import Agent, Crew, Process, Task\nfrom crewai.project import CrewBase, agent, crew, task\nfrom crewai_tools import SerperDevTool\n\n@CrewBase\nclass ResearchCrew():\n    \"\"\"Research crew for comprehensive topic analysis and reporting\"\"\"\n\n    @agent\n    def researcher(self) -> Agent:\n        return Agent(\n            config=self.agents_config['researcher'],\n            verbose=True,\n            tools=[SerperDevTool()]\n        )\n\n    @agent\n    def analyst(self) -> Agent:\n        return Agent(\n            config=self.agents_config['analyst'],\n            verbose=True\n        )\n\n    @task\n    def research_task(self) -> Task:\n        return Task(\n            config=self.tasks_config['research_task']\n        )\n\n    @task\n    def analysis_task(self) -> Task:\n        return Task(\n            config=self.tasks_config['analysis_task'],\n            output_file='output/report.md'\n        )\n\n    @crew\n    def crew(self) -> Crew:\n        \"\"\"Creates the research crew\"\"\"\n        return Crew(\n            agents=self.agents,\n            tasks=self.tasks,\n            process=Process.sequential,\n            verbose=True,\n        )",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Step 6: Set Up Your Main Script",
            "level": 2,
            "content": "Now, let's set up the main script that will run our crew. This is where we provide the specific topic we want our crew to research.\n```\n#!/usr/bin/env python\n# src/research_crew/main.py\nimport os\nfrom research_crew.crew import ResearchCrew\n\n# Create output directory if it doesn't exist\nos.makedirs('output', exist_ok=True)\n\ndef run():\n    \"\"\"\n    Run the research crew.\n    \"\"\"\n    inputs = {\n        'topic': 'Artificial Intelligence in Healthcare'\n    }\n\n    # Create and run the crew\n    result = ResearchCrew().crew().kickoff(inputs=inputs)\n\n    # Print the result\n    print(\"\\n\\n=== FINAL REPORT ===\\n\\n\")\n    print(result.raw)\n\n    print(\"\\n\\nReport has been saved to output/report.md\")\n\nif __name__ == \"__main__\":\n    run()\n```\nThis script prepares the environment, specifies our research topic, and kicks off the crew's work. The power of CrewAI is evident in how simple this code is - all the complexity of managing multiple AI agents is handled by the framework.",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python",
                "content": "#!/usr/bin/env python\n# src/research_crew/main.py\nimport os\nfrom research_crew.crew import ResearchCrew\n\n# Create output directory if it doesn't exist\nos.makedirs('output', exist_ok=True)\n\ndef run():\n    \"\"\"\n    Run the research crew.\n    \"\"\"\n    inputs = {\n        'topic': 'Artificial Intelligence in Healthcare'\n    }\n\n    # Create and run the crew\n    result = ResearchCrew().crew().kickoff(inputs=inputs)\n\n    # Print the result\n    print(\"\\n\\n=== FINAL REPORT ===\\n\\n\")\n    print(result.raw)\n\n    print(\"\\n\\nReport has been saved to output/report.md\")\n\nif __name__ == \"__main__\":\n    run()",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Step 7: Set Up Your Environment Variables",
            "level": 2,
            "content": "Create a `.env` file in your project root with your API keys:\n```\nOPENAI_API_KEY=your_openai_api_key\nSERPER_API_KEY=your_serper_api_key\n```\nYou can get a Serper API key from [Serper.dev](https://serper.dev/).",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": null,
                "content": "OPENAI_API_KEY=your_openai_api_key\nSERPER_API_KEY=your_serper_api_key",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Step 8: Install Dependencies",
            "level": 2,
            "content": "Install the required dependencies using the CrewAI CLI:\n```\ncrewai install\n```\nThis command will: Read the dependencies from your project configuration Create a virtual environment if needed Install all required packages",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "bash",
                "content": "crewai install",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Step 9: Run Your Crew",
            "level": 2,
            "content": "Now for the exciting moment - it's time to run your crew and see AI collaboration in action!\n```\ncrewai run\n```\nWhen you run this command, you'll see your crew spring to life. The researcher will gather information about the specified topic, and the analyst will then create a comprehensive report based on that research. You'll see the agents' thought processes, actions, and outputs in real-time as they work together to complete their tasks.",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "bash",
                "content": "crewai run",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Step 10: Review the Output",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Exploring Other CLI Commands",
            "level": 2,
            "content": "CrewAI offers several other useful CLI commands for working with crews:\n```\n# View all available commands\ncrewai --help\n\n# Run the crew\ncrewai run\n\n# Test the crew\ncrewai test\n\n# Reset crew memories\ncrewai reset-memories\n\n# Replay from a specific task\ncrewai replay -t <task_id>\n```",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "bash",
                "content": "# View all available commands\ncrewai --help\n\n# Run the crew\ncrewai run\n\n# Test the crew\ncrewai test\n\n# Reset crew memories\ncrewai reset-memories\n\n# Replay from a specific task\ncrewai replay -t <task_id>",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "The Art of the Possible: Beyond Your First Crew",
            "level": 2,
            "content": "What you've built in this guide is just the beginning. The skills and patterns you've learned can be applied to create increasingly sophisticated AI systems. Here are some ways you could extend this basic research crew:",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": [
              {
                "type": "header",
                "title": "Expanding Your Crew",
                "level": 3,
                "content": "You could add more specialized agents to your crew: A **fact-checker** to verify research findings A **data visualizer** to create charts and graphs A **domain expert** with specialized knowledge in a particular area A **critic** to identify weaknesses in the analysis",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Adding Tools and Capabilities",
                "level": 3,
                "content": "You could enhance your agents with additional tools: Web browsing tools for real-time research CSV/database tools for data analysis Code execution tools for data processing API connections to external services",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Creating More Complex Workflows",
                "level": 3,
                "content": "You could implement more sophisticated processes: Hierarchical processes where manager agents delegate to worker agents Iterative processes with feedback loops for refinement Parallel processes where multiple agents work simultaneously Dynamic processes that adapt based on intermediate results",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Applying to Different Domains",
                "level": 3,
                "content": "",
                "metadata": {
                  "section_type": "General",
                  "content_type": null
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Next Steps",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Build Your First Flow",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": []
      },
      {
        "type": "header",
        "title": "Build Your First Flow",
        "level": 1,
        "content": "Source: https://docs.crewai.com/guides/flows/first-flow Learn how to create structured, event-driven workflows with precise control over execution.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": [
          {
            "type": "header",
            "title": "Taking Control of AI Workflows with Flows",
            "level": 2,
            "content": "CrewAI Flows represent the next level in AI orchestration - combining the collaborative power of AI agent crews with the precision and flexibility of procedural programming. While crews excel at agent collaboration, flows give you fine-grained control over exactly how and when different components of your AI system interact. In this guide, we'll walk through creating a powerful CrewAI Flow that generates a comprehensive learning guide on any topic. This tutorial will demonstrate how Flows provide structured, event-driven control over your AI workflows by combining regular code, direct LLM calls, and crew-based processing.",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": [
              {
                "type": "header",
                "title": "What Makes Flows Powerful",
                "level": 3,
                "content": "Flows enable you to: **Combine different AI interaction patterns** - Use crews for complex collaborative tasks, direct LLM calls for simpler operations, and regular code for procedural logic **Build event-driven systems** - Define how components respond to specific events and data changes **Maintain state across components** - Share and transform data between different parts of your application **Integrate with external systems** - Seamlessly connect your AI workflow with databases, APIs, and user interfaces **Create complex execution paths** - Design conditional branches, parallel processing, and dynamic workflows",
                "metadata": {
                  "section_type": "General",
                  "content_type": "descriptive_text"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "What You'll Build and Learn",
                "level": 3,
                "content": "By the end of this guide, you'll have: **Created a specialized AI research team** with distinct roles and responsibilities **Orchestrated collaboration** between multiple AI agents **Automated a complex workflow** that involves gathering information, analysis, and report generation **Built foundational skills** that you can apply to more ambitious projects While we're building a simple research crew in this guide, the same patterns and techniques can be applied to create much more sophisticated teams for tasks like: Multi-stage content creation with specialized writers, editors, and fact-checkers Complex customer service systems with tiered support agents Autonomous business analysts that gather data, create visualizations, and generate insights Product development teams that ideate, design, and plan implementation Let's get started building your first crew!\n\nBy the end of this guide, you'll have: **Created a sophisticated content generation system** that combines user input, AI planning, and multi-agent content creation **Orchestrated the flow of information** between different components of your system **Implemented event-driven architecture** where each step responds to the completion of previous steps **Built a foundation for more complex AI applications** that you can expand and customize This guide creator flow demonstrates fundamental patterns that can be applied to create much more advanced applications, such as: Interactive AI assistants that combine multiple specialized subsystems Complex data processing pipelines with AI-enhanced transformations Autonomous agents that integrate with external services and APIs Multi-stage decision-making systems with human-in-the-loop processes Let's dive in and build your first flow!",
                "metadata": {
                  "section_type": "General",
                  "content_type": "descriptive_text"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Prerequisites",
            "level": 2,
            "content": "Before using Google AI embeddings, ensure you have: Access to the Gemini API The necessary API keys and permissions You will need to update your *pyproject.toml* dependencies:\n```\ndependencies = [\n    \"google-generativeai>=0.8.4\", #main version in January/2025 - crewai v.0.100.0 and crewai-tools 0.33.0\n    \"crewai[tools]>=0.100.0,<1.0.0\"\n]\n```\n\n```\nfrom crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"google\",\n        \"config\": {\n            \"api_key\": \"<YOUR_API_KEY>\",\n            \"model\": \"<model_name>\"\n        }\n    }\n)\n```\n\nBefore starting, make sure you have: Installed CrewAI following the [installation guide](/installation) Set up your OpenAI API key in your environment variables Basic understanding of Python\n\nBefore starting, make sure you have: Installed CrewAI following the [installation guide](/installation) Set up your OpenAI API key in your environment variables Basic understanding of Python",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "YAML",
                "content": "dependencies = [\n    \"google-generativeai>=0.8.4\", #main version in January/2025 - crewai v.0.100.0 and crewai-tools 0.33.0\n    \"crewai[tools]>=0.100.0,<1.0.0\"\n]",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"google\",\n        \"config\": {\n            \"api_key\": \"<YOUR_API_KEY>\",\n            \"model\": \"<model_name>\"\n        }\n    }\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Step 1: Create a New CrewAI Flow Project",
            "level": 2,
            "content": "First, let's create a new CrewAI Flow project using the CLI. This command sets up a scaffolded project with all the necessary directories and template files for your flow.\n```\ncrewai create flow guide_creator_flow\ncd guide_creator_flow\n```\nThis will generate a project with the basic structure needed for your flow.",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "bash",
                "content": "crewai create flow guide_creator_flow\ncd guide_creator_flow",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Step 2: Understanding the Project Structure",
            "level": 2,
            "content": "The generated project has the following structure. Take a moment to familiarize yourself with it, as understanding this structure will help you create more complex flows in the future.\n```\nguide_creator_flow/\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 .env\n\u251c\u2500\u2500 main.py\n\u251c\u2500\u2500 crews/\n\u2502   \u2514\u2500\u2500 poem_crew/\n\u2502       \u251c\u2500\u2500 config/\n\u2502       \u2502   \u251c\u2500\u2500 agents.yaml\n\u2502       \u2502   \u2514\u2500\u2500 tasks.yaml\n\u2502       \u2514\u2500\u2500 poem_crew.py\n\u2514\u2500\u2500 tools/\n    \u2514\u2500\u2500 custom_tool.py\n```\nThis structure provides a clear separation between different components of your flow: The main flow logic in the `main.py` file Specialized crews in the `crews` directory Custom tools in the `tools` directory We'll modify this structure to create our guide creator flow, which will orchestrate the process of generating comprehensive learning guides.",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": null,
                "content": "guide_creator_flow/\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 .env\n\u251c\u2500\u2500 main.py\n\u251c\u2500\u2500 crews/\n\u2502   \u2514\u2500\u2500 poem_crew/\n\u2502       \u251c\u2500\u2500 config/\n\u2502       \u2502   \u251c\u2500\u2500 agents.yaml\n\u2502       \u2502   \u2514\u2500\u2500 tasks.yaml\n\u2502       \u2514\u2500\u2500 poem_crew.py\n\u2514\u2500\u2500 tools/\n    \u2514\u2500\u2500 custom_tool.py",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Step 3: Add a Content Writer Crew",
            "level": 2,
            "content": "Our flow will need a specialized crew to handle the content creation process. Let's use the CrewAI CLI to add a content writer crew:\n```\ncrewai flow add-crew content-crew\n```\nThis command automatically creates the necessary directories and template files for your crew. The content writer crew will be responsible for writing and reviewing sections of our guide, working within the overall flow orchestrated by our main application.",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "bash",
                "content": "crewai flow add-crew content-crew",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Step 4: Configure the Content Writer Crew",
            "level": 2,
            "content": "Now, let's modify the generated files for the content writer crew. We'll set up two specialized agents - a writer and a reviewer - that will collaborate to create high-quality content for our guide. First, update the agents configuration file to define our content creation team:\n```\n# src/guide_creator_flow/crews/content_crew/config/agents.yaml\ncontent_writer:\n  role: >\n    Educational Content Writer\n  goal: >\n    Create engaging, informative content that thoroughly explains the assigned topic\n    and provides valuable insights to the reader\n  backstory: >\n    You are a talented educational writer with expertise in creating clear, engaging\n    content. You have a gift for explaining complex concepts in accessible language\n    and organizing information in a way that helps readers build their understanding.\n  llm: openai/gpt-4o-mini\n\ncontent_reviewer:\n  role: >\n    Educational Content Reviewer and Editor\n  goal: >\n    Ensure content is accurate, comprehensive, well-structured, and maintains\n    consistency with previously written sections\n  backstory: >\n    You are a meticulous editor with years of experience reviewing educational\n    content. You have an eye for detail, clarity, and coherence. You excel at\n    improving content while maintaining the original author's voice and ensuring\n    consistent quality across multiple sections.\n  llm: openai/gpt-4o-mini\n```\nThese agent definitions establish the specialized roles and perspectives that will shape how our AI agents approach content creation. Notice how each agent has a distinct purpose and expertise. Next, update the tasks configuration file to define the specific writing and reviewing tasks:\n```\n# src/guide_creator_flow/crews/content_crew/config/tasks.yaml\nwrite_section_task:\n  description: >\n    Write a comprehensive section on the topic: \"{section_title}\"\n\n    Section description: {section_description}\n    Target audience: {audience_level} level learners\n\n    Your content should:\n    1. Begin with a brief introduction to the section topic\n    2. Explain all key concepts clearly with examples\n    3. Include practical applications or exercises where appropriate\n    4. End with a summary of key points\n    5. Be approximately 500-800 words in length\n\n    Format your content in Markdown with appropriate headings, lists, and emphasis.\n\n    Previously written sections:\n    {previous_sections}\n\n    Make sure your content maintains consistency with previously written sections\n    and builds upon concepts that have already been explained.\n  expected_output: >\n    A well-structured, comprehensive section in Markdown format that thoroughly\n    explains the topic and is appropriate for the target audience.\n  agent: content_writer\n\nreview_section_task:\n  description: >\n    Review and improve the following section on \"{section_title}\":\n\n    {draft_content}\n\n    Target audience: {audience_level} level learners\n\n    Previously written sections:\n    {previous_sections}\n\n    Your review should:\n    1. Fix any grammatical or spelling errors\n    2. Improve clarity and readability\n    3. Ensure content is comprehensive and accurate\n    4. Verify consistency with previously written sections\n    5. Enhance the structure and flow\n    6. Add any missing key information\n\n    Provide the improved version of the section in Markdown format.\n  expected_output: >\n    An improved, polished version of the section that maintains the original\n    structure but enhances clarity, accuracy, and consistency.\n  agent: content_reviewer\n  context:\n    - write_section_task\n```\nThese task definitions provide detailed instructions to our agents, ensuring they produce content that meets our quality standards. Note how the `context` parameter in the review task creates a workflow where the reviewer has access to the writer's output. Now, update the crew implementation file to define how our agents and tasks work together:\n```\n# src/guide_creator_flow/crews/content_crew/content_crew.py\nfrom crewai import Agent, Crew, Process, Task\nfrom crewai.project import CrewBase, agent, crew, task\n\n@CrewBase\nclass ContentCrew():\n    \"\"\"Content writing crew\"\"\"\n\n    @agent\n    def content_writer(self) -> Agent:\n        return Agent(\n            config=self.agents_config['content_writer'],\n            verbose=True\n        )\n\n    @agent\n    def content_reviewer(self) -> Agent:\n        return Agent(\n            config=self.agents_config['content_reviewer'],\n            verbose=True\n        )\n\n    @task\n    def write_section_task(self) -> Task:\n        return Task(\n            config=self.tasks_config['write_section_task']\n        )\n\n    @task\n    def review_section_task(self) -> Task:\n        return Task(\n            config=self.tasks_config['review_section_task'],\n            context=[self.write_section_task()]\n        )\n\n    @crew\n    def crew(self) -> Crew:\n        \"\"\"Creates the content writing crew\"\"\"\n        return Crew(\n            agents=self.agents,\n            tasks=self.tasks,\n            process=Process.sequential,\n            verbose=True,\n        )\n```\nThis crew definition establishes the relationship between our agents and tasks, setting up a sequential process where the content writer creates a draft and then the reviewer improves it. While this crew can function independently, in our flow it will be orchestrated as part of a larger system.",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "yaml",
                "content": "# src/guide_creator_flow/crews/content_crew/config/agents.yaml\ncontent_writer:\n  role: >\n    Educational Content Writer\n  goal: >\n    Create engaging, informative content that thoroughly explains the assigned topic\n    and provides valuable insights to the reader\n  backstory: >\n    You are a talented educational writer with expertise in creating clear, engaging\n    content. You have a gift for explaining complex concepts in accessible language\n    and organizing information in a way that helps readers build their understanding.\n  llm: openai/gpt-4o-mini\n\ncontent_reviewer:\n  role: >\n    Educational Content Reviewer and Editor\n  goal: >\n    Ensure content is accurate, comprehensive, well-structured, and maintains\n    consistency with previously written sections\n  backstory: >\n    You are a meticulous editor with years of experience reviewing educational\n    content. You have an eye for detail, clarity, and coherence. You excel at\n    improving content while maintaining the original author's voice and ensuring\n    consistent quality across multiple sections.\n  llm: openai/gpt-4o-mini",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "yaml",
                "content": "# src/guide_creator_flow/crews/content_crew/config/tasks.yaml\nwrite_section_task:\n  description: >\n    Write a comprehensive section on the topic: \"{section_title}\"\n\n    Section description: {section_description}\n    Target audience: {audience_level} level learners\n\n    Your content should:\n    1. Begin with a brief introduction to the section topic\n    2. Explain all key concepts clearly with examples\n    3. Include practical applications or exercises where appropriate\n    4. End with a summary of key points\n    5. Be approximately 500-800 words in length\n\n    Format your content in Markdown with appropriate headings, lists, and emphasis.\n\n    Previously written sections:\n    {previous_sections}\n\n    Make sure your content maintains consistency with previously written sections\n    and builds upon concepts that have already been explained.\n  expected_output: >\n    A well-structured, comprehensive section in Markdown format that thoroughly\n    explains the topic and is appropriate for the target audience.\n  agent: content_writer\n\nreview_section_task:\n  description: >\n    Review and improve the following section on \"{section_title}\":\n\n    {draft_content}\n\n    Target audience: {audience_level} level learners\n\n    Previously written sections:\n    {previous_sections}\n\n    Your review should:\n    1. Fix any grammatical or spelling errors\n    2. Improve clarity and readability\n    3. Ensure content is comprehensive and accurate\n    4. Verify consistency with previously written sections\n    5. Enhance the structure and flow\n    6. Add any missing key information\n\n    Provide the improved version of the section in Markdown format.\n  expected_output: >\n    An improved, polished version of the section that maintains the original\n    structure but enhances clarity, accuracy, and consistency.\n  agent: content_reviewer\n  context:\n    - write_section_task",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python",
                "content": "# src/guide_creator_flow/crews/content_crew/content_crew.py\nfrom crewai import Agent, Crew, Process, Task\nfrom crewai.project import CrewBase, agent, crew, task\n\n@CrewBase\nclass ContentCrew():\n    \"\"\"Content writing crew\"\"\"\n\n    @agent\n    def content_writer(self) -> Agent:\n        return Agent(\n            config=self.agents_config['content_writer'],\n            verbose=True\n        )\n\n    @agent\n    def content_reviewer(self) -> Agent:\n        return Agent(\n            config=self.agents_config['content_reviewer'],\n            verbose=True\n        )\n\n    @task\n    def write_section_task(self) -> Task:\n        return Task(\n            config=self.tasks_config['write_section_task']\n        )\n\n    @task\n    def review_section_task(self) -> Task:\n        return Task(\n            config=self.tasks_config['review_section_task'],\n            context=[self.write_section_task()]\n        )\n\n    @crew\n    def crew(self) -> Crew:\n        \"\"\"Creates the content writing crew\"\"\"\n        return Crew(\n            agents=self.agents,\n            tasks=self.tasks,\n            process=Process.sequential,\n            verbose=True,\n        )",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Step 5: Create the Flow",
            "level": 2,
            "content": "Now comes the exciting part - creating the flow that will orchestrate the entire guide creation process. This is where we'll combine regular Python code, direct LLM calls, and our content creation crew into a cohesive system. Our flow will: Get user input for a topic and audience level Make a direct LLM call to create a structured guide outline Process each section sequentially using the content writer crew Combine everything into a final comprehensive document Let's create our flow in the `main.py` file:\n```\n#!/usr/bin/env python\nimport json\nfrom typing import List, Dict\nfrom pydantic import BaseModel, Field\nfrom crewai import LLM\nfrom crewai.flow.flow import Flow, listen, start\nfrom guide_creator_flow.crews.content_crew.content_crew import ContentCrew\n\n# Define our models for structured data\nclass Section(BaseModel):\n    title: str = Field(description=\"Title of the section\")\n    description: str = Field(description=\"Brief description of what the section should cover\")\n\nclass GuideOutline(BaseModel):\n    title: str = Field(description=\"Title of the guide\")\n    introduction: str = Field(description=\"Introduction to the topic\")\n    target_audience: str = Field(description=\"Description of the target audience\")\n    sections: List[Section] = Field(description=\"List of sections in the guide\")\n    conclusion: str = Field(description=\"Conclusion or summary of the guide\")\n\n# Define our flow state\nclass GuideCreatorState(BaseModel):\n    topic: str = \"\"\n    audience_level: str = \"\"\n    guide_outline: GuideOutline = None\n    sections_content: Dict[str, str] = {}\n\nclass GuideCreatorFlow(Flow[GuideCreatorState]):\n    \"\"\"Flow for creating a comprehensive guide on any topic\"\"\"\n\n    @start()\n    def get_user_input(self):\n        \"\"\"Get input from the user about the guide topic and audience\"\"\"\n        print(\"\\n=== Create Your Comprehensive Guide ===\\n\")\n\n        # Get user input\n        self.state.topic = input(\"What topic would you like to create a guide for? \")\n\n        # Get audience level with validation\n        while True:\n            audience = input(\"Who is your target audience? (beginner/intermediate/advanced) \").lower()\n            if audience in [\"beginner\", \"intermediate\", \"advanced\"]:\n                self.state.audience_level = audience\n                break\n            print(\"Please enter 'beginner', 'intermediate', or 'advanced'\")\n\n        print(f\"\\nCreating a guide on {self.state.topic} for {self.state.audience_level} audience...\\n\")\n        return self.state\n\n    @listen(get_user_input)\n    def create_guide_outline(self, state):\n        \"\"\"Create a structured outline for the guide using a direct LLM call\"\"\"\n        print(\"Creating guide outline...\")\n\n        # Initialize the LLM\n        llm = LLM(model=\"openai/gpt-4o-mini\", response_format=GuideOutline)\n\n        # Create the messages for the outline\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are a helpful assistant designed to output JSON.\"},\n            {\"role\": \"user\", \"content\": f\"\"\"\n            Create a detailed outline for a comprehensive guide on \"{state.topic}\" for {state.audience_level} level learners.\n\n            The outline should include:\n            1. A compelling title for the guide\n            2. An introduction to the topic\n            3. 4-6 main sections that cover the most important aspects of the topic\n            4. A conclusion or summary\n\n            For each section, provide a clear title and a brief description of what it should cover.\n            \"\"\"}\n        ]\n\n        # Make the LLM call with JSON response format\n        response = llm.call(messages=messages)\n\n        # Parse the JSON response\n        outline_dict = json.loads(response)\n        self.state.guide_outline = GuideOutline(**outline_dict)\n\n        # Save the outline to a file\n        with open(\"output/guide_outline.json\", \"w\") as f:\n            json.dump(outline_dict, f, indent=2)\n\n        print(f\"Guide outline created with {len(self.state.guide_outline.sections)} sections\")\n        return self.state.guide_outline\n\n    @listen(create_guide_outline)\n    def write_and_compile_guide(self, outline):\n        \"\"\"Write all sections and compile the guide\"\"\"\n        print(\"Writing guide sections and compiling...\")\n        completed_sections = []\n\n        # Process sections one by one to maintain context flow\n        for section in outline.sections:\n            print(f\"Processing section: {section.title}\")\n\n            # Build context from previous sections\n            previous_sections_text = \"\"\n            if completed_sections:\n                previous_sections_text = \"# Previously Written Sections\\n\\n\"\n                for title in completed_sections:\n                    previous_sections_text += f\"## {title}\\n\\n\"\n                    previous_sections_text += self.state.sections_content.get(title, \"\") + \"\\n\\n\"\n            else:\n                previous_sections_text = \"No previous sections written yet.\"\n\n            # Run the content crew for this section\n            result = ContentCrew().crew().kickoff(inputs={\n                \"section_title\": section.title,\n                \"section_description\": section.description,\n                \"audience_level\": self.state.audience_level,\n                \"previous_sections\": previous_sections_text,\n                \"draft_content\": \"\"\n            })\n\n            # Store the content\n            self.state.sections_content[section.title] = result.raw\n            completed_sections.append(section.title)\n            print(f\"Section completed: {section.title}\")\n\n        # Compile the final guide\n        guide_content = f\"# {outline.title}\\n\\n\"\n        guide_content += f\"## Introduction\\n\\n{outline.introduction}\\n\\n\"\n\n        # Add each section in order\n        for section in outline.sections:\n            section_content = self.state.sections_content.get(section.title, \"\")\n            guide_content += f\"\\n\\n{section_content}\\n\\n\"\n\n        # Add conclusion\n        guide_content += f\"## Conclusion\\n\\n{outline.conclusion}\\n\\n\"\n\n        # Save the guide\n        with open(\"output/complete_guide.md\", \"w\") as f:\n            f.write(guide_content)\n\n        print(\"\\nComplete guide compiled and saved to output/complete_guide.md\")\n        return \"Guide creation completed successfully\"\n\ndef kickoff():\n    \"\"\"Run the guide creator flow\"\"\"\n    GuideCreatorFlow().kickoff()\n    print(\"\\n=== Flow Complete ===\")\n    print(\"Your comprehensive guide is ready in the output directory.\")\n    print(\"Open output/complete_guide.md to view it.\")\n\ndef plot():\n    \"\"\"Generate a visualization of the flow\"\"\"\n    flow = GuideCreatorFlow()\n    flow.plot(\"guide_creator_flow\")\n    print(\"Flow visualization saved to guide_creator_flow.html\")\n\nif __name__ == \"__main__\":\n    kickoff()\n```\nLet's analyze what's happening in this flow: We define Pydantic models for structured data, ensuring type safety and clear data representation We create a state class to maintain data across different steps of the flow We implement three main flow steps: Getting user input with the `@start()` decorator Creating a guide outline with a direct LLM call Processing sections with our content crew We use the `@listen()` decorator to establish event-driven relationships between steps This is the power of flows - combining different types of processing (user interaction, direct LLM calls, crew-based tasks) into a coherent, event-driven system.",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python",
                "content": "#!/usr/bin/env python\nimport json\nfrom typing import List, Dict\nfrom pydantic import BaseModel, Field\nfrom crewai import LLM\nfrom crewai.flow.flow import Flow, listen, start\nfrom guide_creator_flow.crews.content_crew.content_crew import ContentCrew\n\n# Define our models for structured data\nclass Section(BaseModel):\n    title: str = Field(description=\"Title of the section\")\n    description: str = Field(description=\"Brief description of what the section should cover\")\n\nclass GuideOutline(BaseModel):\n    title: str = Field(description=\"Title of the guide\")\n    introduction: str = Field(description=\"Introduction to the topic\")\n    target_audience: str = Field(description=\"Description of the target audience\")\n    sections: List[Section] = Field(description=\"List of sections in the guide\")\n    conclusion: str = Field(description=\"Conclusion or summary of the guide\")\n\n# Define our flow state\nclass GuideCreatorState(BaseModel):\n    topic: str = \"\"\n    audience_level: str = \"\"\n    guide_outline: GuideOutline = None\n    sections_content: Dict[str, str] = {}\n\nclass GuideCreatorFlow(Flow[GuideCreatorState]):\n    \"\"\"Flow for creating a comprehensive guide on any topic\"\"\"\n\n    @start()\n    def get_user_input(self):\n        \"\"\"Get input from the user about the guide topic and audience\"\"\"\n        print(\"\\n=== Create Your Comprehensive Guide ===\\n\")\n\n        # Get user input\n        self.state.topic = input(\"What topic would you like to create a guide for? \")\n\n        # Get audience level with validation\n        while True:\n            audience = input(\"Who is your target audience? (beginner/intermediate/advanced) \").lower()\n            if audience in [\"beginner\", \"intermediate\", \"advanced\"]:\n                self.state.audience_level = audience\n                break\n            print(\"Please enter 'beginner', 'intermediate', or 'advanced'\")\n\n        print(f\"\\nCreating a guide on {self.state.topic} for {self.state.audience_level} audience...\\n\")\n        return self.state\n\n    @listen(get_user_input)\n    def create_guide_outline(self, state):\n        \"\"\"Create a structured outline for the guide using a direct LLM call\"\"\"\n        print(\"Creating guide outline...\")\n\n        # Initialize the LLM\n        llm = LLM(model=\"openai/gpt-4o-mini\", response_format=GuideOutline)\n\n        # Create the messages for the outline\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are a helpful assistant designed to output JSON.\"},\n            {\"role\": \"user\", \"content\": f\"\"\"\n            Create a detailed outline for a comprehensive guide on \"{state.topic}\" for {state.audience_level} level learners.\n\n            The outline should include:\n            1. A compelling title for the guide\n            2. An introduction to the topic\n            3. 4-6 main sections that cover the most important aspects of the topic\n            4. A conclusion or summary\n\n            For each section, provide a clear title and a brief description of what it should cover.\n            \"\"\"}\n        ]\n\n        # Make the LLM call with JSON response format\n        response = llm.call(messages=messages)\n\n        # Parse the JSON response\n        outline_dict = json.loads(response)\n        self.state.guide_outline = GuideOutline(**outline_dict)\n\n        # Save the outline to a file\n        with open(\"output/guide_outline.json\", \"w\") as f:\n            json.dump(outline_dict, f, indent=2)\n\n        print(f\"Guide outline created with {len(self.state.guide_outline.sections)} sections\")\n        return self.state.guide_outline\n\n    @listen(create_guide_outline)\n    def write_and_compile_guide(self, outline):\n        \"\"\"Write all sections and compile the guide\"\"\"\n        print(\"Writing guide sections and compiling...\")\n        completed_sections = []\n\n        # Process sections one by one to maintain context flow\n        for section in outline.sections:\n            print(f\"Processing section: {section.title}\")\n\n            # Build context from previous sections\n            previous_sections_text = \"\"\n            if completed_sections:\n                previous_sections_text = \"# Previously Written Sections\\n\\n\"\n                for title in completed_sections:\n                    previous_sections_text += f\"## {title}\\n\\n\"\n                    previous_sections_text += self.state.sections_content.get(title, \"\") + \"\\n\\n\"\n            else:\n                previous_sections_text = \"No previous sections written yet.\"\n\n            # Run the content crew for this section\n            result = ContentCrew().crew().kickoff(inputs={\n                \"section_title\": section.title,\n                \"section_description\": section.description,\n                \"audience_level\": self.state.audience_level,\n                \"previous_sections\": previous_sections_text,\n                \"draft_content\": \"\"\n            })\n\n            # Store the content\n            self.state.sections_content[section.title] = result.raw\n            completed_sections.append(section.title)\n            print(f\"Section completed: {section.title}\")\n\n        # Compile the final guide\n        guide_content = f\"# {outline.title}\\n\\n\"\n        guide_content += f\"## Introduction\\n\\n{outline.introduction}\\n\\n\"\n\n        # Add each section in order\n        for section in outline.sections:\n            section_content = self.state.sections_content.get(section.title, \"\")\n            guide_content += f\"\\n\\n{section_content}\\n\\n\"\n\n        # Add conclusion\n        guide_content += f\"## Conclusion\\n\\n{outline.conclusion}\\n\\n\"\n\n        # Save the guide\n        with open(\"output/complete_guide.md\", \"w\") as f:\n            f.write(guide_content)\n\n        print(\"\\nComplete guide compiled and saved to output/complete_guide.md\")\n        return \"Guide creation completed successfully\"\n\ndef kickoff():\n    \"\"\"Run the guide creator flow\"\"\"\n    GuideCreatorFlow().kickoff()\n    print(\"\\n=== Flow Complete ===\")\n    print(\"Your comprehensive guide is ready in the output directory.\")\n    print(\"Open output/complete_guide.md to view it.\")\n\ndef plot():\n    \"\"\"Generate a visualization of the flow\"\"\"\n    flow = GuideCreatorFlow()\n    flow.plot(\"guide_creator_flow\")\n    print(\"Flow visualization saved to guide_creator_flow.html\")\n\nif __name__ == \"__main__\":\n    kickoff()",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Step 6: Set Up Your Environment Variables",
            "level": 2,
            "content": "Create a `.env` file in your project root with your API keys:\n```\nOPENAI_API_KEY=your_openai_api_key\n```",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": null,
                "content": "OPENAI_API_KEY=your_openai_api_key",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Step 7: Install Dependencies",
            "level": 2,
            "content": "Install the required dependencies:\n```\ncrewai install\n```",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "bash",
                "content": "crewai install",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Step 8: Run Your Flow",
            "level": 2,
            "content": "Now it's time to see your flow in action! Run it using the CrewAI CLI:\n```\ncrewai flow kickoff\n```\nWhen you run this command, you'll see your flow spring to life: It will prompt you for a topic and audience level It will create a structured outline for your guide It will process each section, with the content writer and reviewer collaborating on each Finally, it will compile everything into a comprehensive guide This demonstrates the power of flows to orchestrate complex processes involving multiple components, both AI and non-AI.",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "bash",
                "content": "crewai flow kickoff",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Step 9: Visualize Your Flow",
            "level": 2,
            "content": "One of the powerful features of flows is the ability to visualize their structure:\n```\ncrewai flow plot\n```\nThis will create an HTML file that shows the structure of your flow, including the relationships between different steps and the data that flows between them. This visualization can be invaluable for understanding and debugging complex flows.",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "bash",
                "content": "crewai flow plot",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Step 10: Review the Output",
            "level": 2,
            "content": "Once the crew completes its work, you'll find the final report in the `output/report.md` file. The report will include: An executive summary Detailed information about the topic Analysis and insights Recommendations or future considerations Take a moment to appreciate what you've accomplished - you've created a system where multiple AI agents collaborated on a complex task, each contributing their specialized skills to produce a result that's greater than what any single agent could achieve alone.\n\nOnce the flow completes, you'll find two files in the `output` directory: `guide_outline.json`: Contains the structured outline of the guide `complete_guide.md`: The comprehensive guide with all sections Take a moment to review these files and appreciate what you've built - a system that combines user input, direct AI interactions, and collaborative agent work to produce a complex, high-quality output.",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "The Art of the Possible: Beyond Your First Flow",
            "level": 2,
            "content": "What you've learned in this guide provides a foundation for creating much more sophisticated AI systems. Here are some ways you could extend this basic flow:",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": [
              {
                "type": "header",
                "title": "Enhancing User Interaction",
                "level": 3,
                "content": "You could create more interactive flows with: Web interfaces for input and output Real-time progress updates Interactive feedback and refinement loops Multi-stage user interactions",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Adding More Processing Steps",
                "level": 3,
                "content": "You could expand your flow with additional steps for: Research before outline creation Image generation for illustrations Code snippet generation for technical guides Final quality assurance and fact-checking",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Creating More Complex Flows",
                "level": 3,
                "content": "You could implement more sophisticated flow patterns: Conditional branching based on user preferences or content type Parallel processing of independent sections Iterative refinement loops with feedback Integration with external APIs and services",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Applying to Different Domains",
                "level": 3,
                "content": "The same patterns can be applied to create crews for: **Content creation**: Writers, editors, fact-checkers, and designers working together **Customer service**: Triage agents, specialists, and quality control working together **Product development**: Researchers, designers, and planners collaborating **Data analysis**: Data collectors, analysts, and visualization specialists\n\nThe same patterns can be applied to create flows for: **Interactive storytelling**: Create personalized stories based on user input **Business intelligence**: Process data, generate insights, and create reports **Product development**: Facilitate ideation, design, and planning **Educational systems**: Create personalized learning experiences",
                "metadata": {
                  "section_type": "General",
                  "content_type": "descriptive_text"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Key Features Demonstrated",
            "level": 2,
            "content": "This guide creator flow demonstrates several powerful features of CrewAI: **User interaction**: The flow collects input directly from the user **Direct LLM calls**: Uses the LLM class for efficient, single-purpose AI interactions **Structured data with Pydantic**: Uses Pydantic models to ensure type safety **Sequential processing with context**: Writes sections in order, providing previous sections for context **Multi-agent crews**: Leverages specialized agents (writer and reviewer) for content creation **State management**: Maintains state across different steps of the process **Event-driven architecture**: Uses the `@listen` decorator to respond to events",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Understanding the Flow Structure",
            "level": 2,
            "content": "Let's break down the key components of flows to help you understand how to build your own:",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": [
              {
                "type": "header",
                "title": "1. Direct LLM Calls",
                "level": 3,
                "content": "Flows allow you to make direct calls to language models when you need simple, structured responses:\n```\nllm = LLM(model=\"openai/gpt-4o-mini\", response_format=GuideOutline)\nresponse = llm.call(messages=messages)\n```\nThis is more efficient than using a crew when you need a specific, structured output.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "llm = LLM(model=\"openai/gpt-4o-mini\", response_format=GuideOutline)\nresponse = llm.call(messages=messages)",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "2. Event-Driven Architecture",
                "level": 3,
                "content": "Flows use decorators to establish relationships between components:\n```\n@start()\ndef get_user_input(self):\n    # First step in the flow\n    # ...\n\n@listen(get_user_input)\ndef create_guide_outline(self, state):\n    # This runs when get_user_input completes\n    # ...\n```\nThis creates a clear, declarative structure for your application.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "@start()\ndef get_user_input(self):\n    # First step in the flow\n    # ...\n\n@listen(get_user_input)\ndef create_guide_outline(self, state):\n    # This runs when get_user_input completes\n    # ...",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "3. State Management",
                "level": 3,
                "content": "Flows maintain state across steps, making it easy to share data:\n```\nclass GuideCreatorState(BaseModel):\n    topic: str = \"\"\n    audience_level: str = \"\"\n    guide_outline: GuideOutline = None\n    sections_content: Dict[str, str] = {}\n```\nThis provides a type-safe way to track and transform data throughout your flow.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "class GuideCreatorState(BaseModel):\n    topic: str = \"\"\n    audience_level: str = \"\"\n    guide_outline: GuideOutline = None\n    sections_content: Dict[str, str] = {}",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "4. Crew Integration",
                "level": 3,
                "content": "Flows can seamlessly integrate with crews for complex collaborative tasks:\n```\nresult = ContentCrew().crew().kickoff(inputs={\n    \"section_title\": section.title,\n    # ...\n})\n```\nThis allows you to use the right tool for each part of your application - direct LLM calls for simple tasks and crews for complex collaboration.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "result = ContentCrew().crew().kickoff(inputs={\n    \"section_title\": section.title,\n    # ...\n})",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              }
            ]
          },
          {
            "type": "header",
            "title": "Next Steps",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Mastering Flow State Management",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": []
      },
      {
        "type": "header",
        "title": "Mastering Flow State Management",
        "level": 1,
        "content": "Source: https://docs.crewai.com/guides/flows/mastering-flow-state A comprehensive guide to managing, persisting, and leveraging state in CrewAI Flows for building robust AI applications.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": [
          {
            "type": "header",
            "title": "Understanding the Power of State in Flows",
            "level": 2,
            "content": "State management is the backbone of any sophisticated AI workflow. In CrewAI Flows, the state system allows you to maintain context, share data between steps, and build complex application logic. Mastering state management is essential for creating reliable, maintainable, and powerful AI applications. This guide will walk you through everything you need to know about managing state in CrewAI Flows, from basic concepts to advanced techniques, with practical code examples along the way.",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": [
              {
                "type": "header",
                "title": "Why State Management Matters",
                "level": 3,
                "content": "Effective state management enables you to: **Maintain context across execution steps** - Pass information seamlessly between different stages of your workflow **Build complex conditional logic** - Make decisions based on accumulated data **Create persistent applications** - Save and restore workflow progress **Handle errors gracefully** - Implement recovery patterns for more robust applications **Scale your applications** - Support complex workflows with proper data organization **Enable conversational applications** - Store and access conversation history for context-aware AI interactions Let's explore how to leverage these capabilities effectively.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "descriptive_text"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "State Management Fundamentals",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": [
              {
                "type": "header",
                "title": "The Flow State Lifecycle",
                "level": 3,
                "content": "In CrewAI Flows, the state follows a predictable lifecycle: **Initialization** - When a flow is created, its state is initialized (either as an empty dictionary or a Pydantic model instance) **Modification** - Flow methods access and modify the state as they execute **Transmission** - State is passed automatically between flow methods **Persistence** (optional) - State can be saved to storage and later retrieved **Completion** - The final state reflects the cumulative changes from all executed methods Understanding this lifecycle is crucial for designing effective flows.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "descriptive_text"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Two Approaches to State Management",
                "level": 3,
                "content": "CrewAI offers two ways to manage state in your flows: **Unstructured State** - Using dictionary-like objects for flexibility **Structured State** - Using Pydantic models for type safety and validation Let's examine each approach in detail.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Unstructured State Management",
            "level": 2,
            "content": "In unstructured state management, all state is stored in the `state` attribute of the `Flow` class.\nThis approach offers flexibility, enabling developers to add or modify state attributes on the fly without defining a strict schema.\nEven with unstructured states, CrewAI Flows automatically generates and maintains a unique identifier (UUID) for each state instance.\n```\nfrom crewai.flow.flow import Flow, listen, start\n\nclass UnstructuredExampleFlow(Flow):\n\n    @start()\n    def first_method(self):\n        # The state automatically includes an 'id' field\n        print(f\"State ID: {self.state['id']}\")\n        self.state['counter'] = 0\n        self.state['message'] = \"Hello from structured flow\"\n\n    @listen(first_method)\n    def second_method(self):\n        self.state['counter'] += 1\n        self.state['message'] += \" - updated\"\n\n    @listen(second_method)\n    def third_method(self):\n        self.state['counter'] += 1\n        self.state['message'] += \" - updated again\"\n\n        print(f\"State after third_method: {self.state}\")\n\n\nflow = UnstructuredExampleFlow()\nflow.kickoff()\n```\n**Note:** The `id` field is automatically generated and preserved throughout the flow's execution. You don't need to manage or set it manually, and it will be maintained even when updating the state with new data. **Key Points:** **Flexibility:** You can dynamically add attributes to `self.state` without predefined constraints. **Simplicity:** Ideal for straightforward workflows where state structure is minimal or varies significantly.\n\nUnstructured state uses a dictionary-like approach, offering flexibility and simplicity for straightforward applications.",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [
              {
                "type": "header",
                "title": "How It Works",
                "level": 3,
                "content": "",
                "metadata": {
                  "section_type": "General",
                  "content_type": null
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Basic Example",
                "level": 3,
                "content": "",
                "metadata": {
                  "section_type": "Examples",
                  "content_type": null
                },
                "children": []
              },
              {
                "type": "header",
                "title": "When to Use Unstructured State",
                "level": 3,
                "content": "Unstructured state is ideal for: Quick prototyping and simple flows Dynamically evolving state needs Cases where the structure may not be known in advance Flows with simple state requirements While flexible, unstructured state lacks type checking and schema validation, which can lead to errors in complex applications.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              }
            ],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai.flow.flow import Flow, listen, start\n\nclass UnstructuredExampleFlow(Flow):\n\n    @start()\n    def first_method(self):\n        # The state automatically includes an 'id' field\n        print(f\"State ID: {self.state['id']}\")\n        self.state['counter'] = 0\n        self.state['message'] = \"Hello from structured flow\"\n\n    @listen(first_method)\n    def second_method(self):\n        self.state['counter'] += 1\n        self.state['message'] += \" - updated\"\n\n    @listen(second_method)\n    def third_method(self):\n        self.state['counter'] += 1\n        self.state['message'] += \" - updated again\"\n\n        print(f\"State after third_method: {self.state}\")\n\n\nflow = UnstructuredExampleFlow()\nflow.kickoff()",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Structured State Management",
            "level": 2,
            "content": "Structured state management leverages predefined schemas to ensure consistency and type safety across the workflow.\nBy using models like Pydantic's `BaseModel`, developers can define the exact shape of the state, enabling better validation and auto-completion in development environments. Each state in CrewAI Flows automatically receives a unique identifier (UUID) to help track and manage state instances. This ID is automatically generated and managed by the Flow system.\n```\nfrom crewai.flow.flow import Flow, listen, start\nfrom pydantic import BaseModel\n\n\nclass ExampleState(BaseModel):\n    # Note: 'id' field is automatically added to all states\n    counter: int = 0\n    message: str = \"\"\n\n\nclass StructuredExampleFlow(Flow[ExampleState]):\n\n    @start()\n    def first_method(self):\n        # Access the auto-generated ID if needed\n        print(f\"State ID: {self.state.id}\")\n        self.state.message = \"Hello from structured flow\"\n\n    @listen(first_method)\n    def second_method(self):\n        self.state.counter += 1\n        self.state.message += \" - updated\"\n\n    @listen(second_method)\n    def third_method(self):\n        self.state.counter += 1\n        self.state.message += \" - updated again\"\n\n        print(f\"State after third_method: {self.state}\")\n\n\nflow = StructuredExampleFlow()\nflow.kickoff()\n```\n**Key Points:** **Defined Schema:** `ExampleState` clearly outlines the state structure, enhancing code readability and maintainability. **Type Safety:** Leveraging Pydantic ensures that state attributes adhere to the specified types, reducing runtime errors. **Auto-Completion:** IDEs can provide better auto-completion and error checking based on the defined state model.\n\nStructured state uses Pydantic models to define a schema for your flow's state, providing type safety, validation, and better developer experience.",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [
              {
                "type": "header",
                "title": "How It Works",
                "level": 3,
                "content": "",
                "metadata": {
                  "section_type": "General",
                  "content_type": null
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Basic Example",
                "level": 3,
                "content": "Here's a simple example of unstructured state management:\n```\nfrom crewai.flow.flow import Flow, listen, start\n\nclass UnstructuredStateFlow(Flow):\n    @start()\n    def initialize_data(self):\n        print(\"Initializing flow data\")\n        # Add key-value pairs to state\n        self.state[\"user_name\"] = \"Alex\"\n        self.state[\"preferences\"] = {\n            \"theme\": \"dark\",\n            \"language\": \"English\"\n        }\n        self.state[\"items\"] = []\n\n        # The flow state automatically gets a unique ID\n        print(f\"Flow ID: {self.state['id']}\")\n\n        return \"Initialized\"\n\n    @listen(initialize_data)\n    def process_data(self, previous_result):\n        print(f\"Previous step returned: {previous_result}\")\n\n        # Access and modify state\n        user = self.state[\"user_name\"]\n        print(f\"Processing data for {user}\")\n\n        # Add items to a list in state\n        self.state[\"items\"].append(\"item1\")\n        self.state[\"items\"].append(\"item2\")\n\n        # Add a new key-value pair\n        self.state[\"processed\"] = True\n\n        return \"Processed\"\n\n    @listen(process_data)\n    def generate_summary(self, previous_result):\n        # Access multiple state values\n        user = self.state[\"user_name\"]\n        theme = self.state[\"preferences\"][\"theme\"]\n        items = self.state[\"items\"]\n        processed = self.state.get(\"processed\", False)\n\n        summary = f\"User {user} has {len(items)} items with {theme} theme. \"\n        summary += \"Data is processed.\" if processed else \"Data is not processed.\"\n\n        return summary\n\n# Run the flow\nflow = UnstructuredStateFlow()\nresult = flow.kickoff()\nprint(f\"Final result: {result}\")\nprint(f\"Final state: {flow.state}\")\n```\n\nHere's how to implement structured state management:\n```\nfrom crewai.flow.flow import Flow, listen, start\nfrom pydantic import BaseModel, Field\nfrom typing import List, Dict, Optional\n\n# Define your state model\nclass UserPreferences(BaseModel):\n    theme: str = \"light\"\n    language: str = \"English\"\n\nclass AppState(BaseModel):\n    user_name: str = \"\"\n    preferences: UserPreferences = UserPreferences()\n    items: List[str] = []\n    processed: bool = False\n    completion_percentage: float = 0.0\n\n# Create a flow with typed state\nclass StructuredStateFlow(Flow[AppState]):\n    @start()\n    def initialize_data(self):\n        print(\"Initializing flow data\")\n        # Set state values (type-checked)\n        self.state.user_name = \"Taylor\"\n        self.state.preferences.theme = \"dark\"\n\n        # The ID field is automatically available\n        print(f\"Flow ID: {self.state.id}\")\n\n        return \"Initialized\"\n\n    @listen(initialize_data)\n    def process_data(self, previous_result):\n        print(f\"Processing data for {self.state.user_name}\")\n\n        # Modify state (with type checking)\n        self.state.items.append(\"item1\")\n        self.state.items.append(\"item2\")\n        self.state.processed = True\n        self.state.completion_percentage = 50.0\n\n        return \"Processed\"\n\n    @listen(process_data)\n    def generate_summary(self, previous_result):\n        # Access state (with autocompletion)\n        summary = f\"User {self.state.user_name} has {len(self.state.items)} items \"\n        summary += f\"with {self.state.preferences.theme} theme. \"\n        summary += \"Data is processed.\" if self.state.processed else \"Data is not processed.\"\n        summary += f\" Completion: {self.state.completion_percentage}%\"\n\n        return summary\n\n# Run the flow\nflow = StructuredStateFlow()\nresult = flow.kickoff()\nprint(f\"Final result: {result}\")\nprint(f\"Final state: {flow.state}\")\n```",
                "metadata": {
                  "section_type": "Examples",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "from crewai.flow.flow import Flow, listen, start\n\nclass UnstructuredStateFlow(Flow):\n    @start()\n    def initialize_data(self):\n        print(\"Initializing flow data\")\n        # Add key-value pairs to state\n        self.state[\"user_name\"] = \"Alex\"\n        self.state[\"preferences\"] = {\n            \"theme\": \"dark\",\n            \"language\": \"English\"\n        }\n        self.state[\"items\"] = []\n\n        # The flow state automatically gets a unique ID\n        print(f\"Flow ID: {self.state['id']}\")\n\n        return \"Initialized\"\n\n    @listen(initialize_data)\n    def process_data(self, previous_result):\n        print(f\"Previous step returned: {previous_result}\")\n\n        # Access and modify state\n        user = self.state[\"user_name\"]\n        print(f\"Processing data for {user}\")\n\n        # Add items to a list in state\n        self.state[\"items\"].append(\"item1\")\n        self.state[\"items\"].append(\"item2\")\n\n        # Add a new key-value pair\n        self.state[\"processed\"] = True\n\n        return \"Processed\"\n\n    @listen(process_data)\n    def generate_summary(self, previous_result):\n        # Access multiple state values\n        user = self.state[\"user_name\"]\n        theme = self.state[\"preferences\"][\"theme\"]\n        items = self.state[\"items\"]\n        processed = self.state.get(\"processed\", False)\n\n        summary = f\"User {user} has {len(items)} items with {theme} theme. \"\n        summary += \"Data is processed.\" if processed else \"Data is not processed.\"\n\n        return summary\n\n# Run the flow\nflow = UnstructuredStateFlow()\nresult = flow.kickoff()\nprint(f\"Final result: {result}\")\nprint(f\"Final state: {flow.state}\")",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  },
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "from crewai.flow.flow import Flow, listen, start\nfrom pydantic import BaseModel, Field\nfrom typing import List, Dict, Optional\n\n# Define your state model\nclass UserPreferences(BaseModel):\n    theme: str = \"light\"\n    language: str = \"English\"\n\nclass AppState(BaseModel):\n    user_name: str = \"\"\n    preferences: UserPreferences = UserPreferences()\n    items: List[str] = []\n    processed: bool = False\n    completion_percentage: float = 0.0\n\n# Create a flow with typed state\nclass StructuredStateFlow(Flow[AppState]):\n    @start()\n    def initialize_data(self):\n        print(\"Initializing flow data\")\n        # Set state values (type-checked)\n        self.state.user_name = \"Taylor\"\n        self.state.preferences.theme = \"dark\"\n\n        # The ID field is automatically available\n        print(f\"Flow ID: {self.state.id}\")\n\n        return \"Initialized\"\n\n    @listen(initialize_data)\n    def process_data(self, previous_result):\n        print(f\"Processing data for {self.state.user_name}\")\n\n        # Modify state (with type checking)\n        self.state.items.append(\"item1\")\n        self.state.items.append(\"item2\")\n        self.state.processed = True\n        self.state.completion_percentage = 50.0\n\n        return \"Processed\"\n\n    @listen(process_data)\n    def generate_summary(self, previous_result):\n        # Access state (with autocompletion)\n        summary = f\"User {self.state.user_name} has {len(self.state.items)} items \"\n        summary += f\"with {self.state.preferences.theme} theme. \"\n        summary += \"Data is processed.\" if self.state.processed else \"Data is not processed.\"\n        summary += f\" Completion: {self.state.completion_percentage}%\"\n\n        return summary\n\n# Run the flow\nflow = StructuredStateFlow()\nresult = flow.kickoff()\nprint(f\"Final result: {result}\")\nprint(f\"Final state: {flow.state}\")",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Benefits of Structured State",
                "level": 3,
                "content": "Using structured state provides several advantages: **Type Safety** - Catch type errors at development time **Self-Documentation** - The state model clearly documents what data is available **Validation** - Automatic validation of data types and constraints **IDE Support** - Get autocomplete and inline documentation **Default Values** - Easily define fallbacks for missing data",
                "metadata": {
                  "section_type": "General",
                  "content_type": "descriptive_text"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "When to Use Structured State",
                "level": 3,
                "content": "Structured state is recommended for: Complex flows with well-defined data schemas Team projects where multiple developers work on the same code Applications where data validation is important Flows that need to enforce specific data types and constraints",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              }
            ],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai.flow.flow import Flow, listen, start\nfrom pydantic import BaseModel\n\n\nclass ExampleState(BaseModel):\n    # Note: 'id' field is automatically added to all states\n    counter: int = 0\n    message: str = \"\"\n\n\nclass StructuredExampleFlow(Flow[ExampleState]):\n\n    @start()\n    def first_method(self):\n        # Access the auto-generated ID if needed\n        print(f\"State ID: {self.state.id}\")\n        self.state.message = \"Hello from structured flow\"\n\n    @listen(first_method)\n    def second_method(self):\n        self.state.counter += 1\n        self.state.message += \" - updated\"\n\n    @listen(second_method)\n    def third_method(self):\n        self.state.counter += 1\n        self.state.message += \" - updated again\"\n\n        print(f\"State after third_method: {self.state}\")\n\n\nflow = StructuredExampleFlow()\nflow.kickoff()",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "The Automatic State ID",
            "level": 2,
            "content": "Both unstructured and structured states automatically receive a unique identifier (UUID) to help track and manage state instances.",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": [
              {
                "type": "header",
                "title": "How It Works",
                "level": 3,
                "content": "CrewAI uses an event bus architecture to emit events throughout the execution lifecycle. The event system is built on the following components: **CrewAIEventsBus**: A singleton event bus that manages event registration and emission **CrewEvent**: Base class for all events in the system **BaseEventListener**: Abstract base class for creating custom event listeners When specific actions occur in CrewAI (like a Crew starting execution, an Agent completing a task, or a tool being used), the system emits corresponding events. You can register handlers for these events to execute custom code when they occur.\n\n**Unique State Identification** Each flow state automatically receives a unique UUID The ID is preserved across state updates and method calls Supports both structured (Pydantic BaseModel) and unstructured (dictionary) states **Default SQLite Backend** SQLiteFlowPersistence is the default storage backend States are automatically saved to a local SQLite database Robust error handling ensures clear messages if database operations fail **Error Handling** Comprehensive error messages for database operations Automatic state validation during save and load Clear feedback when persistence operations encounter issues\n\nWith unstructured state: You access state via `self.state` which behaves like a dictionary You can freely add, modify, or remove keys at any point All state is automatically available to all flow methods\n\nWith structured state: You define a Pydantic model that represents your state structure You pass this model type to your Flow class as a type parameter You access state via `self.state`, which behaves like a Pydantic model instance All fields are validated according to their defined types You get IDE autocompletion and type checking support\n\nFor unstructured state, the ID is accessible as `self.state[\"id\"]` For structured state, the ID is accessible as `self.state.id` This ID is generated automatically when the flow is created The ID remains the same throughout the flow's lifecycle The ID can be used for tracking, logging, and retrieving persisted states This UUID is particularly valuable when implementing persistence or tracking multiple flow executions.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "descriptive_text"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Dynamic State Updates",
            "level": 2,
            "content": "Regardless of whether you're using structured or unstructured state, you can update state dynamically throughout your flow's execution.",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": [
              {
                "type": "header",
                "title": "Passing Data Between Steps",
                "level": 3,
                "content": "Flow methods can return values that are then passed as arguments to listening methods:\n```\nfrom crewai.flow.flow import Flow, listen, start\n\nclass DataPassingFlow(Flow):\n    @start()\n    def generate_data(self):\n        # This return value will be passed to listening methods\n        return \"Generated data\"\n\n    @listen(generate_data)\n    def process_data(self, data_from_previous_step):\n        print(f\"Received: {data_from_previous_step}\")\n        # You can modify the data and pass it along\n        processed_data = f\"{data_from_previous_step} - processed\"\n        # Also update state\n        self.state[\"last_processed\"] = processed_data\n        return processed_data\n\n    @listen(process_data)\n    def finalize_data(self, processed_data):\n        print(f\"Received processed data: {processed_data}\")\n        # Access both the passed data and state\n        last_processed = self.state.get(\"last_processed\", \"\")\n        return f\"Final: {processed_data} (from state: {last_processed})\"\n```\nThis pattern allows you to combine direct data passing with state updates for maximum flexibility.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "from crewai.flow.flow import Flow, listen, start\n\nclass DataPassingFlow(Flow):\n    @start()\n    def generate_data(self):\n        # This return value will be passed to listening methods\n        return \"Generated data\"\n\n    @listen(generate_data)\n    def process_data(self, data_from_previous_step):\n        print(f\"Received: {data_from_previous_step}\")\n        # You can modify the data and pass it along\n        processed_data = f\"{data_from_previous_step} - processed\"\n        # Also update state\n        self.state[\"last_processed\"] = processed_data\n        return processed_data\n\n    @listen(process_data)\n    def finalize_data(self, processed_data):\n        print(f\"Received processed data: {processed_data}\")\n        # Access both the passed data and state\n        last_processed = self.state.get(\"last_processed\", \"\")\n        return f\"Final: {processed_data} (from state: {last_processed})\"",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              }
            ]
          },
          {
            "type": "header",
            "title": "Persisting Flow State",
            "level": 2,
            "content": "One of CrewAI's most powerful features is the ability to persist flow state across executions. This enables workflows that can be paused, resumed, and even recovered after failures.",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": [
              {
                "type": "header",
                "title": "The @persist Decorator",
                "level": 3,
                "content": "The `@persist` decorator automates state persistence, saving your flow's state at key points in execution.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": [
                  {
                    "type": "header",
                    "title": "Class-Level Persistence",
                    "level": 4,
                    "content": "When applied at the class level, the @persist decorator automatically persists all flow method states:\n```\n@persist  # Using SQLiteFlowPersistence by default\nclass MyFlow(Flow[MyState]):\n    @start()\n    def initialize_flow(self):\n        # This method will automatically have its state persisted\n        self.state.counter = 1\n        print(\"Initialized flow. State ID:\", self.state.id)\n\n    @listen(initialize_flow)\n    def next_step(self):\n        # The state (including self.state.id) is automatically reloaded\n        self.state.counter += 1\n        print(\"Flow state is persisted. Counter:\", self.state.counter)\n```\n\nWhen applied at the class level, `@persist` saves state after every method execution:\n```\nfrom crewai.flow.flow import Flow, listen, persist, start\nfrom pydantic import BaseModel\n\nclass CounterState(BaseModel):\n    value: int = 0\n\n@persist  # Apply to the entire flow class\nclass PersistentCounterFlow(Flow[CounterState]):\n    @start()\n    def increment(self):\n        self.state.value += 1\n        print(f\"Incremented to {self.state.value}\")\n        return self.state.value\n\n    @listen(increment)\n    def double(self, value):\n        self.state.value = value * 2\n        print(f\"Doubled to {self.state.value}\")\n        return self.state.value\n\n# First run\nflow1 = PersistentCounterFlow()\nresult1 = flow1.kickoff()\nprint(f\"First run result: {result1}\")\n\n# Second run - state is automatically loaded\nflow2 = PersistentCounterFlow()\nresult2 = flow2.kickoff()\nprint(f\"Second run result: {result2}\")  # Will be higher due to persisted state\n```",
                    "metadata": {
                      "section_type": "General",
                      "content_type": "code_example"
                    },
                    "children": [],
                    "code_blocks": [
                      {
                        "type": "code_block",
                        "language": "python",
                        "content": "@persist  # Using SQLiteFlowPersistence by default\nclass MyFlow(Flow[MyState]):\n    @start()\n    def initialize_flow(self):\n        # This method will automatically have its state persisted\n        self.state.counter = 1\n        print(\"Initialized flow. State ID:\", self.state.id)\n\n    @listen(initialize_flow)\n    def next_step(self):\n        # The state (including self.state.id) is automatically reloaded\n        self.state.counter += 1\n        print(\"Flow state is persisted. Counter:\", self.state.counter)",
                        "metadata": {
                          "section_type": "code",
                          "content_type": "code_example"
                        },
                        "children": []
                      },
                      {
                        "type": "code_block",
                        "language": "python",
                        "content": "from crewai.flow.flow import Flow, listen, persist, start\nfrom pydantic import BaseModel\n\nclass CounterState(BaseModel):\n    value: int = 0\n\n@persist  # Apply to the entire flow class\nclass PersistentCounterFlow(Flow[CounterState]):\n    @start()\n    def increment(self):\n        self.state.value += 1\n        print(f\"Incremented to {self.state.value}\")\n        return self.state.value\n\n    @listen(increment)\n    def double(self, value):\n        self.state.value = value * 2\n        print(f\"Doubled to {self.state.value}\")\n        return self.state.value\n\n# First run\nflow1 = PersistentCounterFlow()\nresult1 = flow1.kickoff()\nprint(f\"First run result: {result1}\")\n\n# Second run - state is automatically loaded\nflow2 = PersistentCounterFlow()\nresult2 = flow2.kickoff()\nprint(f\"Second run result: {result2}\")  # Will be higher due to persisted state",
                        "metadata": {
                          "section_type": "code",
                          "content_type": "code_example"
                        },
                        "children": []
                      }
                    ]
                  },
                  {
                    "type": "header",
                    "title": "Method-Level Persistence",
                    "level": 4,
                    "content": "For more granular control, you can apply @persist to specific methods:\n```\nclass AnotherFlow(Flow[dict]):\n    @persist  # Persists only this method's state\n    @start()\n    def begin(self):\n        if \"runs\" not in self.state:\n            self.state[\"runs\"] = 0\n        self.state[\"runs\"] += 1\n        print(\"Method-level persisted runs:\", self.state[\"runs\"])\n```\n\nFor more granular control, you can apply `@persist` to specific methods:\n```\nfrom crewai.flow.flow import Flow, listen, persist, start\n\nclass SelectivePersistFlow(Flow):\n    @start()\n    def first_step(self):\n        self.state[\"count\"] = 1\n        return \"First step\"\n\n    @persist  # Only persist after this method\n    @listen(first_step)\n    def important_step(self, prev_result):\n        self.state[\"count\"] += 1\n        self.state[\"important_data\"] = \"This will be persisted\"\n        return \"Important step completed\"\n\n    @listen(important_step)\n    def final_step(self, prev_result):\n        self.state[\"count\"] += 1\n        return f\"Complete with count {self.state['count']}\"\n```",
                    "metadata": {
                      "section_type": "General",
                      "content_type": "code_example"
                    },
                    "children": [],
                    "code_blocks": [
                      {
                        "type": "code_block",
                        "language": "python",
                        "content": "class AnotherFlow(Flow[dict]):\n    @persist  # Persists only this method's state\n    @start()\n    def begin(self):\n        if \"runs\" not in self.state:\n            self.state[\"runs\"] = 0\n        self.state[\"runs\"] += 1\n        print(\"Method-level persisted runs:\", self.state[\"runs\"])",
                        "metadata": {
                          "section_type": "code",
                          "content_type": "code_example"
                        },
                        "children": []
                      },
                      {
                        "type": "code_block",
                        "language": "python",
                        "content": "from crewai.flow.flow import Flow, listen, persist, start\n\nclass SelectivePersistFlow(Flow):\n    @start()\n    def first_step(self):\n        self.state[\"count\"] = 1\n        return \"First step\"\n\n    @persist  # Only persist after this method\n    @listen(first_step)\n    def important_step(self, prev_result):\n        self.state[\"count\"] += 1\n        self.state[\"important_data\"] = \"This will be persisted\"\n        return \"Important step completed\"\n\n    @listen(important_step)\n    def final_step(self, prev_result):\n        self.state[\"count\"] += 1\n        return f\"Complete with count {self.state['count']}\"",
                        "metadata": {
                          "section_type": "code",
                          "content_type": "code_example"
                        },
                        "children": []
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "header",
            "title": "Advanced State Patterns",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Internals/Advanced",
              "content_type": null
            },
            "children": [
              {
                "type": "header",
                "title": "State-Based Conditional Logic",
                "level": 3,
                "content": "You can use state to implement complex conditional logic in your flows:\n```\nfrom crewai.flow.flow import Flow, listen, router, start\nfrom pydantic import BaseModel\n\nclass PaymentState(BaseModel):\n    amount: float = 0.0\n    is_approved: bool = False\n    retry_count: int = 0\n\nclass PaymentFlow(Flow[PaymentState]):\n    @start()\n    def process_payment(self):\n        # Simulate payment processing\n        self.state.amount = 100.0\n        self.state.is_approved = self.state.amount < 1000\n        return \"Payment processed\"\n\n    @router(process_payment)\n    def check_approval(self, previous_result):\n        if self.state.is_approved:\n            return \"approved\"\n        elif self.state.retry_count < 3:\n            return \"retry\"\n        else:\n            return \"rejected\"\n\n    @listen(\"approved\")\n    def handle_approval(self):\n        return f\"Payment of ${self.state.amount} approved!\"\n\n    @listen(\"retry\")\n    def handle_retry(self):\n        self.state.retry_count += 1\n        print(f\"Retrying payment (attempt {self.state.retry_count})...\")\n        # Could implement retry logic here\n        return \"Retry initiated\"\n\n    @listen(\"rejected\")\n    def handle_rejection(self):\n        return f\"Payment of ${self.state.amount} rejected after {self.state.retry_count} retries.\"\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "from crewai.flow.flow import Flow, listen, router, start\nfrom pydantic import BaseModel\n\nclass PaymentState(BaseModel):\n    amount: float = 0.0\n    is_approved: bool = False\n    retry_count: int = 0\n\nclass PaymentFlow(Flow[PaymentState]):\n    @start()\n    def process_payment(self):\n        # Simulate payment processing\n        self.state.amount = 100.0\n        self.state.is_approved = self.state.amount < 1000\n        return \"Payment processed\"\n\n    @router(process_payment)\n    def check_approval(self, previous_result):\n        if self.state.is_approved:\n            return \"approved\"\n        elif self.state.retry_count < 3:\n            return \"retry\"\n        else:\n            return \"rejected\"\n\n    @listen(\"approved\")\n    def handle_approval(self):\n        return f\"Payment of ${self.state.amount} approved!\"\n\n    @listen(\"retry\")\n    def handle_retry(self):\n        self.state.retry_count += 1\n        print(f\"Retrying payment (attempt {self.state.retry_count})...\")\n        # Could implement retry logic here\n        return \"Retry initiated\"\n\n    @listen(\"rejected\")\n    def handle_rejection(self):\n        return f\"Payment of ${self.state.amount} rejected after {self.state.retry_count} retries.\"",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Handling Complex State Transformations",
                "level": 3,
                "content": "For complex state transformations, you can create dedicated methods:\n```\nfrom crewai.flow.flow import Flow, listen, start\nfrom pydantic import BaseModel\nfrom typing import List, Dict\n\nclass UserData(BaseModel):\n    name: str\n    active: bool = True\n    login_count: int = 0\n\nclass ComplexState(BaseModel):\n    users: Dict[str, UserData] = {}\n    active_user_count: int = 0\n\nclass TransformationFlow(Flow[ComplexState]):\n    @start()\n    def initialize(self):\n        # Add some users\n        self.add_user(\"alice\", \"Alice\")\n        self.add_user(\"bob\", \"Bob\")\n        self.add_user(\"charlie\", \"Charlie\")\n        return \"Initialized\"\n\n    @listen(initialize)\n    def process_users(self, _):\n        # Increment login counts\n        for user_id in self.state.users:\n            self.increment_login(user_id)\n\n        # Deactivate one user\n        self.deactivate_user(\"bob\")\n\n        # Update active count\n        self.update_active_count()\n\n        return f\"Processed {len(self.state.users)} users\"\n\n    # Helper methods for state transformations\n    def add_user(self, user_id: str, name: str):\n        self.state.users[user_id] = UserData(name=name)\n        self.update_active_count()\n\n    def increment_login(self, user_id: str):\n        if user_id in self.state.users:\n            self.state.users[user_id].login_count += 1\n\n    def deactivate_user(self, user_id: str):\n        if user_id in self.state.users:\n            self.state.users[user_id].active = False\n            self.update_active_count()\n\n    def update_active_count(self):\n        self.state.active_user_count = sum(\n            1 for user in self.state.users.values() if user.active\n        )\n```\nThis pattern of creating helper methods keeps your flow methods clean while enabling complex state manipulations.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "from crewai.flow.flow import Flow, listen, start\nfrom pydantic import BaseModel\nfrom typing import List, Dict\n\nclass UserData(BaseModel):\n    name: str\n    active: bool = True\n    login_count: int = 0\n\nclass ComplexState(BaseModel):\n    users: Dict[str, UserData] = {}\n    active_user_count: int = 0\n\nclass TransformationFlow(Flow[ComplexState]):\n    @start()\n    def initialize(self):\n        # Add some users\n        self.add_user(\"alice\", \"Alice\")\n        self.add_user(\"bob\", \"Bob\")\n        self.add_user(\"charlie\", \"Charlie\")\n        return \"Initialized\"\n\n    @listen(initialize)\n    def process_users(self, _):\n        # Increment login counts\n        for user_id in self.state.users:\n            self.increment_login(user_id)\n\n        # Deactivate one user\n        self.deactivate_user(\"bob\")\n\n        # Update active count\n        self.update_active_count()\n\n        return f\"Processed {len(self.state.users)} users\"\n\n    # Helper methods for state transformations\n    def add_user(self, user_id: str, name: str):\n        self.state.users[user_id] = UserData(name=name)\n        self.update_active_count()\n\n    def increment_login(self, user_id: str):\n        if user_id in self.state.users:\n            self.state.users[user_id].login_count += 1\n\n    def deactivate_user(self, user_id: str):\n        if user_id in self.state.users:\n            self.state.users[user_id].active = False\n            self.update_active_count()\n\n    def update_active_count(self):\n        self.state.active_user_count = sum(\n            1 for user in self.state.users.values() if user.active\n        )",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              }
            ]
          },
          {
            "type": "header",
            "title": "State Management with Crews",
            "level": 2,
            "content": "One of the most powerful patterns in CrewAI is combining flow state management with crew execution.",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": [
              {
                "type": "header",
                "title": "Passing State to Crews",
                "level": 3,
                "content": "You can use flow state to parameterize crews:\n```\nfrom crewai.flow.flow import Flow, listen, start\nfrom crewai import Agent, Crew, Process, Task\nfrom pydantic import BaseModel\n\nclass ResearchState(BaseModel):\n    topic: str = \"\"\n    depth: str = \"medium\"\n    results: str = \"\"\n\nclass ResearchFlow(Flow[ResearchState]):\n    @start()\n    def get_parameters(self):\n        # In a real app, this might come from user input\n        self.state.topic = \"Artificial Intelligence Ethics\"\n        self.state.depth = \"deep\"\n        return \"Parameters set\"\n\n    @listen(get_parameters)\n    def execute_research(self, _):\n        # Create agents\n        researcher = Agent(\n            role=\"Research Specialist\",\n            goal=f\"Research {self.state.topic} in {self.state.depth} detail\",\n            backstory=\"You are an expert researcher with a talent for finding accurate information.\"\n        )\n\n        writer = Agent(\n            role=\"Content Writer\",\n            goal=\"Transform research into clear, engaging content\",\n            backstory=\"You excel at communicating complex ideas clearly and concisely.\"\n        )\n\n        # Create tasks\n        research_task = Task(\n            description=f\"Research {self.state.topic} with {self.state.depth} analysis\",\n            expected_output=\"Comprehensive research notes in markdown format\",\n            agent=researcher\n        )\n\n        writing_task = Task(\n            description=f\"Create a summary on {self.state.topic} based on the research\",\n            expected_output=\"Well-written article in markdown format\",\n            agent=writer,\n            context=[research_task]\n        )\n\n        # Create and run crew\n        research_crew = Crew(\n            agents=[researcher, writer],\n            tasks=[research_task, writing_task],\n            process=Process.sequential,\n            verbose=True\n        )\n\n        # Run crew and store result in state\n        result = research_crew.kickoff()\n        self.state.results = result.raw\n\n        return \"Research completed\"\n\n    @listen(execute_research)\n    def summarize_results(self, _):\n        # Access the stored results\n        result_length = len(self.state.results)\n        return f\"Research on {self.state.topic} completed with {result_length} characters of results.\"\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "from crewai.flow.flow import Flow, listen, start\nfrom crewai import Agent, Crew, Process, Task\nfrom pydantic import BaseModel\n\nclass ResearchState(BaseModel):\n    topic: str = \"\"\n    depth: str = \"medium\"\n    results: str = \"\"\n\nclass ResearchFlow(Flow[ResearchState]):\n    @start()\n    def get_parameters(self):\n        # In a real app, this might come from user input\n        self.state.topic = \"Artificial Intelligence Ethics\"\n        self.state.depth = \"deep\"\n        return \"Parameters set\"\n\n    @listen(get_parameters)\n    def execute_research(self, _):\n        # Create agents\n        researcher = Agent(\n            role=\"Research Specialist\",\n            goal=f\"Research {self.state.topic} in {self.state.depth} detail\",\n            backstory=\"You are an expert researcher with a talent for finding accurate information.\"\n        )\n\n        writer = Agent(\n            role=\"Content Writer\",\n            goal=\"Transform research into clear, engaging content\",\n            backstory=\"You excel at communicating complex ideas clearly and concisely.\"\n        )\n\n        # Create tasks\n        research_task = Task(\n            description=f\"Research {self.state.topic} with {self.state.depth} analysis\",\n            expected_output=\"Comprehensive research notes in markdown format\",\n            agent=researcher\n        )\n\n        writing_task = Task(\n            description=f\"Create a summary on {self.state.topic} based on the research\",\n            expected_output=\"Well-written article in markdown format\",\n            agent=writer,\n            context=[research_task]\n        )\n\n        # Create and run crew\n        research_crew = Crew(\n            agents=[researcher, writer],\n            tasks=[research_task, writing_task],\n            process=Process.sequential,\n            verbose=True\n        )\n\n        # Run crew and store result in state\n        result = research_crew.kickoff()\n        self.state.results = result.raw\n\n        return \"Research completed\"\n\n    @listen(execute_research)\n    def summarize_results(self, _):\n        # Access the stored results\n        result_length = len(self.state.results)\n        return f\"Research on {self.state.topic} completed with {result_length} characters of results.\"",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Handling Crew Outputs in State",
                "level": 3,
                "content": "When a crew completes, you can process its output and store it in your flow state:\n```\n@listen(execute_crew)\ndef process_crew_results(self, _):\n    # Parse the raw results (assuming JSON output)\n    import json\n    try:\n        results_dict = json.loads(self.state.raw_results)\n        self.state.processed_results = {\n            \"title\": results_dict.get(\"title\", \"\"),\n            \"main_points\": results_dict.get(\"main_points\", []),\n            \"conclusion\": results_dict.get(\"conclusion\", \"\")\n        }\n        return \"Results processed successfully\"\n    except json.JSONDecodeError:\n        self.state.error = \"Failed to parse crew results as JSON\"\n        return \"Error processing results\"\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "@listen(execute_crew)\ndef process_crew_results(self, _):\n    # Parse the raw results (assuming JSON output)\n    import json\n    try:\n        results_dict = json.loads(self.state.raw_results)\n        self.state.processed_results = {\n            \"title\": results_dict.get(\"title\", \"\"),\n            \"main_points\": results_dict.get(\"main_points\", []),\n            \"conclusion\": results_dict.get(\"conclusion\", \"\")\n        }\n        return \"Results processed successfully\"\n    except json.JSONDecodeError:\n        self.state.error = \"Failed to parse crew results as JSON\"\n        return \"Error processing results\"",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              }
            ]
          },
          {
            "type": "header",
            "title": "Best Practices for State Management",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": [
              {
                "type": "header",
                "title": "1. Keep State Focused",
                "level": 3,
                "content": "Design your state to contain only what's necessary:\n```\n# Too broad\nclass BloatedState(BaseModel):\n    user_data: Dict = {}\n    system_settings: Dict = {}\n    temporary_calculations: List = []\n    debug_info: Dict = {}\n    # ...many more fields\n\n# Better: Focused state\nclass FocusedState(BaseModel):\n    user_id: str\n    preferences: Dict[str, str]\n    completion_status: Dict[str, bool]\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "# Too broad\nclass BloatedState(BaseModel):\n    user_data: Dict = {}\n    system_settings: Dict = {}\n    temporary_calculations: List = []\n    debug_info: Dict = {}\n    # ...many more fields\n\n# Better: Focused state\nclass FocusedState(BaseModel):\n    user_id: str\n    preferences: Dict[str, str]\n    completion_status: Dict[str, bool]",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "2. Use Structured State for Complex Flows",
                "level": 3,
                "content": "As your flows grow in complexity, structured state becomes increasingly valuable:\n```\n# Simple flow can use unstructured state\nclass SimpleGreetingFlow(Flow):\n    @start()\n    def greet(self):\n        self.state[\"name\"] = \"World\"\n        return f\"Hello, {self.state['name']}!\"\n\n# Complex flow benefits from structured state\nclass UserRegistrationState(BaseModel):\n    username: str\n    email: str\n    verification_status: bool = False\n    registration_date: datetime = Field(default_factory=datetime.now)\n    last_login: Optional[datetime] = None\n\nclass RegistrationFlow(Flow[UserRegistrationState]):\n    # Methods with strongly-typed state access\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "# Simple flow can use unstructured state\nclass SimpleGreetingFlow(Flow):\n    @start()\n    def greet(self):\n        self.state[\"name\"] = \"World\"\n        return f\"Hello, {self.state['name']}!\"\n\n# Complex flow benefits from structured state\nclass UserRegistrationState(BaseModel):\n    username: str\n    email: str\n    verification_status: bool = False\n    registration_date: datetime = Field(default_factory=datetime.now)\n    last_login: Optional[datetime] = None\n\nclass RegistrationFlow(Flow[UserRegistrationState]):\n    # Methods with strongly-typed state access",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "3. Document State Transitions",
                "level": 3,
                "content": "For complex flows, document how state changes throughout the execution:\n```\n@start()\ndef initialize_order(self):\n    \"\"\"\n    Initialize order state with empty values.\n\n    State before: {}\n    State after: {order_id: str, items: [], status: 'new'}\n    \"\"\"\n    self.state.order_id = str(uuid.uuid4())\n    self.state.items = []\n    self.state.status = \"new\"\n    return \"Order initialized\"\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "@start()\ndef initialize_order(self):\n    \"\"\"\n    Initialize order state with empty values.\n\n    State before: {}\n    State after: {order_id: str, items: [], status: 'new'}\n    \"\"\"\n    self.state.order_id = str(uuid.uuid4())\n    self.state.items = []\n    self.state.status = \"new\"\n    return \"Order initialized\"",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "4. Handle State Errors Gracefully",
                "level": 3,
                "content": "Implement error handling for state access:\n```\n@listen(previous_step)\ndef process_data(self, _):\n    try:\n        # Try to access a value that might not exist\n        user_preference = self.state.preferences.get(\"theme\", \"default\")\n    except (AttributeError, KeyError):\n        # Handle the error gracefully\n        self.state.errors = self.state.get(\"errors\", [])\n        self.state.errors.append(\"Failed to access preferences\")\n        user_preference = \"default\"\n\n    return f\"Used preference: {user_preference}\"\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "@listen(previous_step)\ndef process_data(self, _):\n    try:\n        # Try to access a value that might not exist\n        user_preference = self.state.preferences.get(\"theme\", \"default\")\n    except (AttributeError, KeyError):\n        # Handle the error gracefully\n        self.state.errors = self.state.get(\"errors\", [])\n        self.state.errors.append(\"Failed to access preferences\")\n        user_preference = \"default\"\n\n    return f\"Used preference: {user_preference}\"",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "5. Use State for Progress Tracking",
                "level": 3,
                "content": "Leverage state to track progress in long-running flows:\n```\nclass ProgressTrackingFlow(Flow):\n    @start()\n    def initialize(self):\n        self.state[\"total_steps\"] = 3\n        self.state[\"current_step\"] = 0\n        self.state[\"progress\"] = 0.0\n        self.update_progress()\n        return \"Initialized\"\n\n    def update_progress(self):\n        \"\"\"Helper method to calculate and update progress\"\"\"\n        if self.state.get(\"total_steps\", 0) > 0:\n            self.state[\"progress\"] = (self.state.get(\"current_step\", 0) /\n                                    self.state[\"total_steps\"]) * 100\n            print(f\"Progress: {self.state['progress']:.1f}%\")\n\n    @listen(initialize)\n    def step_one(self, _):\n        # Do work...\n        self.state[\"current_step\"] = 1\n        self.update_progress()\n        return \"Step 1 complete\"\n\n    # Additional steps...\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "class ProgressTrackingFlow(Flow):\n    @start()\n    def initialize(self):\n        self.state[\"total_steps\"] = 3\n        self.state[\"current_step\"] = 0\n        self.state[\"progress\"] = 0.0\n        self.update_progress()\n        return \"Initialized\"\n\n    def update_progress(self):\n        \"\"\"Helper method to calculate and update progress\"\"\"\n        if self.state.get(\"total_steps\", 0) > 0:\n            self.state[\"progress\"] = (self.state.get(\"current_step\", 0) /\n                                    self.state[\"total_steps\"]) * 100\n            print(f\"Progress: {self.state['progress']:.1f}%\")\n\n    @listen(initialize)\n    def step_one(self, _):\n        # Do work...\n        self.state[\"current_step\"] = 1\n        self.update_progress()\n        return \"Step 1 complete\"\n\n    # Additional steps...",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "6. Use Immutable Operations When Possible",
                "level": 3,
                "content": "Especially with structured state, prefer immutable operations for clarity:\n```\n# Instead of modifying lists in place:\nself.state.items.append(new_item)  # Mutable operation\n\n# Consider creating new state:\nfrom pydantic import BaseModel\nfrom typing import List\n\nclass ItemState(BaseModel):\n    items: List[str] = []\n\nclass ImmutableFlow(Flow[ItemState]):\n    @start()\n    def add_item(self):\n        # Create new list with the added item\n        self.state.items = [*self.state.items, \"new item\"]\n        return \"Item added\"\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "# Instead of modifying lists in place:\nself.state.items.append(new_item)  # Mutable operation\n\n# Consider creating new state:\nfrom pydantic import BaseModel\nfrom typing import List\n\nclass ItemState(BaseModel):\n    items: List[str] = []\n\nclass ImmutableFlow(Flow[ItemState]):\n    @start()\n    def add_item(self):\n        # Create new list with the added item\n        self.state.items = [*self.state.items, \"new item\"]\n        return \"Item added\"",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              }
            ]
          },
          {
            "type": "header",
            "title": "Debugging Flow State",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": [
              {
                "type": "header",
                "title": "Logging State Changes",
                "level": 3,
                "content": "When developing, add logging to track state changes:\n```\nimport logging\nlogging.basicConfig(level=logging.INFO)\n\nclass LoggingFlow(Flow):\n    def log_state(self, step_name):\n        logging.info(f\"State after {step_name}: {self.state}\")\n\n    @start()\n    def initialize(self):\n        self.state[\"counter\"] = 0\n        self.log_state(\"initialize\")\n        return \"Initialized\"\n\n    @listen(initialize)\n    def increment(self, _):\n        self.state[\"counter\"] += 1\n        self.log_state(\"increment\")\n        return f\"Incremented to {self.state['counter']}\"\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "import logging\nlogging.basicConfig(level=logging.INFO)\n\nclass LoggingFlow(Flow):\n    def log_state(self, step_name):\n        logging.info(f\"State after {step_name}: {self.state}\")\n\n    @start()\n    def initialize(self):\n        self.state[\"counter\"] = 0\n        self.log_state(\"initialize\")\n        return \"Initialized\"\n\n    @listen(initialize)\n    def increment(self, _):\n        self.state[\"counter\"] += 1\n        self.log_state(\"increment\")\n        return f\"Incremented to {self.state['counter']}\"",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "State Visualization",
                "level": 3,
                "content": "You can add methods to visualize your state for debugging:\n```\ndef visualize_state(self):\n    \"\"\"Create a simple visualization of the current state\"\"\"\n    import json\n    from rich.console import Console\n    from rich.panel import Panel\n\n    console = Console()\n\n    if hasattr(self.state, \"model_dump\"):\n        # Pydantic v2\n        state_dict = self.state.model_dump()\n    elif hasattr(self.state, \"dict\"):\n        # Pydantic v1\n        state_dict = self.state.dict()\n    else:\n        # Unstructured state\n        state_dict = dict(self.state)\n\n    # Remove id for cleaner output\n    if \"id\" in state_dict:\n        state_dict.pop(\"id\")\n\n    state_json = json.dumps(state_dict, indent=2, default=str)\n    console.print(Panel(state_json, title=\"Current Flow State\"))\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "def visualize_state(self):\n    \"\"\"Create a simple visualization of the current state\"\"\"\n    import json\n    from rich.console import Console\n    from rich.panel import Panel\n\n    console = Console()\n\n    if hasattr(self.state, \"model_dump\"):\n        # Pydantic v2\n        state_dict = self.state.model_dump()\n    elif hasattr(self.state, \"dict\"):\n        # Pydantic v1\n        state_dict = self.state.dict()\n    else:\n        # Unstructured state\n        state_dict = dict(self.state)\n\n    # Remove id for cleaner output\n    if \"id\" in state_dict:\n        state_dict.pop(\"id\")\n\n    state_json = json.dumps(state_dict, indent=2, default=str)\n    console.print(Panel(state_json, title=\"Current Flow State\"))",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              }
            ]
          },
          {
            "type": "header",
            "title": "Conclusion",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Next Steps",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "AgentOps Integration",
        "level": 1,
        "content": "Source: https://docs.crewai.com/how-to/agentops-observability Understanding and logging your agent performance with AgentOps.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "Introduction",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "AgentOps",
            "level": 2,
            "content": "[AgentOps](https://agentops.ai/?=crew) provides session replays, metrics, and monitoring for agents. At a high level, AgentOps gives you the ability to monitor cost, token usage, latency, agent failures, session-wide statistics, and more.\nFor more info, check out the [AgentOps Repo](https://github.com/AgentOps-AI/agentops).",
            "metadata": {
              "section_type": "General",
              "content_type": "link_list"
            },
            "children": [
              {
                "type": "header",
                "title": "Overview",
                "level": 3,
                "content": "Fingerprints in CrewAI provide a way to uniquely identify and track components throughout their lifecycle. Each `Agent`, `Crew`, and `Task` automatically receives a unique fingerprint when created, which cannot be manually overridden. These fingerprints can be used for: Auditing and tracking component usage Ensuring component identity integrity Attaching metadata to components Creating a traceable chain of operations\n\nAgentOps provides monitoring for agents in development and production.\nIt provides a dashboard for tracking agent performance, session replays, and custom reporting. Additionally, AgentOps provides session drilldowns for viewing Crew agent interactions, LLM calls, and tool usage in real-time.\nThis feature is useful for debugging and understanding how agents interact with users as well as other agents. ![Overview of a select series of agent session runs](https://mintlify.s3.us-west-1.amazonaws.com/crewai/images/agentops-overview.png)\n![Overview of session drilldowns for examining agent runs](https://mintlify.s3.us-west-1.amazonaws.com/crewai/images/agentops-session.png)\n![Viewing a step-by-step agent replay execution graph](https://mintlify.s3.us-west-1.amazonaws.com/crewai/images/agentops-replay.png)",
                "metadata": {
                  "section_type": "Concepts documentation",
                  "content_type": "link_list"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Features",
                "level": 3,
                "content": "",
                "metadata": {
                  "section_type": "General",
                  "content_type": null
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Using AgentOps",
                "level": 3,
                "content": "",
                "metadata": {
                  "section_type": "General",
                  "content_type": null
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Crew + AgentOps Examples",
                "level": 3,
                "content": "",
                "metadata": {
                  "section_type": "Examples",
                  "content_type": null
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Further Information",
                "level": 3,
                "content": "To get started, create an [AgentOps account](https://agentops.ai/?=crew). For feature requests or bug reports, please reach out to the AgentOps team on the [AgentOps Repo](https://github.com/AgentOps-AI/agentops).",
                "metadata": {
                  "section_type": "General",
                  "content_type": "link_list"
                },
                "children": [
                  {
                    "type": "header",
                    "title": "Extra links",
                    "level": 4,
                    "content": "<a href=\"https://twitter.com/agentopsai/\">\ud83d\udc26 Twitter</a>\n<span>\u00a0\u00a0\u2022\u00a0\u00a0</span>\n<a href=\"https://discord.gg/JHPt4C7r\">\ud83d\udce2 Discord</a>\n<span>\u00a0\u00a0\u2022\u00a0\u00a0</span>\n<a href=\"https://app.agentops.ai/?=crew\">\ud83d\udd87\ufe0f AgentOps Dashboard</a>\n<span>\u00a0\u00a0\u2022\u00a0\u00a0</span>\n<a href=\"https://docs.agentops.ai/introduction\">\ud83d\udcd9 Documentation</a>",
                    "metadata": {
                      "section_type": "General",
                      "content_type": "short_description"
                    },
                    "children": []
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type": "header",
        "title": "Coding Agents",
        "level": 1,
        "content": "Source: https://docs.crewai.com/how-to/coding-agents Learn how to enable your CrewAI Agents to write and execute code, and explore advanced features for enhanced functionality.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": [
          {
            "type": "header",
            "title": "Introduction",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Enabling Code Execution",
            "level": 2,
            "content": "To enable code execution for an agent, set the `allow_code_execution` parameter to `True` when creating the agent. Here's an example:\n```\nfrom crewai import Agent\n\ncoding_agent = Agent(\n    role=\"Senior Python Developer\",\n    goal=\"Craft well-designed and thought-out code\",\n    backstory=\"You are a senior Python developer with extensive experience in software architecture and best practices.\",\n    allow_code_execution=True\n)\n```",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai import Agent\n\ncoding_agent = Agent(\n    role=\"Senior Python Developer\",\n    goal=\"Craft well-designed and thought-out code\",\n    backstory=\"You are a senior Python developer with extensive experience in software architecture and best practices.\",\n    allow_code_execution=True\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Important Considerations",
            "level": 2,
            "content": "**State Types**: Both structured (Pydantic BaseModel) and unstructured (dictionary) states are supported **Automatic ID**: The `id` field is automatically added if not present **State Recovery**: Failed or restarted flows can automatically reload their previous state **Custom Implementation**: You can provide your own FlowPersistence implementation for specialized storage needs\n\n**Model Selection**: It is strongly recommended to use more capable models like Claude 3.5 Sonnet and GPT-4 when enabling code execution.\nThese models have a better understanding of programming concepts and are more likely to generate correct and efficient code. **Error Handling**: The code execution feature includes error handling. If executed code raises an exception, the agent will receive the error message and can attempt to correct the code or\nprovide alternative solutions. The `max_retry_limit` parameter, which defaults to 2, controls the maximum number of retries for a task. **Dependencies**: To use the code execution feature, you need to install the `crewai_tools` package. If not installed, the agent will log an info message:\n\"Coding tools not available. Install crewai\\_tools.\"",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Code Execution Process",
            "level": 2,
            "content": "When an agent with code execution enabled encounters a task requiring programming:",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example Usage",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Conditional Tasks",
        "level": 1,
        "content": "Source: https://docs.crewai.com/how-to/conditional-tasks Learn how to use conditional tasks in a crewAI kickoff",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": [
          {
            "type": "header",
            "title": "Introduction",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example Usage",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Create Custom Tools",
        "level": 1,
        "content": "Source: https://docs.crewai.com/how-to/create-custom-tools Comprehensive guide on crafting, using, and managing custom tools within the CrewAI framework, including new functionalities and error handling.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": [
          {
            "type": "header",
            "title": "Creating and Utilizing Tools in CrewAI",
            "level": 2,
            "content": "This guide provides detailed instructions on creating custom tools for the CrewAI framework and how to efficiently manage and utilize these tools,\nincorporating the latest functionalities such as tool delegation, error handling, and dynamic tool calling. It also highlights the importance of collaboration tools,\nenabling agents to perform a wide range of actions.",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": [
              {
                "type": "header",
                "title": "Subclassing `BaseTool`",
                "level": 3,
                "content": "```\nfrom crewai.tools import BaseTool\nfrom pydantic import BaseModel, Field\n\nclass MyToolInput(BaseModel):\n    \"\"\"Input schema for MyCustomTool.\"\"\"\n    argument: str = Field(..., description=\"Description of the argument.\")\n\nclass MyCustomTool(BaseTool):\n    name: str = \"Name of my tool\"\n    description: str = \"What this tool does. It's vital for effective utilization.\"\n    args_schema: Type[BaseModel] = MyToolInput\n\n    def _run(self, argument: str) -> str:\n        # Your tool's logic here\n        return \"Tool's result\"\n```\n\nTo create a personalized tool, inherit from `BaseTool` and define the necessary attributes, including the `args_schema` for input validation, and the `_run` method.\n```\nfrom typing import Type\nfrom crewai.tools import BaseTool\nfrom pydantic import BaseModel, Field\n\nclass MyToolInput(BaseModel):\n    \"\"\"Input schema for MyCustomTool.\"\"\"\n    argument: str = Field(..., description=\"Description of the argument.\")\n\nclass MyCustomTool(BaseTool):\n    name: str = \"Name of my tool\"\n    description: str = \"What this tool does. It's vital for effective utilization.\"\n    args_schema: Type[BaseModel] = MyToolInput\n\n    def _run(self, argument: str) -> str:\n        # Your tool's logic here\n        return \"Tool's result\"\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "from crewai.tools import BaseTool\nfrom pydantic import BaseModel, Field\n\nclass MyToolInput(BaseModel):\n    \"\"\"Input schema for MyCustomTool.\"\"\"\n    argument: str = Field(..., description=\"Description of the argument.\")\n\nclass MyCustomTool(BaseTool):\n    name: str = \"Name of my tool\"\n    description: str = \"What this tool does. It's vital for effective utilization.\"\n    args_schema: Type[BaseModel] = MyToolInput\n\n    def _run(self, argument: str) -> str:\n        # Your tool's logic here\n        return \"Tool's result\"",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  },
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "from typing import Type\nfrom crewai.tools import BaseTool\nfrom pydantic import BaseModel, Field\n\nclass MyToolInput(BaseModel):\n    \"\"\"Input schema for MyCustomTool.\"\"\"\n    argument: str = Field(..., description=\"Description of the argument.\")\n\nclass MyCustomTool(BaseTool):\n    name: str = \"Name of my tool\"\n    description: str = \"What this tool does. It's vital for effective utilization.\"\n    args_schema: Type[BaseModel] = MyToolInput\n\n    def _run(self, argument: str) -> str:\n        # Your tool's logic here\n        return \"Tool's result\"",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Using the `tool` Decorator",
                "level": 3,
                "content": "Alternatively, you can use the tool decorator `@tool`. This approach allows you to define the tool's attributes and functionality directly within a function,\noffering a concise and efficient way to create specialized tools tailored to your needs.\n```\nfrom crewai.tools import tool\n\n@tool(\"Tool Name\")\ndef my_simple_tool(question: str) -> str:\n    \"\"\"Tool description for clarity.\"\"\"\n    # Tool logic here\n    return \"Tool output\"\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "from crewai.tools import tool\n\n@tool(\"Tool Name\")\ndef my_simple_tool(question: str) -> str:\n    \"\"\"Tool description for clarity.\"\"\"\n    # Tool logic here\n    return \"Tool output\"",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Defining a Cache Function for the Tool",
                "level": 3,
                "content": "To optimize tool performance with caching, define custom caching strategies using the `cache_function` attribute.\n```\n@tool(\"Tool with Caching\")\ndef cached_tool(argument: str) -> str:\n    \"\"\"Tool functionality description.\"\"\"\n    return \"Cacheable result\"\n\ndef my_cache_strategy(arguments: dict, result: str) -> bool:\n    # Define custom caching logic\n    return True if some_condition else False\n\ncached_tool.cache_function = my_cache_strategy\n```\nBy adhering to these guidelines and incorporating new functionalities and collaboration tools into your tool creation and management processes,\nyou can leverage the full capabilities of the CrewAI framework, enhancing both the development experience and the efficiency of your AI agents.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "@tool(\"Tool with Caching\")\ndef cached_tool(argument: str) -> str:\n    \"\"\"Tool functionality description.\"\"\"\n    return \"Cacheable result\"\n\ndef my_cache_strategy(arguments: dict, result: str) -> bool:\n    # Define custom caching logic\n    return True if some_condition else False\n\ncached_tool.cache_function = my_cache_strategy",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type": "header",
        "title": "Create Your Own Manager Agent",
        "level": 1,
        "content": "Source: https://docs.crewai.com/how-to/custom-manager-agent Learn how to set a custom agent as the manager in CrewAI, providing more control over task management and coordination.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "Setting a Specific Agent as Manager in CrewAI",
        "level": 1,
        "content": "CrewAI allows users to set a specific agent as the manager of the crew, providing more control over the management and coordination of tasks.\nThis feature enables the customization of the managerial role to better fit your project's requirements.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": [
          {
            "type": "header",
            "title": "Using the `manager_agent` Attribute",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": [
              {
                "type": "header",
                "title": "Custom Manager Agent",
                "level": 3,
                "content": "The `manager_agent` attribute allows you to define a custom agent to manage the crew. This agent will oversee the entire process, ensuring that tasks are completed efficiently and to the highest standard.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Example",
                "level": 3,
                "content": "",
                "metadata": {
                  "section_type": "Examples",
                  "content_type": null
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Benefits of a Custom Manager Agent",
            "level": 2,
            "content": "**Enhanced Control**: Tailor the management approach to fit the specific needs of your project. **Improved Coordination**: Ensure efficient task coordination and management by an experienced agent. **Customizable Management**: Define managerial roles and responsibilities that align with your project's goals.",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Setting a Manager LLM",
            "level": 2,
            "content": "If you're using the hierarchical process and don't want to set a custom manager agent, you can specify the language model for the manager:\n```\nfrom crewai import LLM\n\nmanager_llm = LLM(model=\"gpt-4o\")\n\ncrew = Crew(\n    agents=[researcher, writer],\n    tasks=[task],\n    process=Process.hierarchical,\n    manager_llm=manager_llm\n)\n```",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai import LLM\n\nmanager_llm = LLM(model=\"gpt-4o\")\n\ncrew = Crew(\n    agents=[researcher, writer],\n    tasks=[task],\n    process=Process.hierarchical,\n    manager_llm=manager_llm\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          }
        ]
      },
      {
        "type": "header",
        "title": "Customize Agents",
        "level": 1,
        "content": "Source: https://docs.crewai.com/how-to/customizing-agents A comprehensive guide to tailoring agents for specific roles, tasks, and advanced customizations within the CrewAI framework.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": [
          {
            "type": "header",
            "title": "Customizable Attributes",
            "level": 2,
            "content": "Crafting an efficient CrewAI team hinges on the ability to dynamically tailor your AI agents to meet the unique requirements of any project. This section covers the foundational attributes you can customize.",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": [
              {
                "type": "header",
                "title": "Key Attributes for Customization",
                "level": 3,
                "content": "| Attribute                           | Description                                                                                                         |\n| :---------------------------------- | :------------------------------------------------------------------------------------------------------------------ |\n| **Role**                            | Specifies the agent's job within the crew, such as 'Analyst' or 'Customer Service Rep'.                             |\n| **Goal**                            | Defines the agent\u2019s objectives, aligned with its role and the crew\u2019s overarching mission.                           |\n| **Backstory**                       | Provides depth to the agent's persona, enhancing motivations and engagements within the crew.                       |\n| **Tools** *(Optional)*              | Represents the capabilities or methods the agent uses for tasks, from simple functions to complex integrations.     |\n| **Cache** *(Optional)*              | Determines if the agent should use a cache for tool usage.                                                          |\n| **Max RPM**                         | Sets the maximum requests per minute (`max_rpm`). Can be set to `None` for unlimited requests to external services. |\n| **Verbose** *(Optional)*            | Enables detailed logging for debugging and optimization, providing insights into execution processes.               |\n| **Allow Delegation** *(Optional)*   | Controls task delegation to other agents, default is `False`.                                                       |\n| **Max Iter** *(Optional)*           | Limits the maximum number of iterations (`max_iter`) for a task to prevent infinite loops, with a default of 25.    |\n| **Max Execution Time** *(Optional)* | Sets the maximum time allowed for an agent to complete a task.                                                      |\n| **System Template** *(Optional)*    | Defines the system format for the agent.                                                                            |\n| **Prompt Template** *(Optional)*    | Defines the prompt format for the agent.                                                                            |\n| **Response Template** *(Optional)*  | Defines the response format for the agent.                                                                          |\n| **Use System Prompt** *(Optional)*  | Controls whether the agent will use a system prompt during task execution.                                          |\n| **Respect Context Window**          | Enables a sliding context window by default, maintaining context size.                                              |\n| **Max Retry Limit**                 | Sets the maximum number of retries (`max_retry_limit`) for an agent in case of errors.                              |",
                "metadata": {
                  "section_type": "General",
                  "content_type": "descriptive_text"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Advanced Customization Options",
            "level": 2,
            "content": "Beyond the basic attributes, CrewAI allows for deeper customization to enhance an agent's behavior and capabilities significantly.",
            "metadata": {
              "section_type": "Internals/Advanced",
              "content_type": "short_description"
            },
            "children": [
              {
                "type": "header",
                "title": "Language Model Customization",
                "level": 3,
                "content": "Agents can be customized with specific language models (`llm`) and function-calling language models (`function_calling_llm`), offering advanced control over their processing and decision-making abilities.\nIt's important to note that setting the `function_calling_llm` allows for overriding the default crew function-calling language model, providing a greater degree of customization.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Performance and Debugging Settings",
            "level": 2,
            "content": "Adjusting an agent's performance and monitoring its operations are crucial for efficient task execution.",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": [
              {
                "type": "header",
                "title": "Verbose Mode and RPM Limit",
                "level": 3,
                "content": "**Verbose Mode**: Enables detailed logging of an agent's actions, useful for debugging and optimization. Specifically, it provides insights into agent execution processes, aiding in the optimization of performance. **RPM Limit**: Sets the maximum number of requests per minute (`max_rpm`). This attribute is optional and can be set to `None` for no limit, allowing for unlimited queries to external services if needed.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "descriptive_text"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Maximum Iterations for Task Execution",
                "level": 3,
                "content": "The `max_iter` attribute allows users to define the maximum number of iterations an agent can perform for a single task, preventing infinite loops or excessively long executions.\nThe default value is set to 25, providing a balance between thoroughness and efficiency. Once the agent approaches this number, it will try its best to give a good answer.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "descriptive_text"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Customizing Agents and Tools",
            "level": 2,
            "content": "Agents are customized by defining their attributes and tools during initialization. Tools are critical for an agent's functionality, enabling them to perform specialized tasks.\nThe `tools` attribute should be an array of tools the agent can utilize, and it's initialized as an empty list by default. Tools can be added or modified post-agent initialization to adapt to new requirements.\n```\npip install 'crewai[tools]'\n```",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [
              {
                "type": "header",
                "title": "Example: Assigning Tools to an Agent",
                "level": 3,
                "content": "```\nimport os\nfrom crewai import Agent\nfrom crewai_tools import SerperDevTool\n\n# Set API keys for tool initialization\nos.environ[\"OPENAI_API_KEY\"] = \"Your Key\"\nos.environ[\"SERPER_API_KEY\"] = \"Your Key\"\n\n# Initialize a search tool\nsearch_tool = SerperDevTool()\n\n# Initialize the agent with advanced options\nagent = Agent(\n  role='Research Analyst',\n  goal='Provide up-to-date market analysis',\n  backstory='An expert analyst with a keen eye for market trends.',\n  tools=[search_tool],\n  memory=True, # Enable memory\n  verbose=True,\n  max_rpm=None, # No limit on requests per minute\n  max_iter=25, # Default value for maximum iterations\n)\n```",
                "metadata": {
                  "section_type": "Examples",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "import os\nfrom crewai import Agent\nfrom crewai_tools import SerperDevTool\n\n# Set API keys for tool initialization\nos.environ[\"OPENAI_API_KEY\"] = \"Your Key\"\nos.environ[\"SERPER_API_KEY\"] = \"Your Key\"\n\n# Initialize a search tool\nsearch_tool = SerperDevTool()\n\n# Initialize the agent with advanced options\nagent = Agent(\n  role='Research Analyst',\n  goal='Provide up-to-date market analysis',\n  backstory='An expert analyst with a keen eye for market trends.',\n  tools=[search_tool],\n  memory=True, # Enable memory\n  verbose=True,\n  max_rpm=None, # No limit on requests per minute\n  max_iter=25, # Default value for maximum iterations\n)",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              }
            ],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "shell",
                "content": "pip install 'crewai[tools]'",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Delegation and Autonomy",
            "level": 2,
            "content": "Controlling an agent's ability to delegate tasks or ask questions is vital for tailoring its autonomy and collaborative dynamics within the CrewAI framework. By default,\nthe `allow_delegation` attribute is now set to `False`, disabling agents to seek assistance or delegate tasks as needed. This default behavior can be changed to promote collaborative problem-solving and\nefficiency within the CrewAI ecosystem. If needed, delegation can be enabled to suit specific operational requirements.",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": [
              {
                "type": "header",
                "title": "Example: Disabling Delegation for an Agent",
                "level": 3,
                "content": "```\nagent = Agent(\n  role='Content Writer',\n  goal='Write engaging content on market trends',\n  backstory='A seasoned writer with expertise in market analysis.',\n  allow_delegation=True # Enabling delegation\n)\n```",
                "metadata": {
                  "section_type": "Examples",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "agent = Agent(\n  role='Content Writer',\n  goal='Write engaging content on market trends',\n  backstory='A seasoned writer with expertise in market analysis.',\n  allow_delegation=True # Enabling delegation\n)",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              }
            ]
          },
          {
            "type": "header",
            "title": "Conclusion",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Force Tool Output as Result",
        "level": 1,
        "content": "Source: https://docs.crewai.com/how-to/force-tool-output-as-result Learn how to force tool output as the result in an Agent's task in CrewAI.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": [
          {
            "type": "header",
            "title": "Introduction",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Forcing Tool Output as Result",
            "level": 2,
            "content": "To force the tool output as the result of an agent's task, you need to set the `result_as_answer` parameter to `True` when adding a tool to the agent.\nThis parameter ensures that the tool output is captured and returned as the task result, without any modifications by the agent. Here's an example of how to force the tool output as the result of an agent's task:\n```\nfrom crewai.agent import Agent\nfrom my_tool import MyCustomTool\n\n# Create a coding agent with the custom tool\ncoding_agent = Agent(\n        role=\"Data Scientist\",\n        goal=\"Produce amazing reports on AI\",\n        backstory=\"You work with data and AI\",\n        tools=[MyCustomTool(result_as_answer=True)],\n    )\n\n# Assuming the tool's execution and result population occurs within the system\ntask_result = coding_agent.execute_task(task)\n```",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai.agent import Agent\nfrom my_tool import MyCustomTool\n\n# Create a coding agent with the custom tool\ncoding_agent = Agent(\n        role=\"Data Scientist\",\n        goal=\"Produce amazing reports on AI\",\n        backstory=\"You work with data and AI\",\n        tools=[MyCustomTool(result_as_answer=True)],\n    )\n\n# Assuming the tool's execution and result population occurs within the system\ntask_result = coding_agent.execute_task(task)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Workflow in Action",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Hierarchical Process",
        "level": 1,
        "content": "Emulates a corporate hierarchy, CrewAI allows specifying a custom manager agent or automatically creates one, requiring the specification of a manager language model (`manager_llm`). This agent oversees task execution, including planning, delegation, and validation. Tasks are not pre-assigned; the manager allocates tasks to agents based on their capabilities, reviews outputs, and assesses task completion.\n\nSource: https://docs.crewai.com/how-to/hierarchical-process A comprehensive guide to understanding and applying the hierarchical process within your CrewAI projects, updated to reflect the latest coding practices and functionalities.",
        "metadata": {
          "section_type": "General",
          "content_type": "descriptive_text"
        },
        "children": [
          {
            "type": "header",
            "title": "Introduction",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Hierarchical Process Overview",
            "level": 2,
            "content": "By default, tasks in CrewAI are managed through a sequential process. However, adopting a hierarchical approach allows for a clear hierarchy in task management,\nwhere a 'manager' agent coordinates the workflow, delegates tasks, and validates outcomes for streamlined and effective execution. This manager agent can now be either\nautomatically created by CrewAI or explicitly set by the user.",
            "metadata": {
              "section_type": "Concepts documentation",
              "content_type": "descriptive_text"
            },
            "children": [
              {
                "type": "header",
                "title": "Key Features",
                "level": 3,
                "content": "",
                "metadata": {
                  "section_type": "General",
                  "content_type": null
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Implementing the Hierarchical Process",
            "level": 2,
            "content": "To utilize the hierarchical process, it's essential to explicitly set the process attribute to `Process.hierarchical`, as the default behavior is `Process.sequential`.\nDefine a crew with a designated manager and establish a clear chain of command.\n```\nfrom crewai import Crew, Process, Agent\n\n# Agents are defined with attributes for backstory, cache, and verbose mode\nresearcher = Agent(\n    role='Researcher',\n    goal='Conduct in-depth analysis',\n    backstory='Experienced data analyst with a knack for uncovering hidden trends.',\n)\nwriter = Agent(\n    role='Writer',\n    goal='Create engaging content',\n    backstory='Creative writer passionate about storytelling in technical domains.',\n)\n\n# Establishing the crew with a hierarchical process and additional configurations\nproject_crew = Crew(\n    tasks=[...],  # Tasks to be delegated and executed under the manager's supervision\n    agents=[researcher, writer],\n    manager_llm=\"gpt-4o\",  # Specify which LLM the manager should use\n    process=Process.hierarchical,  \n    planning=True, \n)\n```",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [
              {
                "type": "header",
                "title": "Using a Custom Manager Agent",
                "level": 3,
                "content": "Alternatively, you can create a custom manager agent with specific attributes tailored to your project's management needs. This gives you more control over the manager's behavior and capabilities.\n```\n# Define a custom manager agent\nmanager = Agent(\n    role=\"Project Manager\",\n    goal=\"Efficiently manage the crew and ensure high-quality task completion\",\n    backstory=\"You're an experienced project manager, skilled in overseeing complex projects and guiding teams to success.\",\n    allow_delegation=True,\n)\n\n# Use the custom manager in your crew\nproject_crew = Crew(\n    tasks=[...],\n    agents=[researcher, writer],\n    manager_agent=manager,  # Use your custom manager agent\n    process=Process.hierarchical,\n    planning=True,\n)\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "# Define a custom manager agent\nmanager = Agent(\n    role=\"Project Manager\",\n    goal=\"Efficiently manage the crew and ensure high-quality task completion\",\n    backstory=\"You're an experienced project manager, skilled in overseeing complex projects and guiding teams to success.\",\n    allow_delegation=True,\n)\n\n# Use the custom manager in your crew\nproject_crew = Crew(\n    tasks=[...],\n    agents=[researcher, writer],\n    manager_agent=manager,  # Use your custom manager agent\n    process=Process.hierarchical,\n    planning=True,\n)",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Workflow in Action",
                "level": 3,
                "content": "",
                "metadata": {
                  "section_type": "General",
                  "content_type": null
                },
                "children": []
              }
            ],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai import Crew, Process, Agent\n\n# Agents are defined with attributes for backstory, cache, and verbose mode\nresearcher = Agent(\n    role='Researcher',\n    goal='Conduct in-depth analysis',\n    backstory='Experienced data analyst with a knack for uncovering hidden trends.',\n)\nwriter = Agent(\n    role='Writer',\n    goal='Create engaging content',\n    backstory='Creative writer passionate about storytelling in technical domains.',\n)\n\n# Establishing the crew with a hierarchical process and additional configurations\nproject_crew = Crew(\n    tasks=[...],  # Tasks to be delegated and executed under the manager's supervision\n    agents=[researcher, writer],\n    manager_llm=\"gpt-4o\",  # Specify which LLM the manager should use\n    process=Process.hierarchical,  \n    planning=True, \n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Conclusion",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Human Input on Execution",
        "level": 1,
        "content": "Source: https://docs.crewai.com/how-to/human-input-on-execution Integrating CrewAI with human input during execution in complex decision-making processes and leveraging the full capabilities of the agent's attributes and tools.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": [
          {
            "type": "header",
            "title": "Human input in agent execution",
            "level": 2,
            "content": "Human input is critical in several agent execution scenarios, allowing agents to request additional information or clarification when necessary.\nThis feature is especially useful in complex decision-making processes or when agents require more details to complete a task effectively.",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Using human input with CrewAI",
            "level": 2,
            "content": "To integrate human input into agent execution, set the `human_input` flag in the task definition. When enabled, the agent prompts the user for input before delivering its final answer.\nThis input can provide extra context, clarify ambiguities, or validate the agent's output.",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": [
              {
                "type": "header",
                "title": "Example:",
                "level": 3,
                "content": "Using `StructuredTool.from_function`, you can wrap a function that interacts with an external API or system, providing a structured interface. This enables robust validation and consistent execution, making it easier to integrate complex functionalities into your applications as demonstrated in the following example:\n```\nfrom crewai.tools.structured_tool import CrewStructuredTool\nfrom pydantic import BaseModel\n\n# Define the schema for the tool's input using Pydantic\nclass APICallInput(BaseModel):\n    endpoint: str\n    parameters: dict\n\n# Wrapper function to execute the API call\ndef tool_wrapper(*args, **kwargs):\n    # Here, you would typically call the API using the parameters\n    # For demonstration, we'll return a placeholder string\n    return f\"Call the API at {kwargs['endpoint']} with parameters {kwargs['parameters']}\"\n\n# Create and return the structured tool\ndef create_structured_tool():\n    return CrewStructuredTool.from_function(\n        name='Wrapper API',\n        description=\"A tool to wrap API calls with structured input.\",\n        args_schema=APICallInput,\n        func=tool_wrapper,\n    )\n\n# Example usage\nstructured_tool = create_structured_tool()\n\n# Execute the tool with structured input\nresult = structured_tool._run(**{\n    \"endpoint\": \"https://example.com/api\",\n    \"parameters\": {\"key1\": \"value1\", \"key2\": \"value2\"}\n})\nprint(result)  # Output: Call the API at https://example.com/api with parameters {'key1': 'value1', 'key2': 'value2'}\n```\n\n```\npip install crewai\n```\n\n```\nimport os\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import SerperDevTool\n\nos.environ[\"SERPER_API_KEY\"] = \"Your Key\"  # serper.dev API key\nos.environ[\"OPENAI_API_KEY\"] = \"Your Key\"\n\n# Loading Tools\nsearch_tool = SerperDevTool()\n\n# Define your agents with roles, goals, tools, and additional attributes\nresearcher = Agent(\n    role='Senior Research Analyst',\n    goal='Uncover cutting-edge developments in AI and data science',\n    backstory=(\n        \"You are a Senior Research Analyst at a leading tech think tank. \"\n        \"Your expertise lies in identifying emerging trends and technologies in AI and data science. \"\n        \"You have a knack for dissecting complex data and presenting actionable insights.\"\n    ),\n    verbose=True,\n    allow_delegation=False,\n    tools=[search_tool]\n)\nwriter = Agent(\n    role='Tech Content Strategist',\n    goal='Craft compelling content on tech advancements',\n    backstory=(\n        \"You are a renowned Tech Content Strategist, known for your insightful and engaging articles on technology and innovation. \"\n        \"With a deep understanding of the tech industry, you transform complex concepts into compelling narratives.\"\n    ),\n    verbose=True,\n    allow_delegation=True,\n    tools=[search_tool],\n    cache=False,  # Disable cache for this agent\n)\n\n# Create tasks for your agents\ntask1 = Task(\n    description=(\n        \"Conduct a comprehensive analysis of the latest advancements in AI in 2025. \"\n        \"Identify key trends, breakthrough technologies, and potential industry impacts. \"\n        \"Compile your findings in a detailed report. \"\n        \"Make sure to check with a human if the draft is good before finalizing your answer.\"\n    ),\n    expected_output='A comprehensive full report on the latest AI advancements in 2025, leave nothing out',\n    agent=researcher,\n    human_input=True\n)\n\ntask2 = Task(\n    description=(\n        \"Using the insights from the researcher\\'s report, develop an engaging blog post that highlights the most significant AI advancements. \"\n        \"Your post should be informative yet accessible, catering to a tech-savvy audience. \"\n        \"Aim for a narrative that captures the essence of these breakthroughs and their implications for the future.\"\n    ),\n    expected_output='A compelling 3 paragraphs blog post formatted as markdown about the latest AI advancements in 2025',\n    agent=writer,\n    human_input=True\n)\n\n# Instantiate your crew with a sequential process\ncrew = Crew(\n    agents=[researcher, writer],\n    tasks=[task1, task2],\n    verbose=True,\n    memory=True,\n    planning=True  # Enable planning feature for the crew\n)\n\n# Get your crew to work!\nresult = crew.kickoff()\n\nprint(\"######################\")\nprint(result)\n```",
                "metadata": {
                  "section_type": "Examples",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "from crewai.tools.structured_tool import CrewStructuredTool\nfrom pydantic import BaseModel\n\n# Define the schema for the tool's input using Pydantic\nclass APICallInput(BaseModel):\n    endpoint: str\n    parameters: dict\n\n# Wrapper function to execute the API call\ndef tool_wrapper(*args, **kwargs):\n    # Here, you would typically call the API using the parameters\n    # For demonstration, we'll return a placeholder string\n    return f\"Call the API at {kwargs['endpoint']} with parameters {kwargs['parameters']}\"\n\n# Create and return the structured tool\ndef create_structured_tool():\n    return CrewStructuredTool.from_function(\n        name='Wrapper API',\n        description=\"A tool to wrap API calls with structured input.\",\n        args_schema=APICallInput,\n        func=tool_wrapper,\n    )\n\n# Example usage\nstructured_tool = create_structured_tool()\n\n# Execute the tool with structured input\nresult = structured_tool._run(**{\n    \"endpoint\": \"https://example.com/api\",\n    \"parameters\": {\"key1\": \"value1\", \"key2\": \"value2\"}\n})\nprint(result)  # Output: Call the API at https://example.com/api with parameters {'key1': 'value1', 'key2': 'value2'}",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  },
                  {
                    "type": "code_block",
                    "language": "shell",
                    "content": "pip install crewai",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  },
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "import os\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import SerperDevTool\n\nos.environ[\"SERPER_API_KEY\"] = \"Your Key\"  # serper.dev API key\nos.environ[\"OPENAI_API_KEY\"] = \"Your Key\"\n\n# Loading Tools\nsearch_tool = SerperDevTool()\n\n# Define your agents with roles, goals, tools, and additional attributes\nresearcher = Agent(\n    role='Senior Research Analyst',\n    goal='Uncover cutting-edge developments in AI and data science',\n    backstory=(\n        \"You are a Senior Research Analyst at a leading tech think tank. \"\n        \"Your expertise lies in identifying emerging trends and technologies in AI and data science. \"\n        \"You have a knack for dissecting complex data and presenting actionable insights.\"\n    ),\n    verbose=True,\n    allow_delegation=False,\n    tools=[search_tool]\n)\nwriter = Agent(\n    role='Tech Content Strategist',\n    goal='Craft compelling content on tech advancements',\n    backstory=(\n        \"You are a renowned Tech Content Strategist, known for your insightful and engaging articles on technology and innovation. \"\n        \"With a deep understanding of the tech industry, you transform complex concepts into compelling narratives.\"\n    ),\n    verbose=True,\n    allow_delegation=True,\n    tools=[search_tool],\n    cache=False,  # Disable cache for this agent\n)\n\n# Create tasks for your agents\ntask1 = Task(\n    description=(\n        \"Conduct a comprehensive analysis of the latest advancements in AI in 2025. \"\n        \"Identify key trends, breakthrough technologies, and potential industry impacts. \"\n        \"Compile your findings in a detailed report. \"\n        \"Make sure to check with a human if the draft is good before finalizing your answer.\"\n    ),\n    expected_output='A comprehensive full report on the latest AI advancements in 2025, leave nothing out',\n    agent=researcher,\n    human_input=True\n)\n\ntask2 = Task(\n    description=(\n        \"Using the insights from the researcher\\'s report, develop an engaging blog post that highlights the most significant AI advancements. \"\n        \"Your post should be informative yet accessible, catering to a tech-savvy audience. \"\n        \"Aim for a narrative that captures the essence of these breakthroughs and their implications for the future.\"\n    ),\n    expected_output='A compelling 3 paragraphs blog post formatted as markdown about the latest AI advancements in 2025',\n    agent=writer,\n    human_input=True\n)\n\n# Instantiate your crew with a sequential process\ncrew = Crew(\n    agents=[researcher, writer],\n    tasks=[task1, task2],\n    verbose=True,\n    memory=True,\n    planning=True  # Enable planning feature for the crew\n)\n\n# Get your crew to work!\nresult = crew.kickoff()\n\nprint(\"######################\")\nprint(result)",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type": "header",
        "title": "Kickoff Crew Asynchronously",
        "level": 1,
        "content": "Source: https://docs.crewai.com/how-to/kickoff-async Kickoff a Crew Asynchronously",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": [
          {
            "type": "header",
            "title": "Introduction",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Asynchronous Crew Execution",
            "level": 2,
            "content": "To kickoff a crew asynchronously, use the `kickoff_async()` method. This method initiates the crew execution in a separate thread, allowing the main thread to continue executing other tasks.",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": [
              {
                "type": "header",
                "title": "Method Signature",
                "level": 3,
                "content": "```\ndef kickoff_async(self, inputs: dict) -> CrewOutput:\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "def kickoff_async(self, inputs: dict) -> CrewOutput:",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Parameters",
                "level": 3,
                "content": "",
                "metadata": {
                  "section_type": "General",
                  "content_type": null
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Returns",
                "level": 3,
                "content": "`CrewOutput`: An object representing the result of the crew execution.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Potential Use Cases",
            "level": 2,
            "content": "**Parallel Content Generation**: Kickoff multiple independent crews asynchronously, each responsible for generating content on different topics. For example, one crew might research and draft an article on AI trends, while another crew generates social media posts about a new product launch. Each crew operates independently, allowing content production to scale efficiently. **Concurrent Market Research Tasks**: Launch multiple crews asynchronously to conduct market research in parallel. One crew might analyze industry trends, while another examines competitor strategies, and yet another evaluates consumer sentiment. Each crew independently completes its task, enabling faster and more comprehensive insights. **Independent Travel Planning Modules**: Execute separate crews to independently plan different aspects of a trip. One crew might handle flight options, another handles accommodation, and a third plans activities. Each crew works asynchronously, allowing various components of the trip to be planned simultaneously and independently for faster results.",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example: Single Asynchronous Crew Execution",
            "level": 2,
            "content": "Here's an example of how to kickoff a crew asynchronously using asyncio and awaiting the result:\n```\nimport asyncio\nfrom crewai import Crew, Agent, Task\n\n# Create an agent with code execution enabled\ncoding_agent = Agent(\n    role=\"Python Data Analyst\",\n    goal=\"Analyze data and provide insights using Python\",\n    backstory=\"You are an experienced data analyst with strong Python skills.\",\n    allow_code_execution=True\n)\n\n# Create a task that requires code execution\ndata_analysis_task = Task(\n    description=\"Analyze the given dataset and calculate the average age of participants. Ages: {ages}\",\n    agent=coding_agent,\n    expected_output=\"The average age of the participants.\"\n)\n\n# Create a crew and add the task\nanalysis_crew = Crew(\n    agents=[coding_agent],\n    tasks=[data_analysis_task]\n)\n\n# Async function to kickoff the crew asynchronously\nasync def async_crew_execution():\n    result = await analysis_crew.kickoff_async(inputs={\"ages\": [25, 30, 35, 40, 45]})\n    print(\"Crew Result:\", result)\n\n# Run the async function\nasyncio.run(async_crew_execution())\n```",
            "metadata": {
              "section_type": "Examples",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "import asyncio\nfrom crewai import Crew, Agent, Task\n\n# Create an agent with code execution enabled\ncoding_agent = Agent(\n    role=\"Python Data Analyst\",\n    goal=\"Analyze data and provide insights using Python\",\n    backstory=\"You are an experienced data analyst with strong Python skills.\",\n    allow_code_execution=True\n)\n\n# Create a task that requires code execution\ndata_analysis_task = Task(\n    description=\"Analyze the given dataset and calculate the average age of participants. Ages: {ages}\",\n    agent=coding_agent,\n    expected_output=\"The average age of the participants.\"\n)\n\n# Create a crew and add the task\nanalysis_crew = Crew(\n    agents=[coding_agent],\n    tasks=[data_analysis_task]\n)\n\n# Async function to kickoff the crew asynchronously\nasync def async_crew_execution():\n    result = await analysis_crew.kickoff_async(inputs={\"ages\": [25, 30, 35, 40, 45]})\n    print(\"Crew Result:\", result)\n\n# Run the async function\nasyncio.run(async_crew_execution())",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Example: Multiple Asynchronous Crew Executions",
            "level": 2,
            "content": "In this example, we'll show how to kickoff multiple crews asynchronously and wait for all of them to complete using `asyncio.gather()`:\n```\nimport asyncio\nfrom crewai import Crew, Agent, Task\n\n# Create an agent with code execution enabled\ncoding_agent = Agent(\n    role=\"Python Data Analyst\",\n    goal=\"Analyze data and provide insights using Python\",\n    backstory=\"You are an experienced data analyst with strong Python skills.\",\n    allow_code_execution=True\n)\n\n# Create tasks that require code execution\ntask_1 = Task(\n    description=\"Analyze the first dataset and calculate the average age of participants. Ages: {ages}\",\n    agent=coding_agent\n)\n\ntask_2 = Task(\n    description=\"Analyze the second dataset and calculate the average age of participants. Ages: {ages}\",\n    agent=coding_agent\n)\n\n# Create two crews and add tasks\ncrew_1 = Crew(agents=[coding_agent], tasks=[task_1])\ncrew_2 = Crew(agents=[coding_agent], tasks=[task_2])\n\n# Async function to kickoff multiple crews asynchronously and wait for all to finish\nasync def async_multiple_crews():\n    result_1 = crew_1.kickoff_async(inputs={\"ages\": [25, 30, 35, 40, 45]})\n    result_2 = crew_2.kickoff_async(inputs={\"ages\": [20, 22, 24, 28, 30]})\n\n    # Wait for both crews to finish\n    results = await asyncio.gather(result_1, result_2)\n\n    for i, result in enumerate(results, 1):\n        print(f\"Crew {i} Result:\", result)\n\n# Run the async function\nasyncio.run(async_multiple_crews())\n```",
            "metadata": {
              "section_type": "Examples",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "import asyncio\nfrom crewai import Crew, Agent, Task\n\n# Create an agent with code execution enabled\ncoding_agent = Agent(\n    role=\"Python Data Analyst\",\n    goal=\"Analyze data and provide insights using Python\",\n    backstory=\"You are an experienced data analyst with strong Python skills.\",\n    allow_code_execution=True\n)\n\n# Create tasks that require code execution\ntask_1 = Task(\n    description=\"Analyze the first dataset and calculate the average age of participants. Ages: {ages}\",\n    agent=coding_agent\n)\n\ntask_2 = Task(\n    description=\"Analyze the second dataset and calculate the average age of participants. Ages: {ages}\",\n    agent=coding_agent\n)\n\n# Create two crews and add tasks\ncrew_1 = Crew(agents=[coding_agent], tasks=[task_1])\ncrew_2 = Crew(agents=[coding_agent], tasks=[task_2])\n\n# Async function to kickoff multiple crews asynchronously and wait for all to finish\nasync def async_multiple_crews():\n    result_1 = crew_1.kickoff_async(inputs={\"ages\": [25, 30, 35, 40, 45]})\n    result_2 = crew_2.kickoff_async(inputs={\"ages\": [20, 22, 24, 28, 30]})\n\n    # Wait for both crews to finish\n    results = await asyncio.gather(result_1, result_2)\n\n    for i, result in enumerate(results, 1):\n        print(f\"Crew {i} Result:\", result)\n\n# Run the async function\nasyncio.run(async_multiple_crews())",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          }
        ]
      },
      {
        "type": "header",
        "title": "Kickoff Crew for Each",
        "level": 1,
        "content": "Source: https://docs.crewai.com/how-to/kickoff-for-each Kickoff Crew for Each Item in a List",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": [
          {
            "type": "header",
            "title": "Introduction",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Kicking Off a Crew for Each Item",
            "level": 2,
            "content": "To kickoff a crew for each item in a list, use the `kickoff_for_each()` method.\nThis method executes the crew for each item in the list, allowing you to process multiple items efficiently. Here's an example of how to kickoff a crew for each item in a list:\n```\nfrom crewai import Crew, Agent, Task\n\n# Create an agent with code execution enabled\ncoding_agent = Agent(\n    role=\"Python Data Analyst\",\n    goal=\"Analyze data and provide insights using Python\",\n    backstory=\"You are an experienced data analyst with strong Python skills.\",\n    allow_code_execution=True\n)\n\n# Create a task that requires code execution\ndata_analysis_task = Task(\n    description=\"Analyze the given dataset and calculate the average age of participants. Ages: {ages}\",\n    agent=coding_agent,\n    expected_output=\"The average age calculated from the dataset\"\n)\n\n# Create a crew and add the task\nanalysis_crew = Crew(\n    agents=[coding_agent],\n    tasks=[data_analysis_task],\n    verbose=True,\n    memory=False\n)\n\ndatasets = [\n  { \"ages\": [25, 30, 35, 40, 45] },\n  { \"ages\": [20, 25, 30, 35, 40] },\n  { \"ages\": [30, 35, 40, 45, 50] }\n]\n\n# Execute the crew\nresult = analysis_crew.kickoff_for_each(inputs=datasets)\n```",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai import Crew, Agent, Task\n\n# Create an agent with code execution enabled\ncoding_agent = Agent(\n    role=\"Python Data Analyst\",\n    goal=\"Analyze data and provide insights using Python\",\n    backstory=\"You are an experienced data analyst with strong Python skills.\",\n    allow_code_execution=True\n)\n\n# Create a task that requires code execution\ndata_analysis_task = Task(\n    description=\"Analyze the given dataset and calculate the average age of participants. Ages: {ages}\",\n    agent=coding_agent,\n    expected_output=\"The average age calculated from the dataset\"\n)\n\n# Create a crew and add the task\nanalysis_crew = Crew(\n    agents=[coding_agent],\n    tasks=[data_analysis_task],\n    verbose=True,\n    memory=False\n)\n\ndatasets = [\n  { \"ages\": [25, 30, 35, 40, 45] },\n  { \"ages\": [20, 25, 30, 35, 40] },\n  { \"ages\": [30, 35, 40, 45, 50] }\n]\n\n# Execute the crew\nresult = analysis_crew.kickoff_for_each(inputs=datasets)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          }
        ]
      },
      {
        "type": "header",
        "title": "Langfuse Integration",
        "level": 1,
        "content": "Source: https://docs.crewai.com/how-to/langfuse-observability Learn how to integrate Langfuse with CrewAI via OpenTelemetry using OpenLit",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "Integrate Langfuse with CrewAI",
        "level": 1,
        "content": "This notebook demonstrates how to integrate **Langfuse** with **CrewAI** using OpenTelemetry via the **OpenLit** SDK. By the end of this notebook, you will be able to trace your CrewAI applications with Langfuse for improved observability and debugging. **What is Langfuse?** [Langfuse](https://langfuse.com) is an open-source LLM engineering platform. It provides tracing and monitoring capabilities for LLM applications, helping developers debug, analyze, and optimize their AI systems. Langfuse integrates with various tools and frameworks via native integrations, OpenTelemetry, and APIs/SDKs. [![Langfuse Overview Video](https://github.com/user-attachments/assets/3926b288-ff61-4b95-8aa1-45d041c70866)](https://langfuse.com/watch-demo)",
        "metadata": {
          "section_type": "General",
          "content_type": "link_list"
        },
        "children": [
          {
            "type": "header",
            "title": "Get Started",
            "level": 2,
            "content": "We'll walk through a simple example of using CrewAI and integrating it with Langfuse via OpenTelemetry using OpenLit.",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": [
              {
                "type": "header",
                "title": "Step 1: Install Dependencies",
                "level": 3,
                "content": "```\n%pip install langfuse openlit crewai crewai_tools\n```",
                "metadata": {
                  "section_type": "Installation/Setup",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "%pip install langfuse openlit crewai crewai_tools",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Step 2: Set Up Environment Variables",
                "level": 3,
                "content": "Set your Langfuse API keys and configure OpenTelemetry export settings to send traces to Langfuse. Please refer to the [Langfuse OpenTelemetry Docs](https://langfuse.com/docs/opentelemetry/get-started) for more information on the Langfuse OpenTelemetry endpoint `/api/public/otel` and authentication.\n```\nimport os\nimport base64\n\nLANGFUSE_PUBLIC_KEY=\"pk-lf-...\"\nLANGFUSE_SECRET_KEY=\"sk-lf-...\"\nLANGFUSE_AUTH=base64.b64encode(f\"{LANGFUSE_PUBLIC_KEY}:{LANGFUSE_SECRET_KEY}\".encode()).decode()\n\nos.environ[\"OTEL_EXPORTER_OTLP_ENDPOINT\"] = \"https://cloud.langfuse.com/api/public/otel\" # EU data region\n# os.environ[\"OTEL_EXPORTER_OTLP_ENDPOINT\"] = \"https://us.cloud.langfuse.com/api/public/otel\" # US data region\nos.environ[\"OTEL_EXPORTER_OTLP_HEADERS\"] = f\"Authorization=Basic {LANGFUSE_AUTH}\"\n\n# your openai key\nos.environ[\"OPENAI_API_KEY\"] = \"sk-...\"\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "import os\nimport base64\n\nLANGFUSE_PUBLIC_KEY=\"pk-lf-...\"\nLANGFUSE_SECRET_KEY=\"sk-lf-...\"\nLANGFUSE_AUTH=base64.b64encode(f\"{LANGFUSE_PUBLIC_KEY}:{LANGFUSE_SECRET_KEY}\".encode()).decode()\n\nos.environ[\"OTEL_EXPORTER_OTLP_ENDPOINT\"] = \"https://cloud.langfuse.com/api/public/otel\" # EU data region\n# os.environ[\"OTEL_EXPORTER_OTLP_ENDPOINT\"] = \"https://us.cloud.langfuse.com/api/public/otel\" # US data region\nos.environ[\"OTEL_EXPORTER_OTLP_HEADERS\"] = f\"Authorization=Basic {LANGFUSE_AUTH}\"\n\n# your openai key\nos.environ[\"OPENAI_API_KEY\"] = \"sk-...\"",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Step 3: Initialize OpenLit",
                "level": 3,
                "content": "Initialize the OpenLit OpenTelemetry instrumentation SDK to start capturing OpenTelemetry traces.\n```\nimport openlit\n\nopenlit.init()\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "import openlit\n\nopenlit.init()",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Step 4: Create a Simple CrewAI Application",
                "level": 3,
                "content": "We'll create a simple CrewAI application where multiple agents collaborate to answer a user's question.\n```\nfrom crewai import Agent, Task, Crew\n\nfrom crewai_tools import (\n    WebsiteSearchTool\n)\n\nweb_rag_tool = WebsiteSearchTool()\n\nwriter = Agent(\n        role=\"Writer\",\n        goal=\"You make math engaging and understandable for young children through poetry\",\n        backstory=\"You're an expert in writing haikus but you know nothing of math.\",\n        tools=[web_rag_tool],  \n    )\n\ntask = Task(description=(\"What is {multiplication}?\"),\n            expected_output=(\"Compose a haiku that includes the answer.\"),\n            agent=writer)\n\ncrew = Crew(\n  agents=[writer],\n  tasks=[task],\n  share_crew=False\n)\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "from crewai import Agent, Task, Crew\n\nfrom crewai_tools import (\n    WebsiteSearchTool\n)\n\nweb_rag_tool = WebsiteSearchTool()\n\nwriter = Agent(\n        role=\"Writer\",\n        goal=\"You make math engaging and understandable for young children through poetry\",\n        backstory=\"You're an expert in writing haikus but you know nothing of math.\",\n        tools=[web_rag_tool],  \n    )\n\ntask = Task(description=(\"What is {multiplication}?\"),\n            expected_output=(\"Compose a haiku that includes the answer.\"),\n            agent=writer)\n\ncrew = Crew(\n  agents=[writer],\n  tasks=[task],\n  share_crew=False\n)",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Step 5: See Traces in Langfuse",
                "level": 3,
                "content": "After running the agent, you can view the traces generated by your CrewAI application in [Langfuse](https://cloud.langfuse.com). You should see detailed steps of the LLM interactions, which can help you debug and optimize your AI agent. ![CrewAI example trace in Langfuse](https://langfuse.com/images/cookbook/integration_crewai/crewai-example-trace.png) *[Public example trace in Langfuse](https://cloud.langfuse.com/project/cloramnkj0002jz088vzn1ja4/traces/e2cf380ffc8d47d28da98f136140642b?timestamp=2025-02-05T15%3A12%3A02.717Z\\&observation=3b32338ee6a5d9af)*",
                "metadata": {
                  "section_type": "General",
                  "content_type": "link_list"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "References",
            "level": 2,
            "content": "[Langfuse OpenTelemetry Docs](https://langfuse.com/docs/opentelemetry/get-started)",
            "metadata": {
              "section_type": "General",
              "content_type": "link_list"
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Langtrace Integration",
        "level": 1,
        "content": "Source: https://docs.crewai.com/how-to/langtrace-observability How to monitor cost, latency, and performance of CrewAI Agents using Langtrace, an external observability tool.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "Langtrace Overview",
        "level": 1,
        "content": "Langtrace is an open-source, external tool that helps you set up observability and evaluations for Large Language Models (LLMs), LLM frameworks, and Vector Databases.\nWhile not built directly into CrewAI, Langtrace can be used alongside CrewAI to gain deep visibility into the cost, latency, and performance of your CrewAI Agents.\nThis integration allows you to log hyperparameters, monitor performance regressions, and establish a process for continuous improvement of your Agents. ![Overview of a select series of agent session runs](https://mintlify.s3.us-west-1.amazonaws.com/crewai/images/langtrace1.png)\n![Overview of agent traces](https://mintlify.s3.us-west-1.amazonaws.com/crewai/images/langtrace2.png)\n![Overview of llm traces in details](https://mintlify.s3.us-west-1.amazonaws.com/crewai/images/langtrace3.png)",
        "metadata": {
          "section_type": "Concepts documentation",
          "content_type": "link_list"
        },
        "children": [
          {
            "type": "header",
            "title": "Setup Instructions",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": [
              {
                "type": "header",
                "title": "Features and Their Application to CrewAI",
                "level": 3,
                "content": "**LLM Token and Cost Tracking** Monitor the token usage and associated costs for each CrewAI agent interaction. **Trace Graph for Execution Steps** Visualize the execution flow of your CrewAI tasks, including latency and logs. Useful for identifying bottlenecks in your agent workflows. **Dataset Curation with Manual Annotation** Create datasets from your CrewAI task outputs for future training or evaluation. **Prompt Versioning and Management** Keep track of different versions of prompts used in your CrewAI agents. Useful for A/B testing and optimizing agent performance. **Prompt Playground with Model Comparisons** Test and compare different prompts and models for your CrewAI agents before deployment. **Testing and Evaluations** Set up automated tests for your CrewAI agents and tasks.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "descriptive_text"
                },
                "children": []
              }
            ]
          }
        ]
      },
      {
        "type": "header",
        "title": "Connect to any LLM",
        "level": 1,
        "content": "Source: https://docs.crewai.com/how-to/llm-connections Comprehensive guide on integrating CrewAI with various Large Language Models (LLMs) using LiteLLM, including supported providers and configuration options.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": [
          {
            "type": "header",
            "title": "Connect CrewAI to LLMs",
            "level": 2,
            "content": "CrewAI uses LiteLLM to connect to a wide variety of Language Models (LLMs). This integration provides extensive versatility, allowing you to use models from numerous providers with a simple, unified interface.",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Supported Providers",
            "level": 2,
            "content": "LiteLLM supports a wide range of providers, including but not limited to: OpenAI Anthropic Google (Vertex AI, Gemini) Azure OpenAI AWS (Bedrock, SageMaker) Cohere VoyageAI Hugging Face Ollama Mistral AI Replicate Together AI AI21 Cloudflare Workers AI DeepInfra Groq SambaNova [NVIDIA NIMs](https://docs.api.nvidia.com/nim/reference/models-1) And many more! For a complete and up-to-date list of supported providers, please refer to the [LiteLLM Providers documentation](https://docs.litellm.ai/docs/providers).",
            "metadata": {
              "section_type": "General",
              "content_type": "link_list"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Changing the LLM",
            "level": 2,
            "content": "To use a different LLM with your CrewAI agents, you have several options:",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Configuration Options",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Connecting to OpenAI-Compatible LLMs",
            "level": 2,
            "content": "You can connect to OpenAI-compatible LLMs using either environment variables or by setting specific attributes on the LLM class:",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Using Local Models with Ollama",
            "level": 2,
            "content": "For local models like those provided by Ollama:",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Changing the Base API URL",
            "level": 2,
            "content": "You can change the base API URL for any LLM provider by setting the `base_url` parameter:\n```\nllm = LLM(\n    model=\"custom-model-name\",\n    base_url=\"https://api.your-provider.com/v1\",\n    api_key=\"your-api-key\"\n)\nagent = Agent(llm=llm, ...)\n```\nThis is particularly useful when working with OpenAI-compatible APIs or when you need to specify a different endpoint for your chosen provider.",
            "metadata": {
              "section_type": "API documentation",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "llm = LLM(\n    model=\"custom-model-name\",\n    base_url=\"https://api.your-provider.com/v1\",\n    api_key=\"your-api-key\"\n)\nagent = Agent(llm=llm, ...)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Conclusion",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "MLflow Integration",
        "level": 1,
        "content": "Source: https://docs.crewai.com/how-to/mlflow-observability Quickly start monitoring your Agents with MLflow.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "MLflow Overview",
        "level": 1,
        "content": "[MLflow](https://mlflow.org/) is an open-source platform to assist machine learning practitioners and teams in handling the complexities of the machine learning process. It provides a tracing feature that enhances LLM observability in your Generative AI applications by capturing detailed information about the execution of your application\u2019s services.\nTracing provides a way to record the inputs, outputs, and metadata associated with each intermediate step of a request, enabling you to easily pinpoint the source of bugs and unexpected behaviors. ![Overview of MLflow crewAI tracing usage](https://mintlify.s3.us-west-1.amazonaws.com/crewai/images/mlflow-tracing.gif)",
        "metadata": {
          "section_type": "Concepts documentation",
          "content_type": "link_list"
        },
        "children": [
          {
            "type": "header",
            "title": "Features",
            "level": 3,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Setup Instructions",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Using Multimodal Agents",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Using Multimodal Agents",
            "level": 2,
            "content": "Source: https://docs.crewai.com/how-to/multimodal-agents Learn how to enable and use multimodal capabilities in your agents for processing images and other non-text content within the CrewAI framework.\n\nCrewAI supports multimodal agents that can process both text and non-text content like images. This guide will show you how to enable and use multimodal capabilities in your agents.",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": [
              {
                "type": "header",
                "title": "Enabling Multimodal Capabilities",
                "level": 3,
                "content": "To create a multimodal agent, simply set the `multimodal` parameter to `True` when initializing your agent:\n```\nfrom crewai import Agent\n\nagent = Agent(\n    role=\"Image Analyst\",\n    goal=\"Analyze and extract insights from images\",\n    backstory=\"An expert in visual content interpretation with years of experience in image analysis\",\n    multimodal=True  # This enables multimodal capabilities\n)\n```\nWhen you set `multimodal=True`, the agent is automatically configured with the necessary tools for handling non-text content, including the `AddImageTool`.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "from crewai import Agent\n\nagent = Agent(\n    role=\"Image Analyst\",\n    goal=\"Analyze and extract insights from images\",\n    backstory=\"An expert in visual content interpretation with years of experience in image analysis\",\n    multimodal=True  # This enables multimodal capabilities\n)",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Working with Images",
                "level": 3,
                "content": "The multimodal agent comes pre-configured with the `AddImageTool`, which allows it to process images. You don't need to manually add this tool - it's automatically included when you enable multimodal capabilities. Here's a complete example showing how to use a multimodal agent to analyze an image:\n```\nfrom crewai import Agent, Task, Crew\n\n# Create a multimodal agent\nimage_analyst = Agent(\n    role=\"Product Analyst\",\n    goal=\"Analyze product images and provide detailed descriptions\",\n    backstory=\"Expert in visual product analysis with deep knowledge of design and features\",\n    multimodal=True\n)\n\n# Create a task for image analysis\ntask = Task(\n    description=\"Analyze the product image at https://example.com/product.jpg and provide a detailed description\",\n    expected_output=\"A detailed description of the product image\",\n    agent=image_analyst\n)\n\n# Create and run the crew\ncrew = Crew(\n    agents=[image_analyst],\n    tasks=[task]\n)\n\nresult = crew.kickoff()\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "from crewai import Agent, Task, Crew\n\n# Create a multimodal agent\nimage_analyst = Agent(\n    role=\"Product Analyst\",\n    goal=\"Analyze product images and provide detailed descriptions\",\n    backstory=\"Expert in visual product analysis with deep knowledge of design and features\",\n    multimodal=True\n)\n\n# Create a task for image analysis\ntask = Task(\n    description=\"Analyze the product image at https://example.com/product.jpg and provide a detailed description\",\n    expected_output=\"A detailed description of the product image\",\n    agent=image_analyst\n)\n\n# Create and run the crew\ncrew = Crew(\n    agents=[image_analyst],\n    tasks=[task]\n)\n\nresult = crew.kickoff()",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Advanced Usage with Context",
                "level": 3,
                "content": "You can provide additional context or specific questions about the image when creating tasks for multimodal agents. The task description can include specific aspects you want the agent to focus on:\n```\nfrom crewai import Agent, Task, Crew\n\n# Create a multimodal agent for detailed analysis\nexpert_analyst = Agent(\n    role=\"Visual Quality Inspector\",\n    goal=\"Perform detailed quality analysis of product images\",\n    backstory=\"Senior quality control expert with expertise in visual inspection\",\n    multimodal=True  # AddImageTool is automatically included\n)\n\n# Create a task with specific analysis requirements\ninspection_task = Task(\n    description=\"\"\"\n    Analyze the product image at https://example.com/product.jpg with focus on:\n    1. Quality of materials\n    2. Manufacturing defects\n    3. Compliance with standards\n    Provide a detailed report highlighting any issues found.\n    \"\"\",\n    expected_output=\"A detailed report highlighting any issues found\",\n    agent=expert_analyst\n)\n\n# Create and run the crew\ncrew = Crew(\n    agents=[expert_analyst],\n    tasks=[inspection_task]\n)\n\nresult = crew.kickoff()\n```",
                "metadata": {
                  "section_type": "Examples",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "from crewai import Agent, Task, Crew\n\n# Create a multimodal agent for detailed analysis\nexpert_analyst = Agent(\n    role=\"Visual Quality Inspector\",\n    goal=\"Perform detailed quality analysis of product images\",\n    backstory=\"Senior quality control expert with expertise in visual inspection\",\n    multimodal=True  # AddImageTool is automatically included\n)\n\n# Create a task with specific analysis requirements\ninspection_task = Task(\n    description=\"\"\"\n    Analyze the product image at https://example.com/product.jpg with focus on:\n    1. Quality of materials\n    2. Manufacturing defects\n    3. Compliance with standards\n    Provide a detailed report highlighting any issues found.\n    \"\"\",\n    expected_output=\"A detailed report highlighting any issues found\",\n    agent=expert_analyst\n)\n\n# Create and run the crew\ncrew = Crew(\n    agents=[expert_analyst],\n    tasks=[inspection_task]\n)\n\nresult = crew.kickoff()",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Tool Details",
                "level": 3,
                "content": "When working with multimodal agents, the `AddImageTool` is automatically configured with the following schema:\n```\nclass AddImageToolSchema:\n    image_url: str  # Required: The URL or path of the image to process\n    action: Optional[str] = None  # Optional: Additional context or specific questions about the image\n```\nThe multimodal agent will automatically handle the image processing through its built-in tools, allowing it to: Access images via URLs or local file paths Process image content with optional context or specific questions Provide analysis and insights based on the visual information and task requirements",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "class AddImageToolSchema:\n    image_url: str  # Required: The URL or path of the image to process\n    action: Optional[str] = None  # Optional: Additional context or specific questions about the image",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Best Practices",
                "level": 3,
                "content": "**Keep Handlers Light**: Event handlers should be lightweight and avoid blocking operations **Error Handling**: Include proper error handling in your event handlers to prevent exceptions from affecting the main execution **Cleanup**: If your listener allocates resources, ensure they're properly cleaned up **Selective Listening**: Only listen for events you actually need to handle **Testing**: Test your event listeners in isolation to ensure they behave as expected By leveraging CrewAI's event system, you can extend its functionality and integrate it seamlessly with your existing infrastructure.\n\nWhen working with multimodal agents, keep these best practices in mind: **Image Access** Ensure your images are accessible via URLs that the agent can reach For local images, consider hosting them temporarily or using absolute file paths Verify that image URLs are valid and accessible before running tasks **Task Description** Be specific about what aspects of the image you want the agent to analyze Include clear questions or requirements in the task description Consider using the optional `action` parameter for focused analysis **Resource Management** Image processing may require more computational resources than text-only tasks Some language models may require base64 encoding for image data Consider batch processing for multiple images to optimize performance **Environment Setup** Verify that your environment has the necessary dependencies for image processing Ensure your language model supports multimodal capabilities Test with small images first to validate your setup **Error Handling** Implement proper error handling for image loading failures Have fallback strategies for when image processing fails Monitor and log image processing operations for debugging",
                "metadata": {
                  "section_type": "General",
                  "content_type": "descriptive_text"
                },
                "children": []
              }
            ]
          }
        ]
      },
      {
        "type": "header",
        "title": "OpenLIT Integration",
        "level": 1,
        "content": "Source: https://docs.crewai.com/how-to/openlit-observability Quickly start monitoring your Agents in just a single line of code with OpenTelemetry.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "OpenLIT Overview",
        "level": 1,
        "content": "[OpenLIT](https://github.com/openlit/openlit?src=crewai-docs) is an open-source tool that makes it simple to monitor the performance of AI agents, LLMs, VectorDBs, and GPUs with just **one** line of code. It provides OpenTelemetry-native tracing and metrics to track important parameters like cost, latency, interactions and task sequences.\nThis setup enables you to track hyperparameters and monitor for performance issues, helping you find ways to enhance and fine-tune your agents over time.",
        "metadata": {
          "section_type": "Concepts documentation",
          "content_type": "link_list"
        },
        "children": [
          {
            "type": "header",
            "title": "Features",
            "level": 3,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Setup Instructions",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Opik Integration",
        "level": 1,
        "content": "Source: https://docs.crewai.com/how-to/opik-observability Learn how to use Comet Opik to debug, evaluate, and monitor your CrewAI applications with comprehensive tracing, automated evaluations, and production-ready dashboards.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "Opik Overview",
        "level": 1,
        "content": "With [Comet Opik](https://www.comet.com/docs/opik/), debug, evaluate, and monitor your LLM applications, RAG systems, and agentic workflows with comprehensive tracing, automated evaluations, and production-ready dashboards. Opik provides comprehensive support for every stage of your CrewAI application development: **Log Traces and Spans**: Automatically track LLM calls and application logic to debug and analyze development and production systems. Manually or programmatically annotate, view, and compare responses across projects. **Evaluate Your LLM Application's Performance**: Evaluate against a custom test set and run built-in evaluation metrics or define your own metrics in the SDK or UI. **Test Within Your CI/CD Pipeline**: Establish reliable performance baselines with Opik's LLM unit tests, built on PyTest. Run online evaluations for continuous monitoring in production. **Monitor & Analyze Production Data**: Understand your models' performance on unseen data in production and generate datasets for new dev iterations.",
        "metadata": {
          "section_type": "Concepts documentation",
          "content_type": "link_list"
        },
        "children": [
          {
            "type": "header",
            "title": "Setup",
            "level": 2,
            "content": "Comet provides a hosted version of the Opik platform, or you can run the platform locally. To use the hosted version, simply [create a free Comet account](https://www.comet.com/signup?utm_medium=github\\&utm_source=crewai_docs) and grab you API Key. To run the Opik platform locally, see our [installation guide](https://www.comet.com/docs/opik/self-host/overview/) for more information. For this guide we will use CrewAI\u2019s quickstart example.",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": "link_list"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Resources",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Portkey Integration",
        "level": 1,
        "content": "Source: https://docs.crewai.com/how-to/portkey-observability How to use Portkey with CrewAI [Portkey](https://portkey.ai/?utm_source=crewai\\&utm_medium=crewai\\&utm_campaign=crewai) is a 2-line upgrade to make your CrewAI agents reliable, cost-efficient, and fast. Portkey adds 4 core production capabilities to any CrewAI agent: Routing to **200+ LLMs** Making each LLM call more robust Full-stack tracing & cost, performance analytics Real-time guardrails to enforce behavior",
        "metadata": {
          "section_type": "General",
          "content_type": "link_list"
        },
        "children": [
          {
            "type": "header",
            "title": "Getting Started",
            "level": 2,
            "content": "Let's create a simple Flow where you will use OpenAI to generate a random city in one task and then use that city to generate a fun fact in another task.\n```\n\nfrom crewai.flow.flow import Flow, listen, start\nfrom dotenv import load_dotenv\nfrom litellm import completion\n\n\nclass ExampleFlow(Flow):\n    model = \"gpt-4o-mini\"\n\n    @start()\n    def generate_city(self):\n        print(\"Starting flow\")\n        # Each flow state automatically gets a unique ID\n        print(f\"Flow State ID: {self.state['id']}\")\n\n        response = completion(\n            model=self.model,\n            messages=[\n                {\n                    \"role\": \"user\",\n                    \"content\": \"Return the name of a random city in the world.\",\n                },\n            ],\n        )\n\n        random_city = response[\"choices\"][0][\"message\"][\"content\"]\n        # Store the city in our state\n        self.state[\"city\"] = random_city\n        print(f\"Random City: {random_city}\")\n\n        return random_city\n\n    @listen(generate_city)\n    def generate_fun_fact(self, random_city):\n        response = completion(\n            model=self.model,\n            messages=[\n                {\n                    \"role\": \"user\",\n                    \"content\": f\"Tell me a fun fact about {random_city}\",\n                },\n            ],\n        )\n\n        fun_fact = response[\"choices\"][0][\"message\"][\"content\"]\n        # Store the fun fact in our state\n        self.state[\"fun_fact\"] = fun_fact\n        return fun_fact\n\n\n\nflow = ExampleFlow()\nresult = flow.kickoff()\n\nprint(f\"Generated fun fact: {result}\")\n```\nIn the above example, we have created a simple Flow that generates a random city using OpenAI and then generates a fun fact about that city. The Flow consists of two tasks: `generate_city` and `generate_fun_fact`. The `generate_city` task is the starting point of the Flow, and the `generate_fun_fact` task listens for the output of the `generate_city` task. Each Flow instance automatically receives a unique identifier (UUID) in its state, which helps track and manage flow executions. The state can also store additional data (like the generated city and fun fact) that persists throughout the flow's execution. When you run the Flow, it will: Generate a unique ID for the flow state Generate a random city and store it in the state Generate a fun fact about that city and store it in the state Print the results to the console The state's unique ID and stored data can be useful for tracking flow executions and maintaining context between tasks. **Note:** Ensure you have set up your `.env` file to store your `OPENAI_API_KEY`. This key is necessary for authenticating requests to the OpenAI API.",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai.flow.flow import Flow, listen, start\nfrom dotenv import load_dotenv\nfrom litellm import completion\n\n\nclass ExampleFlow(Flow):\n    model = \"gpt-4o-mini\"\n\n    @start()\n    def generate_city(self):\n        print(\"Starting flow\")\n        # Each flow state automatically gets a unique ID\n        print(f\"Flow State ID: {self.state['id']}\")\n\n        response = completion(\n            model=self.model,\n            messages=[\n                {\n                    \"role\": \"user\",\n                    \"content\": \"Return the name of a random city in the world.\",\n                },\n            ],\n        )\n\n        random_city = response[\"choices\"][0][\"message\"][\"content\"]\n        # Store the city in our state\n        self.state[\"city\"] = random_city\n        print(f\"Random City: {random_city}\")\n\n        return random_city\n\n    @listen(generate_city)\n    def generate_fun_fact(self, random_city):\n        response = completion(\n            model=self.model,\n            messages=[\n                {\n                    \"role\": \"user\",\n                    \"content\": f\"Tell me a fun fact about {random_city}\",\n                },\n            ],\n        )\n\n        fun_fact = response[\"choices\"][0][\"message\"][\"content\"]\n        # Store the fun fact in our state\n        self.state[\"fun_fact\"] = fun_fact\n        return fun_fact\n\n\n\nflow = ExampleFlow()\nresult = flow.kickoff()\n\nprint(f\"Generated fun fact: {result}\")",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Key Features",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Production Features with Portkey Configs",
            "level": 2,
            "content": "All features mentioned below are through Portkey's Config system. Portkey's Config system allows you to define routing strategies using simple JSON objects in your LLM API calls. You can create and manage Configs directly in your code or through the Portkey Dashboard. Each Config has a unique ID for easy reference.",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": [
              {
                "type": "header",
                "title": "1. Use 250+ LLMs",
                "level": 3,
                "content": "Access various LLMs like Anthropic, Gemini, Mistral, Azure OpenAI, and more with minimal code changes. Switch between providers or use them together seamlessly. [Learn more about Universal API](https://portkey.ai/docs/product/ai-gateway/universal-api) Easily switch between different LLM providers:\n```\n# Anthropic Configuration\nanthropic_llm = LLM(\n    model=\"claude-3-5-sonnet-latest\",\n    base_url=PORTKEY_GATEWAY_URL,\n    api_key=\"dummy\",\n    extra_headers=createHeaders(\n        api_key=\"YOUR_PORTKEY_API_KEY\",\n        virtual_key=\"YOUR_ANTHROPIC_VIRTUAL_KEY\", #You don't need provider when using Virtual keys\n        trace_id=\"anthropic_agent\"\n    )\n)\n\n# Azure OpenAI Configuration\nazure_llm = LLM(\n    model=\"gpt-4\",\n    base_url=PORTKEY_GATEWAY_URL,\n    api_key=\"dummy\",\n    extra_headers=createHeaders(\n        api_key=\"YOUR_PORTKEY_API_KEY\",\n        virtual_key=\"YOUR_AZURE_VIRTUAL_KEY\", #You don't need provider when using Virtual keys\n        trace_id=\"azure_agent\"\n    )\n)\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "# Anthropic Configuration\nanthropic_llm = LLM(\n    model=\"claude-3-5-sonnet-latest\",\n    base_url=PORTKEY_GATEWAY_URL,\n    api_key=\"dummy\",\n    extra_headers=createHeaders(\n        api_key=\"YOUR_PORTKEY_API_KEY\",\n        virtual_key=\"YOUR_ANTHROPIC_VIRTUAL_KEY\", #You don't need provider when using Virtual keys\n        trace_id=\"anthropic_agent\"\n    )\n)\n\n# Azure OpenAI Configuration\nazure_llm = LLM(\n    model=\"gpt-4\",\n    base_url=PORTKEY_GATEWAY_URL,\n    api_key=\"dummy\",\n    extra_headers=createHeaders(\n        api_key=\"YOUR_PORTKEY_API_KEY\",\n        virtual_key=\"YOUR_AZURE_VIRTUAL_KEY\", #You don't need provider when using Virtual keys\n        trace_id=\"azure_agent\"\n    )\n)",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "2. Caching",
                "level": 3,
                "content": "Improve response times and reduce costs with two powerful caching modes: **Simple Cache**: Perfect for exact matches **Semantic Cache**: Matches responses for requests that are semantically similar\n[Learn more about Caching](https://portkey.ai/docs/product/ai-gateway/cache-simple-and-semantic)\n```\nconfig = {\n    \"cache\": {\n        \"mode\": \"semantic\",  # or \"simple\" for exact matching\n    }\n}\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "py",
                    "content": "config = {\n    \"cache\": {\n        \"mode\": \"semantic\",  # or \"simple\" for exact matching\n    }\n}",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "3. Production Reliability",
                "level": 3,
                "content": "Portkey provides comprehensive reliability features: **Automatic Retries**: Handle temporary failures gracefully **Request Timeouts**: Prevent hanging operations **Conditional Routing**: Route requests based on specific conditions **Fallbacks**: Set up automatic provider failovers **Load Balancing**: Distribute requests efficiently [Learn more about Reliability Features](https://portkey.ai/docs/product/ai-gateway/)",
                "metadata": {
                  "section_type": "General",
                  "content_type": "link_list"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "4. Metrics",
                "level": 3,
                "content": "Agent runs are complex. Portkey automatically logs **40+ comprehensive metrics** for your AI agents, including cost, tokens used, latency, etc. Whether you need a broad overview or granular insights into your agent runs, Portkey's customizable filters provide the metrics you need. Cost per agent interaction Response times and latency Token usage and efficiency Success/failure rates Cache hit rates",
                "metadata": {
                  "section_type": "General",
                  "content_type": "descriptive_text"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "5. Detailed Logging",
                "level": 3,
                "content": "Logs are essential for understanding agent behavior, diagnosing issues, and improving performance. They provide a detailed record of agent activities and tool use, which is crucial for debugging and optimizing processes. Access a dedicated section to view records of agent executions, including parameters, outcomes, function calls, and errors. Filter logs based on multiple parameters such as trace ID, model, tokens used, and metadata.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "descriptive_text"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "6. Enterprise Security Features",
                "level": 3,
                "content": "Set budget limit and rate limts per Virtual Key (disposable API keys) Implement role-based access control Track system changes with audit logs Configure data retention policies For detailed information on creating and managing Configs, visit the [Portkey documentation](https://docs.portkey.ai/product/ai-gateway/configs).",
                "metadata": {
                  "section_type": "General",
                  "content_type": "link_list"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Resources",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Replay Tasks from Latest Crew Kickoff",
        "level": 1,
        "content": "Source: https://docs.crewai.com/how-to/replay-tasks-from-latest-crew-kickoff Replay tasks from the latest crew.kickoff(...)",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": [
          {
            "type": "header",
            "title": "Introduction",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": [
              {
                "type": "header",
                "title": "Replaying from Specific Task Using the CLI",
                "level": 3,
                "content": "To use the replay feature, follow these steps:",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Replaying from a Task Programmatically",
                "level": 3,
                "content": "To replay from a task programmatically, use the following steps:",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Conclusion",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Sequential Processes",
        "level": 1,
        "content": "Source: https://docs.crewai.com/how-to/sequential-process A comprehensive guide to utilizing the sequential processes for task execution in CrewAI projects.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": [
          {
            "type": "header",
            "title": "Introduction",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Sequential Process Overview",
            "level": 2,
            "content": "The sequential process ensures tasks are executed one after the other, following a linear progression.\nThis approach is ideal for projects requiring tasks to be completed in a specific order.",
            "metadata": {
              "section_type": "Concepts documentation",
              "content_type": "short_description"
            },
            "children": [
              {
                "type": "header",
                "title": "Key Features",
                "level": 3,
                "content": "",
                "metadata": {
                  "section_type": "General",
                  "content_type": null
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Implementing the Sequential Process",
            "level": 2,
            "content": "To use the sequential process, assemble your crew and define tasks in the order they need to be executed.\n```\nfrom crewai import Crew, Process, Agent, Task, TaskOutput, CrewOutput\n\n# Define your agents\nresearcher = Agent(\n  role='Researcher',\n  goal='Conduct foundational research',\n  backstory='An experienced researcher with a passion for uncovering insights'\n)\nanalyst = Agent(\n  role='Data Analyst',\n  goal='Analyze research findings',\n  backstory='A meticulous analyst with a knack for uncovering patterns'\n)\nwriter = Agent(\n  role='Writer',\n  goal='Draft the final report',\n  backstory='A skilled writer with a talent for crafting compelling narratives'\n)\n\n# Define your tasks\nresearch_task = Task(\n  description='Gather relevant data...', \n  agent=researcher, \n  expected_output='Raw Data'\n)\nanalysis_task = Task(\n  description='Analyze the data...', \n  agent=analyst, \n  expected_output='Data Insights'\n)\nwriting_task = Task(\n  description='Compose the report...', \n  agent=writer, \n  expected_output='Final Report'\n)\n\n# Form the crew with a sequential process\nreport_crew = Crew(\n  agents=[researcher, analyst, writer],\n  tasks=[research_task, analysis_task, writing_task],\n  process=Process.sequential\n)\n\n# Execute the crew\nresult = report_crew.kickoff()\n\n# Accessing the type-safe output\ntask_output: TaskOutput = result.tasks[0].output\ncrew_output: CrewOutput = result.output\n```",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [
              {
                "type": "header",
                "title": "Note:",
                "level": 3,
                "content": "Each task in a sequential process **must** have an agent assigned. Ensure that every `Task` includes an `agent` parameter.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Workflow in Action",
                "level": 3,
                "content": "**Task Assignment**: The manager assigns tasks strategically, considering each agent's capabilities and available tools. **Execution and Review**: Agents complete their tasks with the option for asynchronous execution and callback functions for streamlined workflows. **Sequential Task Progression**: Despite being a hierarchical process, tasks follow a logical order for smooth progression, facilitated by the manager's oversight.\n\n**Initial Task**: In a sequential process, the first agent completes their task and signals completion. **Subsequent Tasks**: Agents pick up their tasks based on the process type, with outcomes of preceding tasks or directives guiding their execution. **Completion**: The process concludes once the final task is executed, leading to project completion.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "descriptive_text"
                },
                "children": []
              }
            ],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai import Crew, Process, Agent, Task, TaskOutput, CrewOutput\n\n# Define your agents\nresearcher = Agent(\n  role='Researcher',\n  goal='Conduct foundational research',\n  backstory='An experienced researcher with a passion for uncovering insights'\n)\nanalyst = Agent(\n  role='Data Analyst',\n  goal='Analyze research findings',\n  backstory='A meticulous analyst with a knack for uncovering patterns'\n)\nwriter = Agent(\n  role='Writer',\n  goal='Draft the final report',\n  backstory='A skilled writer with a talent for crafting compelling narratives'\n)\n\n# Define your tasks\nresearch_task = Task(\n  description='Gather relevant data...', \n  agent=researcher, \n  expected_output='Raw Data'\n)\nanalysis_task = Task(\n  description='Analyze the data...', \n  agent=analyst, \n  expected_output='Data Insights'\n)\nwriting_task = Task(\n  description='Compose the report...', \n  agent=writer, \n  expected_output='Final Report'\n)\n\n# Form the crew with a sequential process\nreport_crew = Crew(\n  agents=[researcher, analyst, writer],\n  tasks=[research_task, analysis_task, writing_task],\n  process=Process.sequential\n)\n\n# Execute the crew\nresult = report_crew.kickoff()\n\n# Accessing the type-safe output\ntask_output: TaskOutput = result.tasks[0].output\ncrew_output: CrewOutput = result.output",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Advanced Features",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Internals/Advanced",
              "content_type": null
            },
            "children": [
              {
                "type": "header",
                "title": "Task Delegation",
                "level": 3,
                "content": "In sequential processes, if an agent has `allow_delegation` set to `True`, they can delegate tasks to other agents in the crew.\nThis feature is automatically set up when there are multiple agents in the crew.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Asynchronous Execution",
                "level": 3,
                "content": "You can define a task to be executed asynchronously. This means that the crew will not wait for it to be completed to continue with the next task. This is useful for tasks that take a long time to be completed, or that are not crucial for the next tasks to be performed. You can then use the `context` attribute to define in a future task that it should wait for the output of the asynchronous task to be completed.\n```\n#...\n\nlist_ideas = Task(\n    description=\"List of 5 interesting ideas to explore for an article about AI.\",\n    expected_output=\"Bullet point list of 5 ideas for an article.\",\n    agent=researcher,\n    async_execution=True # Will be executed asynchronously\n)\n\nlist_important_history = Task(\n    description=\"Research the history of AI and give me the 5 most important events.\",\n    expected_output=\"Bullet point list of 5 important events.\",\n    agent=researcher,\n    async_execution=True # Will be executed asynchronously\n)\n\nwrite_article = Task(\n    description=\"Write an article about AI, its history, and interesting ideas.\",\n    expected_output=\"A 4 paragraph article about AI.\",\n    agent=writer,\n    context=[list_ideas, list_important_history] # Will wait for the output of the two tasks to be completed\n)\n\n#...\n```\n\nTasks can be executed asynchronously, allowing for parallel processing when appropriate.\nTo create an asynchronous task, set `async_execution=True` when defining the task.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "#...\n\nlist_ideas = Task(\n    description=\"List of 5 interesting ideas to explore for an article about AI.\",\n    expected_output=\"Bullet point list of 5 ideas for an article.\",\n    agent=researcher,\n    async_execution=True # Will be executed asynchronously\n)\n\nlist_important_history = Task(\n    description=\"Research the history of AI and give me the 5 most important events.\",\n    expected_output=\"Bullet point list of 5 important events.\",\n    agent=researcher,\n    async_execution=True # Will be executed asynchronously\n)\n\nwrite_article = Task(\n    description=\"Write an article about AI, its history, and interesting ideas.\",\n    expected_output=\"A 4 paragraph article about AI.\",\n    agent=writer,\n    context=[list_ideas, list_important_history] # Will wait for the output of the two tasks to be completed\n)\n\n#...",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Memory and Caching",
                "level": 3,
                "content": "CrewAI supports both memory and caching features: **Memory**: Enable by setting `memory=True` when creating the Crew. This allows agents to retain information across tasks. **Caching**: By default, caching is enabled. Set `cache=False` to disable it.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Callbacks",
                "level": 3,
                "content": "You can set callbacks at both the task and step level: `task_callback`: Executed after each task completion. `step_callback`: Executed after each step in an agent's execution.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Usage Metrics",
                "level": 3,
                "content": "CrewAI tracks token usage across all tasks and agents. You can access these metrics after execution.",
                "metadata": {
                  "section_type": "Examples",
                  "content_type": "short_description"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Best Practices for Sequential Processes",
            "level": 2,
            "content": "**Order Matters**: Arrange tasks in a logical sequence where each task builds upon the previous one. **Clear Task Descriptions**: Provide detailed descriptions for each task to guide the agents effectively. **Appropriate Agent Selection**: Match agents' skills and roles to the requirements of each task. **Use Context**: Leverage the context from previous tasks to inform subsequent ones. This updated documentation ensures that details accurately reflect the latest changes in the codebase and clearly describes how to leverage new features and configurations.\nThe content is kept simple and direct to ensure easy understanding.",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Weave Integration",
        "level": 1,
        "content": "Source: https://docs.crewai.com/how-to/weave-integration Learn how to use Weights & Biases (W&B) Weave to track, experiment with, evaluate, and improve your CrewAI applications.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "Weave Overview",
        "level": 1,
        "content": "[Weights & Biases (W\\&B) Weave](https://weave-docs.wandb.ai/) is a framework for tracking, experimenting with, evaluating, deploying, and improving LLM-based applications. ![Overview of W\\&B Weave CrewAI tracing usage](https://mintlify.s3.us-west-1.amazonaws.com/crewai/images/weave-tracing.gif) Weave provides comprehensive support for every stage of your CrewAI application development: **Tracing & Monitoring**: Automatically track LLM calls and application logic to debug and analyze production systems **Systematic Iteration**: Refine and iterate on prompts, datasets, and models **Evaluation**: Use custom or pre-built scorers to systematically assess and enhance agent performance **Guardrails**: Protect your agents with pre- and post-safeguards for content moderation and prompt safety Weave automatically captures traces for your CrewAI applications, enabling you to monitor and analyze your agents' performance, interactions, and execution flow. This helps you build better evaluation datasets and optimize your agent workflows.",
        "metadata": {
          "section_type": "Concepts documentation",
          "content_type": "link_list"
        },
        "children": [
          {
            "type": "header",
            "title": "Setup Instructions",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Features",
            "level": 2,
            "content": "**LLM Cost Management and Tracking**: Track spend with foundation model providers. **Replay Analytics**: Watch step-by-step agent execution graphs. **Recursive Thought Detection**: Identify when agents fall into infinite loops. **Custom Reporting**: Create custom analytics on agent performance. **Analytics Dashboard**: Monitor high-level statistics about agents in development and production. **Public Model Testing**: Test your agents against benchmarks and leaderboards. **Custom Tests**: Run your agents against domain-specific tests. **Time Travel Debugging**: Restart your sessions from checkpoints. **Compliance and Security**: Create audit logs and detect potential threats such as profanity and PII leaks. **Prompt Injection Detection**: Identify potential code injection and secret leaks.\n\n**Tracing Dashboard**: Monitor activities of your crewAI agents with detailed dashboards that include inputs, outputs and metadata of spans. **Automated Tracing**: A fully automated integration with crewAI, which can be enabled by running `mlflow.crewai.autolog()`. **Manual Trace Instrumentation with minor efforts**: Customize trace instrumentation through MLflow's high-level fluent APIs such as decorators, function wrappers and context managers. **OpenTelemetry Compatibility**: MLflow Tracing supports exporting traces to an OpenTelemetry Collector, which can then be used to export traces to various backends such as Jaeger, Zipkin, and AWS X-Ray. **Package and Deploy Agents**: Package and deploy your crewAI agents to an inference server with a variety of deployment targets. **Securely Host LLMs**: Host multiple LLM from various providers in one unified endpoint through MFflow gateway. **Evaluation**: Evaluate your crewAI agents with a wide range of metrics using a convenient API `mlflow.evaluate()`.\n\n**Analytics Dashboard**: Monitor your Agents health and performance with detailed dashboards that track metrics, costs, and user interactions. **OpenTelemetry-native Observability SDK**: Vendor-neutral SDKs to send traces and metrics to your existing observability tools like Grafana, DataDog and more. **Cost Tracking for Custom and Fine-Tuned Models**: Tailor cost estimations for specific models using custom pricing files for precise budgeting. **Exceptions Monitoring Dashboard**: Quickly spot and resolve issues by tracking common exceptions and errors with a monitoring dashboard. **Compliance and Security**: Detect potential threats such as profanity and PII leaks. **Prompt Injection Detection**: Identify potential code injection and secret leaks. **API Keys and Secrets Management**: Securely handle your LLM API keys and secrets centrally, avoiding insecure practices. **Prompt Management**: Manage and version Agent prompts using PromptHub for consistent and easy access across Agents. **Model Playground** Test and compare different models for your CrewAI agents before deployment.\n\nWeave automatically captures all CrewAI operations: agent interactions and task executions; LLM calls with metadata and token usage; tool usage and results. The integration supports all CrewAI execution methods: `kickoff()`, `kickoff_for_each()`, `kickoff_async()`, and `kickoff_for_each_async()`. Automatic tracing of all [crewAI-tools](https://github.com/crewAIInc/crewAI-tools). Flow feature support with decorator patching (`@start`, `@listen`, `@router`, `@or_`, `@and_`). Track custom guardrails passed to CrewAI `Task` with `@weave.op()`. For detailed information on what's supported, visit the [Weave CrewAI documentation](https://weave-docs.wandb.ai/guides/integrations/crewai/#getting-started-with-flow).",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Resources",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Installation",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "Installation/Setup",
          "content_type": null
        },
        "children": []
      },
      {
        "type": "header",
        "title": "Creating a CrewAI Project",
        "level": 1,
        "content": "We recommend using the `YAML` template scaffolding for a structured approach to defining agents and tasks. Here's how to get started:",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": [
          {
            "type": "header",
            "title": "Next Steps",
            "level": 2,
            "content": "If you're interested in exploring additional examples of flows, we have a variety of recommendations in our examples repository. Here are four specific flow examples, each showcasing unique use cases to help you match your current problem type to a specific example: **Email Auto Responder Flow**: This example demonstrates an infinite loop where a background job continually runs to automate email responses. It's a great use case for tasks that need to be performed repeatedly without manual intervention. [View Example](https://github.com/crewAIInc/crewAI-examples/tree/main/email_auto_responder_flow) **Lead Score Flow**: This flow showcases adding human-in-the-loop feedback and handling different conditional branches using the router. It's an excellent example of how to incorporate dynamic decision-making and human oversight into your workflows. [View Example](https://github.com/crewAIInc/crewAI-examples/tree/main/lead-score-flow) **Write a Book Flow**: This example excels at chaining multiple crews together, where the output of one crew is used by another. Specifically, one crew outlines an entire book, and another crew generates chapters based on the outline. Eventually, everything is connected to produce a complete book. This flow is perfect for complex, multi-step processes that require coordination between different tasks. [View Example](https://github.com/crewAIInc/crewAI-examples/tree/main/write_a_book_with_flows) **Meeting Assistant Flow**: This flow demonstrates how to broadcast one event to trigger multiple follow-up actions. For instance, after a meeting is completed, the flow can update a Trello board, send a Slack message, and save the results. It's a great example of handling multiple outcomes from a single event, making it ideal for comprehensive task management and notification systems. [View Example](https://github.com/crewAIInc/crewAI-examples/tree/main/meeting_assistant_flow) By exploring these examples, you can gain insights into how to leverage CrewAI Flows for various use cases, from automating repetitive tasks to managing complex, multi-step processes with dynamic decision-making and human feedback. Also, check out our YouTube video on how to use flows in CrewAI below!\n\nExperiment with different agent configurations for your specific use case Learn about [building your first crew](/guides/crews/first-crew) to see how agents work together Explore [CrewAI Flows](/guides/flows/first-flow) for more advanced orchestration\n\nLearn more about [crafting effective agents](/guides/agents/crafting-effective-agents) Explore [building your first crew](/guides/crews/first-crew) Dive into [mastering flow state management](/guides/flows/mastering-flow-state) Check out the [core concepts](/concepts/agents) for deeper understanding\n\nNow that you've built your first crew, you can: Experiment with different agent configurations and personalities Try more complex task structures and workflows Implement custom tools to give your agents new capabilities Apply your crew to different topics or problem domains Explore [CrewAI Flows](/guides/flows/first-flow) for more advanced workflows with procedural programming\n\nNow that you've built your first flow, you can: Experiment with more complex flow structures and patterns Try using `@router()` to create conditional branches in your flows Explore the `and_` and `or_` functions for more complex parallel execution Connect your flow to external APIs, databases, or user interfaces Combine multiple specialized crews in a single flow\n\nExperiment with both structured and unstructured state in your flows Try implementing state persistence for long-running workflows Explore [building your first crew](/guides/crews/first-crew) to see how crews and flows can work together Check out the [Flow reference documentation](/concepts/flows) for more advanced features",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Introduction",
        "level": 1,
        "content": "CrewAI Flows is a powerful feature designed to streamline the creation and management of AI workflows. Flows allow developers to combine and coordinate coding tasks and Crews efficiently, providing a robust framework for building sophisticated AI automations. Flows allow you to create structured, event-driven workflows. They provide a seamless way to connect multiple tasks, manage state, and control the flow of execution in your AI applications. With Flows, you can easily design and implement multi-step processes that leverage the full potential of CrewAI's capabilities. **Simplified Workflow Creation**: Easily chain together multiple Crews and tasks to create complex AI workflows. **State Management**: Flows make it super easy to manage and share state between different tasks in your workflow. **Event-Driven Architecture**: Built on an event-driven model, allowing for dynamic and responsive workflows. **Flexible Control Flow**: Implement conditional logic, loops, and branching within your workflows.\n\nThe planning feature in CrewAI allows you to add planning capability to your crew. When enabled, before each Crew iteration,\nall Crew information is sent to an AgentPlanner that will plan the tasks step by step, and this plan will be added to each task description.\n\nTesting is a crucial part of the development process, and it is essential to ensure that your crew is performing as expected. With crewAI, you can easily test your crew and evaluate its performance using the built-in testing capabilities.\n\nCrewAI tools empower agents with capabilities ranging from web searching and data analysis to collaboration and delegating tasks among coworkers.\nThis documentation outlines how to create, integrate, and leverage these tools within the CrewAI framework, including a new focus on collaboration tools.\n\nThe training feature in CrewAI allows you to train your AI agents using the command-line interface (CLI).\nBy running the command `crewai train -n <n_iterations>`, you can specify the number of iterations for the training process. During training, CrewAI utilizes techniques to optimize the performance of your agents along with human feedback.\nThis helps the agents improve their understanding, decision-making, and problem-solving abilities.\n\nObservability is a key aspect of developing and deploying conversational AI agents. It allows developers to understand how their agents are performing,\nhow their agents are interacting with users, and how their agents use external tools and APIs.\nAgentOps is a product independent of CrewAI that provides a comprehensive observability solution for agents.\n\nCrewAI Agents now have the powerful ability to write and execute code, significantly enhancing their problem-solving capabilities. This feature is particularly useful for tasks that require computational or programmatic solutions.\n\nConditional Tasks in crewAI allow for dynamic workflow adaptation based on the outcomes of previous tasks.\nThis powerful feature enables crews to make decisions and execute tasks selectively, enhancing the flexibility and efficiency of your AI-driven processes.\n\nIn CrewAI, you can force the output of a tool as the result of an agent's task.\nThis feature is useful when you want to ensure that the tool output is captured and returned as the task result, avoiding any agent modification during the task execution.\n\nThe hierarchical process in CrewAI introduces a structured approach to task management, simulating traditional organizational hierarchies for efficient task delegation and execution.\nThis systematic workflow enhances project outcomes by ensuring tasks are handled with optimal efficiency and accuracy.\n\nCrewAI provides the ability to kickoff a crew asynchronously, allowing you to start the crew execution in a non-blocking manner.\nThis feature is particularly useful when you want to run multiple crews concurrently or when you need to perform other tasks while the crew is executing.\n\nCrewAI provides the ability to kickoff a crew for each item in a list, allowing you to execute the crew for each item in the list.\nThis feature is particularly useful when you need to perform the same set of tasks for multiple items.\n\nCrewAI provides the ability to replay from a task specified from the latest crew kickoff. This feature is particularly useful when you've finished a kickoff and may want to retry certain tasks or don't need to refetch data over and your agents already have the context saved from the kickoff execution so you just need to replay the tasks you want to. Here's an example of how to replay from a task:\n\nCrewAI offers a flexible framework for executing tasks in a structured manner, supporting both sequential and hierarchical processes.\nThis guide outlines how to effectively implement these processes to ensure efficient task execution and project completion.\n\nSource: https://docs.crewai.com/introduction Build AI agent teams that work together to tackle complex tasks",
        "metadata": {
          "section_type": "General",
          "content_type": "descriptive_text"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "What is CrewAI?",
        "level": 1,
        "content": "**CrewAI is a lean, lightning-fast Python framework built entirely from scratch\u2014completely independent of LangChain or other agent frameworks.** CrewAI empowers developers with both high-level simplicity and precise low-level control, ideal for creating autonomous AI agents tailored to any scenario: **[CrewAI Crews](/guides/crews/first-crew)**: Optimize for autonomy and collaborative intelligence, enabling you to create AI teams where each agent has specific roles, tools, and goals. **[CrewAI Flows](/guides/flows/first-flow)**: Enable granular, event-driven control, single LLM calls for precise task orchestration and supports Crews natively. With over 100,000 developers certified through our community courses, CrewAI is rapidly becoming the standard for enterprise-ready AI automation.",
        "metadata": {
          "section_type": "General",
          "content_type": "link_list"
        },
        "children": [
          {
            "type": "header",
            "title": "How Crews Work",
            "level": 2,
            "content": "| Component     |         Description        | Key Features                                                                                                                      |\n| :------------ | :------------------------: | :-------------------------------------------------------------------------------------------------------------------------------- |\n| **Crew**      | The top-level organization | \u2022 Manages AI agent teams<br />\u2022 Oversees workflows<br />\u2022 Ensures collaboration<br />\u2022 Delivers outcomes                          |\n| **AI Agents** |  Specialized team members  | \u2022 Have specific roles (researcher, writer)<br />\u2022 Use designated tools<br />\u2022 Can delegate tasks<br />\u2022 Make autonomous decisions |\n| **Process**   | Workflow management system | \u2022 Defines collaboration patterns<br />\u2022 Controls task assignments<br />\u2022 Manages interactions<br />\u2022 Ensures efficient execution  |\n| **Tasks**     |   Individual assignments   | \u2022 Have clear objectives<br />\u2022 Use specific tools<br />\u2022 Feed into larger process<br />\u2022 Produce actionable results               |",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": [
              {
                "type": "header",
                "title": "How It All Works Together",
                "level": 3,
                "content": "The **Crew** organizes the overall operation **AI Agents** work on their specialized tasks The **Process** ensures smooth collaboration **Tasks** get completed to achieve the goal",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Key Features",
            "level": 2,
            "content": "**Task Delegation**: A manager agent allocates tasks among crew members based on their roles and capabilities. **Result Validation**: The manager evaluates outcomes to ensure they meet the required standards. **Efficient Workflow**: Emulates corporate structures, providing an organized approach to task management. **System Prompt Handling**: Optionally specify whether the system should use predefined prompts. **Stop Words Control**: Optionally specify whether stop words should be used, supporting various models including the o1 models. **Context Window Respect**: Prioritize important context by enabling respect of the context window, which is now the default behavior. **Delegation Control**: Delegation is now disabled by default to give users explicit control. **Max Requests Per Minute**: Configurable option to set the maximum number of requests per minute. **Max Iterations**: Limit the maximum number of iterations for obtaining a final answer.\n\n| Feature                    | Description                                                                             |\n| :------------------------- | :-------------------------------------------------------------------------------------- |\n| \ud83c\udf10 Multi-LLM Support       | Access OpenAI, Anthropic, Gemini, Azure, and 250+ providers through a unified interface |\n| \ud83d\udee1\ufe0f Production Reliability | Implement retries, timeouts, load balancing, and fallbacks                              |\n| \ud83d\udcca Advanced Observability  | Track 40+ metrics including costs, tokens, latency, and custom metadata                 |\n| \ud83d\udd0d Comprehensive Logging   | Debug with detailed execution traces and function call logs                             |\n| \ud83d\udea7 Security Controls       | Set budget limits and implement role-based access control                               |\n| \ud83d\udd04 Performance Analytics   | Capture and analyze feedback for continuous improvement                                 |\n| \ud83d\udcbe Intelligent Caching     | Reduce costs and latency with semantic or simple caching                                |\n\n**Linear Task Flow**: Ensures orderly progression by handling tasks in a predetermined sequence. **Simplicity**: Best suited for projects with clear, step-by-step tasks. **Easy Monitoring**: Facilitates easy tracking of task completion and project progress.",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "How Flows Work",
            "level": 2,
            "content": "| Component        |            Description            | Key Features                                                                                                                                                         |\n| :--------------- | :-------------------------------: | :------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Flow**         | Structured workflow orchestration | \u2022 Manages execution paths<br />\u2022 Handles state transitions<br />\u2022 Controls task sequencing<br />\u2022 Ensures reliable execution                                         |\n| **Events**       |   Triggers for workflow actions   | \u2022 Initiate specific processes<br />\u2022 Enable dynamic responses<br />\u2022 Support conditional branching<br />\u2022 Allow for real-time adaptation                             |\n| **States**       |    Workflow execution contexts    | \u2022 Maintain execution data<br />\u2022 Enable persistence<br />\u2022 Support resumability<br />\u2022 Ensure execution integrity                                                    |\n| **Crew Support** |    Enhances workflow automation   | \u2022 Injects pockets of agency when needed<br />\u2022 Complements structured workflows<br />\u2022 Balances automation with intelligence<br />\u2022 Enables adaptive decision-making |",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": [
              {
                "type": "header",
                "title": "Key Capabilities",
                "level": 3,
                "content": "",
                "metadata": {
                  "section_type": "General",
                  "content_type": null
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "When to Use Crews vs. Flows",
            "level": 2,
            "content": "| Use Case                | Recommended Approach              | Why?                                                                                                                                  |\n| :---------------------- | :-------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------ |\n| **Open-ended research** | [Crews](/guides/crews/first-crew) | When tasks require creative thinking, exploration, and adaptation                                                                     |\n| **Content generation**  | [Crews](/guides/crews/first-crew) | For collaborative creation of articles, reports, or marketing materials                                                               |\n| **Decision workflows**  | [Flows](/guides/flows/first-flow) | When you need predictable, auditable decision paths with precise control                                                              |\n| **API orchestration**   | [Flows](/guides/flows/first-flow) | For reliable integration with multiple external services in a specific sequence                                                       |\n| **Hybrid applications** | Combined approach                 | Use [Flows](/guides/flows/first-flow) to orchestrate overall process with [Crews](/guides/crews/first-crew) handling complex subtasks |",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": [
              {
                "type": "header",
                "title": "Decision Framework",
                "level": 3,
                "content": "**Choose [Crews](/guides/crews/first-crew) when:** You need autonomous problem-solving, creative collaboration, or exploratory tasks **Choose [Flows](/guides/flows/first-flow) when:** You require deterministic outcomes, auditability, or precise control over execution **Combine both when:** Your application needs both structured processes and pockets of autonomous intelligence",
                "metadata": {
                  "section_type": "General",
                  "content_type": "link_list"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Why Choose CrewAI?",
            "level": 2,
            "content": "\ud83e\udde0 **Autonomous Operation**: Agents make intelligent decisions based on their roles and available tools \ud83d\udcdd **Natural Interaction**: Agents communicate and collaborate like human team members \ud83d\udee0\ufe0f **Extensible Design**: Easy to add new tools, roles, and capabilities \ud83d\ude80 **Production Ready**: Built for reliability and scalability in real-world applications \ud83d\udd12 **Security-Focused**: Designed with enterprise security requirements in mind \ud83d\udcb0 **Cost-Efficient**: Optimized to minimize token usage and API calls",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Ready to Start Building?",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Quickstart",
        "level": 1,
        "content": "Source: https://docs.crewai.com/quickstart Build your first AI agent with CrewAI in under 5 minutes.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": [
          {
            "type": "header",
            "title": "Build your first CrewAI Agent",
            "level": 2,
            "content": "Let's create a simple crew that will help us `research` and `report` on the `latest AI developments` for a given topic or subject. Before we proceed, make sure you have finished installing CrewAI.\nIf you haven't installed them yet, you can do so by following the [installation guide](/installation). Follow the steps below to get Crewing! \ud83d\udea3\u200d\u2642\ufe0f You have successfully set up your crew project and are ready to start building your own agentic workflows!\n</Check>",
            "metadata": {
              "section_type": "General",
              "content_type": "link_list"
            },
            "children": [
              {
                "type": "header",
                "title": "Note on Consistency in Naming",
                "level": 3,
                "content": "The names you use in your YAML files (`agents.yaml` and `tasks.yaml`) should match the method names in your Python code.\nFor example, you can reference the agent for specific tasks from `tasks.yaml` file.\nThis naming consistency allows CrewAI to automatically link your configurations with your code; otherwise, your task won't recognize the reference properly.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "descriptive_text"
                },
                "children": [
                  {
                    "type": "header",
                    "title": "Example References",
                    "level": 4,
                    "content": "```\nemail_summarizer:\n    role: >\n      Email Summarizer\n    goal: >\n      Summarize emails into a concise and clear summary\n    backstory: >\n      You will create a 5 bullet point summary of the report\n    llm: openai/gpt-4o\n```\n\n```\nemail_summarizer_task:\n    description: >\n      Summarize the email into a 5 bullet point summary\n    expected_output: >\n      A 5 bullet point summary of the email\n    agent: email_summarizer\n    context:\n      - reporting_task\n      - research_task\n```",
                    "metadata": {
                      "section_type": "Examples",
                      "content_type": "code_example"
                    },
                    "children": [],
                    "code_blocks": [
                      {
                        "type": "code_block",
                        "language": "yaml agents.yaml",
                        "content": "email_summarizer:\n    role: >\n      Email Summarizer\n    goal: >\n      Summarize emails into a concise and clear summary\n    backstory: >\n      You will create a 5 bullet point summary of the report\n    llm: openai/gpt-4o",
                        "metadata": {
                          "section_type": "code",
                          "content_type": "code_example"
                        },
                        "children": []
                      },
                      {
                        "type": "code_block",
                        "language": "yaml tasks.yaml",
                        "content": "email_summarizer_task:\n    description: >\n      Summarize the email into a 5 bullet point summary\n    expected_output: >\n      A 5 bullet point summary of the email\n    agent: email_summarizer\n    context:\n      - reporting_task\n      - research_task",
                        "metadata": {
                          "section_type": "code",
                          "content_type": "code_example"
                        },
                        "children": []
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "header",
            "title": "Deploying Your Project",
            "level": 2,
            "content": "The easiest way to deploy your crew is through [CrewAI Enterprise](http://app.crewai.com), where you can deploy your crew in a few clicks.",
            "metadata": {
              "section_type": "General",
              "content_type": "link_list"
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Telemetry",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Telemetry",
            "level": 2,
            "content": "Source: https://docs.crewai.com/telemetry Understanding the telemetry data collected by CrewAI and how it contributes to the enhancement of the library.\n\nCrewAI utilizes anonymous telemetry to gather usage statistics with the primary goal of enhancing the library.\nOur focus is on improving and developing the features, integrations, and tools most utilized by our users. It's pivotal to understand that by default, **NO personal data is collected** concerning prompts, task descriptions, agents' backstories or goals,\nusage of tools, API calls, responses, any data processed by the agents, or secrets and environment variables.\nWhen the `share_crew` feature is enabled, detailed data including task descriptions, agents' backstories or goals, and other specific attributes are collected\nto provide deeper insights. This expanded data collection may include personal information if users have incorporated it into their crews or tasks.\nUsers should carefully consider the content of their crews and tasks before enabling `share_crew`.\nUsers can disable telemetry by setting the environment variable `OTEL_SDK_DISABLED` to `true`.",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": [
              {
                "type": "header",
                "title": "Data Explanation:",
                "level": 3,
                "content": "| Defaulted | Data                                     | Reason and Specifics                                                                                                                                                                                                                                                                                             |\n| --------- | ---------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Yes       | CrewAI and Python Version                | Tracks software versions. Example: CrewAI v1.2.3, Python 3.8.10. No personal data.                                                                                                                                                                                                                               |\n| Yes       | Crew Metadata                            | Includes: randomly generated key and ID, process type (e.g., 'sequential', 'parallel'), boolean flag for memory usage (true/false), count of tasks, count of agents. All non-personal.                                                                                                                           |\n| Yes       | Agent Data                               | Includes: randomly generated key and ID, role name (should not include personal info), boolean settings (verbose, delegation enabled, code execution allowed), max iterations, max RPM, max retry limit, LLM info (see LLM Attributes), list of tool names (should not include personal info). No personal data. |\n| Yes       | Task Metadata                            | Includes: randomly generated key and ID, boolean execution settings (async\\_execution, human\\_input), associated agent's role and key, list of tool names. All non-personal.                                                                                                                                     |\n| Yes       | Tool Usage Statistics                    | Includes: tool name (should not include personal info), number of usage attempts (integer), LLM attributes used. No personal data.                                                                                                                                                                               |\n| Yes       | Test Execution Data                      | Includes: crew's randomly generated key and ID, number of iterations, model name used, quality score (float), execution time (in seconds). All non-personal.                                                                                                                                                     |\n| Yes       | Task Lifecycle Data                      | Includes: creation and execution start/end times, crew and task identifiers. Stored as spans with timestamps. No personal data.                                                                                                                                                                                  |\n| Yes       | LLM Attributes                           | Includes: name, model\\_name, model, top\\_k, temperature, and class name of the LLM. All technical, non-personal data.                                                                                                                                                                                            |\n| Yes       | Crew Deployment attempt using crewAI CLI | Includes: The fact a deploy is being made and crew id, and if it's trying to pull logs, no other data.                                                                                                                                                                                                           |\n| No        | Agent's Expanded Data                    | Includes: goal description, backstory text, i18n prompt file identifier. Users should ensure no personal info is included in text fields.                                                                                                                                                                        |\n| No        | Detailed Task Information                | Includes: task description, expected output description, context references. Users should ensure no personal info is included in these fields.                                                                                                                                                                   |\n| No        | Environment Information                  | Includes: platform, release, system, version, and CPU count. Example: 'Windows 10', 'x86\\_64'. No personal data.                                                                                                                                                                                                 |\n| No        | Crew and Task Inputs and Outputs         | Includes: input parameters and output results as non-identifiable data. Users should ensure no personal info is included.                                                                                                                                                                                        |\n| No        | Comprehensive Crew Execution Data        | Includes: detailed logs of crew operations, all agents and tasks data, final output. All non-personal and technical in nature.                                                                                                                                                                                   |",
                "metadata": {
                  "section_type": "General",
                  "content_type": "descriptive_text"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Opt-In Further Telemetry Sharing",
                "level": 3,
                "content": "Users can choose to share their complete telemetry data by enabling the `share_crew` attribute to `True` in their crew configurations.\nEnabling `share_crew` results in the collection of detailed crew and task execution data, including `goal`, `backstory`, `context`, and `output` of tasks.\nThis enables a deeper insight into usage patterns.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          }
        ]
      },
      {
        "type": "header",
        "title": "AI Mind Tool",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/aimindtool The `AIMindTool` is designed to query data sources in natural language.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`AIMindTool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Steps to Get Started",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Parameters",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Agent Integration Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Conclusion",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Apify Actors",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/apifyactorstool `ApifyActorsTool` lets you call Apify Actors to provide your CrewAI workflows with web scraping, crawling, data extraction, and web automation capabilities.",
        "metadata": {
          "section_type": "API documentation",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`ApifyActorsTool`",
        "level": 1,
        "content": "Integrate [Apify Actors](https://apify.com/actors) into your CrewAI workflows.",
        "metadata": {
          "section_type": "API documentation",
          "content_type": "link_list"
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Steps to get started",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Usage example",
            "level": 2,
            "content": "Use the `ApifyActorsTool` manually to run the [RAG Web Browser Actor](https://apify.com/apify/rag-web-browser) to perform a web search:\n```\nfrom crewai_tools import ApifyActorsTool\n\n# Initialize the tool with an Apify Actor\ntool = ApifyActorsTool(actor_name=\"apify/rag-web-browser\")\n\n# Run the tool with input parameters\nresults = tool.run(run_input={\"query\": \"What is CrewAI?\", \"maxResults\": 5})\n\n# Process the results\nfor result in results:\n    print(f\"URL: {result['metadata']['url']}\")\n    print(f\"Content: {result.get('markdown', 'N/A')[:100]}...\")\n```",
            "metadata": {
              "section_type": "Examples",
              "content_type": "code_example"
            },
            "children": [
              {
                "type": "header",
                "title": "Expected output",
                "level": 3,
                "content": "Here is the output from running the code above:\n```\nURL: https://www.example.com/crewai-intro\nContent: CrewAI is a framework for building AI-powered workflows...\nURL: https://docs.crewai.com/\nContent: Official documentation for CrewAI...\n```\nThe `ApifyActorsTool` automatically fetches the Actor definition and input schema from Apify using the provided `actor_name` and then constructs the tool description and argument schema. This means you need to specify only a valid `actor_name`, and the tool handles the rest when used with agents\u2014no need to specify the `run_input`. Here's how it works:\n```\nfrom crewai import Agent\nfrom crewai_tools import ApifyActorsTool\n\nrag_browser = ApifyActorsTool(actor_name=\"apify/rag-web-browser\")\n\nagent = Agent(\n    role=\"Research Analyst\",\n    goal=\"Find and summarize information about specific topics\",\n    backstory=\"You are an experienced researcher with attention to detail\",\n    tools=[rag_browser],\n)\n```\nYou can run other Actors from [Apify Store](https://apify.com/store) simply by changing the `actor_name` and, when using it manually, adjusting the `run_input` based on the Actor input schema. For an example of usage with agents, see the [CrewAI Actor template](https://apify.com/templates/python-crewai).",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "text",
                    "content": "URL: https://www.example.com/crewai-intro\nContent: CrewAI is a framework for building AI-powered workflows...\nURL: https://docs.crewai.com/\nContent: Official documentation for CrewAI...",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  },
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "from crewai import Agent\nfrom crewai_tools import ApifyActorsTool\n\nrag_browser = ApifyActorsTool(actor_name=\"apify/rag-web-browser\")\n\nagent = Agent(\n    role=\"Research Analyst\",\n    goal=\"Find and summarize information about specific topics\",\n    backstory=\"You are an experienced researcher with attention to detail\",\n    tools=[rag_browser],\n)",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              }
            ],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python",
                "content": "from crewai_tools import ApifyActorsTool\n\n# Initialize the tool with an Apify Actor\ntool = ApifyActorsTool(actor_name=\"apify/rag-web-browser\")\n\n# Run the tool with input parameters\nresults = tool.run(run_input={\"query\": \"What is CrewAI?\", \"maxResults\": 5})\n\n# Process the results\nfor result in results:\n    print(f\"URL: {result['metadata']['url']}\")\n    print(f\"Content: {result.get('markdown', 'N/A')[:100]}...\")",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Configuration",
            "level": 2,
            "content": "The `ApifyActorsTool` requires these inputs to work: **`actor_name`**\nThe ID of the Apify Actor to run, e.g., `\"apify/rag-web-browser\"`. Browse all Actors on [Apify Store](https://apify.com/store). **`run_input`**\nA dictionary of input parameters for the Actor when running the tool manually. For example, for the `apify/rag-web-browser` Actor: `{\"query\": \"search term\", \"maxResults\": 5}` See the Actor's [input schema](https://apify.com/apify/rag-web-browser/input-schema) for the list of input parameters.",
            "metadata": {
              "section_type": "General",
              "content_type": "link_list"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Resources",
            "level": 2,
            "content": "[\ud83e\udd89 Opik Documentation](https://www.comet.com/docs/opik/) [\ud83d\udc49 Opik + CrewAI Colab](https://colab.research.google.com/github/comet-ml/opik/blob/main/apps/opik-documentation/documentation/docs/cookbook/crewai.ipynb) [\ud83d\udc26 X](https://x.com/cometml) [\ud83d\udcac Slack](https://slack.comet.com/)\n\n[\ud83d\udcd8 Portkey Documentation](https://docs.portkey.ai) [\ud83d\udcca Portkey Dashboard](https://app.portkey.ai/?utm_source=crewai\\&utm_medium=crewai\\&utm_campaign=crewai) [\ud83d\udc26 Twitter](https://twitter.com/portkeyai) [\ud83d\udcac Discord Community](https://discord.gg/DD7vgKK299)\n\n[\ud83d\udcd8 Weave Documentation](https://weave-docs.wandb.ai) [\ud83d\udcca Example Weave x CrewAI dashboard](https://wandb.ai/ayut/crewai_demo/weave/traces?cols=%7B%22wb_run_id%22%3Afalse%2C%22attributes.weave.client_version%22%3Afalse%2C%22attributes.weave.os_name%22%3Afalse%2C%22attributes.weave.os_release%22%3Afalse%2C%22attributes.weave.os_version%22%3Afalse%2C%22attributes.weave.source%22%3Afalse%2C%22attributes.weave.sys_version%22%3Afalse%7D\\&peekPath=%2Fayut%2Fcrewai_demo%2Fcalls%2F0195c838-38cb-71a2-8a15-651ecddf9d89) [\ud83d\udc26 X](https://x.com/weave_wb)\n\n**[Apify](https://apify.com/)**: Explore the Apify platform. **[How to build an AI agent on Apify](https://blog.apify.com/how-to-build-an-ai-agent/)** - A complete step-by-step guide to creating, publishing, and monetizing AI agents on the Apify platform. **[RAG Web Browser Actor](https://apify.com/apify/rag-web-browser)**: A popular Actor for web search for LLMs. **[CrewAI Integration Guide](https://docs.apify.com/platform/integrations/crewai)**: Follow the official guide for integrating Apify and CrewAI.",
            "metadata": {
              "section_type": "General",
              "content_type": "link_list"
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Bedrock Invoke Agent Tool",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/bedrockinvokeagenttool Enables CrewAI agents to invoke Amazon Bedrock Agents and leverage their capabilities within your workflows",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`BedrockInvokeAgentTool`",
        "level": 1,
        "content": "The `BedrockInvokeAgentTool` enables CrewAI agents to invoke Amazon Bedrock Agents and leverage their capabilities within your workflows.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": [
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Requirements",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Usage",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Tool Arguments",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Environment Variables",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Advanced Usage",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": [
              {
                "type": "header",
                "title": "Multi-Agent Workflow with Session Management",
                "level": 3,
                "content": "```\nfrom crewai import Agent, Task, Crew, Process\nfrom crewai_tools.aws.bedrock.agents.invoke_agent_tool import BedrockInvokeAgentTool\n\n# Initialize tools with session management\ninitial_tool = BedrockInvokeAgentTool(\n    agent_id=\"your-agent-id\",\n    agent_alias_id=\"your-agent-alias-id\",\n    session_id=\"custom-session-id\"\n)\n\nfollowup_tool = BedrockInvokeAgentTool(\n    agent_id=\"your-agent-id\",\n    agent_alias_id=\"your-agent-alias-id\",\n    session_id=\"custom-session-id\"\n)\n\nfinal_tool = BedrockInvokeAgentTool(\n    agent_id=\"your-agent-id\",\n    agent_alias_id=\"your-agent-alias-id\",\n    session_id=\"custom-session-id\",\n    end_session=True\n)\n\n# Create agents for different stages\nresearcher = Agent(\n    role='AWS Service Researcher',\n    goal='Gather information about AWS services',\n    backstory='I am specialized in finding detailed AWS service information.',\n    tools=[initial_tool]\n)\n\nanalyst = Agent(\n    role='Service Compatibility Analyst',\n    goal='Analyze service compatibility and requirements',\n    backstory='I analyze AWS services for compatibility and integration possibilities.',\n    tools=[followup_tool]\n)\n\nsummarizer = Agent(\n    role='Technical Documentation Writer',\n    goal='Create clear technical summaries',\n    backstory='I specialize in creating clear, concise technical documentation.',\n    tools=[final_tool]\n)\n\n# Create tasks\nresearch_task = Task(\n    description=\"Find all available AWS services in us-west-2 region.\",\n    agent=researcher\n)\n\nanalysis_task = Task(\n    description=\"Analyze which services support IPv6 and their implementation requirements.\",\n    agent=analyst\n)\n\nsummary_task = Task(\n    description=\"Create a summary of IPv6-compatible services and their key features.\",\n    agent=summarizer\n)\n\n# Create a crew with the agents and tasks\ncrew = Crew(\n    agents=[researcher, analyst, summarizer],\n    tasks=[research_task, analysis_task, summary_task],\n    process=Process.sequential,\n    verbose=2\n)\n\n# Run the crew\nresult = crew.kickoff()\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python {2, 4-22}",
                    "content": "from crewai import Agent, Task, Crew, Process\nfrom crewai_tools.aws.bedrock.agents.invoke_agent_tool import BedrockInvokeAgentTool\n\n# Initialize tools with session management\ninitial_tool = BedrockInvokeAgentTool(\n    agent_id=\"your-agent-id\",\n    agent_alias_id=\"your-agent-alias-id\",\n    session_id=\"custom-session-id\"\n)\n\nfollowup_tool = BedrockInvokeAgentTool(\n    agent_id=\"your-agent-id\",\n    agent_alias_id=\"your-agent-alias-id\",\n    session_id=\"custom-session-id\"\n)\n\nfinal_tool = BedrockInvokeAgentTool(\n    agent_id=\"your-agent-id\",\n    agent_alias_id=\"your-agent-alias-id\",\n    session_id=\"custom-session-id\",\n    end_session=True\n)\n\n# Create agents for different stages\nresearcher = Agent(\n    role='AWS Service Researcher',\n    goal='Gather information about AWS services',\n    backstory='I am specialized in finding detailed AWS service information.',\n    tools=[initial_tool]\n)\n\nanalyst = Agent(\n    role='Service Compatibility Analyst',\n    goal='Analyze service compatibility and requirements',\n    backstory='I analyze AWS services for compatibility and integration possibilities.',\n    tools=[followup_tool]\n)\n\nsummarizer = Agent(\n    role='Technical Documentation Writer',\n    goal='Create clear technical summaries',\n    backstory='I specialize in creating clear, concise technical documentation.',\n    tools=[final_tool]\n)\n\n# Create tasks\nresearch_task = Task(\n    description=\"Find all available AWS services in us-west-2 region.\",\n    agent=researcher\n)\n\nanalysis_task = Task(\n    description=\"Analyze which services support IPv6 and their implementation requirements.\",\n    agent=analyst\n)\n\nsummary_task = Task(\n    description=\"Create a summary of IPv6-compatible services and their key features.\",\n    agent=summarizer\n)\n\n# Create a crew with the agents and tasks\ncrew = Crew(\n    agents=[researcher, analyst, summarizer],\n    tasks=[research_task, analysis_task, summary_task],\n    process=Process.sequential,\n    verbose=2\n)\n\n# Run the crew\nresult = crew.kickoff()",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              }
            ]
          },
          {
            "type": "header",
            "title": "Use Cases",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": [
              {
                "type": "header",
                "title": "Hybrid Multi-Agent Collaborations",
                "level": 3,
                "content": "Create workflows where CrewAI agents collaborate with managed Bedrock agents running as services in AWS Enable scenarios where sensitive data processing happens within your AWS environment while other agents operate externally Bridge on-premises CrewAI agents with cloud-based Bedrock agents for distributed intelligence workflows",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Data Sovereignty and Compliance",
                "level": 3,
                "content": "Keep data-sensitive agentic workflows within your AWS environment while allowing external CrewAI agents to orchestrate tasks Maintain compliance with data residency requirements by processing sensitive information only within your AWS account Enable secure multi-agent collaborations where some agents cannot access your organization's private data",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Seamless AWS Service Integration",
                "level": 3,
                "content": "Access any AWS service through Amazon Bedrock Actions without writing complex integration code Enable CrewAI agents to interact with AWS services through natural language requests Leverage pre-built Bedrock agent capabilities to interact with AWS services like Bedrock Knowledge Bases, Lambda, and more",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Scalable Hybrid Agent Architectures",
                "level": 3,
                "content": "Offload computationally intensive tasks to managed Bedrock agents while lightweight tasks run in CrewAI Scale agent processing by distributing workloads between local CrewAI agents and cloud-based Bedrock agents",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Cross-Organizational Agent Collaboration",
                "level": 3,
                "content": "Enable secure collaboration between your organization's CrewAI agents and partner organizations' Bedrock agents Create workflows where external expertise from Bedrock agents can be incorporated without exposing sensitive data Build agent ecosystems that span organizational boundaries while maintaining security and data control",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              }
            ]
          }
        ]
      },
      {
        "type": "header",
        "title": "Bedrock Knowledge Base Retriever",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/bedrockkbretriever Retrieve information from Amazon Bedrock Knowledge Bases using natural language queries",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`BedrockKBRetrieverTool`",
        "level": 1,
        "content": "The `BedrockKBRetrieverTool` enables CrewAI agents to retrieve information from Amazon Bedrock Knowledge Bases using natural language queries.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": [
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Requirements",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Usage",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Tool Arguments",
            "level": 2,
            "content": "| Argument             | Type   | Required | Default   | Description                                 |\n| :------------------- | :----- | :------- | :-------- | :------------------------------------------ |\n| **agent\\_id**        | `str`  | Yes      | None      | The unique identifier of the Bedrock agent  |\n| **agent\\_alias\\_id** | `str`  | Yes      | None      | The unique identifier of the agent alias    |\n| **session\\_id**      | `str`  | No       | timestamp | The unique identifier of the session        |\n| **enable\\_trace**    | `bool` | No       | False     | Whether to enable trace for debugging       |\n| **end\\_session**     | `bool` | No       | False     | Whether to end the session after invocation |\n| **description**      | `str`  | No       | None      | Custom description for the tool             |\n\n| Argument                     | Type   | Required | Default | Description                                                                |\n| :--------------------------- | :----- | :------- | :------ | :------------------------------------------------------------------------- |\n| **knowledge\\_base\\_id**      | `str`  | Yes      | None    | The unique identifier of the knowledge base (0-10 alphanumeric characters) |\n| **number\\_of\\_results**      | `int`  | No       | 5       | Maximum number of results to return                                        |\n| **retrieval\\_configuration** | `dict` | No       | None    | Custom configurations for the knowledge base query                         |\n| **guardrail\\_configuration** | `dict` | No       | None    | Content filtering settings                                                 |\n| **next\\_token**              | `str`  | No       | None    | Token for pagination                                                       |",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Environment Variables",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Response Format",
            "level": 2,
            "content": "The tool returns results in JSON format:\n```\n{\n  \"results\": [\n    {\n      \"content\": \"Retrieved text content\",\n      \"content_type\": \"text\",\n      \"source_type\": \"S3\",\n      \"source_uri\": \"s3://bucket/document.pdf\",\n      \"score\": 0.95,\n      \"metadata\": {\n        \"additional\": \"metadata\"\n      }\n    }\n  ],\n  \"nextToken\": \"pagination-token\",\n  \"guardrailAction\": \"NONE\"\n}\n```",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "json",
                "content": "{\n  \"results\": [\n    {\n      \"content\": \"Retrieved text content\",\n      \"content_type\": \"text\",\n      \"source_type\": \"S3\",\n      \"source_uri\": \"s3://bucket/document.pdf\",\n      \"score\": 0.95,\n      \"metadata\": {\n        \"additional\": \"metadata\"\n      }\n    }\n  ],\n  \"nextToken\": \"pagination-token\",\n  \"guardrailAction\": \"NONE\"\n}",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Advanced Usage",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": [
              {
                "type": "header",
                "title": "Custom Retrieval Configuration",
                "level": 3,
                "content": "```\nkb_tool = BedrockKBRetrieverTool(\n    knowledge_base_id=\"your-kb-id\",\n    retrieval_configuration={\n        \"vectorSearchConfiguration\": {\n            \"numberOfResults\": 10,\n            \"overrideSearchType\": \"HYBRID\"\n        }\n    }\n)\n\npolicy_expert = Agent(\n    role='Policy Expert',\n    goal='Analyze company policies in detail',\n    backstory='I am an expert in corporate policy analysis with deep knowledge of regulatory requirements.',\n    tools=[kb_tool]\n)\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python",
                    "content": "kb_tool = BedrockKBRetrieverTool(\n    knowledge_base_id=\"your-kb-id\",\n    retrieval_configuration={\n        \"vectorSearchConfiguration\": {\n            \"numberOfResults\": 10,\n            \"overrideSearchType\": \"HYBRID\"\n        }\n    }\n)\n\npolicy_expert = Agent(\n    role='Policy Expert',\n    goal='Analyze company policies in detail',\n    backstory='I am an expert in corporate policy analysis with deep knowledge of regulatory requirements.',\n    tools=[kb_tool]\n)",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              }
            ]
          },
          {
            "type": "header",
            "title": "Supported Data Sources",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Use Cases",
            "level": 2,
            "content": "Event listeners can be used for a variety of purposes: **Logging and Monitoring**: Track the execution of your Crew and log important events **Analytics**: Collect data about your Crew's performance and behavior **Debugging**: Set up temporary listeners to debug specific issues **Integration**: Connect CrewAI with external systems like monitoring platforms, databases, or notification services **Custom Behavior**: Trigger custom actions based on specific events",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": [
              {
                "type": "header",
                "title": "Enterprise Knowledge Integration",
                "level": 3,
                "content": "Enable CrewAI agents to access your organization's proprietary knowledge without exposing sensitive data Allow agents to make decisions based on your company's specific policies, procedures, and documentation Create agents that can answer questions based on your internal documentation while maintaining data security",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Specialized Domain Knowledge",
                "level": 3,
                "content": "Connect CrewAI agents to domain-specific knowledge bases (legal, medical, technical) without retraining models Leverage existing knowledge repositories that are already maintained in your AWS environment Combine CrewAI's reasoning with domain-specific information from your knowledge bases",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Data-Driven Decision Making",
                "level": 3,
                "content": "Ground CrewAI agent responses in your actual company data rather than general knowledge Ensure agents provide recommendations based on your specific business context and documentation Reduce hallucinations by retrieving factual information from your knowledge bases",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Scalable Information Access",
                "level": 3,
                "content": "Access terabytes of organizational knowledge without embedding it all into your models Dynamically query only the relevant information needed for specific tasks Leverage AWS's scalable infrastructure to handle large knowledge bases efficiently",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Compliance and Governance",
                "level": 3,
                "content": "Ensure CrewAI agents provide responses that align with your company's approved documentation Create auditable trails of information sources used by your agents Maintain control over what information sources your agents can access",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              }
            ]
          }
        ]
      },
      {
        "type": "header",
        "title": "Brave Search",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/bravesearchtool The `BraveSearchTool` is designed to search the internet using the Brave Search API.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`BraveSearchTool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Steps to Get Started",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Parameters",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example with Parameters",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Agent Integration Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Conclusion",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Browserbase Web Loader",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/browserbaseloadtool Browserbase is a developer platform to reliably run, manage, and monitor headless browsers.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`BrowserbaseLoadTool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Arguments",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Code Docs RAG Search",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/codedocssearchtool The `CodeDocsSearchTool` is a powerful RAG (Retrieval-Augmented Generation) tool designed for semantic searches within code documentation.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`CodeDocsSearchTool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Arguments",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Custom model and embeddings",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Code Interpreter",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/codeinterpretertool The `CodeInterpreterTool` is a powerful tool designed for executing Python 3 code within a secure, isolated environment.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`CodeInterpreterTool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Requirements",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Parameters",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Agent Integration Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Implementation Details",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Security Considerations",
            "level": 2,
            "content": "When configuring memory storage: Use environment variables for storage paths (e.g., `CREWAI_STORAGE_DIR`) Never hardcode sensitive information like database credentials Consider access permissions for storage directories Use relative paths when possible to maintain portability Example using environment variables:\n```\nimport os\nfrom crewai import Crew\nfrom crewai.memory import LongTermMemory\nfrom crewai.memory.storage.ltm_sqlite_storage import LTMSQLiteStorage\n\n# Configure storage path using environment variable\nstorage_path = os.getenv(\"CREWAI_STORAGE_DIR\", \"./storage\")\ncrew = Crew(\n    memory=True,\n    long_term_memory=LongTermMemory(\n        storage=LTMSQLiteStorage(\n            db_path=\"{storage_path}/memory.db\".format(storage_path=storage_path)\n        )\n    )\n)\n```\n\nBy default, the `CodeInterpreterTool` runs code in an isolated Docker container, which provides a layer of security. However, there are still some security considerations to keep in mind: The Docker container has access to the current working directory, so sensitive files could potentially be accessed. The `unsafe_mode` parameter allows code to be executed directly on the host machine, which should only be used in trusted environments. Be cautious when allowing agents to install arbitrary libraries, as they could potentially include malicious code.",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python",
                "content": "import os\nfrom crewai import Crew\nfrom crewai.memory import LongTermMemory\nfrom crewai.memory.storage.ltm_sqlite_storage import LTMSQLiteStorage\n\n# Configure storage path using environment variable\nstorage_path = os.getenv(\"CREWAI_STORAGE_DIR\", \"./storage\")\ncrew = Crew(\n    memory=True,\n    long_term_memory=LongTermMemory(\n        storage=LTMSQLiteStorage(\n            db_path=\"{storage_path}/memory.db\".format(storage_path=storage_path)\n        )\n    )\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Conclusion",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Composio Tool",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/composiotool Composio provides 250+ production-ready tools for AI agents with flexible authentication management.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`ComposioToolSet`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "CSV RAG Search",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/csvsearchtool The `CSVSearchTool` is a powerful RAG (Retrieval-Augmented Generation) tool designed for semantic searches within a CSV file's content.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`CSVSearchTool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Arguments",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Custom model and embeddings",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "DALL-E Tool",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/dalletool The `DallETool` is a powerful tool designed for generating images from textual descriptions.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`DallETool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Directory Read",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/directoryreadtool The `DirectoryReadTool` is a powerful utility designed to provide a comprehensive listing of directory contents.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`DirectoryReadTool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Arguments",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Directory RAG Search",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/directorysearchtool The `DirectorySearchTool` is a powerful RAG (Retrieval-Augmented Generation) tool designed for semantic searches within a directory's content.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`DirectorySearchTool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Initialization and Usage",
            "level": 2,
            "content": "Import the DirectorySearchTool from the `crewai_tools` package to start. You can initialize the tool without specifying a directory, enabling the setting of the search directory at runtime. Alternatively, the tool can be initialized with a predefined directory.\n```\nfrom crewai_tools import DirectorySearchTool\n\n# For dynamic directory specification at runtime\ntool = DirectorySearchTool()\n\n# For fixed directory searches\ntool = DirectorySearchTool(directory='/path/to/directory')\n```",
            "metadata": {
              "section_type": "Examples",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai_tools import DirectorySearchTool\n\n# For dynamic directory specification at runtime\ntool = DirectorySearchTool()\n\n# For fixed directory searches\ntool = DirectorySearchTool(directory='/path/to/directory')",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Arguments",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Custom Model and Embeddings",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "DOCX RAG Search",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/docxsearchtool The `DOCXSearchTool` is a RAG tool designed for semantic searching within DOCX documents.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`DOCXSearchTool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Arguments",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Custom model and embeddings",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "EXA Search Web Loader",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/exasearchtool The `EXASearchTool` is designed to perform a semantic search for a specified query from a text's content across the internet.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`EXASearchTool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Steps to Get Started",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Conclusion",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "File Read",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/filereadtool The `FileReadTool` is designed to read files from the local file system.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`FileReadTool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Usage Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Arguments",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "File Write",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/filewritetool The `FileWriterTool` is designed to write content to files.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`FileWriterTool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Arguments",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Conclusion",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Firecrawl Crawl Website",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/firecrawlcrawlwebsitetool The `FirecrawlCrawlWebsiteTool` is designed to crawl and convert websites into clean markdown or structured data.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`FirecrawlCrawlWebsiteTool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Arguments",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Firecrawl Scrape Website",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/firecrawlscrapewebsitetool The `FirecrawlScrapeWebsiteTool` is designed to scrape websites and convert them into clean markdown or structured data.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`FirecrawlScrapeWebsiteTool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Arguments",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Firecrawl Search",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/firecrawlsearchtool The `FirecrawlSearchTool` is designed to search websites and convert them into clean markdown or structured data.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`FirecrawlSearchTool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Arguments",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Github Search",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/githubsearchtool The `GithubSearchTool` is designed to search websites and convert them into clean markdown or structured data.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`GithubSearchTool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Arguments",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Custom model and embeddings",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Hyperbrowser Load Tool",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/hyperbrowserloadtool The `HyperbrowserLoadTool` enables web scraping and crawling using Hyperbrowser.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`HyperbrowserLoadTool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Steps to Get Started",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Parameters",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": [
              {
                "type": "header",
                "title": "Constructor Parameters",
                "level": 3,
                "content": "",
                "metadata": {
                  "section_type": "General",
                  "content_type": null
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Run Parameters",
                "level": 3,
                "content": "",
                "metadata": {
                  "section_type": "General",
                  "content_type": null
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Supported Parameters",
            "level": 2,
            "content": "For detailed information on all supported parameters, visit: [Scrape Parameters](https://docs.hyperbrowser.ai/reference/sdks/python/scrape#start-scrape-job-and-wait) [Crawl Parameters](https://docs.hyperbrowser.ai/reference/sdks/python/crawl#start-crawl-job-and-wait)",
            "metadata": {
              "section_type": "General",
              "content_type": "link_list"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Return Format",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Conclusion",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "JSON RAG Search",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/jsonsearchtool The `JSONSearchTool` is designed to search JSON files and return the most relevant results.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`JSONSearchTool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Usage Examples",
            "level": 2,
            "content": "Here are updated examples on how to utilize the JSONSearchTool effectively for searching within JSON files. These examples take into account the current implementation and usage patterns identified in the codebase.\n```\nfrom crewai.json_tools import JSONSearchTool  # Updated import path\n\n# General JSON content search\n# This approach is suitable when the JSON path is either known beforehand or can be dynamically identified.\ntool = JSONSearchTool()\n\n# Restricting search to a specific JSON file\n# Use this initialization method when you want to limit the search scope to a specific JSON file.\ntool = JSONSearchTool(json_path='./path/to/your/file.json')\n```",
            "metadata": {
              "section_type": "Examples",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai.json_tools import JSONSearchTool  # Updated import path\n\n# General JSON content search\n# This approach is suitable when the JSON path is either known beforehand or can be dynamically identified.\ntool = JSONSearchTool()\n\n# Restricting search to a specific JSON file\n# Use this initialization method when you want to limit the search scope to a specific JSON file.\ntool = JSONSearchTool(json_path='./path/to/your/file.json')",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Arguments",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Configuration Options",
            "level": 2,
            "content": "When configuring an LLM for your agent, you have access to a wide range of parameters: | Parameter              |        Type        | Description                                                      |\n| :--------------------- | :----------------: | :--------------------------------------------------------------- |\n| **model**              |        `str`       | The name of the model to use (e.g., \"gpt-4\", \"claude-2\")         |\n| **temperature**        |       `float`      | Controls randomness in output (0.0 to 1.0)                       |\n| **max\\_tokens**        |        `int`       | Maximum number of tokens to generate                             |\n| **top\\_p**             |       `float`      | Controls diversity of output (0.0 to 1.0)                        |\n| **frequency\\_penalty** |       `float`      | Penalizes new tokens based on their frequency in the text so far |\n| **presence\\_penalty**  |       `float`      | Penalizes new tokens based on their presence in the text so far  |\n| **stop**               | `str`, `List[str]` | Sequence(s) to stop generation                                   |\n| **base\\_url**          |        `str`       | The base URL for the API endpoint                                |\n| **api\\_key**           |        `str`       | Your API key for authentication                                  | For a complete list of parameters and their descriptions, refer to the LLM class documentation.\n\nThe JSONSearchTool supports extensive customization through a configuration dictionary. This allows users to select different models for embeddings and summarization based on their requirements.\n```\ntool = JSONSearchTool(\n    config={\n        \"llm\": {\n            \"provider\": \"ollama\",  # Other options include google, openai, anthropic, llama2, etc.\n            \"config\": {\n                \"model\": \"llama2\",\n                # Additional optional configurations can be specified here.\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            },\n        },\n        \"embedding_model\": {\n            \"provider\": \"google\", # or openai, ollama, ...\n            \"config\": {\n                \"model\": \"models/embedding-001\",\n                \"task_type\": \"retrieval_document\",\n                # Further customization options can be added here.\n            },\n        },\n    }\n)\n```",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "tool = JSONSearchTool(\n    config={\n        \"llm\": {\n            \"provider\": \"ollama\",  # Other options include google, openai, anthropic, llama2, etc.\n            \"config\": {\n                \"model\": \"llama2\",\n                # Additional optional configurations can be specified here.\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            },\n        },\n        \"embedding_model\": {\n            \"provider\": \"google\", # or openai, ollama, ...\n            \"config\": {\n                \"model\": \"models/embedding-001\",\n                \"task_type\": \"retrieval_document\",\n                # Further customization options can be added here.\n            },\n        },\n    }\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          }
        ]
      },
      {
        "type": "header",
        "title": "Linkup Search Tool",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/linkupsearchtool The `LinkupSearchTool` enables querying the Linkup API for contextual information.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`LinkupSearchTool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Steps to Get Started",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Parameters",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": [
              {
                "type": "header",
                "title": "Constructor Parameters",
                "level": 3,
                "content": "**api\\_key**: Optional. Your Hyperbrowser API key. If not provided, it will be read from the `HYPERBROWSER_API_KEY` environment variable.\n\n**api\\_key**: Required. Your Linkup API key.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Run Parameters",
                "level": 3,
                "content": "",
                "metadata": {
                  "section_type": "General",
                  "content_type": null
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Advanced Usage",
            "level": 2,
            "content": "You can customize the search parameters for more specific results:\n```\n# Perform a search with custom parameters\nresults = linkup_tool.run(\n    query=\"Women Nobel Prize Physics\",\n    depth=\"deep\",\n    output_type=\"searchResults\"\n)\n```",
            "metadata": {
              "section_type": "Examples",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "# Perform a search with custom parameters\nresults = linkup_tool.run(\n    query=\"Women Nobel Prize Physics\",\n    depth=\"deep\",\n    output_type=\"searchResults\"\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Return Format",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Error Handling",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Conclusion",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "LlamaIndex Tool",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/llamaindextool The `LlamaIndexTool` is a wrapper for LlamaIndex tools and query engines.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`LlamaIndexTool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Steps to Get Started",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": [
              {
                "type": "header",
                "title": "From a LlamaIndex Tool",
                "level": 3,
                "content": "```\nfrom crewai_tools import LlamaIndexTool\nfrom crewai import Agent\nfrom llama_index.core.tools import FunctionTool\n\n# Example 1: Initialize from FunctionTool\ndef search_data(query: str) -> str:\n    \"\"\"Search for information in the data.\"\"\"\n    # Your implementation here\n    return f\"Results for: {query}\"\n\n# Create a LlamaIndex FunctionTool\nog_tool = FunctionTool.from_defaults(\n    search_data, \n    name=\"DataSearchTool\",\n    description=\"Search for information in the data\"\n)\n\n# Wrap it with LlamaIndexTool\ntool = LlamaIndexTool.from_tool(og_tool)\n\n# Define an agent that uses the tool\n@agent\ndef researcher(self) -> Agent:\n    '''\n    This agent uses the LlamaIndexTool to search for information.\n    '''\n    return Agent(\n        config=self.agents_config[\"researcher\"],\n        tools=[tool]\n    )\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "from crewai_tools import LlamaIndexTool\nfrom crewai import Agent\nfrom llama_index.core.tools import FunctionTool\n\n# Example 1: Initialize from FunctionTool\ndef search_data(query: str) -> str:\n    \"\"\"Search for information in the data.\"\"\"\n    # Your implementation here\n    return f\"Results for: {query}\"\n\n# Create a LlamaIndex FunctionTool\nog_tool = FunctionTool.from_defaults(\n    search_data, \n    name=\"DataSearchTool\",\n    description=\"Search for information in the data\"\n)\n\n# Wrap it with LlamaIndexTool\ntool = LlamaIndexTool.from_tool(og_tool)\n\n# Define an agent that uses the tool\n@agent\ndef researcher(self) -> Agent:\n    '''\n    This agent uses the LlamaIndexTool to search for information.\n    '''\n    return Agent(\n        config=self.agents_config[\"researcher\"],\n        tools=[tool]\n    )",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "From LlamaHub Tools",
                "level": 3,
                "content": "```\nfrom crewai_tools import LlamaIndexTool\nfrom llama_index.tools.wolfram_alpha import WolframAlphaToolSpec\n\n# Initialize from LlamaHub Tools\nwolfram_spec = WolframAlphaToolSpec(app_id=\"your_app_id\")\nwolfram_tools = wolfram_spec.to_tool_list()\ntools = [LlamaIndexTool.from_tool(t) for t in wolfram_tools]\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "from crewai_tools import LlamaIndexTool\nfrom llama_index.tools.wolfram_alpha import WolframAlphaToolSpec\n\n# Initialize from LlamaHub Tools\nwolfram_spec = WolframAlphaToolSpec(app_id=\"your_app_id\")\nwolfram_tools = wolfram_spec.to_tool_list()\ntools = [LlamaIndexTool.from_tool(t) for t in wolfram_tools]",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "From a LlamaIndex Query Engine",
                "level": 3,
                "content": "```\nfrom crewai_tools import LlamaIndexTool\nfrom llama_index.core import VectorStoreIndex\nfrom llama_index.core.readers import SimpleDirectoryReader\n\n# Load documents\ndocuments = SimpleDirectoryReader(\"./data\").load_data()\n\n# Create an index\nindex = VectorStoreIndex.from_documents(documents)\n\n# Create a query engine\nquery_engine = index.as_query_engine()\n\n# Create a LlamaIndexTool from the query engine\nquery_tool = LlamaIndexTool.from_query_engine(\n    query_engine,\n    name=\"Company Data Query Tool\",\n    description=\"Use this tool to lookup information in company documents\"\n)\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "from crewai_tools import LlamaIndexTool\nfrom llama_index.core import VectorStoreIndex\nfrom llama_index.core.readers import SimpleDirectoryReader\n\n# Load documents\ndocuments = SimpleDirectoryReader(\"./data\").load_data()\n\n# Create an index\nindex = VectorStoreIndex.from_documents(documents)\n\n# Create a query engine\nquery_engine = index.as_query_engine()\n\n# Create a LlamaIndexTool from the query engine\nquery_tool = LlamaIndexTool.from_query_engine(\n    query_engine,\n    name=\"Company Data Query Tool\",\n    description=\"Use this tool to lookup information in company documents\"\n)",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              }
            ]
          },
          {
            "type": "header",
            "title": "Class Methods",
            "level": 2,
            "content": "The `LlamaIndexTool` provides two main class methods for creating instances:",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": [
              {
                "type": "header",
                "title": "from\\_tool",
                "level": 3,
                "content": "Creates a `LlamaIndexTool` from a LlamaIndex tool.\n```\n@classmethod\ndef from_tool(cls, tool: Any, **kwargs: Any) -> \"LlamaIndexTool\":\n    # Implementation details\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "@classmethod\ndef from_tool(cls, tool: Any, **kwargs: Any) -> \"LlamaIndexTool\":\n    # Implementation details",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "from\\_query\\_engine",
                "level": 3,
                "content": "Creates a `LlamaIndexTool` from a LlamaIndex query engine.\n```\n@classmethod\ndef from_query_engine(\n    cls,\n    query_engine: Any,\n    name: Optional[str] = None,\n    description: Optional[str] = None,\n    return_direct: bool = False,\n    **kwargs: Any,\n) -> \"LlamaIndexTool\":\n    # Implementation details\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "@classmethod\ndef from_query_engine(\n    cls,\n    query_engine: Any,\n    name: Optional[str] = None,\n    description: Optional[str] = None,\n    return_direct: bool = False,\n    **kwargs: Any,\n) -> \"LlamaIndexTool\":\n    # Implementation details",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              }
            ]
          },
          {
            "type": "header",
            "title": "Parameters",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Conclusion",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "MDX RAG Search",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/mdxsearchtool The `MDXSearchTool` is designed to search MDX files and return the most relevant results.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`MDXSearchTool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Usage Example",
            "level": 2,
            "content": "To get started with the FileReadTool:\n```\nfrom crewai_tools import FileReadTool\n\n# Initialize the tool to read any files the agents knows or lean the path for\nfile_read_tool = FileReadTool()\n\n# OR\n\n# Initialize the tool with a specific file path, so the agent can only read the content of the specified file\nfile_read_tool = FileReadTool(file_path='path/to/your/file.txt')\n```\n\nTo use the MDX Search Tool, you must first set up the necessary environment variables. Then, integrate the tool into your crewAI project to begin your market research. Below is a basic example of how to do this:\n```\nfrom crewai_tools import MDXSearchTool\n\n# Initialize the tool to search any MDX content it learns about during execution\ntool = MDXSearchTool()\n\n# OR\n\n# Initialize the tool with a specific MDX file path for an exclusive search within that document\ntool = MDXSearchTool(mdx='path/to/your/document.mdx')\n```",
            "metadata": {
              "section_type": "Examples",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai_tools import FileReadTool\n\n# Initialize the tool to read any files the agents knows or lean the path for\nfile_read_tool = FileReadTool()\n\n# OR\n\n# Initialize the tool with a specific file path, so the agent can only read the content of the specified file\nfile_read_tool = FileReadTool(file_path='path/to/your/file.txt')",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai_tools import MDXSearchTool\n\n# Initialize the tool to search any MDX content it learns about during execution\ntool = MDXSearchTool()\n\n# OR\n\n# Initialize the tool with a specific MDX file path for an exclusive search within that document\ntool = MDXSearchTool(mdx='path/to/your/document.mdx')",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Parameters",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Customization of Model and Embeddings",
            "level": 2,
            "content": "The tool defaults to using OpenAI for embeddings and summarization. For customization, utilize a configuration dictionary as shown below:\n```\ntool = MDXSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # Options include google, openai, anthropic, llama2, etc.\n            config=dict(\n                model=\"llama2\",\n                # Optional parameters can be included here.\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # Optional title for the embeddings can be added here.\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)\n```",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "tool = MDXSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # Options include google, openai, anthropic, llama2, etc.\n            config=dict(\n                model=\"llama2\",\n                # Optional parameters can be included here.\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # Optional title for the embeddings can be added here.\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          }
        ]
      },
      {
        "type": "header",
        "title": "MultiOn Tool",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/multiontool The `MultiOnTool` empowers CrewAI agents with the capability to navigate and interact with the web through natural language instructions.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`MultiOnTool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Steps to Get Started",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Parameters",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Usage",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Implementation Details",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Conclusion",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "MySQL RAG Search",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/mysqltool The `MySQLSearchTool` is designed to search MySQL databases and return the most relevant results.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`MySQLSearchTool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Arguments",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Custom model and embeddings",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "NL2SQL Tool",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/nl2sqltool The `NL2SQLTool` is designed to convert natural language to SQL queries.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`NL2SQLTool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Requirements",
            "level": 2,
            "content": "AWS credentials configured (either through environment variables or AWS CLI) `boto3` and `python-dotenv` packages Access to Amazon Bedrock Agents\n\nAWS credentials configured (either through environment variables or AWS CLI) `boto3` and `python-dotenv` packages Access to Amazon Bedrock Knowledge Base\n\nDocker must be installed and running on your system. If you don't have it, you can install it from [here](https://docs.docker.com/get-docker/).\n\nSqlAlchemy Any DB compatible library (e.g. psycopg2, mysql-connector-python)",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Usage",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Patronus Evaluation Tools",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/patronustools The Patronus evaluation tools enable CrewAI agents to evaluate and score model inputs and outputs using the Patronus AI platform.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`Patronus Evaluation Tools`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Steps to Get Started",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Examples",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": [
              {
                "type": "header",
                "title": "Using PatronusEvalTool",
                "level": 3,
                "content": "The following example demonstrates how to use the `PatronusEvalTool`, which allows agents to select the most appropriate evaluator and criteria:\n```\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import PatronusEvalTool\n\n# Initialize the tool\npatronus_eval_tool = PatronusEvalTool()\n\n# Define an agent that uses the tool\ncoding_agent = Agent(\n    role=\"Coding Agent\",\n    goal=\"Generate high quality code and verify that the output is code\",\n    backstory=\"An experienced coder who can generate high quality python code.\",\n    tools=[patronus_eval_tool],\n    verbose=True,\n)\n\n# Example task to generate and evaluate code\ngenerate_code_task = Task(\n    description=\"Create a simple program to generate the first N numbers in the Fibonacci sequence. Select the most appropriate evaluator and criteria for evaluating your output.\",\n    expected_output=\"Program that generates the first N numbers in the Fibonacci sequence.\",\n    agent=coding_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[coding_agent], tasks=[generate_code_task])\nresult = crew.kickoff()\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "from crewai import Agent, Task, Crew\nfrom crewai_tools import PatronusEvalTool\n\n# Initialize the tool\npatronus_eval_tool = PatronusEvalTool()\n\n# Define an agent that uses the tool\ncoding_agent = Agent(\n    role=\"Coding Agent\",\n    goal=\"Generate high quality code and verify that the output is code\",\n    backstory=\"An experienced coder who can generate high quality python code.\",\n    tools=[patronus_eval_tool],\n    verbose=True,\n)\n\n# Example task to generate and evaluate code\ngenerate_code_task = Task(\n    description=\"Create a simple program to generate the first N numbers in the Fibonacci sequence. Select the most appropriate evaluator and criteria for evaluating your output.\",\n    expected_output=\"Program that generates the first N numbers in the Fibonacci sequence.\",\n    agent=coding_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[coding_agent], tasks=[generate_code_task])\nresult = crew.kickoff()",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Using PatronusPredefinedCriteriaEvalTool",
                "level": 3,
                "content": "The following example demonstrates how to use the `PatronusPredefinedCriteriaEvalTool`, which uses predefined evaluator and criteria:\n```\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import PatronusPredefinedCriteriaEvalTool\n\n# Initialize the tool with predefined criteria\npatronus_eval_tool = PatronusPredefinedCriteriaEvalTool(\n    evaluators=[{\"evaluator\": \"judge\", \"criteria\": \"contains-code\"}]\n)\n\n# Define an agent that uses the tool\ncoding_agent = Agent(\n    role=\"Coding Agent\",\n    goal=\"Generate high quality code\",\n    backstory=\"An experienced coder who can generate high quality python code.\",\n    tools=[patronus_eval_tool],\n    verbose=True,\n)\n\n# Example task to generate code\ngenerate_code_task = Task(\n    description=\"Create a simple program to generate the first N numbers in the Fibonacci sequence.\",\n    expected_output=\"Program that generates the first N numbers in the Fibonacci sequence.\",\n    agent=coding_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[coding_agent], tasks=[generate_code_task])\nresult = crew.kickoff()\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "from crewai import Agent, Task, Crew\nfrom crewai_tools import PatronusPredefinedCriteriaEvalTool\n\n# Initialize the tool with predefined criteria\npatronus_eval_tool = PatronusPredefinedCriteriaEvalTool(\n    evaluators=[{\"evaluator\": \"judge\", \"criteria\": \"contains-code\"}]\n)\n\n# Define an agent that uses the tool\ncoding_agent = Agent(\n    role=\"Coding Agent\",\n    goal=\"Generate high quality code\",\n    backstory=\"An experienced coder who can generate high quality python code.\",\n    tools=[patronus_eval_tool],\n    verbose=True,\n)\n\n# Example task to generate code\ngenerate_code_task = Task(\n    description=\"Create a simple program to generate the first N numbers in the Fibonacci sequence.\",\n    expected_output=\"Program that generates the first N numbers in the Fibonacci sequence.\",\n    agent=coding_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[coding_agent], tasks=[generate_code_task])\nresult = crew.kickoff()",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              },
              {
                "type": "header",
                "title": "Using PatronusLocalEvaluatorTool",
                "level": 3,
                "content": "The following example demonstrates how to use the `PatronusLocalEvaluatorTool`, which uses custom function evaluators:\n```\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import PatronusLocalEvaluatorTool\nfrom patronus import Client, EvaluationResult\nimport random\n\n# Initialize the Patronus client\nclient = Client()\n\n# Register a custom evaluator\n@client.register_local_evaluator(\"random_evaluator\")\ndef random_evaluator(**kwargs):\n    score = random.random()\n    return EvaluationResult(\n        score_raw=score,\n        pass_=score >= 0.5,\n        explanation=\"example explanation\",\n    )\n\n# Initialize the tool with the custom evaluator\npatronus_eval_tool = PatronusLocalEvaluatorTool(\n    patronus_client=client,\n    evaluator=\"random_evaluator\",\n    evaluated_model_gold_answer=\"example label\",\n)\n\n# Define an agent that uses the tool\ncoding_agent = Agent(\n    role=\"Coding Agent\",\n    goal=\"Generate high quality code\",\n    backstory=\"An experienced coder who can generate high quality python code.\",\n    tools=[patronus_eval_tool],\n    verbose=True,\n)\n\n# Example task to generate code\ngenerate_code_task = Task(\n    description=\"Create a simple program to generate the first N numbers in the Fibonacci sequence.\",\n    expected_output=\"Program that generates the first N numbers in the Fibonacci sequence.\",\n    agent=coding_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[coding_agent], tasks=[generate_code_task])\nresult = crew.kickoff()\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "from crewai import Agent, Task, Crew\nfrom crewai_tools import PatronusLocalEvaluatorTool\nfrom patronus import Client, EvaluationResult\nimport random\n\n# Initialize the Patronus client\nclient = Client()\n\n# Register a custom evaluator\n@client.register_local_evaluator(\"random_evaluator\")\ndef random_evaluator(**kwargs):\n    score = random.random()\n    return EvaluationResult(\n        score_raw=score,\n        pass_=score >= 0.5,\n        explanation=\"example explanation\",\n    )\n\n# Initialize the tool with the custom evaluator\npatronus_eval_tool = PatronusLocalEvaluatorTool(\n    patronus_client=client,\n    evaluator=\"random_evaluator\",\n    evaluated_model_gold_answer=\"example label\",\n)\n\n# Define an agent that uses the tool\ncoding_agent = Agent(\n    role=\"Coding Agent\",\n    goal=\"Generate high quality code\",\n    backstory=\"An experienced coder who can generate high quality python code.\",\n    tools=[patronus_eval_tool],\n    verbose=True,\n)\n\n# Example task to generate code\ngenerate_code_task = Task(\n    description=\"Create a simple program to generate the first N numbers in the Fibonacci sequence.\",\n    expected_output=\"Program that generates the first N numbers in the Fibonacci sequence.\",\n    agent=coding_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[coding_agent], tasks=[generate_code_task])\nresult = crew.kickoff()",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              }
            ]
          },
          {
            "type": "header",
            "title": "Parameters",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": [
              {
                "type": "header",
                "title": "PatronusEvalTool",
                "level": 3,
                "content": "The `PatronusEvalTool` does not require any parameters during initialization. It automatically fetches available evaluators and criteria from the Patronus API.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "PatronusPredefinedCriteriaEvalTool",
                "level": 3,
                "content": "The `PatronusPredefinedCriteriaEvalTool` accepts the following parameters during initialization: **evaluators**: Required. A list of dictionaries containing the evaluator and criteria to use. For example: `[{\"evaluator\": \"judge\", \"criteria\": \"contains-code\"}]`.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "PatronusLocalEvaluatorTool",
                "level": 3,
                "content": "The `PatronusLocalEvaluatorTool` accepts the following parameters during initialization: **patronus\\_client**: Required. The Patronus client instance. **evaluator**: Optional. The name of the registered local evaluator to use. Default is an empty string. **evaluated\\_model\\_gold\\_answer**: Optional. The gold answer to use for evaluation. Default is an empty string.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Usage",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Conclusion",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "PDF RAG Search",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/pdfsearchtool The `PDFSearchTool` is designed to search PDF files and return the most relevant results.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`PDFSearchTool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Arguments",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Custom model and embeddings",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "PG RAG Search",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/pgsearchtool The `PGSearchTool` is designed to search PostgreSQL databases and return the most relevant results.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`PGSearchTool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example Usage",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Arguments",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Custom Model and Embeddings",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Qdrant Vector Search Tool",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/qdrantvectorsearchtool Semantic search capabilities for CrewAI agents using Qdrant vector database",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`QdrantVectorSearchTool`",
        "level": 1,
        "content": "The Qdrant Vector Search Tool enables semantic search capabilities in your CrewAI agents by leveraging [Qdrant](https://qdrant.tech/), a vector similarity search engine. This tool allows your agents to search through documents stored in a Qdrant collection using semantic similarity.",
        "metadata": {
          "section_type": "General",
          "content_type": "link_list"
        },
        "children": [
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Basic Usage",
            "level": 2,
            "content": "The basic structure of a CrewAI CLI command is:\n```\ncrewai [COMMAND] [OPTIONS] [ARGUMENTS]\n```\n\n```\nfrom typing import Tuple, Union\nfrom crewai import Task\n\ndef validate_json_output(result: str) -> Tuple[bool, Union[dict, str]]:\n    \"\"\"Validate that the output is valid JSON.\"\"\"\n    try:\n        json_data = json.loads(result)\n        return (True, json_data)\n    except json.JSONDecodeError:\n        return (False, \"Output must be valid JSON\")\n\ntask = Task(\n    description=\"Generate JSON data\",\n    expected_output=\"Valid JSON object\",\n    guardrail=validate_json_output\n)\n```\n\nHere's a minimal example of how to use the tool:\n```\nfrom crewai import Agent\nfrom crewai_tools import QdrantVectorSearchTool\n\n# Initialize the tool\nqdrant_tool = QdrantVectorSearchTool(\n    qdrant_url=\"your_qdrant_url\",\n    qdrant_api_key=\"your_qdrant_api_key\",\n    collection_name=\"your_collection\"\n)\n\n# Create an agent that uses the tool\nagent = Agent(\n    role=\"Research Assistant\",\n    goal=\"Find relevant information in documents\",\n    tools=[qdrant_tool]\n)\n\n# The tool will automatically use OpenAI embeddings\n# and return the 3 most relevant results with scores > 0.35\n```",
            "metadata": {
              "section_type": "Examples",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "shell Terminal",
                "content": "crewai [COMMAND] [OPTIONS] [ARGUMENTS]",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from typing import Tuple, Union\nfrom crewai import Task\n\ndef validate_json_output(result: str) -> Tuple[bool, Union[dict, str]]:\n    \"\"\"Validate that the output is valid JSON.\"\"\"\n    try:\n        json_data = json.loads(result)\n        return (True, json_data)\n    except json.JSONDecodeError:\n        return (False, \"Output must be valid JSON\")\n\ntask = Task(\n    description=\"Generate JSON data\",\n    expected_output=\"Valid JSON object\",\n    guardrail=validate_json_output\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python",
                "content": "from crewai import Agent\nfrom crewai_tools import QdrantVectorSearchTool\n\n# Initialize the tool\nqdrant_tool = QdrantVectorSearchTool(\n    qdrant_url=\"your_qdrant_url\",\n    qdrant_api_key=\"your_qdrant_api_key\",\n    collection_name=\"your_collection\"\n)\n\n# Create an agent that uses the tool\nagent = Agent(\n    role=\"Research Assistant\",\n    goal=\"Find relevant information in documents\",\n    tools=[qdrant_tool]\n)\n\n# The tool will automatically use OpenAI embeddings\n# and return the 3 most relevant results with scores > 0.35",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Complete Working Example",
            "level": 2,
            "content": "Here's a complete example showing how to: Extract text from a PDF Generate embeddings using OpenAI Store in Qdrant Create a CrewAI agentic RAG workflow for semantic search\n```\nimport os\nimport uuid\nimport pdfplumber\nfrom openai import OpenAI\nfrom dotenv import load_dotenv\nfrom crewai import Agent, Task, Crew, Process, LLM\nfrom crewai_tools import QdrantVectorSearchTool\nfrom qdrant_client import QdrantClient\nfrom qdrant_client.models import PointStruct, Distance, VectorParams\n\n# Load environment variables\nload_dotenv()\n\n# Initialize OpenAI client\nclient = OpenAI(api_key=os.getenv(\"OPENAI_API_KEY\"))\n\n# Extract text from PDF\ndef extract_text_from_pdf(pdf_path):\n    text = []\n    with pdfplumber.open(pdf_path) as pdf:\n        for page in pdf.pages:\n            page_text = page.extract_text()\n            if page_text:\n                text.append(page_text.strip())\n    return text\n\n# Generate OpenAI embeddings\ndef get_openai_embedding(text):\n    response = client.embeddings.create(\n        input=text,\n        model=\"text-embedding-3-small\"\n    )\n    return response.data[0].embedding\n\n# Store text and embeddings in Qdrant\ndef load_pdf_to_qdrant(pdf_path, qdrant, collection_name):\n    # Extract text from PDF\n    text_chunks = extract_text_from_pdf(pdf_path)\n    \n    # Create Qdrant collection\n    if qdrant.collection_exists(collection_name):\n        qdrant.delete_collection(collection_name)\n    qdrant.create_collection(\n        collection_name=collection_name,\n        vectors_config=VectorParams(size=1536, distance=Distance.COSINE)\n    )\n\n    # Store embeddings\n    points = []\n    for chunk in text_chunks:\n        embedding = get_openai_embedding(chunk)\n        points.append(PointStruct(\n            id=str(uuid.uuid4()),\n            vector=embedding,\n            payload={\"text\": chunk}\n        ))\n    qdrant.upsert(collection_name=collection_name, points=points)\n\n# Initialize Qdrant client and load data\nqdrant = QdrantClient(\n    url=os.getenv(\"QDRANT_URL\"),\n    api_key=os.getenv(\"QDRANT_API_KEY\")\n)\ncollection_name = \"example_collection\"\npdf_path = \"path/to/your/document.pdf\"\nload_pdf_to_qdrant(pdf_path, qdrant, collection_name)\n\n# Initialize Qdrant search tool\nqdrant_tool = QdrantVectorSearchTool(\n    qdrant_url=os.getenv(\"QDRANT_URL\"),\n    qdrant_api_key=os.getenv(\"QDRANT_API_KEY\"),\n    collection_name=collection_name,\n    limit=3,\n    score_threshold=0.35\n)\n\n# Create CrewAI agents\nsearch_agent = Agent(\n    role=\"Senior Semantic Search Agent\",\n    goal=\"Find and analyze documents based on semantic search\",\n    backstory=\"\"\"You are an expert research assistant who can find relevant \n    information using semantic search in a Qdrant database.\"\"\",\n    tools=[qdrant_tool],\n    verbose=True\n)\n\nanswer_agent = Agent(\n    role=\"Senior Answer Assistant\",\n    goal=\"Generate answers to questions based on the context provided\",\n    backstory=\"\"\"You are an expert answer assistant who can generate \n    answers to questions based on the context provided.\"\"\",\n    tools=[qdrant_tool],\n    verbose=True\n)\n\n# Define tasks\nsearch_task = Task(\n    description=\"\"\"Search for relevant documents about the {query}.\n    Your final answer should include:\n    - The relevant information found\n    - The similarity scores of the results\n    - The metadata of the relevant documents\"\"\",\n    agent=search_agent\n)\n\nanswer_task = Task(\n    description=\"\"\"Given the context and metadata of relevant documents,\n    generate a final answer based on the context.\"\"\",\n    agent=answer_agent\n)\n\n# Run CrewAI workflow\ncrew = Crew(\n    agents=[search_agent, answer_agent],\n    tasks=[search_task, answer_task],\n    process=Process.sequential,\n    verbose=True\n)\n\nresult = crew.kickoff(\n    inputs={\"query\": \"What is the role of X in the document?\"}\n)\nprint(result)\n```",
            "metadata": {
              "section_type": "Examples",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python",
                "content": "import os\nimport uuid\nimport pdfplumber\nfrom openai import OpenAI\nfrom dotenv import load_dotenv\nfrom crewai import Agent, Task, Crew, Process, LLM\nfrom crewai_tools import QdrantVectorSearchTool\nfrom qdrant_client import QdrantClient\nfrom qdrant_client.models import PointStruct, Distance, VectorParams\n\n# Load environment variables\nload_dotenv()\n\n# Initialize OpenAI client\nclient = OpenAI(api_key=os.getenv(\"OPENAI_API_KEY\"))\n\n# Extract text from PDF\ndef extract_text_from_pdf(pdf_path):\n    text = []\n    with pdfplumber.open(pdf_path) as pdf:\n        for page in pdf.pages:\n            page_text = page.extract_text()\n            if page_text:\n                text.append(page_text.strip())\n    return text\n\n# Generate OpenAI embeddings\ndef get_openai_embedding(text):\n    response = client.embeddings.create(\n        input=text,\n        model=\"text-embedding-3-small\"\n    )\n    return response.data[0].embedding\n\n# Store text and embeddings in Qdrant\ndef load_pdf_to_qdrant(pdf_path, qdrant, collection_name):\n    # Extract text from PDF\n    text_chunks = extract_text_from_pdf(pdf_path)\n    \n    # Create Qdrant collection\n    if qdrant.collection_exists(collection_name):\n        qdrant.delete_collection(collection_name)\n    qdrant.create_collection(\n        collection_name=collection_name,\n        vectors_config=VectorParams(size=1536, distance=Distance.COSINE)\n    )\n\n    # Store embeddings\n    points = []\n    for chunk in text_chunks:\n        embedding = get_openai_embedding(chunk)\n        points.append(PointStruct(\n            id=str(uuid.uuid4()),\n            vector=embedding,\n            payload={\"text\": chunk}\n        ))\n    qdrant.upsert(collection_name=collection_name, points=points)\n\n# Initialize Qdrant client and load data\nqdrant = QdrantClient(\n    url=os.getenv(\"QDRANT_URL\"),\n    api_key=os.getenv(\"QDRANT_API_KEY\")\n)\ncollection_name = \"example_collection\"\npdf_path = \"path/to/your/document.pdf\"\nload_pdf_to_qdrant(pdf_path, qdrant, collection_name)\n\n# Initialize Qdrant search tool\nqdrant_tool = QdrantVectorSearchTool(\n    qdrant_url=os.getenv(\"QDRANT_URL\"),\n    qdrant_api_key=os.getenv(\"QDRANT_API_KEY\"),\n    collection_name=collection_name,\n    limit=3,\n    score_threshold=0.35\n)\n\n# Create CrewAI agents\nsearch_agent = Agent(\n    role=\"Senior Semantic Search Agent\",\n    goal=\"Find and analyze documents based on semantic search\",\n    backstory=\"\"\"You are an expert research assistant who can find relevant \n    information using semantic search in a Qdrant database.\"\"\",\n    tools=[qdrant_tool],\n    verbose=True\n)\n\nanswer_agent = Agent(\n    role=\"Senior Answer Assistant\",\n    goal=\"Generate answers to questions based on the context provided\",\n    backstory=\"\"\"You are an expert answer assistant who can generate \n    answers to questions based on the context provided.\"\"\",\n    tools=[qdrant_tool],\n    verbose=True\n)\n\n# Define tasks\nsearch_task = Task(\n    description=\"\"\"Search for relevant documents about the {query}.\n    Your final answer should include:\n    - The relevant information found\n    - The similarity scores of the results\n    - The metadata of the relevant documents\"\"\",\n    agent=search_agent\n)\n\nanswer_task = Task(\n    description=\"\"\"Given the context and metadata of relevant documents,\n    generate a final answer based on the context.\"\"\",\n    agent=answer_agent\n)\n\n# Run CrewAI workflow\ncrew = Crew(\n    agents=[search_agent, answer_agent],\n    tasks=[search_task, answer_task],\n    process=Process.sequential,\n    verbose=True\n)\n\nresult = crew.kickoff(\n    inputs={\"query\": \"What is the role of X in the document?\"}\n)\nprint(result)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Tool Parameters",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": [
              {
                "type": "header",
                "title": "Required Parameters",
                "level": 3,
                "content": "`qdrant_url` (str): The URL of your Qdrant server `qdrant_api_key` (str): API key for authentication with Qdrant `collection_name` (str): Name of the Qdrant collection to search",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Optional Parameters",
                "level": 3,
                "content": "`limit` (int): Maximum number of results to return (default: 3) `score_threshold` (float): Minimum similarity score threshold (default: 0.35) `custom_embedding_fn` (Callable\\[\\[str], list\\[float]]): Custom function for text vectorization",
                "metadata": {
                  "section_type": "Optional",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Search Parameters",
            "level": 2,
            "content": "The tool accepts these parameters in its schema: `query` (str): The search query to find similar documents `filter_by` (str, optional): Metadata field to filter on `filter_value` (str, optional): Value to filter by",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Return Format",
            "level": 2,
            "content": "The tool returns content in the following format: For **scrape** operations: The content of the page in markdown or HTML format. For **crawl** operations: The content of each page separated by dividers, including the URL of each page.\n\nThe tool returns results in the following format:\n```\n{\n  \"success\": true,\n  \"results\": [\n    {\n      \"name\": \"Result Title\",\n      \"url\": \"https://example.com/result\",\n      \"content\": \"Content of the result...\"\n    },\n    // Additional results...\n  ]\n}\n```\nIf an error occurs, the response will be:\n```\n{\n  \"success\": false,\n  \"error\": \"Error message\"\n}\n```\n\nThe tool returns results in JSON format:\n```\n[\n  {\n    \"metadata\": {\n      // Any metadata stored with the document\n    },\n    \"context\": \"The actual text content of the document\",\n    \"distance\": 0.95  // Similarity score\n  }\n]\n```",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "json",
                "content": "{\n  \"success\": true,\n  \"results\": [\n    {\n      \"name\": \"Result Title\",\n      \"url\": \"https://example.com/result\",\n      \"content\": \"Content of the result...\"\n    },\n    // Additional results...\n  ]\n}",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "json",
                "content": "{\n  \"success\": false,\n  \"error\": \"Error message\"\n}",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "json",
                "content": "[\n  {\n    \"metadata\": {\n      // Any metadata stored with the document\n    },\n    \"context\": \"The actual text content of the document\",\n    \"distance\": 0.95  // Similarity score\n  }\n]",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Default Embedding",
            "level": 2,
            "content": "By default, the tool uses OpenAI's `text-embedding-3-small` model for vectorization. This requires: OpenAI API key set in environment: `OPENAI_API_KEY`",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Custom Embeddings",
            "level": 2,
            "content": "Instead of using the default embedding model, you might want to use your own embedding function in cases where you: Want to use a different embedding model (e.g., Cohere, HuggingFace, Ollama models) Need to reduce costs by using open-source embedding models Have specific requirements for vector dimensions or embedding quality Want to use domain-specific embeddings (e.g., for medical or legal text) Here's an example using a HuggingFace model:\n```\nfrom transformers import AutoTokenizer, AutoModel\nimport torch\n\n# Load model and tokenizer\ntokenizer = AutoTokenizer.from_pretrained('sentence-transformers/all-MiniLM-L6-v2')\nmodel = AutoModel.from_pretrained('sentence-transformers/all-MiniLM-L6-v2')\n\ndef custom_embeddings(text: str) -> list[float]:\n    # Tokenize and get model outputs\n    inputs = tokenizer(text, return_tensors=\"pt\", padding=True, truncation=True)\n    outputs = model(**inputs)\n    \n    # Use mean pooling to get text embedding\n    embeddings = outputs.last_hidden_state.mean(dim=1)\n    \n    # Convert to list of floats and return\n    return embeddings[0].tolist()\n\n# Use custom embeddings with the tool\ntool = QdrantVectorSearchTool(\n    qdrant_url=\"your_url\",\n    qdrant_api_key=\"your_key\",\n    collection_name=\"your_collection\",\n    custom_embedding_fn=custom_embeddings  # Pass your custom function\n)\n```",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python",
                "content": "from transformers import AutoTokenizer, AutoModel\nimport torch\n\n# Load model and tokenizer\ntokenizer = AutoTokenizer.from_pretrained('sentence-transformers/all-MiniLM-L6-v2')\nmodel = AutoModel.from_pretrained('sentence-transformers/all-MiniLM-L6-v2')\n\ndef custom_embeddings(text: str) -> list[float]:\n    # Tokenize and get model outputs\n    inputs = tokenizer(text, return_tensors=\"pt\", padding=True, truncation=True)\n    outputs = model(**inputs)\n    \n    # Use mean pooling to get text embedding\n    embeddings = outputs.last_hidden_state.mean(dim=1)\n    \n    # Convert to list of floats and return\n    return embeddings[0].tolist()\n\n# Use custom embeddings with the tool\ntool = QdrantVectorSearchTool(\n    qdrant_url=\"your_url\",\n    qdrant_api_key=\"your_key\",\n    collection_name=\"your_collection\",\n    custom_embedding_fn=custom_embeddings  # Pass your custom function\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Error Handling",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Environment Variables",
            "level": 2,
            "content": "```\nBEDROCK_AGENT_ID=your-agent-id           # Alternative to passing agent_id\nBEDROCK_AGENT_ALIAS_ID=your-agent-alias-id # Alternative to passing agent_alias_id\nAWS_REGION=your-aws-region               # Defaults to us-west-2\nAWS_ACCESS_KEY_ID=your-access-key        # Required for AWS authentication\nAWS_SECRET_ACCESS_KEY=your-secret-key    # Required for AWS authentication\n```\n\n```\nBEDROCK_KB_ID=your-knowledge-base-id  # Alternative to passing knowledge_base_id\nAWS_REGION=your-aws-region            # Defaults to us-east-1\nAWS_ACCESS_KEY_ID=your-access-key     # Required for AWS authentication\nAWS_SECRET_ACCESS_KEY=your-secret-key # Required for AWS authentication\n```\n\nRequired environment variables:\n```\nexport QDRANT_URL=\"your_qdrant_url\"  # If not provided in constructor\nexport QDRANT_API_KEY=\"your_api_key\"  # If not provided in constructor\nexport OPENAI_API_KEY=\"your_openai_key\"  # If using default embeddings\n```",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "bash",
                "content": "BEDROCK_AGENT_ID=your-agent-id           # Alternative to passing agent_id\nBEDROCK_AGENT_ALIAS_ID=your-agent-alias-id # Alternative to passing agent_alias_id\nAWS_REGION=your-aws-region               # Defaults to us-west-2\nAWS_ACCESS_KEY_ID=your-access-key        # Required for AWS authentication\nAWS_SECRET_ACCESS_KEY=your-secret-key    # Required for AWS authentication",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "bash",
                "content": "BEDROCK_KB_ID=your-knowledge-base-id  # Alternative to passing knowledge_base_id\nAWS_REGION=your-aws-region            # Defaults to us-east-1\nAWS_ACCESS_KEY_ID=your-access-key     # Required for AWS authentication\nAWS_SECRET_ACCESS_KEY=your-secret-key # Required for AWS authentication",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "bash",
                "content": "export QDRANT_URL=\"your_qdrant_url\"  # If not provided in constructor\nexport QDRANT_API_KEY=\"your_api_key\"  # If not provided in constructor\nexport OPENAI_API_KEY=\"your_openai_key\"  # If using default embeddings",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          }
        ]
      },
      {
        "type": "header",
        "title": "RAG Tool",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/ragtool The `RagTool` is a dynamic knowledge base tool for answering questions using Retrieval-Augmented Generation.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`RagTool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Supported Data Sources",
            "level": 2,
            "content": "Amazon S3 Confluence Salesforce SharePoint Web pages Custom document locations Amazon Kendra SQL databases\n\nThe `RagTool` can be used with a wide variety of data sources, including: \ud83d\udcf0 PDF files \ud83d\udcca CSV files \ud83d\udcc3 JSON files \ud83d\udcdd Text \ud83d\udcc1 Directories/Folders \ud83c\udf10 HTML Web pages \ud83d\udcfd\ufe0f YouTube Channels \ud83d\udcfa YouTube Videos \ud83d\udcda Documentation websites \ud83d\udcdd MDX files \ud83d\udcc4 DOCX files \ud83e\uddfe XML files \ud83d\udcec Gmail \ud83d\udcdd GitHub repositories \ud83d\udc18 PostgreSQL databases \ud83d\udc2c MySQL databases \ud83e\udd16 Slack conversations \ud83d\udcac Discord messages \ud83d\udde8\ufe0f Discourse forums \ud83d\udcdd Substack newsletters \ud83d\udc1d Beehiiv content \ud83d\udcbe Dropbox files \ud83d\uddbc\ufe0f Images \u2699\ufe0f Custom data sources",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Parameters",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Adding Content",
            "level": 2,
            "content": "You can add content to the knowledge base using the `add` method:\n```\n# Add a PDF file\nrag_tool.add(data_type=\"file\", path=\"path/to/your/document.pdf\")\n\n# Add a web page\nrag_tool.add(data_type=\"web_page\", url=\"https://example.com\")\n\n# Add a YouTube video\nrag_tool.add(data_type=\"youtube_video\", url=\"https://www.youtube.com/watch?v=VIDEO_ID\")\n\n# Add a directory of files\nrag_tool.add(data_type=\"directory\", path=\"path/to/your/directory\")\n```",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "# Add a PDF file\nrag_tool.add(data_type=\"file\", path=\"path/to/your/document.pdf\")\n\n# Add a web page\nrag_tool.add(data_type=\"web_page\", url=\"https://example.com\")\n\n# Add a YouTube video\nrag_tool.add(data_type=\"youtube_video\", url=\"https://www.youtube.com/watch?v=VIDEO_ID\")\n\n# Add a directory of files\nrag_tool.add(data_type=\"directory\", path=\"path/to/your/directory\")",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Agent Integration Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Advanced Configuration",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Internals/Advanced",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Conclusion",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "S3 Reader Tool",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/s3readertool The `S3ReaderTool` enables CrewAI agents to read files from Amazon S3 buckets.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`S3ReaderTool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Steps to Get Started",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Parameters",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "AWS Credentials",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Usage",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Error Handling",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Implementation Details",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Conclusion",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "S3 Writer Tool",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/s3writertool The `S3WriterTool` enables CrewAI agents to write content to files in Amazon S3 buckets.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`S3WriterTool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Steps to Get Started",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Parameters",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "AWS Credentials",
            "level": 2,
            "content": "The tool requires AWS credentials to access S3 buckets. You can configure these credentials using environment variables: **CREW\\_AWS\\_REGION**: The AWS region where your S3 bucket is located. Default is `us-east-1`. **CREW\\_AWS\\_ACCESS\\_KEY\\_ID**: Your AWS access key ID. **CREW\\_AWS\\_SEC\\_ACCESS\\_KEY**: Your AWS secret access key.\n\nThe tool requires AWS credentials to access S3 buckets. You can configure these credentials using environment variables: **CREW\\_AWS\\_REGION**: The AWS region where your S3 bucket is located. Default is `us-east-1`. **CREW\\_AWS\\_ACCESS\\_KEY\\_ID**: Your AWS access key ID. **CREW\\_AWS\\_SEC\\_ACCESS\\_KEY**: Your AWS secret access key.",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Usage",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Error Handling",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Implementation Details",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Conclusion",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Scrape Element From Website Tool",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/scrapeelementfromwebsitetool The `ScrapeElementFromWebsiteTool` enables CrewAI agents to extract specific elements from websites using CSS selectors.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`ScrapeElementFromWebsiteTool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Steps to Get Started",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Parameters",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Usage",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Implementation Details",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Conclusion",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Scrapegraph Scrape Tool",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/scrapegraphscrapetool The `ScrapegraphScrapeTool` leverages Scrapegraph AI's SmartScraper API to intelligently extract content from websites.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`ScrapegraphScrapeTool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Steps to Get Started",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Parameters",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Usage",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Error Handling",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Rate Limiting",
            "level": 2,
            "content": "The Scrapegraph API has rate limits that vary based on your subscription plan. Consider the following best practices: Implement appropriate delays between requests when processing multiple URLs. Handle rate limit errors gracefully in your application. Check your API plan limits on the Scrapegraph dashboard.",
            "metadata": {
              "section_type": "General",
              "content_type": "short_description"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Implementation Details",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Conclusion",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Scrape Website",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/scrapewebsitetool The `ScrapeWebsiteTool` is designed to extract and read the content of a specified website.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`ScrapeWebsiteTool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Arguments",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Scrapfly Scrape Website Tool",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/scrapflyscrapetool The `ScrapflyScrapeWebsiteTool` leverages Scrapfly's web scraping API to extract content from websites in various formats.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`ScrapflyScrapeWebsiteTool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Steps to Get Started",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Parameters",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": [
              {
                "type": "header",
                "title": "Initialization Parameters",
                "level": 3,
                "content": "**api\\_key**: Required. Your Scrapfly API key.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Run Parameters",
                "level": 3,
                "content": "**url**: Required. The website URL to scrape or crawl. **operation**: Optional. The operation to perform on the website. Either 'scrape' or 'crawl'. Default is 'scrape'. **params**: Optional. Additional parameters for the scrape or crawl operation.\n\n**query**: Required. The search term or phrase. **depth**: Optional. The search depth. Default is \"standard\". **output\\_type**: Optional. The type of output. Default is \"searchResults\".\n\n**url**: Required. The URL of the website to scrape. **scrape\\_format**: Optional. The format in which to extract the web page content. Options are \"raw\" (HTML), \"markdown\", or \"text\". Default is \"markdown\". **scrape\\_config**: Optional. A dictionary containing additional Scrapfly scraping configuration options. **ignore\\_scrape\\_failures**: Optional. Whether to ignore failures during scraping. If set to `True`, the tool will return `None` instead of raising an exception when scraping fails.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "descriptive_text"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Scrapfly Configuration Options",
            "level": 2,
            "content": "The `scrape_config` parameter allows you to customize the scraping behavior with the following options: **asp**: Enable anti-scraping protection bypass. **render\\_js**: Enable JavaScript rendering with a cloud headless browser. **proxy\\_pool**: Select a proxy pool (e.g., \"public\\_residential\\_pool\", \"datacenter\"). **country**: Select a proxy location (e.g., \"us\", \"uk\"). **auto\\_scroll**: Automatically scroll the page to load lazy-loaded content. **js**: Execute custom JavaScript code by the headless browser. For a complete list of configuration options, refer to the [Scrapfly API documentation](https://scrapfly.io/docs/scrape-api/getting-started).",
            "metadata": {
              "section_type": "General",
              "content_type": "link_list"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Usage",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Error Handling",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Implementation Details",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Conclusion",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Selenium Scraper",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/seleniumscrapingtool The `SeleniumScrapingTool` is designed to extract and read the content of a specified website using Selenium.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`SeleniumScrapingTool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "API documentation",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Parameters",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Agent Integration Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Implementation Details",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Handling Dynamic Content",
            "level": 2,
            "content": "The `SeleniumScrapingTool` is particularly useful for scraping websites with dynamic content that is loaded via JavaScript. By using a real browser instance, it can: Execute JavaScript on the page Wait for dynamic content to load Interact with elements if needed Extract content that would not be available with simple HTTP requests You can adjust the `wait_time` parameter to ensure that all dynamic content has loaded before extraction.",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Conclusion",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Google Serper Search",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/serperdevtool The `SerperDevTool` is designed to search the internet and return the most relevant results.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`SerperDevTool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Steps to Get Started",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Parameters",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example with Parameters",
            "level": 2,
            "content": "Here is an example demonstrating how to use the tool with additional parameters:\n```\nfrom crewai_tools import BraveSearchTool\n\n# Initialize the tool with custom parameters\ntool = BraveSearchTool(\n    country=\"US\",\n    n_results=5,\n    save_file=True\n)\n\n# Execute a search\nresults = tool.run(search_query=\"Latest AI developments\")\nprint(results)\n```\n\nHere is an example demonstrating how to use the tool with additional parameters:\n```\nfrom crewai_tools import SerperDevTool\n\ntool = SerperDevTool(\n    search_url=\"https://google.serper.dev/scholar\",\n    n_results=2,\n)\n\nprint(tool.run(search_query=\"ChatGPT\"))\n\n# Using Tool: Search the internet\n\n# Search results: Title: Role of chat gpt in public health\n# Link: https://link.springer.com/article/10.1007/s10439-023-03172-7\n# Snippet: \u2026 ChatGPT in public health. In this overview, we will examine the potential uses of ChatGPT in\n# ---\n# Title: Potential use of chat gpt in global warming\n# Link: https://link.springer.com/article/10.1007/s10439-023-03171-8\n# Snippet: \u2026 as ChatGPT, have the potential to play a critical role in advancing our understanding of climate\n# ---\n\n```\n\n```\nfrom crewai_tools import SerperDevTool\n\ntool = SerperDevTool(\n    country=\"fr\",\n    locale=\"fr\",\n    location=\"Paris, Paris, Ile-de-France, France\",\n    n_results=2,\n)\n\nprint(tool.run(search_query=\"Jeux Olympiques\"))\n\n# Using Tool: Search the internet\n\n# Search results: Title: Jeux Olympiques de Paris 2024 - Actualit\u00e9s, calendriers, r\u00e9sultats\n# Link: https://olympics.com/fr/paris-2024\n# Snippet: Quels sont les sports pr\u00e9sents aux Jeux Olympiques de Paris 2024 ? \u00b7 Athl\u00e9tisme \u00b7 Aviron \u00b7 Badminton \u00b7 Basketball \u00b7 Basketball 3x3 \u00b7 Boxe \u00b7 Breaking \u00b7 Cano\u00eb ...\n# ---\n# Title: Billetterie Officielle de Paris 2024 - Jeux Olympiques et Paralympiques\n# Link: https://tickets.paris2024.org/\n# Snippet: Achetez vos billets exclusivement sur le site officiel de la billetterie de Paris 2024 pour participer au plus grand \u00e9v\u00e9nement sportif au monde.\n# ---\n```",
            "metadata": {
              "section_type": "Examples",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai_tools import BraveSearchTool\n\n# Initialize the tool with custom parameters\ntool = BraveSearchTool(\n    country=\"US\",\n    n_results=5,\n    save_file=True\n)\n\n# Execute a search\nresults = tool.run(search_query=\"Latest AI developments\")\nprint(results)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai_tools import SerperDevTool\n\ntool = SerperDevTool(\n    search_url=\"https://google.serper.dev/scholar\",\n    n_results=2,\n)\n\nprint(tool.run(search_query=\"ChatGPT\"))\n\n# Using Tool: Search the internet\n\n# Search results: Title: Role of chat gpt in public health\n# Link: https://link.springer.com/article/10.1007/s10439-023-03172-7\n# Snippet: \u2026 ChatGPT in public health. In this overview, we will examine the potential uses of ChatGPT in\n# ---\n# Title: Potential use of chat gpt in global warming\n# Link: https://link.springer.com/article/10.1007/s10439-023-03171-8\n# Snippet: \u2026 as ChatGPT, have the potential to play a critical role in advancing our understanding of climate\n# ---",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai_tools import SerperDevTool\n\ntool = SerperDevTool(\n    country=\"fr\",\n    locale=\"fr\",\n    location=\"Paris, Paris, Ile-de-France, France\",\n    n_results=2,\n)\n\nprint(tool.run(search_query=\"Jeux Olympiques\"))\n\n# Using Tool: Search the internet\n\n# Search results: Title: Jeux Olympiques de Paris 2024 - Actualit\u00e9s, calendriers, r\u00e9sultats\n# Link: https://olympics.com/fr/paris-2024\n# Snippet: Quels sont les sports pr\u00e9sents aux Jeux Olympiques de Paris 2024 ? \u00b7 Athl\u00e9tisme \u00b7 Aviron \u00b7 Badminton \u00b7 Basketball \u00b7 Basketball 3x3 \u00b7 Boxe \u00b7 Breaking \u00b7 Cano\u00eb ...\n# ---\n# Title: Billetterie Officielle de Paris 2024 - Jeux Olympiques et Paralympiques\n# Link: https://tickets.paris2024.org/\n# Snippet: Achetez vos billets exclusivement sur le site officiel de la billetterie de Paris 2024 pour participer au plus grand \u00e9v\u00e9nement sportif au monde.\n# ---",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Conclusion",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Snowflake Search Tool",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/snowflakesearchtool The `SnowflakeSearchTool` enables CrewAI agents to execute SQL queries and perform semantic search on Snowflake data warehouses.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`SnowflakeSearchTool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Steps to Get Started",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Parameters",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": [
              {
                "type": "header",
                "title": "SnowflakeConfig Parameters",
                "level": 3,
                "content": "The `SnowflakeConfig` class accepts the following parameters: **account**: Required. Snowflake account identifier. **user**: Required. Snowflake username. **password**: Optional\\*. Snowflake password. **private\\_key\\_path**: Optional\\*. Path to private key file (alternative to password). **warehouse**: Required. Snowflake warehouse name. **database**: Required. Default database. **snowflake\\_schema**: Required. Default schema. **role**: Optional. Snowflake role. **session\\_parameters**: Optional. Custom session parameters as a dictionary. \\*Either `password` or `private_key_path` must be provided.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "descriptive_text"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "SnowflakeSearchTool Parameters",
                "level": 3,
                "content": "The `SnowflakeSearchTool` accepts the following parameters during initialization: **config**: Required. A `SnowflakeConfig` object containing connection details. **pool\\_size**: Optional. Number of connections in the pool. Default is 5. **max\\_retries**: Optional. Maximum retry attempts for failed queries. Default is 3. **retry\\_delay**: Optional. Delay between retries in seconds. Default is 1.0. **enable\\_caching**: Optional. Whether to enable query result caching. Default is True.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "descriptive_text"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Usage",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Advanced Features",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Internals/Advanced",
              "content_type": null
            },
            "children": [
              {
                "type": "header",
                "title": "Connection Pooling",
                "level": 3,
                "content": "The `SnowflakeSearchTool` implements connection pooling to improve performance by reusing database connections. You can control the pool size with the `pool_size` parameter.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Automatic Retries",
                "level": 3,
                "content": "The tool automatically retries failed queries with exponential backoff. You can configure the retry behavior with the `max_retries` and `retry_delay` parameters.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Query Result Caching",
                "level": 3,
                "content": "To improve performance for repeated queries, the tool can cache query results. This feature is enabled by default but can be disabled by setting `enable_caching=False`.",
                "metadata": {
                  "section_type": "General",
                  "content_type": "short_description"
                },
                "children": []
              },
              {
                "type": "header",
                "title": "Key-Pair Authentication",
                "level": 3,
                "content": "In addition to password authentication, the tool supports key-pair authentication for enhanced security:\n```\nconfig = SnowflakeConfig(\n    account=\"your_account\",\n    user=\"your_username\",\n    private_key_path=\"/path/to/your/private/key.p8\",\n    warehouse=\"COMPUTE_WH\",\n    database=\"your_database\",\n    snowflake_schema=\"your_schema\"\n)\n```",
                "metadata": {
                  "section_type": "General",
                  "content_type": "code_example"
                },
                "children": [],
                "code_blocks": [
                  {
                    "type": "code_block",
                    "language": "python Code",
                    "content": "config = SnowflakeConfig(\n    account=\"your_account\",\n    user=\"your_username\",\n    private_key_path=\"/path/to/your/private/key.p8\",\n    warehouse=\"COMPUTE_WH\",\n    database=\"your_database\",\n    snowflake_schema=\"your_schema\"\n)",
                    "metadata": {
                      "section_type": "code",
                      "content_type": "code_example"
                    },
                    "children": []
                  }
                ]
              }
            ]
          },
          {
            "type": "header",
            "title": "Error Handling",
            "level": 2,
            "content": "The tool gracefully handles API errors and provides structured feedback. If the API request fails, the tool will return a dictionary with `success: false` and an error message.\n\nThe tool handles these specific errors: Raises ImportError if `qdrant-client` is not installed (with option to auto-install) Raises ValueError if `QDRANT_URL` is not set Prompts to install `qdrant-client` if missing using `uv add qdrant-client`\n\nThe `S3ReaderTool` includes error handling for common S3 issues: Invalid S3 path format Missing or inaccessible files Permission issues AWS credential problems When an error occurs, the tool will return an error message that includes details about the issue.\n\nThe `S3WriterTool` includes error handling for common S3 issues: Invalid S3 path format Permission issues (e.g., no write access to the bucket) AWS credential problems Bucket does not exist When an error occurs, the tool will return an error message that includes details about the issue.\n\nThe `ScrapegraphScrapeTool` may raise the following exceptions: **ValueError**: When API key is missing or URL format is invalid. **RateLimitError**: When API rate limits are exceeded. **RuntimeError**: When scraping operation fails (network issues, API errors). It's recommended to instruct agents to handle potential errors gracefully:\n```\n# Create a task that includes error handling instructions\nrobust_extract_task = Task(\n    description=\"\"\"\n    Extract the main heading from example.com.\n    Be aware that you might encounter errors such as:\n    - Invalid URL format\n    - Missing API key\n    - Rate limit exceeded\n    - Network or API errors\n    \n    If you encounter any errors, provide a clear explanation of what went wrong\n    and suggest possible solutions.\n    \"\"\",\n    expected_output=\"Either the extracted heading or a clear error explanation\",\n    agent=web_scraper_agent,\n)\n```\n\nBy default, the `ScrapflyScrapeWebsiteTool` will raise an exception if scraping fails. Agents can be instructed to handle failures gracefully by specifying the `ignore_scrape_failures` parameter:\n```\n# Create a task that instructs the agent to handle errors\nerror_handling_task = Task(\n    description=\"\"\"\n    Extract content from a potentially problematic website and make sure to handle any \n    scraping failures gracefully by setting ignore_scrape_failures to True.\n    \"\"\",\n    expected_output=\"Either the extracted content or a graceful error message\",\n    agent=web_scraper_agent,\n)\n```\n\nThe `SnowflakeSearchTool` includes comprehensive error handling for common Snowflake issues: Connection failures Query timeouts Authentication errors Database and schema errors When an error occurs, the tool will attempt to retry the operation (if configured) and provide detailed error information.",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "# Create a task that includes error handling instructions\nrobust_extract_task = Task(\n    description=\"\"\"\n    Extract the main heading from example.com.\n    Be aware that you might encounter errors such as:\n    - Invalid URL format\n    - Missing API key\n    - Rate limit exceeded\n    - Network or API errors\n    \n    If you encounter any errors, provide a clear explanation of what went wrong\n    and suggest possible solutions.\n    \"\"\",\n    expected_output=\"Either the extracted heading or a clear error explanation\",\n    agent=web_scraper_agent,\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "# Create a task that instructs the agent to handle errors\nerror_handling_task = Task(\n    description=\"\"\"\n    Extract content from a potentially problematic website and make sure to handle any \n    scraping failures gracefully by setting ignore_scrape_failures to True.\n    \"\"\",\n    expected_output=\"Either the extracted content or a graceful error message\",\n    agent=web_scraper_agent,\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Conclusion",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Spider Scraper",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/spidertool The `SpiderTool` is designed to extract and read the content of a specified website using Spider.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`SpiderTool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Arguments",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "TXT RAG Search",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/txtsearchtool The `TXTSearchTool` is designed to perform a RAG (Retrieval-Augmented Generation) search within the content of a text file.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`TXTSearchTool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Arguments",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Custom model and embeddings",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Vision Tool",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/visiontool The `VisionTool` is designed to extract text from images.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`VisionTool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Usage",
            "level": 2,
            "content": "The `@listen()` decorator can be used in several ways: **Listening to a Method by Name**: You can pass the name of the method you want to listen to as a string. When that method completes, the listener method will be triggered.\n```\n@listen(\"generate_city\")\ndef generate_fun_fact(self, random_city):\n    # Implementation\n```\n**Listening to a Method Directly**: You can pass the method itself. When that method completes, the listener method will be triggered.\n```\n@listen(generate_city)\ndef generate_fun_fact(self, random_city):\n    # Implementation\n```\n\nHere's how to use the tool with a CrewAI agent:\n```\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools.aws.bedrock.agents.invoke_agent_tool import BedrockInvokeAgentTool\n\n# Initialize the tool\nagent_tool = BedrockInvokeAgentTool(\n    agent_id=\"your-agent-id\",\n    agent_alias_id=\"your-agent-alias-id\"\n)\n\n# Create a CrewAI agent that uses the tool\naws_expert = Agent(\n    role='AWS Service Expert',\n    goal='Help users understand AWS services and quotas',\n    backstory='I am an expert in AWS services and can provide detailed information about them.',\n    tools=[agent_tool],\n    verbose=True\n)\n\n# Create a task for the agent\nquota_task = Task(\n    description=\"Find out the current service quotas for EC2 in us-west-2 and explain any recent changes.\",\n    agent=aws_expert\n)\n\n# Create a crew with the agent\ncrew = Crew(\n    agents=[aws_expert],\n    tasks=[quota_task],\n    verbose=2\n)\n\n# Run the crew\nresult = crew.kickoff()\nprint(result)\n```\n\nHere's how to use the tool with a CrewAI agent:\n```\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools.aws.bedrock.knowledge_base.retriever_tool import BedrockKBRetrieverTool\n\n# Initialize the tool\nkb_tool = BedrockKBRetrieverTool(\n    knowledge_base_id=\"your-kb-id\",\n    number_of_results=5\n)\n\n# Create a CrewAI agent that uses the tool\nresearcher = Agent(\n    role='Knowledge Base Researcher',\n    goal='Find information about company policies',\n    backstory='I am a researcher specialized in retrieving and analyzing company documentation.',\n    tools=[kb_tool],\n    verbose=True\n)\n\n# Create a task for the agent\nresearch_task = Task(\n    description=\"Find our company's remote work policy and summarize the key points.\",\n    agent=researcher\n)\n\n# Create a crew with the agent\ncrew = Crew(\n    agents=[researcher],\n    tasks=[research_task],\n    verbose=2\n)\n\n# Run the crew\nresult = crew.kickoff()\nprint(result)   \n```\n\nWhen using the `MultiOnTool`, the agent will provide natural language instructions that the tool translates into web browsing actions. The tool returns the results of the browsing session along with a status.\n```\n# Example of using the tool with an agent\nbrowser_agent = Agent(\n    role=\"Web Browser Agent\",\n    goal=\"Search for and summarize information from the web\",\n    backstory=\"An expert at finding and extracting information from websites.\",\n    tools=[multion_tool],\n    verbose=True,\n)\n\n# Create a task for the agent\nsearch_task = Task(\n    description=\"Search for the latest AI news on TechCrunch and summarize the top 3 headlines\",\n    expected_output=\"A summary of the top 3 AI news headlines from TechCrunch\",\n    agent=browser_agent,\n)\n\n# Run the task\ncrew = Crew(agents=[browser_agent], tasks=[search_task])\nresult = crew.kickoff()\n```\nIf the status returned is `CONTINUE`, the agent should be instructed to reissue the same instruction to continue execution.\n\nIn order to use the NL2SQLTool, you need to pass the database URI to the tool. The URI should be in the format `dialect+driver://username:password@host:port/database`.\n```\nfrom crewai_tools import NL2SQLTool\n\n# psycopg2 was installed to run this example with PostgreSQL\nnl2sql = NL2SQLTool(db_uri=\"postgresql://example@localhost:5432/test_db\")\n\n@agent\ndef researcher(self) -> Agent:\n    return Agent(\n        config=self.agents_config[\"researcher\"],\n        allow_delegation=False,\n        tools=[nl2sql]\n    )\n```\n\nWhen using the Patronus evaluation tools, you provide the model input, output, and context, and the tool returns the evaluation results from the Patronus API. For the `PatronusEvalTool` and `PatronusPredefinedCriteriaEvalTool`, the following parameters are required when calling the tool: **evaluated\\_model\\_input**: The agent's task description in simple text. **evaluated\\_model\\_output**: The agent's output of the task. **evaluated\\_model\\_retrieved\\_context**: The agent's context. For the `PatronusLocalEvaluatorTool`, the same parameters are required, but the evaluator and gold answer are specified during initialization.\n\nWhen using the `S3ReaderTool` with an agent, the agent will need to provide the S3 file path:\n```\n# Example of using the tool with an agent\nfile_reader_agent = Agent(\n    role=\"File Reader\",\n    goal=\"Read files from S3 buckets\",\n    backstory=\"An expert in retrieving and processing files from cloud storage.\",\n    tools=[s3_reader_tool],\n    verbose=True,\n)\n\n# Create a task for the agent to read a specific file\nread_config_task = Task(\n    description=\"Read the application configuration file from {my_bucket} and extract the database connection settings.\",\n    expected_output=\"The database connection settings from the configuration file.\",\n    agent=file_reader_agent,\n)\n\n# Run the task\ncrew = Crew(agents=[file_reader_agent], tasks=[read_config_task])\nresult = crew.kickoff(inputs={\"my_bucket\": \"s3://my-bucket/config/app-config.json\"})\n```\n\nWhen using the `S3WriterTool` with an agent, the agent will need to provide both the S3 file path and the content to write:\n```\n# Example of using the tool with an agent\nfile_writer_agent = Agent(\n    role=\"File Writer\",\n    goal=\"Write content to files in S3 buckets\",\n    backstory=\"An expert in storing and managing files in cloud storage.\",\n    tools=[s3_writer_tool],\n    verbose=True,\n)\n\n# Create a task for the agent to write a specific file\nwrite_config_task = Task(\n    description=\"\"\"\n    Create a configuration file with the following database settings:\n    - host: db.example.com\n    - port: 5432\n    - username: app_user\n    - password: secure_password\n    \n    Save this configuration as JSON to {my_bucket}.\n    \"\"\",\n    expected_output=\"Confirmation that the configuration file was successfully saved to S3.\",\n    agent=file_writer_agent,\n)\n\n# Run the task\ncrew = Crew(agents=[file_writer_agent], tasks=[write_config_task])\nresult = crew.kickoff(inputs={\"my_bucket\": \"s3://my-bucket/config/db-config.json\"})\n```\n\nWhen using the `ScrapeElementFromWebsiteTool` with an agent, the agent will need to provide the following parameters (unless they were specified during initialization): **website\\_url**: The URL of the website to scrape. **css\\_element**: The CSS selector for the elements to extract. The tool will return the text content of all elements matching the CSS selector, joined by newlines.\n```\n# Example of using the tool with an agent\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract specific elements from websites\",\n    backstory=\"An expert in web scraping who can extract targeted content using CSS selectors.\",\n    tools=[scrape_tool],\n    verbose=True,\n)\n\n# Create a task for the agent to extract specific elements\nextract_task = Task(\n    description=\"\"\"\n    Extract all product titles from the featured products section on example.com.\n    Use the CSS selector '.product-title' to target the title elements.\n    \"\"\",\n    expected_output=\"A list of product titles from the website\",\n    agent=web_scraper_agent,\n)\n\n# Run the task through a crew\ncrew = Crew(agents=[web_scraper_agent], tasks=[extract_task])\nresult = crew.kickoff()\n```\n\nWhen using the `ScrapegraphScrapeTool` with an agent, the agent will need to provide the following parameters (unless they were specified during initialization): **website\\_url**: The URL of the website to scrape. **user\\_prompt**: Optional. Custom instructions for content extraction. Default is \"Extract the main content of the webpage\". The tool will return the extracted content based on the provided prompt.\n```\n# Example of using the tool with an agent\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract specific information from websites\",\n    backstory=\"An expert in web scraping who can extract targeted content from web pages.\",\n    tools=[scrape_tool],\n    verbose=True,\n)\n\n# Create a task for the agent to extract specific content\nextract_task = Task(\n    description=\"Extract the main heading and summary from example.com\",\n    expected_output=\"The main heading and summary from the website\",\n    agent=web_scraper_agent,\n)\n\n# Run the task\ncrew = Crew(agents=[web_scraper_agent], tasks=[extract_task])\nresult = crew.kickoff()\n```\n\nWhen using the `ScrapflyScrapeWebsiteTool` with an agent, the agent will need to provide the URL of the website to scrape and can optionally specify the format and additional configuration options:\n```\n# Example of using the tool with an agent\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract information from websites\",\n    backstory=\"An expert in web scraping who can extract content from any website.\",\n    tools=[scrape_tool],\n    verbose=True,\n)\n\n# Create a task for the agent\nscrape_task = Task(\n    description=\"Extract the main content from example.com in markdown format.\",\n    expected_output=\"The main content of example.com in markdown format.\",\n    agent=web_scraper_agent,\n)\n\n# Run the task\ncrew = Crew(agents=[web_scraper_agent], tasks=[scrape_task])\nresult = crew.kickoff()\n```\nFor more advanced usage with custom configuration:\n```\n# Create a task with more specific instructions\nadvanced_scrape_task = Task(\n    description=\"\"\"\n    Extract content from example.com with the following requirements:\n    - Convert the content to plain text format\n    - Enable JavaScript rendering\n    - Use a US-based proxy\n    - Handle any scraping failures gracefully\n    \"\"\",\n    expected_output=\"The extracted content from example.com\",\n    agent=web_scraper_agent,\n)\n```\n\nWhen using the `SnowflakeSearchTool`, you need to provide the following parameters: **query**: Required. The SQL query to execute. **database**: Optional. Override the default database specified in the config. **snowflake\\_schema**: Optional. Override the default schema specified in the config. **timeout**: Optional. Query timeout in seconds. Default is 300. The tool will return the query results as a list of dictionaries, where each dictionary represents a row with column names as keys.\n```\n# Example of using the tool with an agent\ndata_analyst = Agent(\n    role=\"Data Analyst\",\n    goal=\"Analyze sales data from Snowflake\",\n    backstory=\"An expert data analyst with experience in SQL and data visualization.\",\n    tools=[snowflake_tool],\n    verbose=True\n)\n\n# The agent will use the tool with parameters like:\n# query=\"SELECT product_name, SUM(revenue) as total_revenue FROM sales GROUP BY product_name ORDER BY total_revenue DESC LIMIT 5\"\n# timeout=600\n\n# Create a task for the agent\nanalysis_task = Task(\n    description=\"Query the sales database and identify the top 5 products by revenue for the last quarter.\",\n    expected_output=\"A detailed analysis of the top 5 products by revenue.\",\n    agent=data_analyst\n)\n\n# Run the task\ncrew = Crew(\n    agents=[data_analyst], \n    tasks=[analysis_task]\n)\nresult = crew.kickoff()\n```\n\nIn order to use the VisionTool, the OpenAI API key should be set in the environment variable `OPENAI_API_KEY`.\n```\nfrom crewai_tools import VisionTool\n\nvision_tool = VisionTool()\n\n@agent\ndef researcher(self) -> Agent:\n    '''\n    This agent uses the VisionTool to extract text from images.\n    '''\n    return Agent(\n        config=self.agents_config[\"researcher\"],\n        allow_delegation=False,\n        tools=[vision_tool]\n    )\n```",
            "metadata": {
              "section_type": "Examples",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "@listen(\"generate_city\")\ndef generate_fun_fact(self, random_city):\n    # Implementation",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "@listen(generate_city)\ndef generate_fun_fact(self, random_city):\n    # Implementation",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python {2, 4-8}",
                "content": "from crewai import Agent, Task, Crew\nfrom crewai_tools.aws.bedrock.agents.invoke_agent_tool import BedrockInvokeAgentTool\n\n# Initialize the tool\nagent_tool = BedrockInvokeAgentTool(\n    agent_id=\"your-agent-id\",\n    agent_alias_id=\"your-agent-alias-id\"\n)\n\n# Create a CrewAI agent that uses the tool\naws_expert = Agent(\n    role='AWS Service Expert',\n    goal='Help users understand AWS services and quotas',\n    backstory='I am an expert in AWS services and can provide detailed information about them.',\n    tools=[agent_tool],\n    verbose=True\n)\n\n# Create a task for the agent\nquota_task = Task(\n    description=\"Find out the current service quotas for EC2 in us-west-2 and explain any recent changes.\",\n    agent=aws_expert\n)\n\n# Create a crew with the agent\ncrew = Crew(\n    agents=[aws_expert],\n    tasks=[quota_task],\n    verbose=2\n)\n\n# Run the crew\nresult = crew.kickoff()\nprint(result)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python {2, 4-17}",
                "content": "from crewai import Agent, Task, Crew\nfrom crewai_tools.aws.bedrock.knowledge_base.retriever_tool import BedrockKBRetrieverTool\n\n# Initialize the tool\nkb_tool = BedrockKBRetrieverTool(\n    knowledge_base_id=\"your-kb-id\",\n    number_of_results=5\n)\n\n# Create a CrewAI agent that uses the tool\nresearcher = Agent(\n    role='Knowledge Base Researcher',\n    goal='Find information about company policies',\n    backstory='I am a researcher specialized in retrieving and analyzing company documentation.',\n    tools=[kb_tool],\n    verbose=True\n)\n\n# Create a task for the agent\nresearch_task = Task(\n    description=\"Find our company's remote work policy and summarize the key points.\",\n    agent=researcher\n)\n\n# Create a crew with the agent\ncrew = Crew(\n    agents=[researcher],\n    tasks=[research_task],\n    verbose=2\n)\n\n# Run the crew\nresult = crew.kickoff()\nprint(result)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "# Example of using the tool with an agent\nbrowser_agent = Agent(\n    role=\"Web Browser Agent\",\n    goal=\"Search for and summarize information from the web\",\n    backstory=\"An expert at finding and extracting information from websites.\",\n    tools=[multion_tool],\n    verbose=True,\n)\n\n# Create a task for the agent\nsearch_task = Task(\n    description=\"Search for the latest AI news on TechCrunch and summarize the top 3 headlines\",\n    expected_output=\"A summary of the top 3 AI news headlines from TechCrunch\",\n    agent=browser_agent,\n)\n\n# Run the task\ncrew = Crew(agents=[browser_agent], tasks=[search_task])\nresult = crew.kickoff()",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai_tools import NL2SQLTool\n\n# psycopg2 was installed to run this example with PostgreSQL\nnl2sql = NL2SQLTool(db_uri=\"postgresql://example@localhost:5432/test_db\")\n\n@agent\ndef researcher(self) -> Agent:\n    return Agent(\n        config=self.agents_config[\"researcher\"],\n        allow_delegation=False,\n        tools=[nl2sql]\n    )",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "# Example of using the tool with an agent\nfile_reader_agent = Agent(\n    role=\"File Reader\",\n    goal=\"Read files from S3 buckets\",\n    backstory=\"An expert in retrieving and processing files from cloud storage.\",\n    tools=[s3_reader_tool],\n    verbose=True,\n)\n\n# Create a task for the agent to read a specific file\nread_config_task = Task(\n    description=\"Read the application configuration file from {my_bucket} and extract the database connection settings.\",\n    expected_output=\"The database connection settings from the configuration file.\",\n    agent=file_reader_agent,\n)\n\n# Run the task\ncrew = Crew(agents=[file_reader_agent], tasks=[read_config_task])\nresult = crew.kickoff(inputs={\"my_bucket\": \"s3://my-bucket/config/app-config.json\"})",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "# Example of using the tool with an agent\nfile_writer_agent = Agent(\n    role=\"File Writer\",\n    goal=\"Write content to files in S3 buckets\",\n    backstory=\"An expert in storing and managing files in cloud storage.\",\n    tools=[s3_writer_tool],\n    verbose=True,\n)\n\n# Create a task for the agent to write a specific file\nwrite_config_task = Task(\n    description=\"\"\"\n    Create a configuration file with the following database settings:\n    - host: db.example.com\n    - port: 5432\n    - username: app_user\n    - password: secure_password\n    \n    Save this configuration as JSON to {my_bucket}.\n    \"\"\",\n    expected_output=\"Confirmation that the configuration file was successfully saved to S3.\",\n    agent=file_writer_agent,\n)\n\n# Run the task\ncrew = Crew(agents=[file_writer_agent], tasks=[write_config_task])\nresult = crew.kickoff(inputs={\"my_bucket\": \"s3://my-bucket/config/db-config.json\"})",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "# Example of using the tool with an agent\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract specific elements from websites\",\n    backstory=\"An expert in web scraping who can extract targeted content using CSS selectors.\",\n    tools=[scrape_tool],\n    verbose=True,\n)\n\n# Create a task for the agent to extract specific elements\nextract_task = Task(\n    description=\"\"\"\n    Extract all product titles from the featured products section on example.com.\n    Use the CSS selector '.product-title' to target the title elements.\n    \"\"\",\n    expected_output=\"A list of product titles from the website\",\n    agent=web_scraper_agent,\n)\n\n# Run the task through a crew\ncrew = Crew(agents=[web_scraper_agent], tasks=[extract_task])\nresult = crew.kickoff()",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "# Example of using the tool with an agent\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract specific information from websites\",\n    backstory=\"An expert in web scraping who can extract targeted content from web pages.\",\n    tools=[scrape_tool],\n    verbose=True,\n)\n\n# Create a task for the agent to extract specific content\nextract_task = Task(\n    description=\"Extract the main heading and summary from example.com\",\n    expected_output=\"The main heading and summary from the website\",\n    agent=web_scraper_agent,\n)\n\n# Run the task\ncrew = Crew(agents=[web_scraper_agent], tasks=[extract_task])\nresult = crew.kickoff()",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "# Example of using the tool with an agent\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract information from websites\",\n    backstory=\"An expert in web scraping who can extract content from any website.\",\n    tools=[scrape_tool],\n    verbose=True,\n)\n\n# Create a task for the agent\nscrape_task = Task(\n    description=\"Extract the main content from example.com in markdown format.\",\n    expected_output=\"The main content of example.com in markdown format.\",\n    agent=web_scraper_agent,\n)\n\n# Run the task\ncrew = Crew(agents=[web_scraper_agent], tasks=[scrape_task])\nresult = crew.kickoff()",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "# Create a task with more specific instructions\nadvanced_scrape_task = Task(\n    description=\"\"\"\n    Extract content from example.com with the following requirements:\n    - Convert the content to plain text format\n    - Enable JavaScript rendering\n    - Use a US-based proxy\n    - Handle any scraping failures gracefully\n    \"\"\",\n    expected_output=\"The extracted content from example.com\",\n    agent=web_scraper_agent,\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "# Example of using the tool with an agent\ndata_analyst = Agent(\n    role=\"Data Analyst\",\n    goal=\"Analyze sales data from Snowflake\",\n    backstory=\"An expert data analyst with experience in SQL and data visualization.\",\n    tools=[snowflake_tool],\n    verbose=True\n)\n\n# The agent will use the tool with parameters like:\n# query=\"SELECT product_name, SUM(revenue) as total_revenue FROM sales GROUP BY product_name ORDER BY total_revenue DESC LIMIT 5\"\n# timeout=600\n\n# Create a task for the agent\nanalysis_task = Task(\n    description=\"Query the sales database and identify the top 5 products by revenue for the last quarter.\",\n    expected_output=\"A detailed analysis of the top 5 products by revenue.\",\n    agent=data_analyst\n)\n\n# Run the task\ncrew = Crew(\n    agents=[data_analyst], \n    tasks=[analysis_task]\n)\nresult = crew.kickoff()",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai_tools import VisionTool\n\nvision_tool = VisionTool()\n\n@agent\ndef researcher(self) -> Agent:\n    '''\n    This agent uses the VisionTool to extract text from images.\n    '''\n    return Agent(\n        config=self.agents_config[\"researcher\"],\n        allow_delegation=False,\n        tools=[vision_tool]\n    )",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Arguments",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Weaviate Vector Search",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/weaviatevectorsearchtool The `WeaviateVectorSearchTool` is designed to search a Weaviate vector database for semantically similar documents.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`WeaviateVectorSearchTool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Steps to Get Started",
            "level": 2,
            "content": "To effectively use the LlamaIndexTool, follow these steps:\n\nTo effectively use the `AIMindTool`, follow these steps: **Package Installation**: Confirm that the `crewai[tools]` and `minds-sdk` packages are installed in your Python environment. **API Key Acquisition**: Sign up for a Minds account [here](https://mdb.ai/register), and obtain an API key. **Environment Configuration**: Store your obtained API key in an environment variable named `MINDS_API_KEY` to facilitate its use by the tool.\n\nTo effectively use the `BraveSearchTool`, follow these steps: **Package Installation**: Confirm that the `crewai[tools]` package is installed in your Python environment. **API Key Acquisition**: Acquire a Brave Search API key by registering at [Brave Search API](https://api.search.brave.com/app/keys). **Environment Configuration**: Store your obtained API key in an environment variable named `BRAVE_API_KEY` to facilitate its use by the tool.\n\nTo effectively use the EXASearchTool, follow these steps:\n\nTo effectively use the `HyperbrowserLoadTool`, follow these steps: **Sign Up**: Head to [Hyperbrowser](https://app.hyperbrowser.ai/) to sign up and generate an API key. **API Key**: Set the `HYPERBROWSER_API_KEY` environment variable or pass it directly to the tool constructor. **Install SDK**: Install the Hyperbrowser SDK using the command above.\n\nTo effectively use the `LinkupSearchTool`, follow these steps: **API Key**: Obtain a Linkup API key. **Environment Setup**: Set up your environment with the API key. **Install SDK**: Install the Linkup SDK using the command above.\n\nTo effectively use the `LlamaIndexTool`, follow these steps: **Install LlamaIndex**: Install the LlamaIndex package using the command above. **Set Up LlamaIndex**: Follow the [LlamaIndex documentation](https://docs.llamaindex.ai/) to set up a RAG/agent pipeline. **Create a Tool or Query Engine**: Create a LlamaIndex tool or query engine that you want to use with CrewAI.\n\nTo effectively use the `MultiOnTool`, follow these steps: **Install CrewAI**: Ensure that the `crewai[tools]` package is installed in your Python environment. **Install and use MultiOn**: Follow [MultiOn documentation](https://docs.multion.ai/learn/browser-extension) for installing the MultiOn Browser Extension. **Enable API Usage**: Click on the MultiOn extension in the extensions folder of your browser (not the hovering MultiOn icon on the web page) to open the extension configurations. Click the API Enabled toggle to enable the API.\n\nTo effectively use the Patronus evaluation tools, follow these steps: **Install Patronus**: Install the Patronus package using the command above. **Set Up API Key**: Set your Patronus API key as an environment variable. **Choose the Right Tool**: Select the appropriate Patronus evaluation tool based on your needs. **Configure the Tool**: Configure the tool with the necessary parameters.\n\nTo effectively use the `S3ReaderTool`, follow these steps: **Install Dependencies**: Install the required packages using the command above. **Configure AWS Credentials**: Set up your AWS credentials as environment variables. **Initialize the Tool**: Create an instance of the tool. **Specify S3 Path**: Provide the S3 path to the file you want to read.\n\nTo effectively use the `S3WriterTool`, follow these steps: **Install Dependencies**: Install the required packages using the command above. **Configure AWS Credentials**: Set up your AWS credentials as environment variables. **Initialize the Tool**: Create an instance of the tool. **Specify S3 Path and Content**: Provide the S3 path where you want to write the file and the content to be written.\n\nTo effectively use the `ScrapeElementFromWebsiteTool`, follow these steps: **Install Dependencies**: Install the required packages using the command above. **Identify CSS Selectors**: Determine the CSS selectors for the elements you want to extract from the website. **Initialize the Tool**: Create an instance of the tool with the necessary parameters.\n\nTo effectively use the `ScrapegraphScrapeTool`, follow these steps: **Install Dependencies**: Install the required package using the command above. **Set Up API Key**: Set your Scrapegraph API key as an environment variable or provide it during initialization. **Initialize the Tool**: Create an instance of the tool with the necessary parameters. **Define Extraction Prompts**: Create natural language prompts to guide the extraction of specific content.\n\nTo effectively use the `ScrapflyScrapeWebsiteTool`, follow these steps: **Install Dependencies**: Install the Scrapfly SDK using the command above. **Obtain API Key**: Register at Scrapfly to get your API key. **Initialize the Tool**: Create an instance of the tool with your API key. **Configure Scraping Parameters**: Customize the scraping parameters based on your needs.\n\nTo effectively use the `SerperDevTool`, follow these steps: **Package Installation**: Confirm that the `crewai[tools]` package is installed in your Python environment. **API Key Acquisition**: Acquire a `serper.dev` API key by registering for a free account at `serper.dev`. **Environment Configuration**: Store your obtained API key in an environment variable named `SERPER_API_KEY` to facilitate its use by the tool.\n\nTo effectively use the `SnowflakeSearchTool`, follow these steps: **Install Dependencies**: Install the required packages using one of the commands above. **Configure Snowflake Connection**: Create a `SnowflakeConfig` object with your Snowflake credentials. **Initialize the Tool**: Create an instance of the tool with the necessary configuration. **Execute Queries**: Use the tool to run SQL queries against your Snowflake database.\n\nTo effectively use the `WeaviateVectorSearchTool`, follow these steps: **Package Installation**: Confirm that the `crewai[tools]` and `weaviate-client` packages are installed in your Python environment. **Weaviate Setup**: Set up a Weaviate cluster. You can follow the [Weaviate documentation](https://weaviate.io/developers/wcs/connect) for instructions. **API Keys**: Obtain your Weaviate cluster URL and API key. **OpenAI API Key**: Ensure you have an OpenAI API key set in your environment variables as `OPENAI_API_KEY`.",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Parameters",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Advanced Configuration",
            "level": 2,
            "content": "You can customize the behavior of the `RagTool` by providing a configuration dictionary:\n```\nfrom crewai_tools import RagTool\n\n# Create a RAG tool with custom configuration\nconfig = {\n    \"app\": {\n        \"name\": \"custom_app\",\n    },\n    \"llm\": {\n        \"provider\": \"openai\",\n        \"config\": {\n            \"model\": \"gpt-4\",\n        }\n    },\n    \"embedding_model\": {\n        \"provider\": \"openai\",\n        \"config\": {\n            \"model\": \"text-embedding-ada-002\"\n        }\n    }\n}\n\nrag_tool = RagTool(config=config, summarize=True)\n```\n\nYou can customize the vectorizer and generative model used by the tool:\n```\nfrom crewai_tools import WeaviateVectorSearchTool\nfrom weaviate.classes.config import Configure\n\n# Setup custom model for vectorizer and generative model\ntool = WeaviateVectorSearchTool(\n    collection_name='example_collections',\n    limit=3,\n    vectorizer=Configure.Vectorizer.text2vec_openai(model=\"nomic-embed-text\"),\n    generative_model=Configure.Generative.openai(model=\"gpt-4o-mini\"),\n    weaviate_cluster_url=\"https://your-weaviate-cluster-url.com\",\n    weaviate_api_key=\"your-weaviate-api-key\",\n)\n```",
            "metadata": {
              "section_type": "Internals/Advanced",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai_tools import RagTool\n\n# Create a RAG tool with custom configuration\nconfig = {\n    \"app\": {\n        \"name\": \"custom_app\",\n    },\n    \"llm\": {\n        \"provider\": \"openai\",\n        \"config\": {\n            \"model\": \"gpt-4\",\n        }\n    },\n    \"embedding_model\": {\n        \"provider\": \"openai\",\n        \"config\": {\n            \"model\": \"text-embedding-ada-002\"\n        }\n    }\n}\n\nrag_tool = RagTool(config=config, summarize=True)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai_tools import WeaviateVectorSearchTool\nfrom weaviate.classes.config import Configure\n\n# Setup custom model for vectorizer and generative model\ntool = WeaviateVectorSearchTool(\n    collection_name='example_collections',\n    limit=3,\n    vectorizer=Configure.Vectorizer.text2vec_openai(model=\"nomic-embed-text\"),\n    generative_model=Configure.Generative.openai(model=\"gpt-4o-mini\"),\n    weaviate_cluster_url=\"https://your-weaviate-cluster-url.com\",\n    weaviate_api_key=\"your-weaviate-api-key\",\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Preloading Documents",
            "level": 2,
            "content": "You can preload your Weaviate database with documents before using the tool:\n```\nimport os\nfrom crewai_tools import WeaviateVectorSearchTool\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Connect to Weaviate\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=\"https://your-weaviate-cluster-url.com\",\n    auth_credentials=Auth.api_key(\"your-weaviate-api-key\"),\n    headers={\"X-OpenAI-Api-Key\": \"your-openai-api-key\"}\n)\n\n# Get or create collection\ntest_docs = client.collections.get(\"example_collections\")\nif not test_docs:\n    test_docs = client.collections.create(\n        name=\"example_collections\",\n        vectorizer_config=Configure.Vectorizer.text2vec_openai(model=\"nomic-embed-text\"),\n        generative_config=Configure.Generative.openai(model=\"gpt-4o\"),\n    )\n\n# Load documents\ndocs_to_load = os.listdir(\"knowledge\")\nwith test_docs.batch.dynamic() as batch:\n    for d in docs_to_load:\n        with open(os.path.join(\"knowledge\", d), \"r\") as f:\n            content = f.read()\n        batch.add_object(\n            {\n                \"content\": content,\n                \"year\": d.split(\"_\")[0],\n            }\n        )\n\n# Initialize the tool\ntool = WeaviateVectorSearchTool(\n    collection_name='example_collections', \n    limit=3,\n    weaviate_cluster_url=\"https://your-weaviate-cluster-url.com\",\n    weaviate_api_key=\"your-weaviate-api-key\",\n)\n```",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "import os\nfrom crewai_tools import WeaviateVectorSearchTool\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Connect to Weaviate\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=\"https://your-weaviate-cluster-url.com\",\n    auth_credentials=Auth.api_key(\"your-weaviate-api-key\"),\n    headers={\"X-OpenAI-Api-Key\": \"your-openai-api-key\"}\n)\n\n# Get or create collection\ntest_docs = client.collections.get(\"example_collections\")\nif not test_docs:\n    test_docs = client.collections.create(\n        name=\"example_collections\",\n        vectorizer_config=Configure.Vectorizer.text2vec_openai(model=\"nomic-embed-text\"),\n        generative_config=Configure.Generative.openai(model=\"gpt-4o\"),\n    )\n\n# Load documents\ndocs_to_load = os.listdir(\"knowledge\")\nwith test_docs.batch.dynamic() as batch:\n    for d in docs_to_load:\n        with open(os.path.join(\"knowledge\", d), \"r\") as f:\n            content = f.read()\n        batch.add_object(\n            {\n                \"content\": content,\n                \"year\": d.split(\"_\")[0],\n            }\n        )\n\n# Initialize the tool\ntool = WeaviateVectorSearchTool(\n    collection_name='example_collections', \n    limit=3,\n    weaviate_cluster_url=\"https://your-weaviate-cluster-url.com\",\n    weaviate_api_key=\"your-weaviate-api-key\",\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Agent Integration Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Conclusion",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "Website RAG Search",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/websitesearchtool The `WebsiteSearchTool` is designed to perform a RAG (Retrieval-Augmented Generation) search within the content of a website.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`WebsiteSearchTool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example Usage",
            "level": 2,
            "content": "Here's a detailed example of creating an agent with code execution capabilities and using it in a task:\n```\nfrom crewai import Agent, Task, Crew\n\n# Create an agent with code execution enabled\ncoding_agent = Agent(\n    role=\"Python Data Analyst\",\n    goal=\"Analyze data and provide insights using Python\",\n    backstory=\"You are an experienced data analyst with strong Python skills.\",\n    allow_code_execution=True\n)\n\n# Create a task that requires code execution\ndata_analysis_task = Task(\n    description=\"Analyze the given dataset and calculate the average age of participants.\",\n    agent=coding_agent\n)\n\n# Create a crew and add the task\nanalysis_crew = Crew(\n    agents=[coding_agent],\n    tasks=[data_analysis_task]\n)\n\n# Execute the crew\nresult = analysis_crew.kickoff()\n\nprint(result)\n```\nIn this example, the `coding_agent` can write and execute Python code to perform data analysis tasks.\n\n```\nfrom typing import List\nfrom pydantic import BaseModel\nfrom crewai import Agent, Crew\nfrom crewai.tasks.conditional_task import ConditionalTask\nfrom crewai.tasks.task_output import TaskOutput\nfrom crewai.task import Task\nfrom crewai_tools import SerperDevTool\n\n# Define a condition function for the conditional task\n# If false, the task will be skipped, if true, then execute the task.\ndef is_data_missing(output: TaskOutput) -> bool:\n    return len(output.pydantic.events) < 10  # this will skip this task\n\n# Define the agents\ndata_fetcher_agent = Agent(\n    role=\"Data Fetcher\",\n    goal=\"Fetch data online using Serper tool\",\n    backstory=\"Backstory 1\",\n    verbose=True,\n    tools=[SerperDevTool()]\n)\n\ndata_processor_agent = Agent(\n    role=\"Data Processor\",\n    goal=\"Process fetched data\",\n    backstory=\"Backstory 2\",\n    verbose=True\n)\n\nsummary_generator_agent = Agent(\n    role=\"Summary Generator\",\n    goal=\"Generate summary from fetched data\",\n    backstory=\"Backstory 3\",\n    verbose=True\n)\n\nclass EventOutput(BaseModel):\n    events: List[str]\n\ntask1 = Task(\n    description=\"Fetch data about events in San Francisco using Serper tool\",\n    expected_output=\"List of 10 things to do in SF this week\",\n    agent=data_fetcher_agent,\n    output_pydantic=EventOutput,\n)\n\nconditional_task = ConditionalTask(\n    description=\"\"\"\n        Check if data is missing. If we have less than 10 events,\n        fetch more events using Serper tool so that\n        we have a total of 10 events in SF this week..\n        \"\"\",\n    expected_output=\"List of 10 Things to do in SF this week\",\n    condition=is_data_missing,\n    agent=data_processor_agent,\n)\n\ntask3 = Task(\n    description=\"Generate summary of events in San Francisco from fetched data\",\n    expected_output=\"A complete report on the customer and their customers and competitors, including their demographics, preferences, market positioning and audience engagement.\",\n    agent=summary_generator_agent,\n)\n\n# Create a crew with the tasks\ncrew = Crew(\n    agents=[data_fetcher_agent, data_processor_agent, summary_generator_agent],\n    tasks=[task1, conditional_task, task3],\n    verbose=True,\n    planning=True\n)\n\n# Run the crew\nresult = crew.kickoff()\nprint(\"results\", result)\n```\n\nBelow is a proposed example showcasing how to use the PGSearchTool for conducting a semantic search on a table within a PostgreSQL database:\n```\nfrom crewai_tools import PGSearchTool\n\n# Initialize the tool with the database URI and the target table name\ntool = PGSearchTool(\n    db_uri='postgresql://user:password@localhost:5432/mydatabase', \n    table_name='employees'\n)\n```\n\nBelow are examples of how the WebsiteSearchTool could be utilized in different scenarios. Please note, these examples are illustrative and represent planned functionality:\n```\nfrom crewai_tools import WebsiteSearchTool\n\n# Example of initiating tool that agents can use \n# to search across any discovered websites\ntool = WebsiteSearchTool()\n\n# Example of limiting the search to the content of a specific website, \n# so now agents can only search within that website\ntool = WebsiteSearchTool(website='https://example.com')\n```",
            "metadata": {
              "section_type": "Examples",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai import Agent, Task, Crew\n\n# Create an agent with code execution enabled\ncoding_agent = Agent(\n    role=\"Python Data Analyst\",\n    goal=\"Analyze data and provide insights using Python\",\n    backstory=\"You are an experienced data analyst with strong Python skills.\",\n    allow_code_execution=True\n)\n\n# Create a task that requires code execution\ndata_analysis_task = Task(\n    description=\"Analyze the given dataset and calculate the average age of participants.\",\n    agent=coding_agent\n)\n\n# Create a crew and add the task\nanalysis_crew = Crew(\n    agents=[coding_agent],\n    tasks=[data_analysis_task]\n)\n\n# Execute the crew\nresult = analysis_crew.kickoff()\n\nprint(result)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from typing import List\nfrom pydantic import BaseModel\nfrom crewai import Agent, Crew\nfrom crewai.tasks.conditional_task import ConditionalTask\nfrom crewai.tasks.task_output import TaskOutput\nfrom crewai.task import Task\nfrom crewai_tools import SerperDevTool\n\n# Define a condition function for the conditional task\n# If false, the task will be skipped, if true, then execute the task.\ndef is_data_missing(output: TaskOutput) -> bool:\n    return len(output.pydantic.events) < 10  # this will skip this task\n\n# Define the agents\ndata_fetcher_agent = Agent(\n    role=\"Data Fetcher\",\n    goal=\"Fetch data online using Serper tool\",\n    backstory=\"Backstory 1\",\n    verbose=True,\n    tools=[SerperDevTool()]\n)\n\ndata_processor_agent = Agent(\n    role=\"Data Processor\",\n    goal=\"Process fetched data\",\n    backstory=\"Backstory 2\",\n    verbose=True\n)\n\nsummary_generator_agent = Agent(\n    role=\"Summary Generator\",\n    goal=\"Generate summary from fetched data\",\n    backstory=\"Backstory 3\",\n    verbose=True\n)\n\nclass EventOutput(BaseModel):\n    events: List[str]\n\ntask1 = Task(\n    description=\"Fetch data about events in San Francisco using Serper tool\",\n    expected_output=\"List of 10 things to do in SF this week\",\n    agent=data_fetcher_agent,\n    output_pydantic=EventOutput,\n)\n\nconditional_task = ConditionalTask(\n    description=\"\"\"\n        Check if data is missing. If we have less than 10 events,\n        fetch more events using Serper tool so that\n        we have a total of 10 events in SF this week..\n        \"\"\",\n    expected_output=\"List of 10 Things to do in SF this week\",\n    condition=is_data_missing,\n    agent=data_processor_agent,\n)\n\ntask3 = Task(\n    description=\"Generate summary of events in San Francisco from fetched data\",\n    expected_output=\"A complete report on the customer and their customers and competitors, including their demographics, preferences, market positioning and audience engagement.\",\n    agent=summary_generator_agent,\n)\n\n# Create a crew with the tasks\ncrew = Crew(\n    agents=[data_fetcher_agent, data_processor_agent, summary_generator_agent],\n    tasks=[task1, conditional_task, task3],\n    verbose=True,\n    planning=True\n)\n\n# Run the crew\nresult = crew.kickoff()\nprint(\"results\", result)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai_tools import PGSearchTool\n\n# Initialize the tool with the database URI and the target table name\ntool = PGSearchTool(\n    db_uri='postgresql://user:password@localhost:5432/mydatabase', \n    table_name='employees'\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai_tools import WebsiteSearchTool\n\n# Example of initiating tool that agents can use \n# to search across any discovered websites\ntool = WebsiteSearchTool()\n\n# Example of limiting the search to the content of a specific website, \n# so now agents can only search within that website\ntool = WebsiteSearchTool(website='https://example.com')",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Arguments",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Customization Options",
            "level": 2,
            "content": "By default, the tool uses OpenAI for both embeddings and summarization. To customize the model, you can use a config dictionary as follows:\n```\ntool = WebsiteSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)\n```",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "tool = WebsiteSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          }
        ]
      },
      {
        "type": "header",
        "title": "XML RAG Search",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/xmlsearchtool The `XMLSearchTool` is designed to perform a RAG (Retrieval-Augmented Generation) search within the content of a XML file.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`XMLSearchTool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Arguments",
            "level": 2,
            "content": "The following parameters can be used to customize the `BrowserbaseLoadTool`'s behavior: | Argument          | Type     | Description                                                                           |\n| :---------------- | :------- | :------------------------------------------------------------------------------------ |\n| **api\\_key**      | `string` | *Optional*. Browserbase API key. Default is `BROWSERBASE_API_KEY` env variable.       |\n| **project\\_id**   | `string` | *Optional*. Browserbase Project ID. Default is `BROWSERBASE_PROJECT_ID` env variable. |\n| **text\\_content** | `bool`   | *Optional*. Retrieve only text content. Default is `False`.                           |\n| **session\\_id**   | `string` | *Optional*. Provide an existing Session ID.                                           |\n| **proxy**         | `bool`   | *Optional*. Enable/Disable Proxies. Default is `False`.                               |\n\nThe following parameters can be used to customize the `CodeDocsSearchTool`'s behavior: | Argument      | Type     | Description                                                             |\n| :------------ | :------- | :---------------------------------------------------------------------- |\n| **docs\\_url** | `string` | *Optional*. Specifies the URL of the code documentation to be searched. |\n\nThe following parameters can be used to customize the `CSVSearchTool`'s behavior: | Argument | Type     | Description                                                                                                                                                               |\n| :------- | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| **csv**  | `string` | *Optional*. The path to the CSV file you want to search. This is a mandatory argument if the tool was initialized without a specific CSV file; otherwise, it is optional. |\n\nThe following parameters can be used to customize the `DirectoryReadTool`'s behavior: | Argument      | Type     | Description                                                                                                                                                                                                   |\n| :------------ | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| **directory** | `string` | *Optional*. An argument that specifies the path to the directory whose contents you wish to list. It accepts both absolute and relative paths, guiding the tool to the desired directory for content listing. |\n\n`directory`: A string argument that specifies the search directory. This is optional during initialization but required for searches if not set initially.\n\nThe following parameters can be used to customize the `DOCXSearchTool`'s behavior: | Argument | Type     | Description                                                                                                                                                                                                        |\n| :------- | :------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **docx** | `string` | *Optional*. An argument that specifies the path to the DOCX file you want to search. If not provided during initialization, the tool allows for later specification of any DOCX file's content path for searching. |\n\n`file_path`: The path to the file you want to read. It accepts both absolute and relative paths. Ensure the file exists and you have the necessary permissions to access it.\n\n`filename`: The name of the file you want to create or overwrite. `content`: The content to write into the file. `directory` (optional): The path to the directory where the file will be created. Defaults to the current directory (`.`). If the directory does not exist, it will be created.\n\n`api_key`: Optional. Specifies Firecrawl API key. Defaults is the `FIRECRAWL_API_KEY` environment variable. `url`: The base URL to start crawling from. `page_options`: Optional. `onlyMainContent`: Optional. Only return the main content of the page excluding headers, navs, footers, etc. `includeHtml`: Optional. Include the raw HTML content of the page. Will output a html key in the response. `crawler_options`: Optional. Options for controlling the crawling behavior. `includes`: Optional. URL patterns to include in the crawl. `exclude`: Optional. URL patterns to exclude from the crawl. `generateImgAltText`: Optional. Generate alt text for images using LLMs (requires a paid plan). `returnOnlyUrls`: Optional. If true, returns only the URLs as a list in the crawl status. Note: the response will be a list of URLs inside the data, not a list of documents. `maxDepth`: Optional. Maximum depth to crawl. Depth 1 is the base URL, depth 2 includes the base URL and its direct children, and so on. `mode`: Optional. The crawling mode to use. Fast mode crawls 4x faster on websites without a sitemap but may not be as accurate and shouldn't be used on heavily JavaScript-rendered websites. `limit`: Optional. Maximum number of pages to crawl. `timeout`: Optional. Timeout in milliseconds for the crawling operation.\n\n`api_key`: Optional. Specifies Firecrawl API key. Defaults is the `FIRECRAWL_API_KEY` environment variable. `url`: The URL to scrape. `page_options`: Optional. `onlyMainContent`: Optional. Only return the main content of the page excluding headers, navs, footers, etc. `includeHtml`: Optional. Include the raw HTML content of the page. Will output a html key in the response. `extractor_options`: Optional. Options for LLM-based extraction of structured information from the page content `mode`: The extraction mode to use, currently supports 'llm-extraction' `extractionPrompt`: Optional. A prompt describing what information to extract from the page `extractionSchema`: Optional. The schema for the data to be extracted `timeout`: Optional. Timeout in milliseconds for the request\n\n`api_key`: Optional. Specifies Firecrawl API key. Defaults is the `FIRECRAWL_API_KEY` environment variable. `query`: The search query string to be used for searching. `page_options`: Optional. Options for result formatting. `onlyMainContent`: Optional. Only return the main content of the page excluding headers, navs, footers, etc. `includeHtml`: Optional. Include the raw HTML content of the page. Will output a html key in the response. `fetchPageContent`: Optional. Fetch the full content of the page. `search_options`: Optional. Options for controlling the crawling behavior. `limit`: Optional. Maximum number of pages to crawl.\n\n`github_repo` : The URL of the GitHub repository where the search will be conducted. This is a mandatory field and specifies the target repository for your search. `gh_token` : Your GitHub Personal Access Token (PAT) required for authentication. You can create one in your GitHub account settings under Developer Settings > Personal Access Tokens. `content_types` : Specifies the types of content to include in your search. You must provide a list of content types from the following options: `code` for searching within the code,\n`repo` for searching within the repository's general information, `pr` for searching within pull requests, and `issue` for searching within issues.\nThis field is mandatory and allows tailoring the search to specific content types within the GitHub repository.\n\n`json_path` (str, optional): Specifies the path to the JSON file to be searched. This argument is not required if the tool is initialized for a general search. When provided, it confines the search to the specified JSON file.\n\nThe MySQLSearchTool requires the following arguments for its operation: `db_uri`: A string representing the URI of the MySQL database to be queried. This argument is mandatory and must include the necessary authentication details and the location of the database. `table_name`: A string specifying the name of the table within the database on which the semantic search will be performed. This argument is mandatory.\n\n`pdf`: **Optional** The PDF path for the search. Can be provided at initialization or within the `run` method's arguments. If provided at initialization, the tool confines its search to the specified document.\n\nThe PGSearchTool is designed to require the following arguments for its operation: | Argument        | Type     | Description                                                                                                                                                                                                    |\n| :-------------- | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **db\\_uri**     | `string` | **Mandatory**. A string representing the URI of the PostgreSQL database to be queried. This argument will be mandatory and must include the necessary authentication details and the location of the database. |\n| **table\\_name** | `string` | **Mandatory**. A string specifying the name of the table within the database on which the semantic search will be performed. This argument will also be mandatory.                                             |\n\n| Argument         | Type     | Description                                                                                                                                        |\n| :--------------- | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **website\\_url** | `string` | **Mandatory** website URL to read the file. This is the primary input for the tool, specifying which website's content should be scraped and read. |\n\n| Argument                | Type     | Description                                                                                                                       |\n| :---------------------- | :------- | :-------------------------------------------------------------------------------------------------------------------------------- |\n| **api\\_key**            | `string` | Specifies Spider API key. If not specified, it looks for `SPIDER_API_KEY` in environment variables.                               |\n| **params**              | `object` | Optional parameters for the request. Defaults to `{\"return_format\": \"markdown\"}` to optimize content for LLMs.                    |\n| **request**             | `string` | Type of request to perform (`http`, `chrome`, `smart`). `smart` defaults to HTTP, switching to JavaScript rendering if needed.    |\n| **limit**               | `int`    | Max pages to crawl per website. Set to `0` or omit for unlimited.                                                                 |\n| **depth**               | `int`    | Max crawl depth. Set to `0` for no limit.                                                                                         |\n| **cache**               | `bool`   | Enables HTTP caching to speed up repeated runs. Default is `true`.                                                                |\n| **budget**              | `object` | Sets path-based limits for crawled pages, e.g., `{\"*\":1}` for root page only.                                                     |\n| **locale**              | `string` | Locale for the request, e.g., `en-US`.                                                                                            |\n| **cookies**             | `string` | HTTP cookies for the request.                                                                                                     |\n| **stealth**             | `bool`   | Enables stealth mode for Chrome requests to avoid detection. Default is `true`.                                                   |\n| **headers**             | `object` | HTTP headers as a map of key-value pairs for all requests.                                                                        |\n| **metadata**            | `bool`   | Stores metadata about pages and content, aiding AI interoperability. Defaults to `false`.                                         |\n| **viewport**            | `object` | Sets Chrome viewport dimensions. Default is `800x600`.                                                                            |\n| **encoding**            | `string` | Specifies encoding type, e.g., `UTF-8`, `SHIFT_JIS`.                                                                              |\n| **subdomains**          | `bool`   | Includes subdomains in the crawl. Default is `false`.                                                                             |\n| **user\\_agent**         | `string` | Custom HTTP user agent. Defaults to a random agent.                                                                               |\n| **store\\_data**         | `bool`   | Enables data storage for the request. Overrides `storageless` when set. Default is `false`.                                       |\n| **gpt\\_config**         | `object` | Allows AI to generate crawl actions, with optional chaining steps via an array for `\"prompt\"`.                                    |\n| **fingerprint**         | `bool`   | Enables advanced fingerprinting for Chrome.                                                                                       |\n| **storageless**         | `bool`   | Prevents all data storage, including AI embeddings. Default is `false`.                                                           |\n| **readability**         | `bool`   | Pre-processes content for reading via [Mozilla\u2019s readability](https://github.com/mozilla/readability). Improves content for LLMs. |\n| **return\\_format**      | `string` | Format to return data: `markdown`, `raw`, `text`, `html2text`. Use `raw` for default page format.                                 |\n| **proxy\\_enabled**      | `bool`   | Enables high-performance proxies to avoid network-level blocking.                                                                 |\n| **query\\_selector**     | `string` | CSS query selector for content extraction from markup.                                                                            |\n| **full\\_resources**     | `bool`   | Downloads all resources linked to the website.                                                                                    |\n| **request\\_timeout**    | `int`    | Timeout in seconds for requests (5-60). Default is `30`.                                                                          |\n| **run\\_in\\_background** | `bool`   | Runs the request in the background, useful for data storage and triggering dashboard crawls. No effect if `storageless` is set.   |\n\n`txt` (str): **Optional**. The path to the text file you want to search.\nThis argument is only required if the tool was not initialized with a specific text file;\notherwise, the search will be conducted within the initially provided text file.\n\nThe VisionTool requires the following arguments: | Argument             | Type     | Description                                                                      |\n| :------------------- | :------- | :------------------------------------------------------------------------------- |\n| **image\\_path\\_url** | `string` | **Mandatory**. The path to the image file from which text needs to be extracted. |\n\n`website`: An optional argument intended to specify the website URL for focused searches. This argument is designed to enhance the tool's flexibility by allowing targeted searches when necessary.\n\n`xml`: This is the path to the XML file you wish to search.\nIt is an optional parameter during the tool's initialization but must be provided either at initialization or as part of the `run` method's arguments to execute a search.",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Custom model and embeddings",
            "level": 2,
            "content": "By default, the tool uses OpenAI for both embeddings and summarization. To customize the model, you can use a config dictionary as follows:\n```\ntool = CodeDocsSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)\n```\n\nBy default, the tool uses OpenAI for both embeddings and summarization. To customize the model, you can use a config dictionary as follows:\n```\ntool = CSVSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)\n```\n\nBy default, the tool uses OpenAI for both embeddings and summarization. To customize the model, you can use a config dictionary as follows:\n```\ntool = DOCXSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)\n```\n\nBy default, the tool uses OpenAI for both embeddings and summarization. To customize the model, you can use a config dictionary as follows:\n```\ntool = GithubSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)\n```\n\nBy default, the tool uses OpenAI for both embeddings and summarization. To customize the model, you can use a config dictionary as follows:\n```\ntool = MySQLSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\",\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)\n```\n\nBy default, the tool uses OpenAI for both embeddings and summarization. To customize the model, you can use a config dictionary as follows:\n```\ntool = PDFSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)\n```\n\nBy default, the tool uses OpenAI for both embeddings and summarization.\nTo customize the model, you can use a config dictionary as follows:\n```\ntool = TXTSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)\n```\n\nBy default, the tool uses OpenAI for both embeddings and summarization. To customize the model, you can use a config dictionary as follows:\n```\ntool = XMLSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)\n```",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "tool = CodeDocsSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "tool = CSVSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "tool = DOCXSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "tool = GithubSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "tool = MySQLSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\",\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "tool = PDFSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "tool = TXTSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "tool = XMLSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          }
        ]
      },
      {
        "type": "header",
        "title": "YouTube Channel RAG Search",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/youtubechannelsearchtool The `YoutubeChannelSearchTool` is designed to perform a RAG (Retrieval-Augmented Generation) search within the content of a Youtube channel.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`YoutubeChannelSearchTool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Parameters",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Custom Model and Embeddings",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Agent Integration Example",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "Examples",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Implementation Details",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Conclusion",
            "level": 2,
            "content": "",
            "metadata": {
              "section_type": "General",
              "content_type": null
            },
            "children": []
          }
        ]
      },
      {
        "type": "header",
        "title": "YouTube Video RAG Search",
        "level": 1,
        "content": "Source: https://docs.crewai.com/tools/youtubevideosearchtool The `YoutubeVideoSearchTool` is designed to perform a RAG (Retrieval-Augmented Generation) search within the content of a Youtube video.",
        "metadata": {
          "section_type": "General",
          "content_type": "short_description"
        },
        "children": []
      },
      {
        "type": "header",
        "title": "`YoutubeVideoSearchTool`",
        "level": 1,
        "content": "",
        "metadata": {
          "section_type": "General",
          "content_type": null
        },
        "children": [
          {
            "type": "header",
            "title": "Description",
            "level": 2,
            "content": "The `AIMindTool` is a wrapper around [AI-Minds](https://mindsdb.com/minds) provided by [MindsDB](https://mindsdb.com/). It allows you to query data sources in natural language by simply configuring their connection parameters. This tool is useful when you need answers to questions from your data stored in various data sources including PostgreSQL, MySQL, MariaDB, ClickHouse, Snowflake, and Google BigQuery. Minds are AI systems that work similarly to large language models (LLMs) but go beyond by answering any question from any data. This is accomplished by: Selecting the most relevant data for an answer using parametric search Understanding the meaning and providing responses within the correct context through semantic search Delivering precise answers by analyzing data and using machine learning (ML) models\n\nThe `ApifyActorsTool` connects [Apify Actors](https://apify.com/actors), cloud-based programs for web scraping and automation, to your CrewAI workflows.\nUse any of the 4,000+ Actors on [Apify Store](https://apify.com/store) for use cases such as extracting data from social media, search engines, online maps, e-commerce sites, travel portals, or general websites. For details, see the [Apify CrewAI integration](https://docs.apify.com/platform/integrations/crewai) in Apify documentation.\n\nThis tool is designed to perform web searches using the Brave Search API. It allows you to search the internet with a specified query and retrieve relevant results. The tool supports customizable result counts and country-specific searches.\n\n[Browserbase](https://browserbase.com) is a developer platform to reliably run, manage, and monitor headless browsers. Power your AI data retrievals with: [Serverless Infrastructure](https://docs.browserbase.com/under-the-hood) providing reliable browsers to extract data from complex UIs [Stealth Mode](https://docs.browserbase.com/features/stealth-mode) with included fingerprinting tactics and automatic captcha solving [Session Debugger](https://docs.browserbase.com/features/sessions) to inspect your Browser Session with networks timeline and logs [Live Debug](https://docs.browserbase.com/guides/session-debug-connection/browser-remote-control) to quickly debug your automation\n\nThe CodeDocsSearchTool is a powerful RAG (Retrieval-Augmented Generation) tool designed for semantic searches within code documentation.\nIt enables users to efficiently find specific information or topics within code documentation. By providing a `docs_url` during initialization,\nthe tool narrows down the search to that particular documentation site. Alternatively, without a specific `docs_url`,\nit searches across a wide array of code documentation known or discovered throughout its execution, making it versatile for various documentation search needs.\n\nThe `CodeInterpreterTool` enables CrewAI agents to execute Python 3 code that they generate autonomously. The code is run in a secure, isolated Docker container, ensuring safety regardless of the content. This functionality is particularly valuable as it allows agents to create code, execute it, obtain the results, and utilize that information to inform subsequent decisions and actions.\n\nComposio is an integration platform that allows you to connect your AI agents to 250+ tools. Key features include: **Enterprise-Grade Authentication**: Built-in support for OAuth, API Keys, JWT with automatic token refresh **Full Observability**: Detailed tool usage logs, execution timestamps, and more\n\nThis tool is used to perform a RAG (Retrieval-Augmented Generation) search within a CSV file's content. It allows users to semantically search for queries in the content of a specified CSV file.\nThis feature is particularly useful for extracting information from large CSV datasets where traditional search methods might be inefficient. All tools with \"Search\" in their name, including CSVSearchTool,\nare RAG tools designed for searching different sources of data.\n\nThis tool is used to give the Agent the ability to generate images using the DALL-E model. It is a transformer-based model that generates images from textual descriptions.\nThis tool allows the Agent to generate images based on the text input provided by the user.\n\nThe DirectoryReadTool is a powerful utility designed to provide a comprehensive listing of directory contents.\nIt can recursively navigate through the specified directory, offering users a detailed enumeration of all files, including those within subdirectories.\nThis tool is crucial for tasks that require a thorough inventory of directory structures or for validating the organization of files within directories.\n\nThe DirectorySearchTool enables semantic search within the content of specified directories, leveraging the Retrieval-Augmented Generation (RAG) methodology for efficient navigation through files. Designed for flexibility, it allows users to dynamically specify search directories at runtime or set a fixed directory during initial setup.\n\nThe `DOCXSearchTool` is a RAG tool designed for semantic searching within DOCX documents.\nIt enables users to effectively search and extract relevant information from DOCX files using query-based searches.\nThis tool is invaluable for data analysis, information management, and research tasks,\nstreamlining the process of finding specific information within large document collections.\n\nThe EXASearchTool is designed to perform a semantic search for a specified query from a text's content across the internet.\nIt utilizes the [exa.ai](https://exa.ai/) API to fetch and display the most relevant search results based on the query provided by the user.\n\nThe FileReadTool conceptually represents a suite of functionalities within the crewai\\_tools package aimed at facilitating file reading and content retrieval.\nThis suite includes tools for processing batch text files, reading runtime configuration files, and importing data for analytics.\nIt supports a variety of text-based file formats such as `.txt`, `.csv`, `.json`, and more. Depending on the file type, the suite offers specialized functionality,\nsuch as converting JSON content into a Python dictionary for ease of use.\n\nThe `FileWriterTool` is a component of the crewai\\_tools package, designed to simplify the process of writing content to files with cross-platform compatibility (Windows, Linux, macOS).\nIt is particularly useful in scenarios such as generating reports, saving logs, creating configuration files, and more.\nThis tool handles path differences across operating systems, supports UTF-8 encoding, and automatically creates directories if they don't exist, making it easier to organize your output reliably across different platforms.\n\n[Firecrawl](https://firecrawl.dev) is a platform for crawling and convert any website into clean markdown or structured data.\n\n[Firecrawl](https://firecrawl.dev) is a platform for crawling and convert any website into clean markdown or structured data.\n\n[Firecrawl](https://firecrawl.dev) is a platform for crawling and convert any website into clean markdown or structured data.\n\nThe GithubSearchTool is a Retrieval-Augmented Generation (RAG) tool specifically designed for conducting semantic searches within GitHub repositories. Utilizing advanced semantic search capabilities, it sifts through code, pull requests, issues, and repositories, making it an essential tool for developers, researchers, or anyone in need of precise information from GitHub.\n\nThe `HyperbrowserLoadTool` enables web scraping and crawling using [Hyperbrowser](https://hyperbrowser.ai), a platform for running and scaling headless browsers. This tool allows you to scrape a single page or crawl an entire site, returning the content in properly formatted markdown or HTML. Key Features: Instant Scalability - Spin up hundreds of browser sessions in seconds without infrastructure headaches Simple Integration - Works seamlessly with popular tools like Puppeteer and Playwright Powerful APIs - Easy to use APIs for scraping/crawling any site Bypass Anti-Bot Measures - Built-in stealth mode, ad blocking, automatic CAPTCHA solving, and rotating proxies\n\nThe JSONSearchTool is designed to facilitate efficient and precise searches within JSON file contents. It utilizes a RAG (Retrieve and Generate) search mechanism, allowing users to specify a JSON path for targeted searches within a particular JSON file. This capability significantly improves the accuracy and relevance of search results.\n\nThe `LinkupSearchTool` provides the ability to query the Linkup API for contextual information and retrieve structured results. This tool is ideal for enriching workflows with up-to-date and reliable information from Linkup, allowing agents to access relevant data during their tasks.\n\nThe `LlamaIndexTool` is designed to be a general wrapper around LlamaIndex tools and query engines, enabling you to leverage LlamaIndex resources in terms of RAG/agentic pipelines as tools to plug into CrewAI agents. This tool allows you to seamlessly integrate LlamaIndex's powerful data processing and retrieval capabilities into your CrewAI workflows.\n\nThe MDX Search Tool is a component of the `crewai_tools` package aimed at facilitating advanced markdown language extraction. It enables users to effectively search and extract relevant information from MD files using query-based searches. This tool is invaluable for data analysis, information management, and research tasks, streamlining the process of finding specific information within large document collections.\n\nThe `MultiOnTool` is designed to wrap [MultiOn's](https://docs.multion.ai/welcome) web browsing capabilities, enabling CrewAI agents to control web browsers using natural language instructions. This tool facilitates seamless web browsing, making it an essential asset for projects requiring dynamic web data interaction and automation of web-based tasks.\n\nThis tool is designed to facilitate semantic searches within MySQL database tables. Leveraging the RAG (Retrieve and Generate) technology,\nthe MySQLSearchTool provides users with an efficient means of querying database table content, specifically tailored for MySQL databases.\nIt simplifies the process of finding relevant data through semantic search queries, making it an invaluable resource for users needing\nto perform advanced queries on extensive datasets within a MySQL database.\n\nThis tool is used to convert natural language to SQL queries. When passsed to the agent it will generate queries and then use them to interact with the database. This enables multiple workflows like having an Agent to access the database fetch information based on the goal and then use the information to generate a response, report or any other output.\nAlong with that proivdes the ability for the Agent to update the database based on its goal. **Attention**: Make sure that the Agent has access to a Read-Replica or that is okay for the Agent to run insert/update queries on the database.\n\nThe [Patronus evaluation tools](https://patronus.ai) are designed to enable CrewAI agents to evaluate and score model inputs and outputs using the Patronus AI platform. These tools provide different levels of control over the evaluation process, from allowing agents to select the most appropriate evaluator and criteria to using predefined criteria or custom local evaluators. There are three main Patronus evaluation tools: **PatronusEvalTool**: Allows agents to select the most appropriate evaluator and criteria for the evaluation task. **PatronusPredefinedCriteriaEvalTool**: Uses predefined evaluator and criteria specified by the user. **PatronusLocalEvaluatorTool**: Uses custom function evaluators defined by the user.\n\nThe PDFSearchTool is a RAG tool designed for semantic searches within PDF content. It allows for inputting a search query and a PDF document, leveraging advanced search techniques to find relevant content efficiently.\nThis capability makes it especially useful for extracting specific information from large PDF files quickly.\n\nThe PGSearchTool is envisioned as a powerful tool for facilitating semantic searches within PostgreSQL database tables. By leveraging advanced Retrieve and Generate (RAG) technology,\nit aims to provide an efficient means for querying database table content, specifically tailored for PostgreSQL databases.\nThe tool's goal is to simplify the process of finding relevant data through semantic search queries, offering a valuable resource for users needing to conduct advanced queries on\nextensive datasets within a PostgreSQL environment.\n\nThe `RagTool` is designed to answer questions by leveraging the power of Retrieval-Augmented Generation (RAG) through EmbedChain.\nIt provides a dynamic knowledge base that can be queried to retrieve relevant information from various data sources.\nThis tool is particularly useful for applications that require access to a vast array of information and need to provide contextually relevant answers.\n\nThe `S3ReaderTool` is designed to read files from Amazon S3 buckets. This tool allows CrewAI agents to access and retrieve content stored in S3, making it ideal for workflows that require reading data, configuration files, or any other content stored in AWS S3 storage.\n\nThe `S3WriterTool` is designed to write content to files in Amazon S3 buckets. This tool allows CrewAI agents to create or update files in S3, making it ideal for workflows that require storing data, saving configuration files, or persisting any other content to AWS S3 storage.\n\nThe `ScrapeElementFromWebsiteTool` is designed to extract specific elements from websites using CSS selectors. This tool allows CrewAI agents to scrape targeted content from web pages, making it useful for data extraction tasks where only specific parts of a webpage are needed.\n\nThe `ScrapegraphScrapeTool` is designed to leverage Scrapegraph AI's SmartScraper API to intelligently extract content from websites. This tool provides advanced web scraping capabilities with AI-powered content extraction, making it ideal for targeted data collection and content analysis tasks. Unlike traditional web scrapers, it can understand the context and structure of web pages to extract the most relevant information based on natural language prompts.\n\nA tool designed to extract and read the content of a specified website. It is capable of handling various types of web pages by making HTTP requests and parsing the received HTML content.\nThis tool can be particularly useful for web scraping tasks, data collection, or extracting specific information from websites.\n\nThe `ScrapflyScrapeWebsiteTool` is designed to leverage [Scrapfly](https://scrapfly.io/)'s web scraping API to extract content from websites. This tool provides advanced web scraping capabilities with headless browser support, proxies, and anti-bot bypass features. It allows for extracting web page data in various formats, including raw HTML, markdown, and plain text, making it ideal for a wide range of web scraping tasks.\n\nThe `SeleniumScrapingTool` is crafted for high-efficiency web scraping tasks.\nIt allows for precise extraction of content from web pages by using CSS selectors to target specific elements.\nIts design caters to a wide range of scraping needs, offering flexibility to work with any provided website URL.\n\nThis tool is designed to perform a semantic search for a specified query from a text's content across the internet. It utilizes the [serper.dev](https://serper.dev) API\nto fetch and display the most relevant search results based on the query provided by the user.\n\nThe `SnowflakeSearchTool` is designed to connect to Snowflake data warehouses and execute SQL queries with advanced features like connection pooling, retry logic, and asynchronous execution. This tool allows CrewAI agents to interact with Snowflake databases, making it ideal for data analysis, reporting, and business intelligence tasks that require access to enterprise data stored in Snowflake.\n\n[Spider](https://spider.cloud/?ref=crewai) is the [fastest](https://github.com/spider-rs/spider/blob/main/benches/BENCHMARKS.md#benchmark-results)\nopen source scraper and crawler that returns LLM-ready data.\nIt converts any website into pure HTML, markdown, metadata or text while enabling you to crawl with custom actions using AI.\n\nThis tool is used to perform a RAG (Retrieval-Augmented Generation) search within the content of a text file.\nIt allows for semantic searching of a query within a specified text file's content,\nmaking it an invaluable resource for quickly extracting information or finding specific sections of text based on the query provided.\n\nThis tool is used to extract text from images. When passed to the agent it will extract the text from the image and then use it to generate a response, report or any other output.\nThe URL or the PATH of the image should be passed to the Agent.\n\nThe `WeaviateVectorSearchTool` is specifically crafted for conducting semantic searches within documents stored in a Weaviate vector database. This tool allows you to find semantically similar documents to a given query, leveraging the power of vector embeddings for more accurate and contextually relevant search results. [Weaviate](https://weaviate.io/) is a vector database that stores and queries vector embeddings, enabling semantic search capabilities.\n\nThe WebsiteSearchTool is designed as a concept for conducting semantic searches within the content of websites.\nIt aims to leverage advanced machine learning models like Retrieval-Augmented Generation (RAG) to navigate and extract information from specified URLs efficiently.\nThis tool intends to offer flexibility, allowing users to perform searches across any website or focus on specific websites of interest.\nPlease note, the current implementation details of the WebsiteSearchTool are under development, and its functionalities as described may not yet be accessible.\n\nThe XMLSearchTool is a cutting-edge RAG tool engineered for conducting semantic searches within XML files.\nIdeal for users needing to parse and extract information from XML content efficiently, this tool supports inputting a search query and an optional XML file path.\nBy specifying an XML path, users can target their search more precisely to the content of that file, thereby obtaining more relevant search outcomes.\n\nThis tool is designed to perform semantic searches within a specific Youtube channel's content.\nLeveraging the RAG (Retrieval-Augmented Generation) methodology, it provides relevant search results,\nmaking it invaluable for extracting information or finding specific content without the need to manually sift through videos.\nIt streamlines the search process within Youtube channels, catering to researchers, content creators, and viewers seeking specific information or topics.\n\nThis tool is part of the `crewai_tools` package and is designed to perform semantic searches within Youtube video content, utilizing Retrieval-Augmented Generation (RAG) techniques.\nIt is one of several \"Search\" tools in the package that leverage RAG for different sources.\nThe YoutubeVideoSearchTool allows for flexibility in searches; users can search across any Youtube video content without specifying a video URL,\nor they can target their search to a specific Youtube video by providing its URL.",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Installation",
            "level": 2,
            "content": "To use the CrewAI CLI, make sure you have CrewAI installed:\n```\npip install crewai\n```\n\nSource: https://docs.crewai.com/installation Get started with CrewAI - Install, configure, and build your first AI crew CrewAI requires `Python >=3.10 and <3.13`. Here's how to check your version:\n```\npython3 --version\n```\nIf you need to update Python, visit [python.org/downloads](https://python.org/downloads)\n</Note> CrewAI uses the `uv` as its dependency management and package handling tool. It simplifies project setup and execution, offering a seamless experience. If you haven't installed `uv` yet, follow **step 1** to quickly get it set up on your system, else you can skip to **step 2**.\n\nTo incorporate this tool into your project, you need to install the Minds SDK:\n```\nuv add minds-sdk\n```\n\n```\nuv pip install 'crewai[tools]'\n```\n\n```\nuv pip install 'crewai[tools]'\n```\n\nTo incorporate this tool into your project, follow the installation instructions below:\n```\npip install 'crewai[tools]'\n```\n\nGet an API key and Project ID from [browserbase.com](https://browserbase.com) and set it in environment variables (`BROWSERBASE_API_KEY`, `BROWSERBASE_PROJECT_ID`). Install the [Browserbase SDK](http://github.com/browserbase/python-sdk) along with `crewai[tools]` package:\n```\npip install browserbase 'crewai[tools]'\n```\n\nTo start using the CodeDocsSearchTool, first, install the crewai\\_tools package via pip:\n```\npip install 'crewai[tools]'\n```\n\nTo use this tool, you need to install the CrewAI tools package:\n```\npip install 'crewai[tools]'\n```\n\nTo incorporate Composio tools into your project, follow the instructions below:\n```\npip install composio-crewai\npip install crewai\n```\nAfter the installation is complete, either run `composio login` or export your composio API key as `COMPOSIO_API_KEY`. Get your Composio API key from [here](https://app.composio.dev)\n\nInstall the crewai\\_tools package\n```\npip install 'crewai[tools]'\n```\n\nInstall the crewai\\_tools package\n```\npip install 'crewai[tools]'\n```\n\nTo utilize the DirectoryReadTool in your project, install the `crewai_tools` package. If this package is not yet part of your environment, you can install it using pip with the command below:\n```\npip install 'crewai[tools]'\n```\nThis command installs the latest version of the `crewai_tools` package, granting access to the DirectoryReadTool among other utilities.\n\nTo use the DirectorySearchTool, begin by installing the crewai\\_tools package. Execute the following command in your terminal:\n```\npip install 'crewai[tools]'\n```\n\nInstall the crewai\\_tools package by running the following command in your terminal:\n```\npip install 'crewai[tools]'\n```\n\nTo incorporate this tool into your project, follow the installation instructions below:\n```\npip install 'crewai[tools]'\n```\n\nTo utilize the functionalities previously attributed to the FileReadTool, install the crewai\\_tools package:\n```\npip install 'crewai[tools]'\n```\n\nInstall the crewai\\_tools package to use the `FileWriterTool` in your projects:\n```\npip install 'crewai[tools]'\n```\n\nGet an API key from [firecrawl.dev](https://firecrawl.dev) and set it in environment variables (`FIRECRAWL_API_KEY`). Install the [Firecrawl SDK](https://github.com/mendableai/firecrawl) along with `crewai[tools]` package:\n```\npip install firecrawl-py 'crewai[tools]'\n```\n\nGet an API key from [firecrawl.dev](https://firecrawl.dev) and set it in environment variables (`FIRECRAWL_API_KEY`). Install the [Firecrawl SDK](https://github.com/mendableai/firecrawl) along with `crewai[tools]` package:\n```\npip install firecrawl-py 'crewai[tools]'\n```\n\nGet an API key from [firecrawl.dev](https://firecrawl.dev) and set it in environment variables (`FIRECRAWL_API_KEY`). Install the [Firecrawl SDK](https://github.com/mendableai/firecrawl) along with `crewai[tools]` package:\n```\npip install firecrawl-py 'crewai[tools]'\n```\n\nTo use the GithubSearchTool, first ensure the crewai\\_tools package is installed in your Python environment:\n```\npip install 'crewai[tools]'\n```\nThis command installs the necessary package to run the GithubSearchTool along with any other tools included in the crewai\\_tools package.\n\nTo use this tool, you need to install the Hyperbrowser SDK:\n```\nuv add hyperbrowser\n```\n\nTo install the JSONSearchTool, use the following pip command:\n```\npip install 'crewai[tools]'\n```\n\nTo use this tool, you need to install the Linkup SDK:\n```\nuv add linkup-sdk\n```\n\nTo use this tool, you need to install LlamaIndex:\n```\nuv add llama-index\n```\n\nBefore using the MDX Search Tool, ensure the `crewai_tools` package is installed. If it is not, you can install it with the following command:\n```\npip install 'crewai[tools]'\n```\n\nTo use this tool, you need to install the MultiOn package:\n```\nuv add multion\n```\nYou'll also need to install the MultiOn browser extension and enable API usage.\n\nTo install the `crewai_tools` package and utilize the MySQLSearchTool, execute the following command in your terminal:\n```\npip install 'crewai[tools]'\n```\n\nInstall the crewai\\_tools package\n```\npip install 'crewai[tools]'\n```\n\nTo use these tools, you need to install the Patronus package:\n```\nuv add patronus\n```\nYou'll also need to set up your Patronus API key as an environment variable:\n```\nexport PATRONUS_API_KEY=\"your_patronus_api_key\"\n```\n\nTo get started with the PDFSearchTool, first, ensure the crewai\\_tools package is installed with the following command:\n```\npip install 'crewai[tools]'\n```\n\nThe `crewai_tools` package, which will include the PGSearchTool upon its release, can be installed using the following command:\n```\npip install 'crewai[tools]'\n```\n\nInstall the required packages:\n```\nuv add qdrant-client\n```\n\nTo use this tool, you need to install the required dependencies:\n```\nuv add boto3\n```\n\nTo use this tool, you need to install the required dependencies:\n```\nuv add boto3\n```\n\nTo use this tool, you need to install the required dependencies:\n```\nuv add requests beautifulsoup4\n```\n\nTo use this tool, you need to install the Scrapegraph Python client:\n```\nuv add scrapegraph-py\n```\nYou'll also need to set up your Scrapegraph API key as an environment variable:\n```\nexport SCRAPEGRAPH_API_KEY=\"your_api_key\"\n```\nYou can obtain an API key from [Scrapegraph AI](https://scrapegraphai.com).\n\nInstall the crewai\\_tools package\n```\npip install 'crewai[tools]'\n```\n\nTo use this tool, you need to install the Scrapfly SDK:\n```\nuv add scrapfly-sdk\n```\nYou'll also need to obtain a Scrapfly API key by registering at [scrapfly.io/register](https://www.scrapfly.io/register/).\n\nTo use this tool, you need to install the CrewAI tools package and Selenium:\n```\npip install 'crewai[tools]'\nuv add selenium webdriver-manager\n```\nYou'll also need to have Chrome installed on your system, as the tool uses Chrome WebDriver for browser automation.\n\nTo incorporate this tool into your project, follow the installation instructions below:\n```\npip install 'crewai[tools]'\n```\n\nTo use this tool, you need to install the required dependencies:\n```\nuv add cryptography snowflake-connector-python snowflake-sqlalchemy\n```\nOr alternatively:\n```\nuv sync --extra snowflake\n```\n\nTo use the `SpiderTool` you need to download the [Spider SDK](https://pypi.org/project/spider-client/)\nand the `crewai[tools]` SDK too:\n```\npip install spider-client 'crewai[tools]'\n```\n\nTo use the `TXTSearchTool`, you first need to install the `crewai_tools` package.\nThis can be done using pip, a package manager for Python.\nOpen your terminal or command prompt and enter the following command:\n```\npip install 'crewai[tools]'\n```\nThis command will download and install the TXTSearchTool along with any necessary dependencies.\n\nInstall the crewai\\_tools package\n```\npip install 'crewai[tools]'\n```\n\nTo incorporate this tool into your project, you need to install the Weaviate client:\n```\nuv add weaviate-client\n```\n\nTo prepare your environment for when the WebsiteSearchTool becomes available, you can install the foundational package with:\n```\npip install 'crewai[tools]'\n```\nThis command installs the necessary dependencies to ensure that once the tool is fully integrated, users can start using it immediately.\n\nTo start using the XMLSearchTool, you must first install the crewai\\_tools package. This can be easily done with the following command:\n```\npip install 'crewai[tools]'\n```\n\nTo utilize the YoutubeChannelSearchTool, the `crewai_tools` package must be installed. Execute the following command in your shell to install:\n```\npip install 'crewai[tools]'\n```\n\nTo utilize the `YoutubeVideoSearchTool`, you must first install the `crewai_tools` package.\nThis package contains the `YoutubeVideoSearchTool` among other utilities designed to enhance your data analysis and processing tasks.\nInstall the package by executing the following command in your terminal:\n```\npip install 'crewai[tools]'\n```",
            "metadata": {
              "section_type": "Installation/Setup",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "shell Terminal",
                "content": "pip install crewai",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "bash",
                "content": "python3 --version",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "uv add minds-sdk",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "bash",
                "content": "uv pip install 'crewai[tools]'",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "bash",
                "content": "uv pip install 'crewai[tools]'",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "pip install 'crewai[tools]'",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "pip install browserbase 'crewai[tools]'",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "pip install 'crewai[tools]'",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "pip install 'crewai[tools]'",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "pip install composio-crewai\npip install crewai",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "pip install 'crewai[tools]'",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "pip install 'crewai[tools]'",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "pip install 'crewai[tools]'",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "pip install 'crewai[tools]'",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "pip install 'crewai[tools]'",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "pip install 'crewai[tools]'",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "pip install 'crewai[tools]'",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "pip install 'crewai[tools]'",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "pip install firecrawl-py 'crewai[tools]'",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "pip install firecrawl-py 'crewai[tools]'",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "pip install firecrawl-py 'crewai[tools]'",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "pip install 'crewai[tools]'",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "uv add hyperbrowser",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "pip install 'crewai[tools]'",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "uv add linkup-sdk",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "uv add llama-index",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "pip install 'crewai[tools]'",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "uv add multion",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "pip install 'crewai[tools]'",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "pip install 'crewai[tools]'",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "uv add patronus",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "export PATRONUS_API_KEY=\"your_patronus_api_key\"",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "pip install 'crewai[tools]'",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "pip install 'crewai[tools]'",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "bash",
                "content": "uv add qdrant-client",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "uv add boto3",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "uv add boto3",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "uv add requests beautifulsoup4",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "uv add scrapegraph-py",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "export SCRAPEGRAPH_API_KEY=\"your_api_key\"",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "pip install 'crewai[tools]'",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "uv add scrapfly-sdk",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "pip install 'crewai[tools]'\nuv add selenium webdriver-manager",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "pip install 'crewai[tools]'",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "uv add cryptography snowflake-connector-python snowflake-sqlalchemy",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "uv sync --extra snowflake",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "pip install spider-client 'crewai[tools]'",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "pip install 'crewai[tools]'",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "pip install 'crewai[tools]'",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "uv add weaviate-client",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "pip install 'crewai[tools]'",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "pip install 'crewai[tools]'",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "pip install 'crewai[tools]'",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "shell",
                "content": "pip install 'crewai[tools]'",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Example",
            "level": 2,
            "content": "```\n# Example crew execution\ncrew = Crew(\n    agents=[research_agent, writer_agent],\n    tasks=[research_task, write_article_task],\n    verbose=True\n)\n\ncrew_output = crew.kickoff()\n\n# Accessing the crew output\nprint(f\"Raw Output: {crew_output.raw}\")\nif crew_output.json_dict:\n    print(f\"JSON Output: {json.dumps(crew_output.json_dict, indent=2)}\")\nif crew_output.pydantic:\n    print(f\"Pydantic Output: {crew_output.pydantic}\")\nprint(f\"Tasks Output: {crew_output.tasks_output}\")\nprint(f\"Token Usage: {crew_output.token_usage}\")\n```\n\n```\n# Example task\ntask = Task(\n    description='Find and summarize the latest AI news',\n    expected_output='A bullet list summary of the top 5 most important AI news',\n    agent=research_agent,\n    tools=[search_tool]\n)\n\n# Execute the crew\ncrew = Crew(\n    agents=[research_agent],\n    tasks=[task],\n    verbose=True\n)\n\nresult = crew.kickoff()\n\n# Accessing the task output\ntask_output = task.output\n\nprint(f\"Task Description: {task_output.description}\")\nprint(f\"Task Summary: {task_output.summary}\")\nprint(f\"Raw Output: {task_output.raw}\")\nif task_output.json_dict:\n    print(f\"JSON Output: {json.dumps(task_output.json_dict, indent=2)}\")\nif task_output.pydantic:\n    print(f\"Pydantic Output: {task_output.pydantic}\")\n```\n\n```\nimport os\nfrom crewai import Agent, Task, Crew, Process\n\n# Define your agents\nresearcher = Agent(\n    role=\"Researcher\",\n    goal=\"Conduct thorough research and analysis on AI and AI agents\",\n    backstory=\"You're an expert researcher, specialized in technology, software engineering, AI, and startups. You work as a freelancer and are currently researching for a new client.\",\n    allow_delegation=False,\n)\n\nwriter = Agent(\n    role=\"Senior Writer\",\n    goal=\"Create compelling content about AI and AI agents\",\n    backstory=\"You're a senior writer, specialized in technology, software engineering, AI, and startups. You work as a freelancer and are currently writing content for a new client.\",\n    allow_delegation=False,\n)\n\n# Define your task\ntask = Task(\n    description=\"Generate a list of 5 interesting ideas for an article, then write one captivating paragraph for each idea that showcases the potential of a full article on this topic. Return the list of ideas with their paragraphs and your notes.\",\n    expected_output=\"5 bullet points, each with a paragraph and accompanying notes.\",\n)\n\n# Define the manager agent\nmanager = Agent(\n    role=\"Project Manager\",\n    goal=\"Efficiently manage the crew and ensure high-quality task completion\",\n    backstory=\"You're an experienced project manager, skilled in overseeing complex projects and guiding teams to success. Your role is to coordinate the efforts of the crew members, ensuring that each task is completed on time and to the highest standard.\",\n    allow_delegation=True,\n)\n\n# Instantiate your crew with a custom manager\ncrew = Crew(\n    agents=[researcher, writer],\n    tasks=[task],\n    manager_agent=manager,\n    process=Process.hierarchical,\n)\n\n# Start the crew's work\nresult = crew.kickoff()\n```\n\nThe following example demonstrates how to initialize the tool and execute a query:\n```\nfrom crewai_tools import AIMindTool\n\n# Initialize the AIMindTool\naimind_tool = AIMindTool(\n    datasources=[\n        {\n            \"description\": \"house sales data\",\n            \"engine\": \"postgres\",\n            \"connection_data\": {\n                \"user\": \"demo_user\",\n                \"password\": \"demo_password\",\n                \"host\": \"samples.mindsdb.com\",\n                \"port\": 5432,\n                \"database\": \"demo\",\n                \"schema\": \"demo_data\"\n            },\n            \"tables\": [\"house_sales\"]\n        }\n    ]\n)\n\n# Run a natural language query\nresult = aimind_tool.run(\"How many 3 bedroom houses were sold in 2008?\")\nprint(result)\n```\n\nThe following example demonstrates how to initialize the tool and execute a search with a given query:\n```\nfrom crewai_tools import BraveSearchTool\n\n# Initialize the tool for internet searching capabilities\ntool = BraveSearchTool()\n\n# Execute a search\nresults = tool.run(search_query=\"CrewAI agent framework\")\nprint(results)\n```\n\nUtilize the BrowserbaseLoadTool as follows to allow your agent to load websites:\n```\nfrom crewai_tools import BrowserbaseLoadTool\n\n# Initialize the tool with the Browserbase API key and Project ID\ntool = BrowserbaseLoadTool()\n```\n\nUtilize the CodeDocsSearchTool as follows to conduct searches within code documentation:\n```\nfrom crewai_tools import CodeDocsSearchTool\n\n# To search any code documentation content \n# if the URL is known or discovered during its execution:\ntool = CodeDocsSearchTool()\n\n# OR\n\n# To specifically focus your search on a given documentation site \n# by providing its URL:\ntool = CodeDocsSearchTool(docs_url='https://docs.example.com/reference')\n```\n\nThe following example demonstrates how to use the `CodeInterpreterTool` with a CrewAI agent:\n```\nfrom crewai import Agent, Task, Crew, Process\nfrom crewai_tools import CodeInterpreterTool\n\n# Initialize the tool\ncode_interpreter = CodeInterpreterTool()\n\n# Define an agent that uses the tool\nprogrammer_agent = Agent(\n    role=\"Python Programmer\",\n    goal=\"Write and execute Python code to solve problems\",\n    backstory=\"An expert Python programmer who can write efficient code to solve complex problems.\",\n    tools=[code_interpreter],\n    verbose=True,\n)\n\n# Example task to generate and execute code\ncoding_task = Task(\n    description=\"Write a Python function to calculate the Fibonacci sequence up to the 10th number and print the result.\",\n    expected_output=\"The Fibonacci sequence up to the 10th number.\",\n    agent=programmer_agent,\n)\n\n# Create and run the crew\ncrew = Crew(\n    agents=[programmer_agent],\n    tasks=[coding_task],\n    verbose=True,\n    process=Process.sequential,\n)\nresult = crew.kickoff()\n```\nYou can also enable code execution directly when creating an agent:\n```\nfrom crewai import Agent\n\n# Create an agent with code execution enabled\nprogrammer_agent = Agent(\n    role=\"Python Programmer\",\n    goal=\"Write and execute Python code to solve problems\",\n    backstory=\"An expert Python programmer who can write efficient code to solve complex problems.\",\n    allow_code_execution=True,  # This automatically adds the CodeInterpreterTool\n    verbose=True,\n)\n```\n\nThe following example demonstrates how to initialize the tool and execute a github action: Initialize Composio toolset\n```\nfrom composio_crewai import ComposioToolSet, App, Action\nfrom crewai import Agent, Task, Crew\n\ntoolset = ComposioToolSet()\n```\nConnect your GitHub account\n```\nrequest = toolset.initiate_connection(app=App.GITHUB)\nprint(f\"Open this URL to authenticate: {request.redirectUrl}\")\n```\nGet Tools Retrieving all the tools from an app (not recommended for production):\n```\ntools = toolset.get_tools(apps=[App.GITHUB])\n```\nFiltering tools based on tags:\n```\ntag = \"users\"\n\nfiltered_action_enums = toolset.find_actions_by_tags(\n    App.GITHUB,\n    tags=[tag], \n)\n\ntools = toolset.get_tools(actions=filtered_action_enums)\n```\nFiltering tools based on use case:\n```\nuse_case = \"Star a repository on GitHub\"\n\nfiltered_action_enums = toolset.find_actions_by_use_case(\n    App.GITHUB, use_case=use_case, advanced=False\n)\n\ntools = toolset.get_tools(actions=filtered_action_enums)\n```\n<Tip>Set `advanced` to True to get actions for complex use cases</Tip> Using specific tools: In this demo, we will use the `GITHUB_STAR_A_REPOSITORY_FOR_THE_AUTHENTICATED_USER` action from the GitHub app.\n```\ntools = toolset.get_tools(\n    actions=[Action.GITHUB_STAR_A_REPOSITORY_FOR_THE_AUTHENTICATED_USER]\n)\n```\nLearn more about filtering actions [here](https://docs.composio.dev/patterns/tools/use-tools/use-specific-actions) Define agent\n```\ncrewai_agent = Agent(\n    role=\"GitHub Agent\",\n    goal=\"You take action on GitHub using GitHub APIs\",\n    backstory=\"You are AI agent that is responsible for taking actions on GitHub on behalf of users using GitHub APIs\",\n    verbose=True,\n    tools=tools,\n    llm= # pass an llm\n)\n```\nExecute task\n```\ntask = Task(\n    description=\"Star a repo composiohq/composio on GitHub\",\n    agent=crewai_agent,\n    expected_output=\"Status of the operation\",\n)\n\ncrew = Crew(agents=[crewai_agent], tasks=[task])\n\ncrew.kickoff()\n```\nMore detailed list of tools can be found [here](https://app.composio.dev)\n\n```\nfrom crewai_tools import CSVSearchTool\n\n# Initialize the tool with a specific CSV file. \n# This setup allows the agent to only search the given CSV file.\ntool = CSVSearchTool(csv='path/to/your/csvfile.csv')\n\n# OR\n\n# Initialize the tool without a specific CSV file. \n# Agent will need to provide the CSV path at runtime.\ntool = CSVSearchTool()\n```\n\nRemember that when using this tool, the text must be generated by the Agent itself. The text must be a description of the image you want to generate.\n```\nfrom crewai_tools import DallETool\n\nAgent(\n    ...\n    tools=[DallETool()],\n)\n```\nIf needed you can also tweak the parameters of the DALL-E model by passing them as arguments to the `DallETool` class. For example:\n```\nfrom crewai_tools import DallETool\n\ndalle_tool = DallETool(model=\"dall-e-3\",\n                       size=\"1024x1024\",\n                       quality=\"standard\",\n                       n=1)\n\nAgent(\n    ...\n    tools=[dalle_tool]\n)\n```\nThe parameters are based on the `client.images.generate` method from the OpenAI API. For more information on the parameters,\nplease refer to the [OpenAI API documentation](https://platform.openai.com/docs/guides/images/introduction?lang=python).\n\nEmploying the DirectoryReadTool is straightforward. The following code snippet demonstrates how to set it up and use the tool to list the contents of a specified directory:\n```\nfrom crewai_tools import DirectoryReadTool\n\n# Initialize the tool so the agent can read any directory's content \n# it learns about during execution\ntool = DirectoryReadTool()\n\n# OR\n\n# Initialize the tool with a specific directory, \n# so the agent can only read the content of the specified directory\ntool = DirectoryReadTool(directory='/path/to/your/directory')\n```\n\nThe following example demonstrates initializing the DOCXSearchTool to search within any DOCX file's content or with a specific DOCX file path.\n```\nfrom crewai_tools import DOCXSearchTool\n\n# Initialize the tool to search within any DOCX file's content\ntool = DOCXSearchTool()\n\n# OR\n\n# Initialize the tool with a specific DOCX file, \n# so the agent can only search the content of the specified DOCX file\ntool = DOCXSearchTool(docx='path/to/your/document.docx')\n```\n\nThe following example demonstrates how to initialize the tool and execute a search with a given query:\n```\nfrom crewai_tools import EXASearchTool\n\n# Initialize the tool for internet searching capabilities\ntool = EXASearchTool()\n```\n\nTo get started with the `FileWriterTool`:\n```\nfrom crewai_tools import FileWriterTool\n\n# Initialize the tool\nfile_writer_tool = FileWriterTool()\n\n# Write content to a file in a specified directory\nresult = file_writer_tool._run('example.txt', 'This is a test content.', 'test_directory')\nprint(result)\n```\n\nUtilize the FirecrawlScrapeFromWebsiteTool as follows to allow your agent to load websites:\n```\nfrom crewai_tools import FirecrawlCrawlWebsiteTool\n\ntool = FirecrawlCrawlWebsiteTool(url='firecrawl.dev')\n```\n\nUtilize the FirecrawlScrapeWebsiteTool as follows to allow your agent to load websites:\n```\nfrom crewai_tools import FirecrawlScrapeWebsiteTool\n\ntool = FirecrawlScrapeWebsiteTool(url='firecrawl.dev')\n```\n\nUtilize the FirecrawlSearchTool as follows to allow your agent to load websites:\n```\nfrom crewai_tools import FirecrawlSearchTool\n\ntool = FirecrawlSearchTool(query='what is firecrawl?')\n```\n\nHere\u2019s how you can use the GithubSearchTool to perform semantic searches within a GitHub repository:\n```\nfrom crewai_tools import GithubSearchTool\n\n# Initialize the tool for semantic searches within a specific GitHub repository\ntool = GithubSearchTool(\n\tgithub_repo='https://github.com/example/repo',\n\tgh_token='your_github_personal_access_token',\n\tcontent_types=['code', 'issue'] # Options: code, repo, pr, issue\n)\n\n# OR\n\n# Initialize the tool for semantic searches within a specific GitHub repository, so the agent can search any repository if it learns about during its execution\ntool = GithubSearchTool(\n\tgh_token='your_github_personal_access_token',\n\tcontent_types=['code', 'issue'] # Options: code, repo, pr, issue\n)\n```\n\nThe following example demonstrates how to initialize the tool and use it to scrape a website:\n```\nfrom crewai_tools import HyperbrowserLoadTool\nfrom crewai import Agent\n\n# Initialize the tool with your API key\ntool = HyperbrowserLoadTool(api_key=\"your_api_key\")  # Or use environment variable\n\n# Define an agent that uses the tool\n@agent\ndef web_researcher(self) -> Agent:\n    '''\n    This agent uses the HyperbrowserLoadTool to scrape websites\n    and extract information.\n    '''\n    return Agent(\n        config=self.agents_config[\"web_researcher\"],\n        tools=[tool]\n    )\n```\n\nThe following example demonstrates how to initialize the tool and use it in an agent:\n```\nfrom crewai_tools import LinkupSearchTool\nfrom crewai import Agent\nimport os\n\n# Initialize the tool with your API key\nlinkup_tool = LinkupSearchTool(api_key=os.getenv(\"LINKUP_API_KEY\"))\n\n# Define an agent that uses the tool\n@agent\ndef researcher(self) -> Agent:\n    '''\n    This agent uses the LinkupSearchTool to retrieve contextual information\n    from the Linkup API.\n    '''\n    return Agent(\n        config=self.agents_config[\"researcher\"],\n        tools=[linkup_tool]\n    )\n```\n\nThe following examples demonstrate how to initialize the tool from different LlamaIndex components:\n\nThe following example demonstrates how to initialize the tool and execute a web browsing task:\n```\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import MultiOnTool\n\n# Initialize the tool\nmultion_tool = MultiOnTool(api_key=\"YOUR_MULTION_API_KEY\", local=False)\n\n# Define an agent that uses the tool\nbrowser_agent = Agent(\n    role=\"Browser Agent\",\n    goal=\"Control web browsers using natural language\",\n    backstory=\"An expert browsing agent.\",\n    tools=[multion_tool],\n    verbose=True,\n)\n\n# Example task to search and summarize news\nbrowse_task = Task(\n    description=\"Summarize the top 3 trending AI News headlines\",\n    expected_output=\"A summary of the top 3 trending AI News headlines\",\n    agent=browser_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[browser_agent], tasks=[browse_task])\nresult = crew.kickoff()\n```\n\nBelow is an example showcasing how to use the MySQLSearchTool to conduct a semantic search on a table within a MySQL database:\n```\nfrom crewai_tools import MySQLSearchTool\n\n# Initialize the tool with the database URI and the target table name\ntool = MySQLSearchTool(\n    db_uri='mysql://user:password@localhost:3306/mydatabase',\n    table_name='employees'\n)\n```\n\nThe primary task goal was: \"Retrieve the average, maximum, and minimum monthly revenue for each city, but only include cities that have more than one user. Also, count the number of user in each city and\nsort the results by the average monthly revenue in descending order\" So the Agent tried to get information from the DB, the first one is wrong so the Agent tries again and gets the correct information and passes to the next agent. ![alt text](https://github.com/crewAIInc/crewAI-tools/blob/main/crewai_tools/tools/nl2sql/images/image-2.png?raw=true)\n![alt text](https://github.com/crewAIInc/crewAI-tools/raw/main/crewai_tools/tools/nl2sql/images/image-3.png) The second task goal was: \"Review the data and create a detailed report, and then create the table on the database with the fields based on the data provided.\nInclude information on the average, maximum, and minimum monthly revenue for each city, but only include cities that have more than one user. Also, count the number of users in each city and sort the results by the average monthly revenue in descending order.\" Now things start to get interesting, the Agent generates the SQL query to not only create the table but also insert the data into the table. And in the end the Agent still returns the final report which is exactly what was in the database. ![alt text](https://github.com/crewAIInc/crewAI-tools/raw/main/crewai_tools/tools/nl2sql/images/image-4.png)\n![alt text](https://github.com/crewAIInc/crewAI-tools/raw/main/crewai_tools/tools/nl2sql/images/image-5.png) ![alt text](https://github.com/crewAIInc/crewAI-tools/raw/main/crewai_tools/tools/nl2sql/images/image-9.png)\n![alt text](https://github.com/crewAIInc/crewAI-tools/raw/main/crewai_tools/tools/nl2sql/images/image-7.png) This is a simple example of how the NL2SQLTool can be used to interact with the database and generate reports based on the data in the database. The Tool provides endless possibilities on the logic of the Agent and how it can interact with the database.\n```\n DB -> Agent -> ... -> Agent -> DB\n```\n\nHere's how to use the PDFSearchTool to search within a PDF document:\n```\nfrom crewai_tools import PDFSearchTool\n\n# Initialize the tool allowing for any PDF content search if the path is provided during execution\ntool = PDFSearchTool()\n\n# OR\n\n# Initialize the tool with a specific PDF path for exclusive search within that document\ntool = PDFSearchTool(pdf='path/to/your/document.pdf')\n```\n\nThe following example demonstrates how to initialize the tool and use it with different data sources:\n```\nfrom crewai_tools import RagTool\n\n# Create a RAG tool with default settings\nrag_tool = RagTool()\n\n# Add content from a file\nrag_tool.add(data_type=\"file\", path=\"path/to/your/document.pdf\")\n\n# Add content from a web page\nrag_tool.add(data_type=\"web_page\", url=\"https://example.com\")\n\n# Define an agent with the RagTool\n@agent\ndef knowledge_expert(self) -> Agent:\n    '''\n    This agent uses the RagTool to answer questions about the knowledge base.\n    '''\n    return Agent(\n        config=self.agents_config[\"knowledge_expert\"],\n        allow_delegation=False,\n        tools=[rag_tool]\n    )\n```\n\nThe following example demonstrates how to use the `S3ReaderTool` to read a file from an S3 bucket:\n```\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools.aws.s3 import S3ReaderTool\n\n# Initialize the tool\ns3_reader_tool = S3ReaderTool()\n\n# Define an agent that uses the tool\nfile_reader_agent = Agent(\n    role=\"File Reader\",\n    goal=\"Read files from S3 buckets\",\n    backstory=\"An expert in retrieving and processing files from cloud storage.\",\n    tools=[s3_reader_tool],\n    verbose=True,\n)\n\n# Example task to read a configuration file\nread_task = Task(\n    description=\"Read the configuration file from {my_bucket} and summarize its contents.\",\n    expected_output=\"A summary of the configuration file contents.\",\n    agent=file_reader_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[file_reader_agent], tasks=[read_task])\nresult = crew.kickoff(inputs={\"my_bucket\": \"s3://my-bucket/config/app-config.json\"})\n```\n\nThe following example demonstrates how to use the `S3WriterTool` to write content to a file in an S3 bucket:\n```\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools.aws.s3 import S3WriterTool\n\n# Initialize the tool\ns3_writer_tool = S3WriterTool()\n\n# Define an agent that uses the tool\nfile_writer_agent = Agent(\n    role=\"File Writer\",\n    goal=\"Write content to files in S3 buckets\",\n    backstory=\"An expert in storing and managing files in cloud storage.\",\n    tools=[s3_writer_tool],\n    verbose=True,\n)\n\n# Example task to write a report\nwrite_task = Task(\n    description=\"Generate a summary report of the quarterly sales data and save it to {my_bucket}.\",\n    expected_output=\"Confirmation that the report was successfully saved to S3.\",\n    agent=file_writer_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[file_writer_agent], tasks=[write_task])\nresult = crew.kickoff(inputs={\"my_bucket\": \"s3://my-bucket/reports/quarterly-summary.txt\"})\n```\n\nThe following example demonstrates how to use the `ScrapeElementFromWebsiteTool` to extract specific elements from a website:\n```\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import ScrapeElementFromWebsiteTool\n\n# Initialize the tool\nscrape_tool = ScrapeElementFromWebsiteTool()\n\n# Define an agent that uses the tool\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract specific information from websites\",\n    backstory=\"An expert in web scraping who can extract targeted content from web pages.\",\n    tools=[scrape_tool],\n    verbose=True,\n)\n\n# Example task to extract headlines from a news website\nscrape_task = Task(\n    description=\"Extract the main headlines from the CNN homepage. Use the CSS selector '.headline' to target the headline elements.\",\n    expected_output=\"A list of the main headlines from CNN.\",\n    agent=web_scraper_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[web_scraper_agent], tasks=[scrape_task])\nresult = crew.kickoff()\n```\nYou can also initialize the tool with predefined parameters:\n```\n# Initialize the tool with predefined parameters\nscrape_tool = ScrapeElementFromWebsiteTool(\n    website_url=\"https://www.example.com\",\n    css_element=\".main-content\"\n)\n```\n\nThe following example demonstrates how to use the `ScrapegraphScrapeTool` to extract content from a website:\n```\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import ScrapegraphScrapeTool\n\n# Initialize the tool\nscrape_tool = ScrapegraphScrapeTool(api_key=\"your_api_key\")\n\n# Define an agent that uses the tool\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract specific information from websites\",\n    backstory=\"An expert in web scraping who can extract targeted content from web pages.\",\n    tools=[scrape_tool],\n    verbose=True,\n)\n\n# Example task to extract product information from an e-commerce site\nscrape_task = Task(\n    description=\"Extract product names, prices, and descriptions from the featured products section of example.com.\",\n    expected_output=\"A structured list of product information including names, prices, and descriptions.\",\n    agent=web_scraper_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[web_scraper_agent], tasks=[scrape_task])\nresult = crew.kickoff()\n```\nYou can also initialize the tool with predefined parameters:\n```\n# Initialize the tool with predefined parameters\nscrape_tool = ScrapegraphScrapeTool(\n    website_url=\"https://www.example.com\",\n    user_prompt=\"Extract all product prices and descriptions\",\n    api_key=\"your_api_key\"\n)\n```\n\n```\nfrom crewai_tools import ScrapeWebsiteTool\n\n# To enable scrapping any website it finds during it's execution\ntool = ScrapeWebsiteTool()\n\n# Initialize the tool with the website URL, \n# so the agent can only scrap the content of the specified website\ntool = ScrapeWebsiteTool(website_url='https://www.example.com')\n\n# Extract the text from the site\ntext = tool.run()\nprint(text)\n```\n\nThe following example demonstrates how to use the `ScrapflyScrapeWebsiteTool` to extract content from a website:\n```\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import ScrapflyScrapeWebsiteTool\n\n# Initialize the tool\nscrape_tool = ScrapflyScrapeWebsiteTool(api_key=\"your_scrapfly_api_key\")\n\n# Define an agent that uses the tool\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract information from websites\",\n    backstory=\"An expert in web scraping who can extract content from any website.\",\n    tools=[scrape_tool],\n    verbose=True,\n)\n\n# Example task to extract content from a website\nscrape_task = Task(\n    description=\"Extract the main content from the product page at https://web-scraping.dev/products and summarize the available products.\",\n    expected_output=\"A summary of the products available on the website.\",\n    agent=web_scraper_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[web_scraper_agent], tasks=[scrape_task])\nresult = crew.kickoff()\n```\nYou can also customize the scraping parameters:\n```\n# Example with custom scraping parameters\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract information from websites with custom parameters\",\n    backstory=\"An expert in web scraping who can extract content from any website.\",\n    tools=[scrape_tool],\n    verbose=True,\n)\n\n# The agent will use the tool with parameters like:\n# url=\"https://web-scraping.dev/products\"\n# scrape_format=\"markdown\"\n# ignore_scrape_failures=True\n# scrape_config={\n#     \"asp\": True,  # Bypass scraping blocking solutions, like Cloudflare\n#     \"render_js\": True,  # Enable JavaScript rendering with a cloud headless browser\n#     \"proxy_pool\": \"public_residential_pool\",  # Select a proxy pool\n#     \"country\": \"us\",  # Select a proxy location\n#     \"auto_scroll\": True,  # Auto scroll the page\n# }\n\nscrape_task = Task(\n    description=\"Extract the main content from the product page at https://web-scraping.dev/products using advanced scraping options including JavaScript rendering and proxy settings.\",\n    expected_output=\"A detailed summary of the products with all available information.\",\n    agent=web_scraper_agent,\n)\n```\n\nThe following example demonstrates how to use the `SeleniumScrapingTool` with a CrewAI agent:\n```\nfrom crewai import Agent, Task, Crew, Process\nfrom crewai_tools import SeleniumScrapingTool\n\n# Initialize the tool\nselenium_tool = SeleniumScrapingTool()\n\n# Define an agent that uses the tool\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract information from websites using Selenium\",\n    backstory=\"An expert web scraper who can extract content from dynamic websites.\",\n    tools=[selenium_tool],\n    verbose=True,\n)\n\n# Example task to scrape content from a website\nscrape_task = Task(\n    description=\"Extract the main content from the homepage of example.com. Use the CSS selector 'main' to target the main content area.\",\n    expected_output=\"The main content from example.com's homepage.\",\n    agent=web_scraper_agent,\n)\n\n# Create and run the crew\ncrew = Crew(\n    agents=[web_scraper_agent],\n    tasks=[scrape_task],\n    verbose=True,\n    process=Process.sequential,\n)\nresult = crew.kickoff()\n```\nYou can also initialize the tool with predefined parameters:\n```\n# Initialize the tool with predefined parameters\nselenium_tool = SeleniumScrapingTool(\n    website_url='https://example.com',\n    css_element='.main-content',\n    wait_time=5\n)\n\n# Define an agent that uses the tool\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract information from websites using Selenium\",\n    backstory=\"An expert web scraper who can extract content from dynamic websites.\",\n    tools=[selenium_tool],\n    verbose=True,\n)\n```\n\nThe following example demonstrates how to initialize the tool and execute a search with a given query:\n```\nfrom crewai_tools import SerperDevTool\n\n# Initialize the tool for internet searching capabilities\ntool = SerperDevTool()\n```\n\nThe following example demonstrates how to use the `SnowflakeSearchTool` to query data from a Snowflake database:\n```\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import SnowflakeSearchTool, SnowflakeConfig\n\n# Create Snowflake configuration\nconfig = SnowflakeConfig(\n    account=\"your_account\",\n    user=\"your_username\",\n    password=\"your_password\",\n    warehouse=\"COMPUTE_WH\",\n    database=\"your_database\",\n    snowflake_schema=\"your_schema\"\n)\n\n# Initialize the tool\nsnowflake_tool = SnowflakeSearchTool(config=config)\n\n# Define an agent that uses the tool\ndata_analyst_agent = Agent(\n    role=\"Data Analyst\",\n    goal=\"Analyze data from Snowflake database\",\n    backstory=\"An expert data analyst who can extract insights from enterprise data.\",\n    tools=[snowflake_tool],\n    verbose=True,\n)\n\n# Example task to query sales data\nquery_task = Task(\n    description=\"Query the sales data for the last quarter and summarize the top 5 products by revenue.\",\n    expected_output=\"A summary of the top 5 products by revenue for the last quarter.\",\n    agent=data_analyst_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[data_analyst_agent], \n            tasks=[query_task])\nresult = crew.kickoff()\n```\nYou can also customize the tool with additional parameters:\n```\n# Initialize the tool with custom parameters\nsnowflake_tool = SnowflakeSearchTool(\n    config=config,\n    pool_size=10,\n    max_retries=5,\n    retry_delay=2.0,\n    enable_caching=True\n)\n```\n\nThis example shows you how you can use the `SpiderTool` to enable your agent to scrape and crawl websites.\nThe data returned from the Spider API is already LLM-ready, so no need to do any cleaning there.\n```\nfrom crewai_tools import SpiderTool\n\ndef main():\n    spider_tool = SpiderTool()\n\n    searcher = Agent(\n        role=\"Web Research Expert\",\n        goal=\"Find related information from specific URL's\",\n        backstory=\"An expert web researcher that uses the web extremely well\",\n        tools=[spider_tool],\n        verbose=True,\n    )\n\n    return_metadata = Task(\n        description=\"Scrape https://spider.cloud with a limit of 1 and enable metadata\",\n        expected_output=\"Metadata and 10 word summary of spider.cloud\",\n        agent=searcher\n    )\n\n    crew = Crew(\n        agents=[searcher],\n        tasks=[\n            return_metadata,\n        ],\n        verbose=2\n    )\n\n    crew.kickoff()\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThe following example demonstrates how to use the TXTSearchTool to search within a text file.\nThis example shows both the initialization of the tool with a specific text file and the subsequent search within that file's content.\n```\nfrom crewai_tools import TXTSearchTool\n\n# Initialize the tool to search within any text file's content \n# the agent learns about during its execution\ntool = TXTSearchTool()\n\n# OR\n\n# Initialize the tool with a specific text file, \n# so the agent can search within the given text file's content\ntool = TXTSearchTool(txt='path/to/text/file.txt')\n```\n\nThe following example demonstrates how to initialize the tool and execute a search:\n```\nfrom crewai_tools import WeaviateVectorSearchTool\n\n# Initialize the tool\ntool = WeaviateVectorSearchTool(\n    collection_name='example_collections',\n    limit=3,\n    weaviate_cluster_url=\"https://your-weaviate-cluster-url.com\",\n    weaviate_api_key=\"your-weaviate-api-key\",\n)\n\n@agent\ndef search_agent(self) -> Agent:\n    '''\n    This agent uses the WeaviateVectorSearchTool to search for \n    semantically similar documents in a Weaviate vector database.\n    '''\n    return Agent(\n        config=self.agents_config[\"search_agent\"],\n        tools=[tool]\n    )\n```\n\nHere are two examples demonstrating how to use the XMLSearchTool.\nThe first example shows searching within a specific XML file, while the second example illustrates initiating a search without predefining an XML path, providing flexibility in search scope.\n```\nfrom crewai_tools import XMLSearchTool\n\n# Allow agents to search within any XML file's content \n#as it learns about their paths during execution\ntool = XMLSearchTool()\n\n# OR\n\n# Initialize the tool with a specific XML file path \n#for exclusive search within that document\ntool = XMLSearchTool(xml='path/to/your/xmlfile.xml')\n```\n\nThe following example demonstrates how to use the `YoutubeChannelSearchTool` with a CrewAI agent:\n```\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import YoutubeChannelSearchTool\n\n# Initialize the tool for general YouTube channel searches\nyoutube_channel_tool = YoutubeChannelSearchTool()\n\n# Define an agent that uses the tool\nchannel_researcher = Agent(\n    role=\"Channel Researcher\",\n    goal=\"Extract relevant information from YouTube channels\",\n    backstory=\"An expert researcher who specializes in analyzing YouTube channel content.\",\n    tools=[youtube_channel_tool],\n    verbose=True,\n)\n\n# Example task to search for information in a specific channel\nresearch_task = Task(\n    description=\"Search for information about machine learning tutorials in the YouTube channel {youtube_channel_handle}\",\n    expected_output=\"A summary of the key machine learning tutorials available on the channel.\",\n    agent=channel_researcher,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[channel_researcher], tasks=[research_task])\nresult = crew.kickoff(inputs={\"youtube_channel_handle\": \"@exampleChannel\"})\n```\nYou can also initialize the tool with a specific YouTube channel handle:\n```\n# Initialize the tool with a specific YouTube channel handle\nyoutube_channel_tool = YoutubeChannelSearchTool(\n    youtube_channel_handle='@exampleChannel'\n)\n\n# Define an agent that uses the tool\nchannel_researcher = Agent(\n    role=\"Channel Researcher\",\n    goal=\"Extract relevant information from a specific YouTube channel\",\n    backstory=\"An expert researcher who specializes in analyzing YouTube channel content.\",\n    tools=[youtube_channel_tool],\n    verbose=True,\n)\n```\n\nThe following example demonstrates how to use the `YoutubeVideoSearchTool` with a CrewAI agent:\n```\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import YoutubeVideoSearchTool\n\n# Initialize the tool for general YouTube video searches\nyoutube_search_tool = YoutubeVideoSearchTool()\n\n# Define an agent that uses the tool\nvideo_researcher = Agent(\n    role=\"Video Researcher\",\n    goal=\"Extract relevant information from YouTube videos\",\n    backstory=\"An expert researcher who specializes in analyzing video content.\",\n    tools=[youtube_search_tool],\n    verbose=True,\n)\n\n# Example task to search for information in a specific video\nresearch_task = Task(\n    description=\"Search for information about machine learning frameworks in the YouTube video at {youtube_video_url}\",\n    expected_output=\"A summary of the key machine learning frameworks mentioned in the video.\",\n    agent=video_researcher,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[video_researcher], tasks=[research_task])\nresult = crew.kickoff(inputs={\"youtube_video_url\": \"https://youtube.com/watch?v=example\"})\n```\nYou can also initialize the tool with a specific YouTube video URL:\n```\n# Initialize the tool with a specific YouTube video URL\nyoutube_search_tool = YoutubeVideoSearchTool(\n    youtube_video_url='https://youtube.com/watch?v=example'\n)\n\n# Define an agent that uses the tool\nvideo_researcher = Agent(\n    role=\"Video Researcher\",\n    goal=\"Extract relevant information from a specific YouTube video\",\n    backstory=\"An expert researcher who specializes in analyzing video content.\",\n    tools=[youtube_search_tool],\n    verbose=True,\n)\n```",
            "metadata": {
              "section_type": "Examples",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "# Example crew execution\ncrew = Crew(\n    agents=[research_agent, writer_agent],\n    tasks=[research_task, write_article_task],\n    verbose=True\n)\n\ncrew_output = crew.kickoff()\n\n# Accessing the crew output\nprint(f\"Raw Output: {crew_output.raw}\")\nif crew_output.json_dict:\n    print(f\"JSON Output: {json.dumps(crew_output.json_dict, indent=2)}\")\nif crew_output.pydantic:\n    print(f\"Pydantic Output: {crew_output.pydantic}\")\nprint(f\"Tasks Output: {crew_output.tasks_output}\")\nprint(f\"Token Usage: {crew_output.token_usage}\")",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "# Example task\ntask = Task(\n    description='Find and summarize the latest AI news',\n    expected_output='A bullet list summary of the top 5 most important AI news',\n    agent=research_agent,\n    tools=[search_tool]\n)\n\n# Execute the crew\ncrew = Crew(\n    agents=[research_agent],\n    tasks=[task],\n    verbose=True\n)\n\nresult = crew.kickoff()\n\n# Accessing the task output\ntask_output = task.output\n\nprint(f\"Task Description: {task_output.description}\")\nprint(f\"Task Summary: {task_output.summary}\")\nprint(f\"Raw Output: {task_output.raw}\")\nif task_output.json_dict:\n    print(f\"JSON Output: {json.dumps(task_output.json_dict, indent=2)}\")\nif task_output.pydantic:\n    print(f\"Pydantic Output: {task_output.pydantic}\")",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "import os\nfrom crewai import Agent, Task, Crew, Process\n\n# Define your agents\nresearcher = Agent(\n    role=\"Researcher\",\n    goal=\"Conduct thorough research and analysis on AI and AI agents\",\n    backstory=\"You're an expert researcher, specialized in technology, software engineering, AI, and startups. You work as a freelancer and are currently researching for a new client.\",\n    allow_delegation=False,\n)\n\nwriter = Agent(\n    role=\"Senior Writer\",\n    goal=\"Create compelling content about AI and AI agents\",\n    backstory=\"You're a senior writer, specialized in technology, software engineering, AI, and startups. You work as a freelancer and are currently writing content for a new client.\",\n    allow_delegation=False,\n)\n\n# Define your task\ntask = Task(\n    description=\"Generate a list of 5 interesting ideas for an article, then write one captivating paragraph for each idea that showcases the potential of a full article on this topic. Return the list of ideas with their paragraphs and your notes.\",\n    expected_output=\"5 bullet points, each with a paragraph and accompanying notes.\",\n)\n\n# Define the manager agent\nmanager = Agent(\n    role=\"Project Manager\",\n    goal=\"Efficiently manage the crew and ensure high-quality task completion\",\n    backstory=\"You're an experienced project manager, skilled in overseeing complex projects and guiding teams to success. Your role is to coordinate the efforts of the crew members, ensuring that each task is completed on time and to the highest standard.\",\n    allow_delegation=True,\n)\n\n# Instantiate your crew with a custom manager\ncrew = Crew(\n    agents=[researcher, writer],\n    tasks=[task],\n    manager_agent=manager,\n    process=Process.hierarchical,\n)\n\n# Start the crew's work\nresult = crew.kickoff()",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai_tools import AIMindTool\n\n# Initialize the AIMindTool\naimind_tool = AIMindTool(\n    datasources=[\n        {\n            \"description\": \"house sales data\",\n            \"engine\": \"postgres\",\n            \"connection_data\": {\n                \"user\": \"demo_user\",\n                \"password\": \"demo_password\",\n                \"host\": \"samples.mindsdb.com\",\n                \"port\": 5432,\n                \"database\": \"demo\",\n                \"schema\": \"demo_data\"\n            },\n            \"tables\": [\"house_sales\"]\n        }\n    ]\n)\n\n# Run a natural language query\nresult = aimind_tool.run(\"How many 3 bedroom houses were sold in 2008?\")\nprint(result)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai_tools import BraveSearchTool\n\n# Initialize the tool for internet searching capabilities\ntool = BraveSearchTool()\n\n# Execute a search\nresults = tool.run(search_query=\"CrewAI agent framework\")\nprint(results)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai_tools import BrowserbaseLoadTool\n\n# Initialize the tool with the Browserbase API key and Project ID\ntool = BrowserbaseLoadTool()",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai_tools import CodeDocsSearchTool\n\n# To search any code documentation content \n# if the URL is known or discovered during its execution:\ntool = CodeDocsSearchTool()\n\n# OR\n\n# To specifically focus your search on a given documentation site \n# by providing its URL:\ntool = CodeDocsSearchTool(docs_url='https://docs.example.com/reference')",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai import Agent, Task, Crew, Process\nfrom crewai_tools import CodeInterpreterTool\n\n# Initialize the tool\ncode_interpreter = CodeInterpreterTool()\n\n# Define an agent that uses the tool\nprogrammer_agent = Agent(\n    role=\"Python Programmer\",\n    goal=\"Write and execute Python code to solve problems\",\n    backstory=\"An expert Python programmer who can write efficient code to solve complex problems.\",\n    tools=[code_interpreter],\n    verbose=True,\n)\n\n# Example task to generate and execute code\ncoding_task = Task(\n    description=\"Write a Python function to calculate the Fibonacci sequence up to the 10th number and print the result.\",\n    expected_output=\"The Fibonacci sequence up to the 10th number.\",\n    agent=programmer_agent,\n)\n\n# Create and run the crew\ncrew = Crew(\n    agents=[programmer_agent],\n    tasks=[coding_task],\n    verbose=True,\n    process=Process.sequential,\n)\nresult = crew.kickoff()",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai import Agent\n\n# Create an agent with code execution enabled\nprogrammer_agent = Agent(\n    role=\"Python Programmer\",\n    goal=\"Write and execute Python code to solve problems\",\n    backstory=\"An expert Python programmer who can write efficient code to solve complex problems.\",\n    allow_code_execution=True,  # This automatically adds the CodeInterpreterTool\n    verbose=True,\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from composio_crewai import ComposioToolSet, App, Action\nfrom crewai import Agent, Task, Crew\n\ntoolset = ComposioToolSet()",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "request = toolset.initiate_connection(app=App.GITHUB)\nprint(f\"Open this URL to authenticate: {request.redirectUrl}\")",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "tools = toolset.get_tools(apps=[App.GITHUB])",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "tag = \"users\"\n\nfiltered_action_enums = toolset.find_actions_by_tags(\n    App.GITHUB,\n    tags=[tag], \n)\n\ntools = toolset.get_tools(actions=filtered_action_enums)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "use_case = \"Star a repository on GitHub\"\n\nfiltered_action_enums = toolset.find_actions_by_use_case(\n    App.GITHUB, use_case=use_case, advanced=False\n)\n\ntools = toolset.get_tools(actions=filtered_action_enums)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "tools = toolset.get_tools(\n    actions=[Action.GITHUB_STAR_A_REPOSITORY_FOR_THE_AUTHENTICATED_USER]\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "crewai_agent = Agent(\n    role=\"GitHub Agent\",\n    goal=\"You take action on GitHub using GitHub APIs\",\n    backstory=\"You are AI agent that is responsible for taking actions on GitHub on behalf of users using GitHub APIs\",\n    verbose=True,\n    tools=tools,\n    llm= # pass an llm\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "task = Task(\n    description=\"Star a repo composiohq/composio on GitHub\",\n    agent=crewai_agent,\n    expected_output=\"Status of the operation\",\n)\n\ncrew = Crew(agents=[crewai_agent], tasks=[task])\n\ncrew.kickoff()",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai_tools import CSVSearchTool\n\n# Initialize the tool with a specific CSV file. \n# This setup allows the agent to only search the given CSV file.\ntool = CSVSearchTool(csv='path/to/your/csvfile.csv')\n\n# OR\n\n# Initialize the tool without a specific CSV file. \n# Agent will need to provide the CSV path at runtime.\ntool = CSVSearchTool()",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai_tools import DallETool\n\nAgent(\n    ...\n    tools=[DallETool()],\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai_tools import DallETool\n\ndalle_tool = DallETool(model=\"dall-e-3\",\n                       size=\"1024x1024\",\n                       quality=\"standard\",\n                       n=1)\n\nAgent(\n    ...\n    tools=[dalle_tool]\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai_tools import DirectoryReadTool\n\n# Initialize the tool so the agent can read any directory's content \n# it learns about during execution\ntool = DirectoryReadTool()\n\n# OR\n\n# Initialize the tool with a specific directory, \n# so the agent can only read the content of the specified directory\ntool = DirectoryReadTool(directory='/path/to/your/directory')",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai_tools import DOCXSearchTool\n\n# Initialize the tool to search within any DOCX file's content\ntool = DOCXSearchTool()\n\n# OR\n\n# Initialize the tool with a specific DOCX file, \n# so the agent can only search the content of the specified DOCX file\ntool = DOCXSearchTool(docx='path/to/your/document.docx')",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai_tools import EXASearchTool\n\n# Initialize the tool for internet searching capabilities\ntool = EXASearchTool()",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai_tools import FileWriterTool\n\n# Initialize the tool\nfile_writer_tool = FileWriterTool()\n\n# Write content to a file in a specified directory\nresult = file_writer_tool._run('example.txt', 'This is a test content.', 'test_directory')\nprint(result)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai_tools import FirecrawlCrawlWebsiteTool\n\ntool = FirecrawlCrawlWebsiteTool(url='firecrawl.dev')",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai_tools import FirecrawlScrapeWebsiteTool\n\ntool = FirecrawlScrapeWebsiteTool(url='firecrawl.dev')",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai_tools import FirecrawlSearchTool\n\ntool = FirecrawlSearchTool(query='what is firecrawl?')",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai_tools import GithubSearchTool\n\n# Initialize the tool for semantic searches within a specific GitHub repository\ntool = GithubSearchTool(\n\tgithub_repo='https://github.com/example/repo',\n\tgh_token='your_github_personal_access_token',\n\tcontent_types=['code', 'issue'] # Options: code, repo, pr, issue\n)\n\n# OR\n\n# Initialize the tool for semantic searches within a specific GitHub repository, so the agent can search any repository if it learns about during its execution\ntool = GithubSearchTool(\n\tgh_token='your_github_personal_access_token',\n\tcontent_types=['code', 'issue'] # Options: code, repo, pr, issue\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai_tools import HyperbrowserLoadTool\nfrom crewai import Agent\n\n# Initialize the tool with your API key\ntool = HyperbrowserLoadTool(api_key=\"your_api_key\")  # Or use environment variable\n\n# Define an agent that uses the tool\n@agent\ndef web_researcher(self) -> Agent:\n    '''\n    This agent uses the HyperbrowserLoadTool to scrape websites\n    and extract information.\n    '''\n    return Agent(\n        config=self.agents_config[\"web_researcher\"],\n        tools=[tool]\n    )",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai_tools import LinkupSearchTool\nfrom crewai import Agent\nimport os\n\n# Initialize the tool with your API key\nlinkup_tool = LinkupSearchTool(api_key=os.getenv(\"LINKUP_API_KEY\"))\n\n# Define an agent that uses the tool\n@agent\ndef researcher(self) -> Agent:\n    '''\n    This agent uses the LinkupSearchTool to retrieve contextual information\n    from the Linkup API.\n    '''\n    return Agent(\n        config=self.agents_config[\"researcher\"],\n        tools=[linkup_tool]\n    )",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai import Agent, Task, Crew\nfrom crewai_tools import MultiOnTool\n\n# Initialize the tool\nmultion_tool = MultiOnTool(api_key=\"YOUR_MULTION_API_KEY\", local=False)\n\n# Define an agent that uses the tool\nbrowser_agent = Agent(\n    role=\"Browser Agent\",\n    goal=\"Control web browsers using natural language\",\n    backstory=\"An expert browsing agent.\",\n    tools=[multion_tool],\n    verbose=True,\n)\n\n# Example task to search and summarize news\nbrowse_task = Task(\n    description=\"Summarize the top 3 trending AI News headlines\",\n    expected_output=\"A summary of the top 3 trending AI News headlines\",\n    agent=browser_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[browser_agent], tasks=[browse_task])\nresult = crew.kickoff()",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai_tools import MySQLSearchTool\n\n# Initialize the tool with the database URI and the target table name\ntool = MySQLSearchTool(\n    db_uri='mysql://user:password@localhost:3306/mydatabase',\n    table_name='employees'\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "md",
                "content": "DB -> Agent -> ... -> Agent -> DB",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai_tools import PDFSearchTool\n\n# Initialize the tool allowing for any PDF content search if the path is provided during execution\ntool = PDFSearchTool()\n\n# OR\n\n# Initialize the tool with a specific PDF path for exclusive search within that document\ntool = PDFSearchTool(pdf='path/to/your/document.pdf')",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai_tools import RagTool\n\n# Create a RAG tool with default settings\nrag_tool = RagTool()\n\n# Add content from a file\nrag_tool.add(data_type=\"file\", path=\"path/to/your/document.pdf\")\n\n# Add content from a web page\nrag_tool.add(data_type=\"web_page\", url=\"https://example.com\")\n\n# Define an agent with the RagTool\n@agent\ndef knowledge_expert(self) -> Agent:\n    '''\n    This agent uses the RagTool to answer questions about the knowledge base.\n    '''\n    return Agent(\n        config=self.agents_config[\"knowledge_expert\"],\n        allow_delegation=False,\n        tools=[rag_tool]\n    )",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai import Agent, Task, Crew\nfrom crewai_tools.aws.s3 import S3ReaderTool\n\n# Initialize the tool\ns3_reader_tool = S3ReaderTool()\n\n# Define an agent that uses the tool\nfile_reader_agent = Agent(\n    role=\"File Reader\",\n    goal=\"Read files from S3 buckets\",\n    backstory=\"An expert in retrieving and processing files from cloud storage.\",\n    tools=[s3_reader_tool],\n    verbose=True,\n)\n\n# Example task to read a configuration file\nread_task = Task(\n    description=\"Read the configuration file from {my_bucket} and summarize its contents.\",\n    expected_output=\"A summary of the configuration file contents.\",\n    agent=file_reader_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[file_reader_agent], tasks=[read_task])\nresult = crew.kickoff(inputs={\"my_bucket\": \"s3://my-bucket/config/app-config.json\"})",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai import Agent, Task, Crew\nfrom crewai_tools.aws.s3 import S3WriterTool\n\n# Initialize the tool\ns3_writer_tool = S3WriterTool()\n\n# Define an agent that uses the tool\nfile_writer_agent = Agent(\n    role=\"File Writer\",\n    goal=\"Write content to files in S3 buckets\",\n    backstory=\"An expert in storing and managing files in cloud storage.\",\n    tools=[s3_writer_tool],\n    verbose=True,\n)\n\n# Example task to write a report\nwrite_task = Task(\n    description=\"Generate a summary report of the quarterly sales data and save it to {my_bucket}.\",\n    expected_output=\"Confirmation that the report was successfully saved to S3.\",\n    agent=file_writer_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[file_writer_agent], tasks=[write_task])\nresult = crew.kickoff(inputs={\"my_bucket\": \"s3://my-bucket/reports/quarterly-summary.txt\"})",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai import Agent, Task, Crew\nfrom crewai_tools import ScrapeElementFromWebsiteTool\n\n# Initialize the tool\nscrape_tool = ScrapeElementFromWebsiteTool()\n\n# Define an agent that uses the tool\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract specific information from websites\",\n    backstory=\"An expert in web scraping who can extract targeted content from web pages.\",\n    tools=[scrape_tool],\n    verbose=True,\n)\n\n# Example task to extract headlines from a news website\nscrape_task = Task(\n    description=\"Extract the main headlines from the CNN homepage. Use the CSS selector '.headline' to target the headline elements.\",\n    expected_output=\"A list of the main headlines from CNN.\",\n    agent=web_scraper_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[web_scraper_agent], tasks=[scrape_task])\nresult = crew.kickoff()",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "# Initialize the tool with predefined parameters\nscrape_tool = ScrapeElementFromWebsiteTool(\n    website_url=\"https://www.example.com\",\n    css_element=\".main-content\"\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai import Agent, Task, Crew\nfrom crewai_tools import ScrapegraphScrapeTool\n\n# Initialize the tool\nscrape_tool = ScrapegraphScrapeTool(api_key=\"your_api_key\")\n\n# Define an agent that uses the tool\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract specific information from websites\",\n    backstory=\"An expert in web scraping who can extract targeted content from web pages.\",\n    tools=[scrape_tool],\n    verbose=True,\n)\n\n# Example task to extract product information from an e-commerce site\nscrape_task = Task(\n    description=\"Extract product names, prices, and descriptions from the featured products section of example.com.\",\n    expected_output=\"A structured list of product information including names, prices, and descriptions.\",\n    agent=web_scraper_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[web_scraper_agent], tasks=[scrape_task])\nresult = crew.kickoff()",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "# Initialize the tool with predefined parameters\nscrape_tool = ScrapegraphScrapeTool(\n    website_url=\"https://www.example.com\",\n    user_prompt=\"Extract all product prices and descriptions\",\n    api_key=\"your_api_key\"\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python",
                "content": "from crewai_tools import ScrapeWebsiteTool\n\n# To enable scrapping any website it finds during it's execution\ntool = ScrapeWebsiteTool()\n\n# Initialize the tool with the website URL, \n# so the agent can only scrap the content of the specified website\ntool = ScrapeWebsiteTool(website_url='https://www.example.com')\n\n# Extract the text from the site\ntext = tool.run()\nprint(text)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai import Agent, Task, Crew\nfrom crewai_tools import ScrapflyScrapeWebsiteTool\n\n# Initialize the tool\nscrape_tool = ScrapflyScrapeWebsiteTool(api_key=\"your_scrapfly_api_key\")\n\n# Define an agent that uses the tool\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract information from websites\",\n    backstory=\"An expert in web scraping who can extract content from any website.\",\n    tools=[scrape_tool],\n    verbose=True,\n)\n\n# Example task to extract content from a website\nscrape_task = Task(\n    description=\"Extract the main content from the product page at https://web-scraping.dev/products and summarize the available products.\",\n    expected_output=\"A summary of the products available on the website.\",\n    agent=web_scraper_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[web_scraper_agent], tasks=[scrape_task])\nresult = crew.kickoff()",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "# Example with custom scraping parameters\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract information from websites with custom parameters\",\n    backstory=\"An expert in web scraping who can extract content from any website.\",\n    tools=[scrape_tool],\n    verbose=True,\n)\n\n# The agent will use the tool with parameters like:\n# url=\"https://web-scraping.dev/products\"\n# scrape_format=\"markdown\"\n# ignore_scrape_failures=True\n# scrape_config={\n#     \"asp\": True,  # Bypass scraping blocking solutions, like Cloudflare\n#     \"render_js\": True,  # Enable JavaScript rendering with a cloud headless browser\n#     \"proxy_pool\": \"public_residential_pool\",  # Select a proxy pool\n#     \"country\": \"us\",  # Select a proxy location\n#     \"auto_scroll\": True,  # Auto scroll the page\n# }\n\nscrape_task = Task(\n    description=\"Extract the main content from the product page at https://web-scraping.dev/products using advanced scraping options including JavaScript rendering and proxy settings.\",\n    expected_output=\"A detailed summary of the products with all available information.\",\n    agent=web_scraper_agent,\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai import Agent, Task, Crew, Process\nfrom crewai_tools import SeleniumScrapingTool\n\n# Initialize the tool\nselenium_tool = SeleniumScrapingTool()\n\n# Define an agent that uses the tool\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract information from websites using Selenium\",\n    backstory=\"An expert web scraper who can extract content from dynamic websites.\",\n    tools=[selenium_tool],\n    verbose=True,\n)\n\n# Example task to scrape content from a website\nscrape_task = Task(\n    description=\"Extract the main content from the homepage of example.com. Use the CSS selector 'main' to target the main content area.\",\n    expected_output=\"The main content from example.com's homepage.\",\n    agent=web_scraper_agent,\n)\n\n# Create and run the crew\ncrew = Crew(\n    agents=[web_scraper_agent],\n    tasks=[scrape_task],\n    verbose=True,\n    process=Process.sequential,\n)\nresult = crew.kickoff()",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "# Initialize the tool with predefined parameters\nselenium_tool = SeleniumScrapingTool(\n    website_url='https://example.com',\n    css_element='.main-content',\n    wait_time=5\n)\n\n# Define an agent that uses the tool\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract information from websites using Selenium\",\n    backstory=\"An expert web scraper who can extract content from dynamic websites.\",\n    tools=[selenium_tool],\n    verbose=True,\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai_tools import SerperDevTool\n\n# Initialize the tool for internet searching capabilities\ntool = SerperDevTool()",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai import Agent, Task, Crew\nfrom crewai_tools import SnowflakeSearchTool, SnowflakeConfig\n\n# Create Snowflake configuration\nconfig = SnowflakeConfig(\n    account=\"your_account\",\n    user=\"your_username\",\n    password=\"your_password\",\n    warehouse=\"COMPUTE_WH\",\n    database=\"your_database\",\n    snowflake_schema=\"your_schema\"\n)\n\n# Initialize the tool\nsnowflake_tool = SnowflakeSearchTool(config=config)\n\n# Define an agent that uses the tool\ndata_analyst_agent = Agent(\n    role=\"Data Analyst\",\n    goal=\"Analyze data from Snowflake database\",\n    backstory=\"An expert data analyst who can extract insights from enterprise data.\",\n    tools=[snowflake_tool],\n    verbose=True,\n)\n\n# Example task to query sales data\nquery_task = Task(\n    description=\"Query the sales data for the last quarter and summarize the top 5 products by revenue.\",\n    expected_output=\"A summary of the top 5 products by revenue for the last quarter.\",\n    agent=data_analyst_agent,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[data_analyst_agent], \n            tasks=[query_task])\nresult = crew.kickoff()",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "# Initialize the tool with custom parameters\nsnowflake_tool = SnowflakeSearchTool(\n    config=config,\n    pool_size=10,\n    max_retries=5,\n    retry_delay=2.0,\n    enable_caching=True\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai_tools import SpiderTool\n\ndef main():\n    spider_tool = SpiderTool()\n\n    searcher = Agent(\n        role=\"Web Research Expert\",\n        goal=\"Find related information from specific URL's\",\n        backstory=\"An expert web researcher that uses the web extremely well\",\n        tools=[spider_tool],\n        verbose=True,\n    )\n\n    return_metadata = Task(\n        description=\"Scrape https://spider.cloud with a limit of 1 and enable metadata\",\n        expected_output=\"Metadata and 10 word summary of spider.cloud\",\n        agent=searcher\n    )\n\n    crew = Crew(\n        agents=[searcher],\n        tasks=[\n            return_metadata,\n        ],\n        verbose=2\n    )\n\n    crew.kickoff()\n\nif __name__ == \"__main__\":\n    main()",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai_tools import TXTSearchTool\n\n# Initialize the tool to search within any text file's content \n# the agent learns about during its execution\ntool = TXTSearchTool()\n\n# OR\n\n# Initialize the tool with a specific text file, \n# so the agent can search within the given text file's content\ntool = TXTSearchTool(txt='path/to/text/file.txt')",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai_tools import WeaviateVectorSearchTool\n\n# Initialize the tool\ntool = WeaviateVectorSearchTool(\n    collection_name='example_collections',\n    limit=3,\n    weaviate_cluster_url=\"https://your-weaviate-cluster-url.com\",\n    weaviate_api_key=\"your-weaviate-api-key\",\n)\n\n@agent\ndef search_agent(self) -> Agent:\n    '''\n    This agent uses the WeaviateVectorSearchTool to search for \n    semantically similar documents in a Weaviate vector database.\n    '''\n    return Agent(\n        config=self.agents_config[\"search_agent\"],\n        tools=[tool]\n    )",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai_tools import XMLSearchTool\n\n# Allow agents to search within any XML file's content \n#as it learns about their paths during execution\ntool = XMLSearchTool()\n\n# OR\n\n# Initialize the tool with a specific XML file path \n#for exclusive search within that document\ntool = XMLSearchTool(xml='path/to/your/xmlfile.xml')",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai import Agent, Task, Crew\nfrom crewai_tools import YoutubeChannelSearchTool\n\n# Initialize the tool for general YouTube channel searches\nyoutube_channel_tool = YoutubeChannelSearchTool()\n\n# Define an agent that uses the tool\nchannel_researcher = Agent(\n    role=\"Channel Researcher\",\n    goal=\"Extract relevant information from YouTube channels\",\n    backstory=\"An expert researcher who specializes in analyzing YouTube channel content.\",\n    tools=[youtube_channel_tool],\n    verbose=True,\n)\n\n# Example task to search for information in a specific channel\nresearch_task = Task(\n    description=\"Search for information about machine learning tutorials in the YouTube channel {youtube_channel_handle}\",\n    expected_output=\"A summary of the key machine learning tutorials available on the channel.\",\n    agent=channel_researcher,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[channel_researcher], tasks=[research_task])\nresult = crew.kickoff(inputs={\"youtube_channel_handle\": \"@exampleChannel\"})",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "# Initialize the tool with a specific YouTube channel handle\nyoutube_channel_tool = YoutubeChannelSearchTool(\n    youtube_channel_handle='@exampleChannel'\n)\n\n# Define an agent that uses the tool\nchannel_researcher = Agent(\n    role=\"Channel Researcher\",\n    goal=\"Extract relevant information from a specific YouTube channel\",\n    backstory=\"An expert researcher who specializes in analyzing YouTube channel content.\",\n    tools=[youtube_channel_tool],\n    verbose=True,\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai import Agent, Task, Crew\nfrom crewai_tools import YoutubeVideoSearchTool\n\n# Initialize the tool for general YouTube video searches\nyoutube_search_tool = YoutubeVideoSearchTool()\n\n# Define an agent that uses the tool\nvideo_researcher = Agent(\n    role=\"Video Researcher\",\n    goal=\"Extract relevant information from YouTube videos\",\n    backstory=\"An expert researcher who specializes in analyzing video content.\",\n    tools=[youtube_search_tool],\n    verbose=True,\n)\n\n# Example task to search for information in a specific video\nresearch_task = Task(\n    description=\"Search for information about machine learning frameworks in the YouTube video at {youtube_video_url}\",\n    expected_output=\"A summary of the key machine learning frameworks mentioned in the video.\",\n    agent=video_researcher,\n)\n\n# Create and run the crew\ncrew = Crew(agents=[video_researcher], tasks=[research_task])\nresult = crew.kickoff(inputs={\"youtube_video_url\": \"https://youtube.com/watch?v=example\"})",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "# Initialize the tool with a specific YouTube video URL\nyoutube_search_tool = YoutubeVideoSearchTool(\n    youtube_video_url='https://youtube.com/watch?v=example'\n)\n\n# Define an agent that uses the tool\nvideo_researcher = Agent(\n    role=\"Video Researcher\",\n    goal=\"Extract relevant information from a specific YouTube video\",\n    backstory=\"An expert researcher who specializes in analyzing video content.\",\n    tools=[youtube_search_tool],\n    verbose=True,\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Parameters",
            "level": 2,
            "content": "`inputs` (dict): A dictionary containing the input data required for the tasks.\n\nThe `AIMindTool` accepts the following parameters: **api\\_key**: Optional. Your Minds API key. If not provided, it will be read from the `MINDS_API_KEY` environment variable. **datasources**: A list of dictionaries, each containing the following keys: **description**: A description of the data contained in the datasource. **engine**: The engine (or type) of the datasource. **connection\\_data**: A dictionary containing the connection parameters for the datasource. **tables**: A list of tables that the data source will use. This is optional and can be omitted if all tables in the data source are to be used. A list of supported data sources and their connection parameters can be found [here](https://docs.mdb.ai/docs/data_sources).\n\nThe `BraveSearchTool` accepts the following parameters: **search\\_query**: Mandatory. The search query you want to use to search the internet. **country**: Optional. Specify the country for the search results. Default is empty string. **n\\_results**: Optional. Number of search results to return. Default is `10`. **save\\_file**: Optional. Whether to save the search results to a file. Default is `False`.\n\nThe `CodeInterpreterTool` accepts the following parameters during initialization: **user\\_dockerfile\\_path**: Optional. Path to a custom Dockerfile to use for the code interpreter container. **user\\_docker\\_base\\_url**: Optional. URL to the Docker daemon to use for running the container. **unsafe\\_mode**: Optional. Whether to run code directly on the host machine instead of in a Docker container. Default is `False`. Use with caution! When using the tool with an agent, the agent will need to provide: **code**: Required. The Python 3 code to execute. **libraries\\_used**: Required. A list of libraries used in the code that need to be installed.\n\nThe `HyperbrowserLoadTool` accepts the following parameters:\n\nThe `LinkupSearchTool` accepts the following parameters:\n\nThe `from_query_engine` method accepts the following parameters: **query\\_engine**: Required. The LlamaIndex query engine to wrap. **name**: Optional. The name of the tool. **description**: Optional. The description of the tool. **return\\_direct**: Optional. Whether to return the response directly. Default is `False`.\n\nmdx: **Optional**. Specifies the MDX file path for the search. It can be provided during initialization.\n\nThe `MultiOnTool` accepts the following parameters during initialization: **api\\_key**: Optional. Specifies the MultiOn API key. If not provided, it will look for the `MULTION_API_KEY` environment variable. **local**: Optional. Set to `True` to run the agent locally on your browser. Make sure the MultiOn browser extension is installed and API Enabled is checked. Default is `False`. **max\\_steps**: Optional. Sets the maximum number of steps the MultiOn agent can take for a command. Default is `3`.\n\nThe `RagTool` accepts the following parameters: **summarize**: Optional. Whether to summarize the retrieved content. Default is `False`. **adapter**: Optional. A custom adapter for the knowledge base. If not provided, an EmbedchainAdapter will be used. **config**: Optional. Configuration for the underlying EmbedChain App.\n\nThe `S3ReaderTool` accepts the following parameter when used by an agent: **file\\_path**: Required. The S3 file path in the format `s3://bucket-name/file-name`.\n\nThe `S3WriterTool` accepts the following parameters when used by an agent: **file\\_path**: Required. The S3 file path in the format `s3://bucket-name/file-name`. **content**: Required. The content to write to the file.\n\nThe `ScrapeElementFromWebsiteTool` accepts the following parameters during initialization: **website\\_url**: Optional. The URL of the website to scrape. If provided during initialization, the agent won't need to specify it when using the tool. **css\\_element**: Optional. The CSS selector for the elements to extract. If provided during initialization, the agent won't need to specify it when using the tool. **cookies**: Optional. A dictionary containing cookies to be sent with the request. This can be useful for websites that require authentication.\n\nThe `ScrapegraphScrapeTool` accepts the following parameters during initialization: **api\\_key**: Optional. Your Scrapegraph API key. If not provided, it will look for the `SCRAPEGRAPH_API_KEY` environment variable. **website\\_url**: Optional. The URL of the website to scrape. If provided during initialization, the agent won't need to specify it when using the tool. **user\\_prompt**: Optional. Custom instructions for content extraction. If provided during initialization, the agent won't need to specify it when using the tool. **enable\\_logging**: Optional. Whether to enable logging for the Scrapegraph client. Default is `False`.\n\nThe `ScrapflyScrapeWebsiteTool` accepts the following parameters:\n\nThe `SeleniumScrapingTool` accepts the following parameters during initialization: **website\\_url**: Optional. The URL of the website to scrape. If provided during initialization, the agent won't need to specify it when using the tool. **css\\_element**: Optional. The CSS selector for the elements to extract. If provided during initialization, the agent won't need to specify it when using the tool. **cookie**: Optional. A dictionary containing cookie information, useful for simulating a logged-in session to access restricted content. **wait\\_time**: Optional. Specifies the delay (in seconds) before scraping, allowing the website and any dynamic content to fully load. Default is `3` seconds. **return\\_html**: Optional. Whether to return the HTML content instead of just the text. Default is `False`. When using the tool with an agent, the agent will need to provide the following parameters (unless they were specified during initialization): **website\\_url**: Required. The URL of the website to scrape. **css\\_element**: Required. The CSS selector for the elements to extract.\n\nThe `SerperDevTool` comes with several parameters that will be passed to the API : **search\\_url**: The URL endpoint for the search API. (Default is `https://google.serper.dev/search`) **country**: Optional. Specify the country for the search results. **location**: Optional. Specify the location for the search results. **locale**: Optional. Specify the locale for the search results. **n\\_results**: Number of search results to return. Default is `10`. The values for `country`, `location`, `locale` and `search_url` can be found on the [Serper Playground](https://serper.dev/playground).\n\nThe `WeaviateVectorSearchTool` accepts the following parameters: **collection\\_name**: Required. The name of the collection to search within. **weaviate\\_cluster\\_url**: Required. The URL of the Weaviate cluster. **weaviate\\_api\\_key**: Required. The API key for the Weaviate cluster. **limit**: Optional. The number of results to return. Default is `3`. **vectorizer**: Optional. The vectorizer to use. If not provided, it will use `text2vec_openai` with the `nomic-embed-text` model. **generative\\_model**: Optional. The generative model to use. If not provided, it will use OpenAI's `gpt-4o`.\n\nThe `YoutubeChannelSearchTool` accepts the following parameters: **youtube\\_channel\\_handle**: Optional. The handle of the YouTube channel to search within. If provided during initialization, the agent won't need to specify it when using the tool. If the handle doesn't start with '@', it will be automatically added. **config**: Optional. Configuration for the underlying RAG system, including LLM and embedder settings. **summarize**: Optional. Whether to summarize the retrieved content. Default is `False`. When using the tool with an agent, the agent will need to provide: **search\\_query**: Required. The search query to find relevant information in the channel content. **youtube\\_channel\\_handle**: Required only if not provided during initialization. The handle of the YouTube channel to search within.\n\nThe `YoutubeVideoSearchTool` accepts the following parameters: **youtube\\_video\\_url**: Optional. The URL of the YouTube video to search within. If provided during initialization, the agent won't need to specify it when using the tool. **config**: Optional. Configuration for the underlying RAG system, including LLM and embedder settings. **summarize**: Optional. Whether to summarize the retrieved content. Default is `False`. When using the tool with an agent, the agent will need to provide: **search\\_query**: Required. The search query to find relevant information in the video content. **youtube\\_video\\_url**: Required only if not provided during initialization. The URL of the YouTube video to search within.",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": []
          },
          {
            "type": "header",
            "title": "Custom Model and Embeddings",
            "level": 2,
            "content": "The DirectorySearchTool uses OpenAI for embeddings and summarization by default. Customization options for these settings include changing the model provider and configuration, enhancing flexibility for advanced users.\n```\ntool = DirectorySearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # Options include ollama, google, anthropic, llama2, and more\n            config=dict(\n                model=\"llama2\",\n                # Additional configurations here\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)\n```\n\nThe tool intends to use OpenAI for both embeddings and summarization by default. Users will have the option to customize the model using a config dictionary as follows:\n```\ntool = PGSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)\n```\n\nBy default, the tool uses OpenAI for both embeddings and summarization. To customize the model, you can use a config dictionary as follows:\n```\nyoutube_channel_tool = YoutubeChannelSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)\n```\n\nBy default, the tool uses OpenAI for both embeddings and summarization. To customize the model, you can use a config dictionary as follows:\n```\nyoutube_search_tool = YoutubeVideoSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)\n```",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "tool = DirectorySearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # Options include ollama, google, anthropic, llama2, and more\n            config=dict(\n                model=\"llama2\",\n                # Additional configurations here\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "tool = PGSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "youtube_channel_tool = YoutubeChannelSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "youtube_search_tool = YoutubeVideoSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Agent Integration Example",
            "level": 2,
            "content": "Here's how to integrate the `AIMindTool` with a CrewAI agent:\n```\nfrom crewai import Agent\nfrom crewai.project import agent\nfrom crewai_tools import AIMindTool\n\n# Initialize the tool\naimind_tool = AIMindTool(\n    datasources=[\n        {\n            \"description\": \"sales data\",\n            \"engine\": \"postgres\",\n            \"connection_data\": {\n                \"user\": \"your_user\",\n                \"password\": \"your_password\",\n                \"host\": \"your_host\",\n                \"port\": 5432,\n                \"database\": \"your_db\",\n                \"schema\": \"your_schema\"\n            },\n            \"tables\": [\"sales\"]\n        }\n    ]\n)\n\n# Define an agent with the AIMindTool\n@agent\ndef data_analyst(self) -> Agent:\n    return Agent(\n        config=self.agents_config[\"data_analyst\"],\n        allow_delegation=False,\n        tools=[aimind_tool]\n    )\n```\n\nHere's how to integrate the `BraveSearchTool` with a CrewAI agent:\n```\nfrom crewai import Agent\nfrom crewai.project import agent\nfrom crewai_tools import BraveSearchTool\n\n# Initialize the tool\nbrave_search_tool = BraveSearchTool()\n\n# Define an agent with the BraveSearchTool\n@agent\ndef researcher(self) -> Agent:\n    return Agent(\n        config=self.agents_config[\"researcher\"],\n        allow_delegation=False,\n        tools=[brave_search_tool]\n    )\n```\n\nHere's a more detailed example of how to integrate the `CodeInterpreterTool` with a CrewAI agent:\n```\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import CodeInterpreterTool\n\n# Initialize the tool\ncode_interpreter = CodeInterpreterTool()\n\n# Define an agent that uses the tool\ndata_analyst = Agent(\n    role=\"Data Analyst\",\n    goal=\"Analyze data using Python code\",\n    backstory=\"\"\"You are an expert data analyst who specializes in using Python \n    to analyze and visualize data. You can write efficient code to process \n    large datasets and extract meaningful insights.\"\"\",\n    tools=[code_interpreter],\n    verbose=True,\n)\n\n# Create a task for the agent\nanalysis_task = Task(\n    description=\"\"\"\n    Write Python code to:\n    1. Generate a random dataset of 100 points with x and y coordinates\n    2. Calculate the correlation coefficient between x and y\n    3. Create a scatter plot of the data\n    4. Print the correlation coefficient and save the plot as 'scatter.png'\n    \n    Make sure to handle any necessary imports and print the results.\n    \"\"\",\n    expected_output=\"The correlation coefficient and confirmation that the scatter plot has been saved.\",\n    agent=data_analyst,\n)\n\n# Run the task\ncrew = Crew(\n    agents=[data_analyst],\n    tasks=[analysis_task],\n    verbose=True,\n    process=Process.sequential,\n)\nresult = crew.kickoff()\n```\n\nHere's how to integrate the `RagTool` with a CrewAI agent:\n```\nfrom crewai import Agent\nfrom crewai.project import agent\nfrom crewai_tools import RagTool\n\n# Initialize the tool and add content\nrag_tool = RagTool()\nrag_tool.add(data_type=\"web_page\", url=\"https://docs.crewai.com\")\nrag_tool.add(data_type=\"file\", path=\"company_data.pdf\")\n\n# Define an agent with the RagTool\n@agent\ndef knowledge_expert(self) -> Agent:\n    return Agent(\n        config=self.agents_config[\"knowledge_expert\"],\n        allow_delegation=False,\n        tools=[rag_tool]\n    )\n```\n\nHere's a more detailed example of how to integrate the `SeleniumScrapingTool` with a CrewAI agent:\n```\nfrom crewai import Agent, Task, Crew, Process\nfrom crewai_tools import SeleniumScrapingTool\n\n# Initialize the tool\nselenium_tool = SeleniumScrapingTool()\n\n# Define an agent that uses the tool\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract and analyze information from dynamic websites\",\n    backstory=\"\"\"You are an expert web scraper who specializes in extracting \n    content from dynamic websites that require browser automation. You have \n    extensive knowledge of CSS selectors and can identify the right selectors \n    to target specific content on any website.\"\"\",\n    tools=[selenium_tool],\n    verbose=True,\n)\n\n# Create a task for the agent\nscrape_task = Task(\n    description=\"\"\"\n    Extract the following information from the news website at {website_url}:\n    \n    1. The headlines of all featured articles (CSS selector: '.headline')\n    2. The publication dates of these articles (CSS selector: '.pub-date')\n    3. The author names where available (CSS selector: '.author')\n    \n    Compile this information into a structured format with each article's details grouped together.\n    \"\"\",\n    expected_output=\"A structured list of articles with their headlines, publication dates, and authors.\",\n    agent=web_scraper_agent,\n)\n\n# Run the task\ncrew = Crew(\n    agents=[web_scraper_agent],\n    tasks=[scrape_task],\n    verbose=True,\n    process=Process.sequential,\n)\nresult = crew.kickoff(inputs={\"website_url\": \"https://news-example.com\"})\n```\n\nHere's how to integrate the `WeaviateVectorSearchTool` with a CrewAI agent:\n```\nfrom crewai import Agent\nfrom crewai_tools import WeaviateVectorSearchTool\n\n# Initialize the tool\nweaviate_tool = WeaviateVectorSearchTool(\n    collection_name='example_collections',\n    limit=3,\n    weaviate_cluster_url=\"https://your-weaviate-cluster-url.com\",\n    weaviate_api_key=\"your-weaviate-api-key\",\n)\n\n# Create an agent with the tool\nrag_agent = Agent(\n    name=\"rag_agent\",\n    role=\"You are a helpful assistant that can answer questions with the help of the WeaviateVectorSearchTool.\",\n    llm=\"gpt-4o-mini\",\n    tools=[weaviate_tool],\n)\n```\n\nHere's a more detailed example of how to integrate the `YoutubeChannelSearchTool` with a CrewAI agent:\n```\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import YoutubeChannelSearchTool\n\n# Initialize the tool\nyoutube_channel_tool = YoutubeChannelSearchTool()\n\n# Define an agent that uses the tool\nchannel_researcher = Agent(\n    role=\"Channel Researcher\",\n    goal=\"Extract and analyze information from YouTube channels\",\n    backstory=\"\"\"You are an expert channel researcher who specializes in extracting \n    and analyzing information from YouTube channels. You have a keen eye for detail \n    and can quickly identify key points and insights from video content across an entire channel.\"\"\",\n    tools=[youtube_channel_tool],\n    verbose=True,\n)\n\n# Create a task for the agent\nresearch_task = Task(\n    description=\"\"\"\n    Search for information about data science projects and tutorials \n    in the YouTube channel {youtube_channel_handle}. \n    \n    Focus on:\n    1. Key data science techniques covered\n    2. Popular tutorial series\n    3. Most viewed or recommended videos\n    \n    Provide a comprehensive summary of these points.\n    \"\"\",\n    expected_output=\"A detailed summary of data science content available on the channel.\",\n    agent=channel_researcher,\n)\n\n# Run the task\ncrew = Crew(agents=[channel_researcher], tasks=[research_task])\nresult = crew.kickoff(inputs={\"youtube_channel_handle\": \"@exampleDataScienceChannel\"})\n```\n\nHere's a more detailed example of how to integrate the `YoutubeVideoSearchTool` with a CrewAI agent:\n```\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import YoutubeVideoSearchTool\n\n# Initialize the tool\nyoutube_search_tool = YoutubeVideoSearchTool()\n\n# Define an agent that uses the tool\nvideo_researcher = Agent(\n    role=\"Video Researcher\",\n    goal=\"Extract and analyze information from YouTube videos\",\n    backstory=\"\"\"You are an expert video researcher who specializes in extracting \n    and analyzing information from YouTube videos. You have a keen eye for detail \n    and can quickly identify key points and insights from video content.\"\"\",\n    tools=[youtube_search_tool],\n    verbose=True,\n)\n\n# Create a task for the agent\nresearch_task = Task(\n    description=\"\"\"\n    Search for information about recent advancements in artificial intelligence \n    in the YouTube video at {youtube_video_url}. \n    \n    Focus on:\n    1. Key AI technologies mentioned\n    2. Real-world applications discussed\n    3. Future predictions made by the speaker\n    \n    Provide a comprehensive summary of these points.\n    \"\"\",\n    expected_output=\"A detailed summary of AI advancements, applications, and future predictions from the video.\",\n    agent=video_researcher,\n)\n\n# Run the task\ncrew = Crew(agents=[video_researcher], tasks=[research_task])\nresult = crew.kickoff(inputs={\"youtube_video_url\": \"https://youtube.com/watch?v=example\"})\n```",
            "metadata": {
              "section_type": "Examples",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai import Agent\nfrom crewai.project import agent\nfrom crewai_tools import AIMindTool\n\n# Initialize the tool\naimind_tool = AIMindTool(\n    datasources=[\n        {\n            \"description\": \"sales data\",\n            \"engine\": \"postgres\",\n            \"connection_data\": {\n                \"user\": \"your_user\",\n                \"password\": \"your_password\",\n                \"host\": \"your_host\",\n                \"port\": 5432,\n                \"database\": \"your_db\",\n                \"schema\": \"your_schema\"\n            },\n            \"tables\": [\"sales\"]\n        }\n    ]\n)\n\n# Define an agent with the AIMindTool\n@agent\ndef data_analyst(self) -> Agent:\n    return Agent(\n        config=self.agents_config[\"data_analyst\"],\n        allow_delegation=False,\n        tools=[aimind_tool]\n    )",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai import Agent\nfrom crewai.project import agent\nfrom crewai_tools import BraveSearchTool\n\n# Initialize the tool\nbrave_search_tool = BraveSearchTool()\n\n# Define an agent with the BraveSearchTool\n@agent\ndef researcher(self) -> Agent:\n    return Agent(\n        config=self.agents_config[\"researcher\"],\n        allow_delegation=False,\n        tools=[brave_search_tool]\n    )",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai import Agent, Task, Crew\nfrom crewai_tools import CodeInterpreterTool\n\n# Initialize the tool\ncode_interpreter = CodeInterpreterTool()\n\n# Define an agent that uses the tool\ndata_analyst = Agent(\n    role=\"Data Analyst\",\n    goal=\"Analyze data using Python code\",\n    backstory=\"\"\"You are an expert data analyst who specializes in using Python \n    to analyze and visualize data. You can write efficient code to process \n    large datasets and extract meaningful insights.\"\"\",\n    tools=[code_interpreter],\n    verbose=True,\n)\n\n# Create a task for the agent\nanalysis_task = Task(\n    description=\"\"\"\n    Write Python code to:\n    1. Generate a random dataset of 100 points with x and y coordinates\n    2. Calculate the correlation coefficient between x and y\n    3. Create a scatter plot of the data\n    4. Print the correlation coefficient and save the plot as 'scatter.png'\n    \n    Make sure to handle any necessary imports and print the results.\n    \"\"\",\n    expected_output=\"The correlation coefficient and confirmation that the scatter plot has been saved.\",\n    agent=data_analyst,\n)\n\n# Run the task\ncrew = Crew(\n    agents=[data_analyst],\n    tasks=[analysis_task],\n    verbose=True,\n    process=Process.sequential,\n)\nresult = crew.kickoff()",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai import Agent\nfrom crewai.project import agent\nfrom crewai_tools import RagTool\n\n# Initialize the tool and add content\nrag_tool = RagTool()\nrag_tool.add(data_type=\"web_page\", url=\"https://docs.crewai.com\")\nrag_tool.add(data_type=\"file\", path=\"company_data.pdf\")\n\n# Define an agent with the RagTool\n@agent\ndef knowledge_expert(self) -> Agent:\n    return Agent(\n        config=self.agents_config[\"knowledge_expert\"],\n        allow_delegation=False,\n        tools=[rag_tool]\n    )",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai import Agent, Task, Crew, Process\nfrom crewai_tools import SeleniumScrapingTool\n\n# Initialize the tool\nselenium_tool = SeleniumScrapingTool()\n\n# Define an agent that uses the tool\nweb_scraper_agent = Agent(\n    role=\"Web Scraper\",\n    goal=\"Extract and analyze information from dynamic websites\",\n    backstory=\"\"\"You are an expert web scraper who specializes in extracting \n    content from dynamic websites that require browser automation. You have \n    extensive knowledge of CSS selectors and can identify the right selectors \n    to target specific content on any website.\"\"\",\n    tools=[selenium_tool],\n    verbose=True,\n)\n\n# Create a task for the agent\nscrape_task = Task(\n    description=\"\"\"\n    Extract the following information from the news website at {website_url}:\n    \n    1. The headlines of all featured articles (CSS selector: '.headline')\n    2. The publication dates of these articles (CSS selector: '.pub-date')\n    3. The author names where available (CSS selector: '.author')\n    \n    Compile this information into a structured format with each article's details grouped together.\n    \"\"\",\n    expected_output=\"A structured list of articles with their headlines, publication dates, and authors.\",\n    agent=web_scraper_agent,\n)\n\n# Run the task\ncrew = Crew(\n    agents=[web_scraper_agent],\n    tasks=[scrape_task],\n    verbose=True,\n    process=Process.sequential,\n)\nresult = crew.kickoff(inputs={\"website_url\": \"https://news-example.com\"})",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai import Agent\nfrom crewai_tools import WeaviateVectorSearchTool\n\n# Initialize the tool\nweaviate_tool = WeaviateVectorSearchTool(\n    collection_name='example_collections',\n    limit=3,\n    weaviate_cluster_url=\"https://your-weaviate-cluster-url.com\",\n    weaviate_api_key=\"your-weaviate-api-key\",\n)\n\n# Create an agent with the tool\nrag_agent = Agent(\n    name=\"rag_agent\",\n    role=\"You are a helpful assistant that can answer questions with the help of the WeaviateVectorSearchTool.\",\n    llm=\"gpt-4o-mini\",\n    tools=[weaviate_tool],\n)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai import Agent, Task, Crew\nfrom crewai_tools import YoutubeChannelSearchTool\n\n# Initialize the tool\nyoutube_channel_tool = YoutubeChannelSearchTool()\n\n# Define an agent that uses the tool\nchannel_researcher = Agent(\n    role=\"Channel Researcher\",\n    goal=\"Extract and analyze information from YouTube channels\",\n    backstory=\"\"\"You are an expert channel researcher who specializes in extracting \n    and analyzing information from YouTube channels. You have a keen eye for detail \n    and can quickly identify key points and insights from video content across an entire channel.\"\"\",\n    tools=[youtube_channel_tool],\n    verbose=True,\n)\n\n# Create a task for the agent\nresearch_task = Task(\n    description=\"\"\"\n    Search for information about data science projects and tutorials \n    in the YouTube channel {youtube_channel_handle}. \n    \n    Focus on:\n    1. Key data science techniques covered\n    2. Popular tutorial series\n    3. Most viewed or recommended videos\n    \n    Provide a comprehensive summary of these points.\n    \"\"\",\n    expected_output=\"A detailed summary of data science content available on the channel.\",\n    agent=channel_researcher,\n)\n\n# Run the task\ncrew = Crew(agents=[channel_researcher], tasks=[research_task])\nresult = crew.kickoff(inputs={\"youtube_channel_handle\": \"@exampleDataScienceChannel\"})",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "from crewai import Agent, Task, Crew\nfrom crewai_tools import YoutubeVideoSearchTool\n\n# Initialize the tool\nyoutube_search_tool = YoutubeVideoSearchTool()\n\n# Define an agent that uses the tool\nvideo_researcher = Agent(\n    role=\"Video Researcher\",\n    goal=\"Extract and analyze information from YouTube videos\",\n    backstory=\"\"\"You are an expert video researcher who specializes in extracting \n    and analyzing information from YouTube videos. You have a keen eye for detail \n    and can quickly identify key points and insights from video content.\"\"\",\n    tools=[youtube_search_tool],\n    verbose=True,\n)\n\n# Create a task for the agent\nresearch_task = Task(\n    description=\"\"\"\n    Search for information about recent advancements in artificial intelligence \n    in the YouTube video at {youtube_video_url}. \n    \n    Focus on:\n    1. Key AI technologies mentioned\n    2. Real-world applications discussed\n    3. Future predictions made by the speaker\n    \n    Provide a comprehensive summary of these points.\n    \"\"\",\n    expected_output=\"A detailed summary of AI advancements, applications, and future predictions from the video.\",\n    agent=video_researcher,\n)\n\n# Run the task\ncrew = Crew(agents=[video_researcher], tasks=[research_task])\nresult = crew.kickoff(inputs={\"youtube_video_url\": \"https://youtube.com/watch?v=example\"})",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Implementation Details",
            "level": 2,
            "content": "The `CodeInterpreterTool` uses Docker to create a secure environment for code execution:\n```\nclass CodeInterpreterTool(BaseTool):\n    name: str = \"Code Interpreter\"\n    description: str = \"Interprets Python3 code strings with a final print statement.\"\n    args_schema: Type[BaseModel] = CodeInterpreterSchema\n    default_image_tag: str = \"code-interpreter:latest\"\n    \n    def _run(self, **kwargs) -> str:\n        code = kwargs.get(\"code\", self.code)\n        libraries_used = kwargs.get(\"libraries_used\", [])\n\n        if self.unsafe_mode:\n            return self.run_code_unsafe(code, libraries_used)\n        else:\n            return self.run_code_in_docker(code, libraries_used)\n```\nThe tool performs the following steps: Verifies that the Docker image exists or builds it if necessary Creates a Docker container with the current working directory mounted Installs any required libraries specified by the agent Executes the Python code in the container Returns the output of the code execution Cleans up by stopping and removing the container\n\nThe `MultiOnTool` is implemented as a subclass of `BaseTool` from CrewAI. It wraps the MultiOn client to provide web browsing capabilities:\n```\nclass MultiOnTool(BaseTool):\n    \"\"\"Tool to wrap MultiOn Browse Capabilities.\"\"\"\n\n    name: str = \"Multion Browse Tool\"\n    description: str = \"\"\"Multion gives the ability for LLMs to control web browsers using natural language instructions.\n            If the status is 'CONTINUE', reissue the same instruction to continue execution\n        \"\"\"\n    \n    # Implementation details...\n    \n    def _run(self, cmd: str, *args: Any, **kwargs: Any) -> str:\n        \"\"\"\n        Run the Multion client with the given command.\n        \n        Args:\n            cmd (str): The detailed and specific natural language instruction for web browsing\n            *args (Any): Additional arguments to pass to the Multion client\n            **kwargs (Any): Additional keyword arguments to pass to the Multion client\n        \"\"\"\n        # Implementation details...\n```\n\nThe `S3ReaderTool` uses the AWS SDK for Python (boto3) to interact with S3:\n```\nclass S3ReaderTool(BaseTool):\n    name: str = \"S3 Reader Tool\"\n    description: str = \"Reads a file from Amazon S3 given an S3 file path\"\n    \n    def _run(self, file_path: str) -> str:\n        try:\n            bucket_name, object_key = self._parse_s3_path(file_path)\n\n            s3 = boto3.client(\n                's3',\n                region_name=os.getenv('CREW_AWS_REGION', 'us-east-1'),\n                aws_access_key_id=os.getenv('CREW_AWS_ACCESS_KEY_ID'),\n                aws_secret_access_key=os.getenv('CREW_AWS_SEC_ACCESS_KEY')\n            )\n\n            # Read file content from S3\n            response = s3.get_object(Bucket=bucket_name, Key=object_key)\n            file_content = response['Body'].read().decode('utf-8')\n\n            return file_content\n        except ClientError as e:\n            return f\"Error reading file from S3: {str(e)}\"\n```\n\nThe `S3WriterTool` uses the AWS SDK for Python (boto3) to interact with S3:\n```\nclass S3WriterTool(BaseTool):\n    name: str = \"S3 Writer Tool\"\n    description: str = \"Writes content to a file in Amazon S3 given an S3 file path\"\n    \n    def _run(self, file_path: str, content: str) -> str:\n        try:\n            bucket_name, object_key = self._parse_s3_path(file_path)\n\n            s3 = boto3.client(\n                's3',\n                region_name=os.getenv('CREW_AWS_REGION', 'us-east-1'),\n                aws_access_key_id=os.getenv('CREW_AWS_ACCESS_KEY_ID'),\n                aws_secret_access_key=os.getenv('CREW_AWS_SEC_ACCESS_KEY')\n            )\n\n            s3.put_object(Bucket=bucket_name, Key=object_key, Body=content.encode('utf-8'))\n            return f\"Successfully wrote content to {file_path}\"\n        except ClientError as e:\n            return f\"Error writing file to S3: {str(e)}\"\n```\n\nThe `ScrapeElementFromWebsiteTool` uses the `requests` library to fetch the web page and `BeautifulSoup` to parse the HTML and extract the specified elements:\n```\nclass ScrapeElementFromWebsiteTool(BaseTool):\n    name: str = \"Read a website content\"\n    description: str = \"A tool that can be used to read a website content.\"\n    \n    # Implementation details...\n    \n    def _run(self, **kwargs: Any) -> Any:\n        website_url = kwargs.get(\"website_url\", self.website_url)\n        css_element = kwargs.get(\"css_element\", self.css_element)\n        page = requests.get(\n            website_url,\n            headers=self.headers,\n            cookies=self.cookies if self.cookies else {},\n        )\n        parsed = BeautifulSoup(page.content, \"html.parser\")\n        elements = parsed.select(css_element)\n        return \"\\n\".join([element.get_text() for element in elements])\n```\n\nThe `ScrapegraphScrapeTool` uses the Scrapegraph Python client to interact with the SmartScraper API:\n```\nclass ScrapegraphScrapeTool(BaseTool):\n    \"\"\"\n    A tool that uses Scrapegraph AI to intelligently scrape website content.\n    \"\"\"\n    \n    # Implementation details...\n    \n    def _run(self, **kwargs: Any) -> Any:\n        website_url = kwargs.get(\"website_url\", self.website_url)\n        user_prompt = (\n            kwargs.get(\"user_prompt\", self.user_prompt)\n            or \"Extract the main content of the webpage\"\n        )\n\n        if not website_url:\n            raise ValueError(\"website_url is required\")\n\n        # Validate URL format\n        self._validate_url(website_url)\n\n        try:\n            # Make the SmartScraper request\n            response = self._client.smartscraper(\n                website_url=website_url,\n                user_prompt=user_prompt,\n            )\n\n            return response\n        # Error handling...\n```\n\nThe `ScrapflyScrapeWebsiteTool` uses the Scrapfly SDK to interact with the Scrapfly API:\n```\nclass ScrapflyScrapeWebsiteTool(BaseTool):\n    name: str = \"Scrapfly web scraping API tool\"\n    description: str = (\n        \"Scrape a webpage url using Scrapfly and return its content as markdown or text\"\n    )\n    \n    # Implementation details...\n    \n    def _run(\n        self,\n        url: str,\n        scrape_format: str = \"markdown\",\n        scrape_config: Optional[Dict[str, Any]] = None,\n        ignore_scrape_failures: Optional[bool] = None,\n    ):\n        from scrapfly import ScrapeApiResponse, ScrapeConfig\n\n        scrape_config = scrape_config if scrape_config is not None else {}\n        try:\n            response: ScrapeApiResponse = self.scrapfly.scrape(\n                ScrapeConfig(url, format=scrape_format, **scrape_config)\n            )\n            return response.scrape_result[\"content\"]\n        except Exception as e:\n            if ignore_scrape_failures:\n                logger.error(f\"Error fetching data from {url}, exception: {e}\")\n                return None\n            else:\n                raise e\n```\n\nThe `SeleniumScrapingTool` uses Selenium WebDriver to automate browser interactions:\n```\nclass SeleniumScrapingTool(BaseTool):\n    name: str = \"Read a website content\"\n    description: str = \"A tool that can be used to read a website content.\"\n    args_schema: Type[BaseModel] = SeleniumScrapingToolSchema\n    \n    def _run(self, **kwargs: Any) -> Any:\n        website_url = kwargs.get(\"website_url\", self.website_url)\n        css_element = kwargs.get(\"css_element\", self.css_element)\n        return_html = kwargs.get(\"return_html\", self.return_html)\n        driver = self._create_driver(website_url, self.cookie, self.wait_time)\n\n        content = self._get_content(driver, css_element, return_html)\n        driver.close()\n\n        return \"\\n\".join(content)\n```\nThe tool performs the following steps: Creates a headless Chrome browser instance Navigates to the specified URL Waits for the specified time to allow the page to load Adds any cookies if provided Extracts content based on the CSS selector Returns the extracted content as text or HTML Closes the browser instance\n\nThe `YoutubeChannelSearchTool` is implemented as a subclass of `RagTool`, which provides the base functionality for Retrieval-Augmented Generation:\n```\nclass YoutubeChannelSearchTool(RagTool):\n    name: str = \"Search a Youtube Channels content\"\n    description: str = \"A tool that can be used to semantic search a query from a Youtube Channels content.\"\n    args_schema: Type[BaseModel] = YoutubeChannelSearchToolSchema\n\n    def __init__(self, youtube_channel_handle: Optional[str] = None, **kwargs):\n        super().__init__(**kwargs)\n        if youtube_channel_handle is not None:\n            kwargs[\"data_type\"] = DataType.YOUTUBE_CHANNEL\n            self.add(youtube_channel_handle)\n            self.description = f\"A tool that can be used to semantic search a query the {youtube_channel_handle} Youtube Channels content.\"\n            self.args_schema = FixedYoutubeChannelSearchToolSchema\n            self._generate_description()\n\n    def add(\n        self,\n        youtube_channel_handle: str,\n        **kwargs: Any,\n    ) -> None:\n        if not youtube_channel_handle.startswith(\"@\"):\n            youtube_channel_handle = f\"@{youtube_channel_handle}\"\n        super().add(youtube_channel_handle, **kwargs)\n```\n\nThe `YoutubeVideoSearchTool` is implemented as a subclass of `RagTool`, which provides the base functionality for Retrieval-Augmented Generation:\n```\nclass YoutubeVideoSearchTool(RagTool):\n    name: str = \"Search a Youtube Video content\"\n    description: str = \"A tool that can be used to semantic search a query from a Youtube Video content.\"\n    args_schema: Type[BaseModel] = YoutubeVideoSearchToolSchema\n\n    def __init__(self, youtube_video_url: Optional[str] = None, **kwargs):\n        super().__init__(**kwargs)\n        if youtube_video_url is not None:\n            kwargs[\"data_type\"] = DataType.YOUTUBE_VIDEO\n            self.add(youtube_video_url)\n            self.description = f\"A tool that can be used to semantic search a query the {youtube_video_url} Youtube Video content.\"\n            self.args_schema = FixedYoutubeVideoSearchToolSchema\n            self._generate_description()\n```",
            "metadata": {
              "section_type": "General",
              "content_type": "code_example"
            },
            "children": [],
            "code_blocks": [
              {
                "type": "code_block",
                "language": "python Code",
                "content": "class CodeInterpreterTool(BaseTool):\n    name: str = \"Code Interpreter\"\n    description: str = \"Interprets Python3 code strings with a final print statement.\"\n    args_schema: Type[BaseModel] = CodeInterpreterSchema\n    default_image_tag: str = \"code-interpreter:latest\"\n    \n    def _run(self, **kwargs) -> str:\n        code = kwargs.get(\"code\", self.code)\n        libraries_used = kwargs.get(\"libraries_used\", [])\n\n        if self.unsafe_mode:\n            return self.run_code_unsafe(code, libraries_used)\n        else:\n            return self.run_code_in_docker(code, libraries_used)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "class MultiOnTool(BaseTool):\n    \"\"\"Tool to wrap MultiOn Browse Capabilities.\"\"\"\n\n    name: str = \"Multion Browse Tool\"\n    description: str = \"\"\"Multion gives the ability for LLMs to control web browsers using natural language instructions.\n            If the status is 'CONTINUE', reissue the same instruction to continue execution\n        \"\"\"\n    \n    # Implementation details...\n    \n    def _run(self, cmd: str, *args: Any, **kwargs: Any) -> str:\n        \"\"\"\n        Run the Multion client with the given command.\n        \n        Args:\n            cmd (str): The detailed and specific natural language instruction for web browsing\n            *args (Any): Additional arguments to pass to the Multion client\n            **kwargs (Any): Additional keyword arguments to pass to the Multion client\n        \"\"\"\n        # Implementation details...",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "class S3ReaderTool(BaseTool):\n    name: str = \"S3 Reader Tool\"\n    description: str = \"Reads a file from Amazon S3 given an S3 file path\"\n    \n    def _run(self, file_path: str) -> str:\n        try:\n            bucket_name, object_key = self._parse_s3_path(file_path)\n\n            s3 = boto3.client(\n                's3',\n                region_name=os.getenv('CREW_AWS_REGION', 'us-east-1'),\n                aws_access_key_id=os.getenv('CREW_AWS_ACCESS_KEY_ID'),\n                aws_secret_access_key=os.getenv('CREW_AWS_SEC_ACCESS_KEY')\n            )\n\n            # Read file content from S3\n            response = s3.get_object(Bucket=bucket_name, Key=object_key)\n            file_content = response['Body'].read().decode('utf-8')\n\n            return file_content\n        except ClientError as e:\n            return f\"Error reading file from S3: {str(e)}\"",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "class S3WriterTool(BaseTool):\n    name: str = \"S3 Writer Tool\"\n    description: str = \"Writes content to a file in Amazon S3 given an S3 file path\"\n    \n    def _run(self, file_path: str, content: str) -> str:\n        try:\n            bucket_name, object_key = self._parse_s3_path(file_path)\n\n            s3 = boto3.client(\n                's3',\n                region_name=os.getenv('CREW_AWS_REGION', 'us-east-1'),\n                aws_access_key_id=os.getenv('CREW_AWS_ACCESS_KEY_ID'),\n                aws_secret_access_key=os.getenv('CREW_AWS_SEC_ACCESS_KEY')\n            )\n\n            s3.put_object(Bucket=bucket_name, Key=object_key, Body=content.encode('utf-8'))\n            return f\"Successfully wrote content to {file_path}\"\n        except ClientError as e:\n            return f\"Error writing file to S3: {str(e)}\"",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "class ScrapeElementFromWebsiteTool(BaseTool):\n    name: str = \"Read a website content\"\n    description: str = \"A tool that can be used to read a website content.\"\n    \n    # Implementation details...\n    \n    def _run(self, **kwargs: Any) -> Any:\n        website_url = kwargs.get(\"website_url\", self.website_url)\n        css_element = kwargs.get(\"css_element\", self.css_element)\n        page = requests.get(\n            website_url,\n            headers=self.headers,\n            cookies=self.cookies if self.cookies else {},\n        )\n        parsed = BeautifulSoup(page.content, \"html.parser\")\n        elements = parsed.select(css_element)\n        return \"\\n\".join([element.get_text() for element in elements])",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "class ScrapegraphScrapeTool(BaseTool):\n    \"\"\"\n    A tool that uses Scrapegraph AI to intelligently scrape website content.\n    \"\"\"\n    \n    # Implementation details...\n    \n    def _run(self, **kwargs: Any) -> Any:\n        website_url = kwargs.get(\"website_url\", self.website_url)\n        user_prompt = (\n            kwargs.get(\"user_prompt\", self.user_prompt)\n            or \"Extract the main content of the webpage\"\n        )\n\n        if not website_url:\n            raise ValueError(\"website_url is required\")\n\n        # Validate URL format\n        self._validate_url(website_url)\n\n        try:\n            # Make the SmartScraper request\n            response = self._client.smartscraper(\n                website_url=website_url,\n                user_prompt=user_prompt,\n            )\n\n            return response\n        # Error handling...",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "class ScrapflyScrapeWebsiteTool(BaseTool):\n    name: str = \"Scrapfly web scraping API tool\"\n    description: str = (\n        \"Scrape a webpage url using Scrapfly and return its content as markdown or text\"\n    )\n    \n    # Implementation details...\n    \n    def _run(\n        self,\n        url: str,\n        scrape_format: str = \"markdown\",\n        scrape_config: Optional[Dict[str, Any]] = None,\n        ignore_scrape_failures: Optional[bool] = None,\n    ):\n        from scrapfly import ScrapeApiResponse, ScrapeConfig\n\n        scrape_config = scrape_config if scrape_config is not None else {}\n        try:\n            response: ScrapeApiResponse = self.scrapfly.scrape(\n                ScrapeConfig(url, format=scrape_format, **scrape_config)\n            )\n            return response.scrape_result[\"content\"]\n        except Exception as e:\n            if ignore_scrape_failures:\n                logger.error(f\"Error fetching data from {url}, exception: {e}\")\n                return None\n            else:\n                raise e",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "class SeleniumScrapingTool(BaseTool):\n    name: str = \"Read a website content\"\n    description: str = \"A tool that can be used to read a website content.\"\n    args_schema: Type[BaseModel] = SeleniumScrapingToolSchema\n    \n    def _run(self, **kwargs: Any) -> Any:\n        website_url = kwargs.get(\"website_url\", self.website_url)\n        css_element = kwargs.get(\"css_element\", self.css_element)\n        return_html = kwargs.get(\"return_html\", self.return_html)\n        driver = self._create_driver(website_url, self.cookie, self.wait_time)\n\n        content = self._get_content(driver, css_element, return_html)\n        driver.close()\n\n        return \"\\n\".join(content)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "class YoutubeChannelSearchTool(RagTool):\n    name: str = \"Search a Youtube Channels content\"\n    description: str = \"A tool that can be used to semantic search a query from a Youtube Channels content.\"\n    args_schema: Type[BaseModel] = YoutubeChannelSearchToolSchema\n\n    def __init__(self, youtube_channel_handle: Optional[str] = None, **kwargs):\n        super().__init__(**kwargs)\n        if youtube_channel_handle is not None:\n            kwargs[\"data_type\"] = DataType.YOUTUBE_CHANNEL\n            self.add(youtube_channel_handle)\n            self.description = f\"A tool that can be used to semantic search a query the {youtube_channel_handle} Youtube Channels content.\"\n            self.args_schema = FixedYoutubeChannelSearchToolSchema\n            self._generate_description()\n\n    def add(\n        self,\n        youtube_channel_handle: str,\n        **kwargs: Any,\n    ) -> None:\n        if not youtube_channel_handle.startswith(\"@\"):\n            youtube_channel_handle = f\"@{youtube_channel_handle}\"\n        super().add(youtube_channel_handle, **kwargs)",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              },
              {
                "type": "code_block",
                "language": "python Code",
                "content": "class YoutubeVideoSearchTool(RagTool):\n    name: str = \"Search a Youtube Video content\"\n    description: str = \"A tool that can be used to semantic search a query from a Youtube Video content.\"\n    args_schema: Type[BaseModel] = YoutubeVideoSearchToolSchema\n\n    def __init__(self, youtube_video_url: Optional[str] = None, **kwargs):\n        super().__init__(**kwargs)\n        if youtube_video_url is not None:\n            kwargs[\"data_type\"] = DataType.YOUTUBE_VIDEO\n            self.add(youtube_video_url)\n            self.description = f\"A tool that can be used to semantic search a query the {youtube_video_url} Youtube Video content.\"\n            self.args_schema = FixedYoutubeVideoSearchToolSchema\n            self._generate_description()",
                "metadata": {
                  "section_type": "code",
                  "content_type": "code_example"
                },
                "children": []
              }
            ]
          },
          {
            "type": "header",
            "title": "Conclusion",
            "level": 2,
            "content": "The integration of advanced attributes and functionalities into the CrewAI framework significantly enriches the agent collaboration ecosystem. These enhancements not only simplify interactions but also offer unprecedented flexibility and control, paving the way for sophisticated AI-driven solutions capable of tackling complex tasks through intelligent collaboration and delegation.\n\nPlotting your flows is a powerful feature of CrewAI that enhances your ability to design and manage complex AI workflows. Whether you choose to use the `plot()` method or the command line, generating plots will provide you with a visual representation of your workflows, aiding in both development and presentation.\n\nTools are pivotal in extending the capabilities of CrewAI agents, enabling them to undertake a broad spectrum of tasks and collaborate effectively.\nWhen building solutions with CrewAI, leverage both custom and existing tools to empower your agents and enhance the AI ecosystem. Consider utilizing error handling, caching mechanisms,\nand the flexibility of tool arguments to optimize your agents' performance and capabilities.\n\nIntegrating CrewAI's memory system into your projects is straightforward. By leveraging the provided memory components and configurations,\nyou can quickly empower your agents with the ability to remember, reason, and learn from their interactions, unlocking new levels of intelligence and capability.\n\nThe structured collaboration facilitated by processes within CrewAI is crucial for enabling systematic teamwork among agents.\nThis documentation has been updated to reflect the latest features, enhancements, and the planned integration of the Consensual Process, ensuring users have access to the most current and comprehensive information.\n\nTasks are the driving force behind the actions of agents in CrewAI.\nBy properly defining tasks and their outcomes, you set the stage for your AI agents to work effectively, either independently or as a collaborative unit.\nEquipping tasks with appropriate tools, understanding the execution process, and following robust validation practices are crucial for maximizing CrewAI's potential,\nensuring agents are effectively prepared for their assignments and that tasks are executed as intended.\n\nTools are pivotal in extending the capabilities of CrewAI agents, enabling them to undertake a broad spectrum of tasks and collaborate effectively.\nWhen building solutions with CrewAI, leverage both custom and existing tools to empower your agents and enhance the AI ecosystem. Consider utilizing error handling,\ncaching mechanisms, and the flexibility of tool arguments to optimize your agents' performance and capabilities.\n\nLow-level prompt customization in CrewAI opens the door to super custom, complex use cases. By establishing well-organized prompt files (or direct inline templates), you can accommodate various models, languages, and specialized domains. This level of flexibility ensures you can craft precisely the AI behavior you need, all while knowing CrewAI still provides reliable defaults when you don\u2019t override them.\n\nCrafting effective agents is both an art and a science. By carefully defining roles, goals, and backstories that align with your specific needs, and combining them with well-designed tasks, you can create specialized AI collaborators that produce exceptional results. Remember that agent and task design is an iterative process. Start with these best practices, observe your agents in action, and refine your approach based on what you learn. And always keep in mind the 80/20 rule - focus most of your effort on creating clear, focused tasks to get the best results from your agents.\n\nChoosing between Crews and Flows\u2014or combining them\u2014is a critical architectural decision that impacts the effectiveness, maintainability, and scalability of your CrewAI application. By evaluating your use case along the dimensions of complexity and precision, you can make informed decisions that align with your specific requirements. Remember that the best approach often evolves as your application matures. Start with the simplest solution that meets your needs, and be prepared to refine your architecture as you gain experience and your requirements become clearer.\n\nMastering state management in CrewAI Flows gives you the power to build sophisticated, robust AI applications that maintain context, make complex decisions, and deliver consistent results. Whether you choose unstructured or structured state, implementing proper state management practices will help you create flows that are maintainable, extensible, and effective at solving real-world problems. As you develop more complex flows, remember that good state management is about finding the right balance between flexibility and structure, making your code both powerful and easy to understand.\n\nCustomizing agents in CrewAI by setting their roles, goals, backstories, and tools, alongside advanced options like language model customization, memory, performance settings, and delegation preferences,\nequips a nuanced and capable AI team ready for complex challenges.\n\nAdopting the hierarchical process in CrewAI, with the correct configurations and understanding of the system's capabilities, facilitates an organized and efficient approach to project management.\nUtilize the advanced features and customizations to tailor the workflow to your specific needs, ensuring optimal task execution and project success.\n\nBy leveraging LiteLLM, CrewAI offers seamless integration with a vast array of LLMs. This flexibility allows you to choose the most suitable model for your specific needs, whether you prioritize performance, cost-efficiency, or local deployment. Remember to consult the [LiteLLM documentation](https://docs.litellm.ai/docs/) for the most up-to-date information on supported models and configuration options.\n\nWith the above enhancements and detailed functionality, replaying specific tasks in CrewAI has been made more efficient and robust.\nEnsure you follow the commands and steps precisely to make the most of these features.\n\nThe `AIMindTool` provides a powerful way to query your data sources using natural language, making it easier to extract insights without writing complex SQL queries. By connecting to various data sources and leveraging AI-Minds technology, this tool enables agents to access and analyze data efficiently.\n\nBy integrating the `BraveSearchTool` into Python projects, users gain the ability to conduct real-time, relevant searches across the internet directly from their applications. The tool provides a simple interface to the powerful Brave Search API, making it easy to retrieve and process search results programmatically. By adhering to the setup and usage guidelines provided, incorporating this tool into projects is streamlined and straightforward.\n\nThe `CodeInterpreterTool` provides a powerful way for CrewAI agents to execute Python code in a relatively secure environment. By enabling agents to write and run code, it significantly expands their problem-solving capabilities, especially for tasks involving data analysis, calculations, or other computational work. This tool is particularly useful for agents that need to perform complex operations that are more efficiently expressed in code than in natural language.\n\nBy integrating the `EXASearchTool` into Python projects, users gain the ability to conduct real-time, relevant searches across the internet directly from their applications.\nBy adhering to the setup and usage guidelines provided, incorporating this tool into projects is streamlined and straightforward.\n\nBy integrating the `FileWriterTool` into your crews, the agents can reliably write content to files across different operating systems.\nThis tool is essential for tasks that require saving output data, creating structured file systems, and handling cross-platform file operations.\nIt's particularly recommended for Windows users who may encounter file writing issues with standard Python file operations. By adhering to the setup and usage guidelines provided, incorporating this tool into projects is straightforward and ensures consistent file writing behavior across all platforms.\n\nThe `HyperbrowserLoadTool` provides a powerful way to scrape and crawl websites, handling complex scenarios like anti-bot measures, CAPTCHAs, and more. By leveraging Hyperbrowser's platform, this tool enables agents to access and extract web content efficiently.\n\nThe `LinkupSearchTool` provides a seamless way to integrate Linkup's contextual information retrieval capabilities into your CrewAI agents. By leveraging this tool, agents can access relevant and up-to-date information to enhance their decision-making and task execution.\n\nThe `LlamaIndexTool` provides a powerful way to integrate LlamaIndex's capabilities into CrewAI agents. By wrapping LlamaIndex tools and query engines, it enables agents to leverage sophisticated data retrieval and processing functionalities, enhancing their ability to work with complex information sources.\n\nThe `MultiOnTool` provides a powerful way to integrate web browsing capabilities into CrewAI agents. By enabling agents to interact with websites through natural language instructions, it opens up a wide range of possibilities for web-based tasks, from data collection and research to automated interactions with web services.\n\nThe Patronus evaluation tools provide a powerful way to evaluate and score model inputs and outputs using the Patronus AI platform. By enabling agents to evaluate their own outputs or the outputs of other agents, these tools can help improve the quality and reliability of CrewAI workflows.\n\nThe `RagTool` provides a powerful way to create and query knowledge bases from various data sources. By leveraging Retrieval-Augmented Generation, it enables agents to access and retrieve relevant information efficiently, enhancing their ability to provide accurate and contextually appropriate responses.\n\nThe `S3ReaderTool` provides a straightforward way to read files from Amazon S3 buckets. By enabling agents to access content stored in S3, it facilitates workflows that require cloud-based file access. This tool is particularly useful for data processing, configuration management, and any task that involves retrieving information from AWS S3 storage.\n\nThe `S3WriterTool` provides a straightforward way to write content to files in Amazon S3 buckets. By enabling agents to create and update files in S3, it facilitates workflows that require cloud-based file storage. This tool is particularly useful for data persistence, configuration management, report generation, and any task that involves storing information in AWS S3 storage.\n\nThe `ScrapeElementFromWebsiteTool` provides a powerful way to extract specific elements from websites using CSS selectors. By enabling agents to target only the content they need, it makes web scraping tasks more efficient and focused. This tool is particularly useful for data extraction, content monitoring, and research tasks where specific information needs to be extracted from web pages.\n\nThe `ScrapegraphScrapeTool` provides a powerful way to extract content from websites using AI-powered understanding of web page structure. By enabling agents to target specific information using natural language prompts, it makes web scraping tasks more efficient and focused. This tool is particularly useful for data extraction, content monitoring, and research tasks where specific information needs to be extracted from web pages.\n\nThe `ScrapflyScrapeWebsiteTool` provides a powerful way to extract content from websites using Scrapfly's advanced web scraping capabilities. With features like headless browser support, proxies, and anti-bot bypass, it can handle complex websites and extract content in various formats. This tool is particularly useful for data extraction, content monitoring, and research tasks where reliable web scraping is required.\n\nThe `SeleniumScrapingTool` provides a powerful way to extract content from websites using browser automation. By enabling agents to interact with websites as a real user would, it facilitates scraping of dynamic content that would be difficult or impossible to extract using simpler methods. This tool is particularly useful for research, data collection, and monitoring tasks that involve modern web applications with JavaScript-rendered content.\n\nBy integrating the `SerperDevTool` into Python projects, users gain the ability to conduct real-time, relevant searches across the internet directly from their applications.\nThe updated parameters allow for more customized and localized search results. By adhering to the setup and usage guidelines provided, incorporating this tool into projects is streamlined and straightforward.\n\nThe `SnowflakeSearchTool` provides a powerful way to integrate Snowflake data warehouses with CrewAI agents. With features like connection pooling, automatic retries, and query caching, it enables efficient and reliable access to enterprise data. This tool is particularly useful for data analysis, reporting, and business intelligence tasks that require access to structured data stored in Snowflake.\n\nThe `WeaviateVectorSearchTool` provides a powerful way to search for semantically similar documents in a Weaviate vector database. By leveraging vector embeddings, it enables more accurate and contextually relevant search results compared to traditional keyword-based searches. This tool is particularly useful for applications that require finding information based on meaning rather than exact matches.\n\nThe `YoutubeChannelSearchTool` provides a powerful way to search and extract information from YouTube channel content using RAG techniques. By enabling agents to search across an entire channel's videos, it facilitates information extraction and analysis tasks that would otherwise be difficult to perform. This tool is particularly useful for research, content analysis, and knowledge extraction from YouTube channels.\n\nThe `YoutubeVideoSearchTool` provides a powerful way to search and extract information from YouTube video content using RAG techniques. By enabling agents to search within video content, it facilitates information extraction and analysis tasks that would otherwise be difficult to perform. This tool is particularly useful for research, content analysis, and knowledge extraction from video sources.",
            "metadata": {
              "section_type": "General",
              "content_type": "descriptive_text"
            },
            "children": []
          }
        ]
      }
    ]
  }
]
```
