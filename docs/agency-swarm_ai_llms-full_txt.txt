# Asynchronous Execution
Source: https://agency-swarm.ai/additional-features/asynchronous-execution

Run your agents or tools asynchronously.

Asynchronous execution allows you to run your agents or tools asynchronously in separate threads. This can be useful for shortening response times for certain I/O-bound tasks.

## Async Agents

To run each agent in a separate thread, you need to use a special `SendMessageAsyncThreading` tool class. See [Custom Communicaiton Flows](/additional-features/custom-communication-flows) for more information.

```python
from agency_swarm import SendMessageAsyncThreading
from agency_swarm import Agency

agency = Agency(agents=[ceo], send_message_tool_class=SendMessageAsyncThreading)
```

With this mode, the caller agent does not receive an immediate reply. Instead, it first gets a system notification confirming that the message has been sent to the recipient agent. Later, the calling agent can retrieve the actual response from the recipient.

## Async Tools

To run each tool in a separate thread, you need to adjust the ToolConfig class for each tool that you want to run asynchronously. See [Custom Tools Configuration](/core-framework/tools/custom-tools/configuration) for more information.

```python
from agency_swarm import BaseTool

class Tool(BaseTool):
    # ...

    class ToolConfig:
        async_mode = "threading"

    # ...
```

With this mode, the agent will still have to wait for the tool to finish before it can continue with the next step in the conversation. So, it only makes sense to use this mode with multiple tools for the same agent that are not dependent on each other.


# Azure OpenAI
Source: https://agency-swarm.ai/additional-features/azure-openai

Integrate Azure OpenAI with Agency Swarm to ensure secure data processing and enhanced privacy.

Many organizations prioritize data privacy and are cautious about sharing their data with any third-parties. By leveraging Azure OpenAI, you can ensure that your data is processed only within your own secure Azure environment, and not even shared with OpenAI itself.

<Info>
  Running OpenAI models on Azure is the same as deploying your own open source model on any other cloud provider.
</Info>

## Prerequisites

Before you begin, ensure you have the following:

1. Create an Azure Account with an active subscription. [Create an account here](https://azure.microsoft.com/en-us/free/).
2. Get approved access to the OpenAI Service on Azure.
3. Create an Azure OpenAI resource in [one of the available regions](https://learn.microsoft.com/en-us/azure/ai-services/openai/concepts/models#assistants-preview) and deploy a model to it.
4. Obtain the endpoint URL and API key for the OpenAI resource.

## Setting Up Azure OpenAI with Agency Swarm

<Steps>
  <Step title="Configure the Azure OpenAI Client">
    To use Azure OpenAI, you need to replace the default OpenAI client with the configured `AzureOpenAI` client:

    ```python
    from openai import AzureOpenAI
    from agency_swarm import set_openai_client
    import os

    client = AzureOpenAI(
        api_key=os.getenv("AZURE_OPENAI_KEY"),
        api_version="2024-02-15-preview",
        azure_endpoint=os.getenv("AZURE_ENDPOINT"),
        timeout=5,
        max_retries=5,
    )

    set_openai_client(client)
    ```
  </Step>

  <Step title="Update Agent Model Parameters">
    Replace the `model` parameter inside each agent with your model deployment name from Azure.t:

    ```python
    from agency_swarm import Agent

    ceo = Agent(
        name="ceo",
        description="I am the CEO",
        model="azure-model-deployment-name"
    )
    ```

    <Note>
      Model deployment name might be different from the stadard OpenAI model names. It is set by you when you deploy a model to Azure.
    </Note>
  </Step>

  <Step title="Run Your Agency">
    After configuring the client and updating the agents, you can run your agency as usual:

    ```python
    from agency_swarm import Agency

    agency = Agency([ceo])
    agency.run_demo()
    ```
  </Step>
</Steps>

## Example Notebook

For an example of using Azure OpenAI with Agency Swarm, refer to the [Azure OpenAI Notebook](https://github.com/VRSEN/agency-swarm/blob/main/notebooks/azure.ipynb) in the notebooks folder.


# Common Use Cases
Source: https://agency-swarm.ai/additional-features/custom-communication-flows/common-use-cases

Explore common use cases for custom communication flows in Agency Swarm.

In the following sections, we'll look at some common use cases for extending the `SendMessageBase` tool and how to implement them, so you can learn how to create your own SendMessage tools and use them in your own applications.

#### 1. Adjusting parameters and descriptions

The most basic use case is if you want to use your own parameter descriptions, such as if you want to change the docstring or the description of the `message` parameter. This can help you better customize how the agents communicate with each other and what information they relay.

Let's say that instead of sending messages, I want my agents to send tasks to each other. In this case, I can change the docstring and the `message` parameter to a `task` parameter to better fit the nature of my application.

```python
from pydantic import Field
from agency_swarm.tools.send_message import SendMessageBase

class SendMessageTask(SendMessageBase):
    """Use this tool to send tasks to other agents within your agency."""
    chain_of_thought: str = Field(
        ...,
        description="Please think step-by-step about how to solve your current task, provided by the user. Then, break down this task into smaller steps and issue each step individually to the recipient agent via the task parameter."
    )
    task: str = Field(
        ...,
        description="Specify the task required for the recipient agent to complete. Focus on clarifying what the task entails, rather than providing exact instructions. Make sure to include all the relevant information needed to complete the task."
    )

    def run(self):
        return self._get_completion(message=self.task)
```

To remove the chain of thought, you can simply remove the `chain_of_thought` parameter.

#### 2. Adding custom validation logic

Now, let's say that I need to ensure that my message is sent to the correct recipient agent. (This is a very common hallucination in production.) In this case, I can add a custom validator to the `recipient` parameter, which is defined in the `SendMessageBase` class. Since I don't want to change any other parameters or descriptions, I can inherit the default `SendMessage` class and only add this new validation logic.

```python
from agency_swarm.tools.send_message import SendMessage
from pydantic import model_validator

class SendMessageValidation(SendMessage):
    @model_validator(mode='after')
    def validate_recipient(self):
        if "customer support" not in self.message.lower() and self.recipient == "CustomerSupportAgent":
            raise ValueError("Messages not related to customer support cannot be sent to the customer support agent.")
        return self
```

You can, of course, also use GPT for this:

```python
from agency_swarm.tools.send_message import SendMessage
from agency_swarm.util.validators import llm_validator
from pydantic import model_validator

class SendMessageLLMValidation(SendMessage):
    @model_validator(mode='after')
    def validate_recipient(self):
        if self.recipient == "CustomerSupportAgent":
            llm_validator(
                statement="The message is related to customer support."
            )(self.message)
        return self
```

In this example, the `llm_validator` will throw an error if the message is not related to customer support. The caller agent will then have to fix the recipient or the message and send it again! This is extremely useful when you have a lot of agents.

#### 3. Summarizing previous conversations with other agents and adding to context

Sometimes, when using default `SendMessage`, the agents might not relay all the necessary details to the recipient agent, especially when the previous conversation is too long. In this case, you can summarize the previous conversation with GPT and add it to the context, instead of the additional instructions. I will extend the `SendMessageQuick` class, which already contains the `message` parameter, as I don't need chain of thought or files in this case.

```python
from agency_swarm.tools.send_message import SendMessageQuick
from agency_swarm.util.oai import get_openai_client

class SendMessageSummary(SendMessageQuick):
    def run(self):
        client = get_openai_client()
        thread = self._get_main_thread() # get the main thread (conversation with the user)

        # get the previous messages
        previous_messages = thread.get_messages()
        previous_messages_str = "\n".join([f"{m.role}: {m.content[0].text.value}" for m in previous_messages])

        # summarize the previous conversation
        summary = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[
                {"role": "system", "content": "You are a world-class summarizer. Please summarize the following conversation in a few sentences:"},
                {"role": "user", "content": previous_messages_str}
            ]
        )

        # send the message with the summary
        return self._get_completion(message=self.message, additional_instructions=f"\n\nPrevious conversation summary: '{summary.choices[0].message.content}'")
```

With this example, you can add your own custom logic to the `run` method. It does not have to be a summary; you can also use it to add any other information to the context. For example, you can even query a vector database or use an external API.

#### 4. Running each agent in a separate API call

If you are a PRO, and you have managed to deploy each agent in a separate API endpoint, instead of using `_get_completion()`, you can call your own API and let the agents communicate with each other over the internet.

```python
import requests
from agency_swarm.tools.send_message import SendMessage

class SendMessageAPI(SendMessage):
    def run(self):
        response = requests.post(
            "https://your-api-endpoint.com/send-message",
            json={"message": self.message, "recipient": self.recipient}
        )
        return response.json()["message"]
```

This is very powerful, as you can even allow your agents to collaborate with agents outside your system. More on this is coming soon!

<Tip title="Contributing">
  If you have any ideas for new communication flows, please either adjust this page in docs, or add your new send
  message tool in the `agency_swarm/tools/send_message` folder and open a PR!
</Tip>

**After implementing your own `SendMessage` tool**, simply pass it into the `send_message_tool_class` parameter when initializing the `Agency` class:

```python
agency = Agency(
    ...
    send_message_tool_class=SendMessageAPI
)
```

That's it! Now, your agents will use your own custom `SendMessageAPI` class for communication!


# Overview
Source: https://agency-swarm.ai/additional-features/custom-communication-flows/overview

Learn how to customize communication flows for your agency.

Multi-agent communication is the core functionality of any Multi-Agent System. Unlike in all other frameworks, Agency Swarm not only allows you to define communication flows in any way you want (uniform communication flows), but also to configure the underlying logic for this feature. This means that you can create entirely new types of communication or adjust it to your own needs. Below you will find a guide on how to do all this, along with some common examples.

## Pre-Made SendMessage Classes

Agency Swarm contains multiple commonly requested classes for communication flows. Currently, the following classes are available:

| Class Name                  | Description                                                                                                                                                                                                                               | When to Use                                                                                                    | Code Link                                                                                                            |
| --------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------- |
| `SendMessage` (default)     | This is the default class for sending messages to other agents. It uses synchronous communication with basic COT (Chain of Thought) prompting and allows agents to relay files and modify system instructions for each other.             | Suitable for most use cases. Balances speed and functionality.                                                 | [link](https://github.com/VRSEN/agency-swarm/blob/main/agency_swarm/tools/send_message/SendMessage.py)               |
| `SendMessageQuick`          | A variant of the SendMessage class without Chain of Thought prompting, files, and additional instructions. It allows for faster communication without the overhead of COT.                                                                | Use for simpler use cases or when you want to save tokens and increase speed.                                  | [link](https://github.com/VRSEN/agency-swarm/blob/main/agency_swarm/tools/send_message/SendMessageQuick.py)          |
| `SendMessageAsyncThreading` | Similar to `SendMessage` but with `async_mode='threading'`. Each agent will execute asynchronously in a separate thread. In the meantime, the caller agent can continue the conversation with the user and check the results later.       | Use for asynchronous applications or when sub-agents take significant amounts of time to complete their tasks. | [link](https://github.com/VRSEN/agency-swarm/blob/main/agency_swarm/tools/send_message/SendMessageAsyncThreading.py) |
| `SendMessageSwarm`          | Instead of sending a message to another agent, it replaces the caller agent with the recipient agent, similar to [OpenAI's Swarm](https://github.com/openai/swarm). The recipient agent will then have access to the entire conversation. | When you need more granular control. It is not able to handle complex multi-step, multi-agent tasks.           | [link](https://github.com/VRSEN/agency-swarm/blob/main/agency_swarm/tools/send_message/SendMessageSwarm.py)          |

**To use any of the pre-made `SendMessage` classes**, simply put it in the `send_message_tool_class` parameter when initializing the `Agency` class:

```python
from agency_swarm.tools.send_message import SendMessageQuick

agency = Agency(
    ...
    send_message_tool_class=SendMessageQuick
)
```

That's it! Now, your agents will use your own custom `SendMessageQuick` class for communication.

## Creating Your Own Unique Communication Flows

To create your own communication flow, you will first need to extend the `SendMessageBase` class. This class extends the `BaseTool` class, like any other tools in Agency Swarm, and contains the most basic parameters required for communication, such as the `recipient_agent`.

### Default `SendMessage` Class

By default, Agency Swarm uses the following tool for communication:

```python
from pydantic import Field, field_validator, model_validator
from .SendMessageBase import SendMessageBase

class SendMessage(SendMessageBase):
    """Use this tool to facilitate direct, synchronous communication between specialized agents within your agency. When you send a message using this tool, you receive a response exclusively from the designated recipient agent. To continue the dialogue, invoke this tool again with the desired recipient agent and your follow-up message. Remember, communication here is synchronous; the recipient agent won't perform any tasks post-response. You are responsible for relaying the recipient agent's responses back to the user, as the user does not have direct access to these replies. Keep engaging with the tool for continuous interaction until the task is fully resolved. Do not send more than 1 message to the same recipient agent at the same time."""
    my_primary_instructions: str = Field(
        ...,
        description=(
            "Please repeat your primary instructions step-by-step, including both completed "
            "and the following next steps that you need to perform. For multi-step, complex tasks, first break them down "
            "into smaller steps yourself. Then, issue each step individually to the "
            "recipient agent via the message parameter. Each identified step should be "
            "sent in a separate message. Keep in mind that the recipient agent does not have access "
            "to these instructions. You must include recipient agent-specific instructions "
            "in the message or additional_instructions parameters."
        )
    )
    message: str = Field(
        ...,
        description="Specify the task required for the recipient agent to complete. Focus on clarifying what the task entails, rather than providing exact instructions. Make sure to include all the relevant information needed to complete the task."
    )
    message_files: list[str] | None = Field(
        default=None,
        description="A list of file IDs to be sent as attachments to this message. Only use this if you have the file ID that starts with 'file-'.",
        examples=["file-1234", "file-5678"]
    )
    additional_instructions: Optional[str] = Field(
        default=None,
        description="Additional context or instructions from the conversation needed by the recipient agent to complete the task."
    )

    @model_validator(mode='after')
    def validate_files(self):
        # prevent hallucinations with agents sending file IDs into incorrect fields
        if "file-" in self.message or (self.additional_instructions and "file-" in self.additional_instructions):
            if not self.message_files:
                raise ValueError("You must include file IDs in message_files parameter.")
        return self


    def run(self):
        return self._get_completion(message=self.message,
                                    message_files=self.message_files,
                                    additional_instructions=self.additional_instructions)
```

Let's break down the code.

In general, all `SendMessage` tools have the following components:

1. **The Docstring**: This is used to generate a description of the tool for the agent. This part should clearly describe how your multi-agent communication works, along with some additional guidelines on how to use it.
2. **Parameters**: Parameters like `message`, `message_files`, `additional_instructions` are used to provide the recipient agent with the necessary information.
3. **The `run` method**: This is where the communication logic is implemented. Most of the time, you just need to map your parameters to `self._get_completion()` the same way you would call it in the `agency.get_completion()` method.

When creating your own `SendMessage` tools, you can use the above components as a template.

### Common Use Cases

For detailed **Common Use Cases**, please refer to the [Common Use Cases](./common-use-cases) subpage.

## Conclusion

Agency Swarm has been designed to give you, the developer, full control over your systems. It is the only framework that does not hard-code any prompts, parameters, or even worse, agents for you. With this new feature, the last part of the system that you couldn't fully customize to your own needs is now gone!

So, we want to encourage you to keep experimenting and designing your own unique communication flows. While the examples above should serve as a good starting point, they do not even merely scratch the surface of what's possible here! We are looking forward to seeing what you will create. Please share it in our [Discord server](https://discord.gg/7HcABDpFPG) so we can all learn from each other.


# Deployment to Production
Source: https://agency-swarm.ai/additional-features/deployment-to-production

Step-by-step guide for deploying your agency in a production environment.

To deploy your agency to production, typically the process is as follows:

1. **Dynamically Load Conversation Threads**: Required to continue conversations from where they left off
2. **Dynamically Load Assistant Settings**: Needed to make changes to your agent's settings persist even after redeployment
3. **Deploy Agents and Tools on a Production Server**: Decide whether to deploy agents and tools together or separately

<Note>
  This guide assumes that you have already created an agency. If you haven't, check out the [Getting Started](/welcome/installation) guide.
</Note>

<Warning>
  Before deploying your agency, ensure you have thoroughly tested all tools and agents in isolation and in combination. Run the test cases in each tool file and verify the agency works end-to-end using the `run_demo()` or `demo_gradio` methods.
</Warning>

<Steps>
  <Step title="Step 1: Dynamically Load Conversation Threads" icon="message-dots">
    By default, every time you create a new `Agency()`, it starts a fresh conversation thread. However, in production environments, you typically need to pick up old conversations or handle multiple users at once.

    <Info>
      In Agency Swarm, threads are stored in a dictionary that contains all conversation thread IDs, including those between your agents.
    </Info>

    Loading threads from a database before processing a new request allows you to continue conversations from where they left off, even if you are using stateless backend.

    <Info>
      Callbacks are functions that are called by the framework automatically when Agency is initialized.
    </Info>

    Example threads callbacks:

    ```python
    def load_threads(chat_id):
        # Load threads from your database using the chat_id
        threads = load_threads_from_db(chat_id)
        return threads

    def save_threads(new_threads):
        # Save updated threads to your database
        save_threads_to_db(new_threads)

    agency = Agency(
        ...
        threads_callbacks={
            'load': lambda: load_threads(chat_id),
            'save': lambda new_threads: save_threads(new_threads)
        },
    )
    ```
  </Step>

  <Step title="Step 2: Dynamically Load Assistant Settings" icon="gear">
    By default, agencies store assistant settings (such as name, description, instructions, tools, and model) in a local file defined in the `settings_path` parameter (`settings.json` by default). While this works well for development, in production environments, we recommend storing these settings in a database to persist changes between deployments.

    <Info>
      Settings is a list of dictionaries that contains settings of all agents. If a change is detected in the settings, the framework will automatically save the new settings to a local file and trigger the `save` callback.
    </Info>

    `settings_callbacks` are executed every time agent settings are loaded or saved. Just like `threads_callbacks`, you can use it to load or save agent configurations based on your identifier (e.g. user\_id):

    ```python
    def load_settings(user_id):
        # Load settings from your database using the user_id
        settings = load_settings_from_db(user_id)
        return settings

    def save_settings(new_settings):
        # Save updated settings to your database
        save_settings_to_db(new_settings)

    agency = Agency(
        ...
        settings_callbacks={
            'load': lambda: load_settings(user_id),
            'save': lambda new_settings: save_settings(new_settings)
        },
    )
    ```

    <Note>
      Make sure you load and return settings and threads in the exact same format as they are saved.
    </Note>
  </Step>

  <Step title="Step 3: Deploying Agents and Tools on a Production Server" icon="rocket-launch">
    Depending on your needs, you can deploy your agents and tools together or separately:

    1. **Agents Together with Tools**: This is the simplest method: your agents execute the tools directly, in the same environment.
    2. **Tools as Separate API Endpoints**: This is the most scalable method: multiple agents can reuse the same tools, and you can scale the tools independently.

    <Accordion title="Comparison Table" defaultOpen={true}>
      | Feature              | Agents with Tools               | Tools as Separate API Endpoints           |
      | -------------------- | ------------------------------- | ----------------------------------------- |
      | **Setup Complexity** | "One-click" deployment          | Additional setup required                 |
      | **Scalability**      | Combined agency scaling         | Independent tool/agent scaling            |
      | **Tool Reusability** | Limited to current agency       | Cross-project utilization                 |
      | **Cost Efficiency**  | Predictable resource allocation | Optimized resource scaling                |
      | **Security**         | Internal tool access only       | API authentication required               |
      | **Best For**         | Small to medium projects        | Large-scale or multi-project environments |
    </Accordion>

    <Tabs>
      <Tab title="Option 1: Agents and Tools Together" defaultOpen={true}>
        This is the simplest deployment method. You can use the official Railway template to get your agency up and running quickly.

        Watch the video below for a detailed walkthrough:

        <iframe width="560" height="315" src="https://www.youtube.com/embed/53_e3lmk6Mo?si=kASCTtxfa6ljqGNy&start=806" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen />

        <Card title="Railway Deployment Template" href="https://github.com/VRSEN/agency-swarm-api-railway-template" icon="train" iconType="duotone">
          Click here to open the template and follow the instructions provided.
        </Card>

        <Note>
          The template includes a Gradio interface and REST API endpoints with proper authentication.
        </Note>
      </Tab>

      <Tab title="Option 2: Tools as Separate API Endpoints">
        Instead of deploying agents and tools together, you can host your tools separately as serverless functions or custom APIs, then connect them to your agents using [OpenAPI schemas](/core-framework/tools/openapi-schemas). This approach is useful if you want to reuse tools across different projects or scale them independently. You can also use OpenAPI schemas to connect third-party tools to your agency.

        You can use our Firebase template:

        <Card title="Firebase Deployment Template" href="https://github.com/vrsen-ai-solutions/agency-swarm-tools-template" icon="fire" iconType="duotone">
          Click here to open the template and follow the instructions provided.
        </Card>

        <Note>
          When deploying tools separately, shared state between calls will not be preserved.
        </Note>
      </Tab>
    </Tabs>
  </Step>
</Steps>


# Few-Shot Examples
Source: https://agency-swarm.ai/additional-features/few-shot-examples

Guide agent responses using few-shot prompting.

**Few-shot prompting** is a powerful technique where you provide a small number of sample interactions (typically 2 to 5) to guide your agent's behavior. This method helps the agent understand the desired output format and task requirements by learning from the given examples, thereby improving performance without writing extensive instructions.

## Crafting Effective Examples

* **Provide Task Demonstrations**: Use examples that clearly illustrate the tasks that your agents will perform.
* **Use Realistic Scenarios**: Include interactions that mirror actual conversations that your agent will handle.
* **Use Preferred Tone and Style**: Ensure the agent's replies in your examples match your desired brand voice.

## Defining Few-Shot Examples

In the **Agency Swarm** framework, few-shot examples are structured using the [OpenAI message object format](https://platform.openai.com/docs/api-reference/messages/createMessage), including the `role` and `content` fields.

**Example**: Technical Support Agent:

```python
examples = [
    {
        "role": "user",
        "content": "My device won't turn on.",
    },
    {
        "role": "assistant",
        "content": "I'm sorry to hear that. Let's try some troubleshooting steps. First, please press and hold the power button for at least 10 seconds.",
    },
    {
        "role": "user",
        "content": "I tried that, but it still won't turn on.",
    },
    {
        "role": "assistant",
        "content": "Thank you for trying that. Please connect your device to a charger and check if any lights appear. Let me know what you observe.",
    }
]
```

The optional fields `attachments` and `metadata` can be included if needed but are not required for basic examples.

## Using Few-Shot Examples

You can add few-shot examples to your agent either during initialization or afterward:

<Tabs>
  <Tab title="During Initialization">
    ```python
    from agency_swarm import Agent

    agent = Agent(
        name="CustomerSupportAgent",
        description="Assists customers with inquiries and provides detailed information.",
        examples=examples
    )
    ```
  </Tab>

  <Tab title="After Initialization">
    ```python
    agent = Agent(name="CustomerSupportAgent")
    agent.examples = examples
    ```
  </Tab>
</Tabs>

See more advanced features in [Agent Class](/core-framework/agents/advanced-configuration)


# Observability
Source: https://agency-swarm.ai/additional-features/observability

Track and analyze your agent performance and behavior by connecting with third party observability tools.

Agency Swarm uses Langchain callbacks to connect with third party observability tools.

<Info>
  Although we strongly discourage using Langchain for agent development due to its numerous unnecessary abstractions, it currently has the widest support among third-party observability tools. For this reason, we have adopted its callback structure. However, no Langchain code is used within Agency Swarm.
</Info>

<Accordion title="Prerequisites" defaultOpen={true}>
  To get started with observability features, install the Langchain package:

  ```bash
  pip install langchain
  ```
</Accordion>

## Supported Observability Platforms

When it comes to choosing your observability platform, there are a few options. You can use one or multiple trackers simultaneously for comprehensive monitoring:

<CardGroup cols={2}>
  <Card title="Langfuse" icon="chart-line" href="#getting-started">
    Advanced tracing, metrics, and debugging tools
  </Card>

  <Card title="AgentOps" icon="gauge-high" href="#getting-started">
    Platform for managing and tracking your agents
  </Card>

  <Card title="Local Tracking" icon="database" href="#getting-started">
    Lightweight SQLite-based local tracking solution
  </Card>

  <Card title="Implementation" icon="code" href="#how-it-works">
    Technical details about tracking implementation
  </Card>
</CardGroup>

## Getting Started

We currently recommend [**Langfuse**](https://langfuse.com/) because it is fully open source, easy to use, and offers the most comprehensive set of features and support. You can also combine it with other trackers for enhanced observability.

![Langfuse dashboard](https://mintlify.s3.us-west-1.amazonaws.com/vrsenai/images/observability-langfuse.png)

<Tabs>
  <Tab title="Langfuse">
    <Steps>
      <Step title="Install Package">
        ```bash
        pip install langfuse==2.59.7
        ```
      </Step>

      <Step title="Set Environment Variables">
        ```bash
        export LANGFUSE_SECRET_KEY=<your-secret-key>
        export LANGFUSE_PUBLIC_KEY=<your-public-key>
        ```

        <Tooltip tip="You can find these keys on the Langfuse dashboard">Keys are available on the Langfuse dashboard</Tooltip>
      </Step>

      <Step title="Initialize Tracking">
        ```python
        from agency_swarm import init_tracking

        # Initialize single tracker
        init_tracking("langfuse")

        # Or initialize multiple trackers
        init_tracking("langfuse")
        init_tracking("local")  # Add local tracking alongside Langfuse
        ```

        <Accordion title="Configuration (Optional)">
          You can pass additional configuration options:

          ```python
          # Using environment variables with additional options
          init_tracking("langfuse", debug=True, host="custom-host", user_id="user-123")

          # Direct API key passing (useful for multi-user applications)
          init_tracking("langfuse", public_key="your-public-key", secret_key="your-secret-key")
          ```
        </Accordion>

        For more information, see the [Langfuse Documentation](https://langfuse.com/docs/integrations/langchain/tracing#add-langfuse-to-your-langchain-application).
      </Step>
    </Steps>
  </Tab>

  <Tab title="AgentOps (Limited Support)">
    <Steps>
      <Step title="Install Dependencies">
        ```bash
        pip install agentops==0.3.26
        ```
      </Step>

      <Step title="Set API Key">
        Either add to your `.env` file:

        ```bash
        AGENTOPS_API_KEY=<YOUR API KEY>
        ```

        Or pass directly when initializing (for multi-user applications):

        ```python
        init_tracking("agentops", api_key="your-agentops-api-key")
        ```

        <Note>AgentOps integration has limited support - not all messages are shown in the chat view.</Note>
      </Step>

      <Step title="Run and Monitor">
        1. Run your agent
        2. Visit [app.agentops.ai/drilldown](https://app.agentops.ai/drilldown) to observe your agent
        3. After the run, AgentOps prints a clickable URL in the console that takes you directly to your session
      </Step>
    </Steps>
  </Tab>

  <Tab title="Local Tracking">
    Local SQLite implementation:

    <Steps>
      <Step title="Install Dependencies">
        ```bash
        pip install tiktoken
        ```
      </Step>

      <Step title="Initialize Tracking">
        ```python
        from agency_swarm import init_tracking
        init_tracking("local")
        ```

        A SQLite database will be created in the current directory.
      </Step>

      <Step title="Custom Database Path (Optional)">
        ```python
        init_tracking("local", db_path="path/to/your/database.db")
        ```
      </Step>
    </Steps>
  </Tab>
</Tabs>

## How It Works

Agency Swarm uses a simple but powerful tracking system that captures every interaction in your agent's lifecycle:

1. **Event Tracking**: Every message, tool call, and error is automatically tracked with unique IDs and timestamps.
2. **Hierarchical Structure**: Events are organized in a tree structure, showing how different parts of your agent interact.
3. **Multiple Platforms**: You can send this data to different platforms (Langfuse, AgentOps, or local SQLite) for analysis.

The tracking system is built on top of Langchain's callback interface, which means it can work with any observability tool that supports Langchain. This gives you flexibility while keeping the implementation simple.

### What Gets Tracked

The system automatically captures:

* **Messages**: Every conversation between users and agents
* **Tool Calls**: When agents use tools and their results
* **Errors**: Any issues that occur during execution
* **Performance**: Token usage, timing, and other metrics
* **Relationships**: How different parts of your agent interact

This data helps you understand your agent's behavior, debug issues, and optimize performance.

<Accordion title="Event Hierarchy" defaultOpen="true">
  ```
  Agency Chain
  ├── Messages
  │   ├── User messages
  │   ├── Assistant messages
  │   ├── Function calls
  │   └── Function outputs
  └── Errors
      ├── Chain errors (in agency.py)
      │   └── Generator errors
      └── Tool errors (in thread.py)
          ├── Validation errors
          ├── Execution errors
          └── Tool-specific errors
  ```
</Accordion>

<Accordion title="Key Components">
  <ResponseField name="TrackingManager" type="class">
    Central tracking coordinator
  </ResponseField>

  <ResponseField name="Langchain callbacks" type="interface">
    Standardized event tracking interface
  </ResponseField>

  <ResponseField name="LocalCallbackHandler" type="class">
    SQLite-based callback handler that logs events sequentially in a local database, using tiktoken for token counting
  </ResponseField>
</Accordion>

<Accordion title="Event Types">
  <Expandable title="Chain Events" defaultOpen="true">
    <ResponseField name="Agency runs" type="event">Start/end of agency runs</ResponseField>
    <ResponseField name="Relationships" type="metadata">Parent-child relationships</ResponseField>
    <ResponseField name="Errors" type="event">Error tracking</ResponseField>
  </Expandable>

  <Expandable title="Message Events">
    <ResponseField name="User/assistant messages" type="event">Communication between user and assistant</ResponseField>
    <ResponseField name="Tool calls" type="event">Function calls and outputs</ResponseField>
    <ResponseField name="Metadata" type="metadata">Run IDs and related information</ResponseField>
  </Expandable>

  <Expandable title="Tool Events">
    <ResponseField name="Execution" type="event">Tool execution start/end</ResponseField>
    <ResponseField name="Errors" type="event">Tool errors and validation</ResponseField>
    <ResponseField name="File operations" type="event">File search and retrieval</ResponseField>
  </Expandable>
</Accordion>

<Accordion title="Metadata Tracked">
  <ResponseField name="Run IDs" type="string">
    Unique identifiers for each run
  </ResponseField>

  <ResponseField name="Relationships" type="object">
    Parent-child relationships between runs
  </ResponseField>

  <ResponseField name="Agent info" type="object">
    Agent names and roles
  </ResponseField>

  <ResponseField name="Model info" type="object">
    Information about the models used
  </ResponseField>

  <ResponseField name="Timestamps" type="datetime">
    When events occurred
  </ResponseField>

  <ResponseField name="Token usage" type="object">
    Information about token consumption
  </ResponseField>

  <ResponseField name="Error details" type="object">
    Detailed error information when failures occur
  </ResponseField>
</Accordion>


# Open-Source Models
Source: https://agency-swarm.ai/additional-features/open-source-models

Utilize open-source models with Agency Swarm.

While OpenAI is generally recommended, there are situations where you might prefer open-source models. The following projects offer alternatives by mimicking the Assistants API:

## Supported Projects

<CardGroup>
  <Card title="Astra Assistants API" icon="rocket" iconType="solid" href="https://github.com/datastax/astra-assistants-api">
    The best and the easiest option for running Open Source models. Supports Assistants API V2. See example
    [notebook](https://github.com/VRSEN/agency-swarm/blob/main/notebooks/os_models_with_astra_assistants_api.ipynb) and [official examples](https://github.com/datastax/astra-assistants-api/tree/main/examples/python/agency-swarm).
  </Card>

  <Card title="Open Assistant API" icon="users" iconType="solid" href="https://github.com/MLT-OSS/open-assistant-api">
    Fully local, stable, and tested, but only supports Assistants V1. See example
    [here](https://github.com/VRSEN/agency-swarm-lab/tree/main/OpenSourceSwarm).
  </Card>

  <Card title="OpenOpenAI" icon="code" iconType="solid" href="https://github.com/transitive-bullshit/OpenOpenAI">
    Unverified.
  </Card>

  <Card title="LiteLLM" icon="code" iconType="solid" href="https://github.com/BerriAI/litellm/issues/2842">
    Assistants API Proxy in development.
  </Card>
</CardGroup>

## Astra Assistants API

<Steps>
  <Step title="1. Create an account on Astra Assistants API and obtain an API key." icon="user">
    Open the [Astra Assistants API](https://astra.datastax.com/signup) and create an account. Once you have an account,
    you can obtain an API key by clicking on the "Generate Token" button. ![Astra Assistants API
    Example](https://firebasestorage.googleapis.com/v0/b/vrsen-ai/o/public%2Fgithub%2FScreenshot%202024-07-01%20at%208.19.00%E2%80%AFAM.png?alt=media\&token=b4f1a7ad-3b77-40fa-a5da-866a4f1410bd)
  </Step>

  <Step title="2. Add Astra DB Token to your .env file:" icon="file">
    Copy the token from the file that starts with "AstraCS:" and paste it into your `.env` file.

    ```env
    ASTRA_DB_APPLICATION_TOKEN=AstraCS:dsfkgn...
    ```
  </Step>

  <Step title="3. Add other model provider API keys to .env as well:" icon="key">
    ```env
    PERPLEXITYAI_API_KEY=your_perplexityai_api_key
    ANTHROPIC_API_KEY=your_anthropic_api_key
    TOGETHER_API_KEY=your_together_api_key
    GROQ_API_KEY=your_groq_api_key
    ```
  </Step>

  <Step title="4. Install the Astra Assistants API and Gradio:" icon="download">
    ```bash
    pip install astra-assistants-api gradio
    ```
  </Step>

  <Step title="5. Patch the OpenAI client:" icon="code">
    ```python
    from openai import OpenAI
    from astra_assistants import patch
    from agency_swarm import set_openai_client
    from dotenv import load_dotenv

    load_dotenv()

    client = patch(OpenAI())

    set_openai_client(client)
    ```
  </Step>

  <Step title="6. Create an agent:" icon="user-plus">
    Create an agent and replace the `model` parameter with the name of the model you want to use. With Astra Assistants, you can upload files as usual using `files_folder`.

    ```python
    from agency_swarm import Agent

    ceo = Agent(
        name="ceo",
        description="I am the CEO",
        model='ollama/llama3',
        # model = 'perplexity/llama-3-8b-instruct'
        # model = 'anthropic/claude-3-5-sonnet-20240620'
        # model = 'groq/mixtral-8x7b-32768'
        # model="gpt-4o",
        files_folder="path/to/your/files"
    )
    ```
  </Step>

  <Step title="7. Create an agency:" icon="people-arrows">
    You can add more agents as needed, just ensure all manager agents support function calling.

    ```python
    from agency_swarm import Agency

    agency = Agency([ceo])
    ```
  </Step>

  <Step title="8. Start Gradio:" icon="play">
    To utilize your agency in Gradio, apply a specific non-streaming `demo_gradio` method from the [agency-swarm-lab](https://github.com/VRSEN/agency-swarm-lab/blob/main/OpenSourceSwarm/demo_gradio.py) repository:

    ```python
    from agency_swarm import Agency
    from .demo_gradio import demo_gradio

    agency = Agency([ceo])

    demo_gradio(agency)
    ```
  </Step>
</Steps>

**For complete examples, see the [implementation notebook](https://github.com/VRSEN/agency-swarm/blob/main/notebooks/os_models_with_astra_assistants_api.ipynb) and [official Astra Assistants examples](https://github.com/datastax/astra-assistants-api/tree/main/examples/python/agency-swarm).**

## General Instructions

To use agency-swarm with any other projects that mimic the Assistants API, generally, you need to follow these steps:

<Steps>
  <Step title="Install the previous version of agency-swarm as most projects are not yet compatible with streaming and Assistants V2:">
    ```bash
    pip install agency-swarm==0.1.7
    ```
  </Step>

  <Step title="Switch out the OpenAI client:">
    ```python
    import openai
    from agency_swarm import set_openai_client

    client = openai.OpenAI(api_key="your-api-key", base_url="http://127.0.0.1:8000/")

    set_openai_client(client)
    ```
  </Step>

  <Step title="Set the model parameter:">
    ```python
    from agency_swarm import Agent

    ceo = Agent(
        name="ceo",
        description="I am the CEO",
        model='ollama/llama3'
    )
    ```
  </Step>

  <Step title="Start Gradio:">
    To utilize your agency in Gradio, apply a specific non-streaming `demo_gradio` method from the [agency-swarm-lab](https://github.com/VRSEN/agency-swarm-lab/blob/main/OpenSourceSwarm/demo_gradio.py) repository:

    ```python
    from agency_swarm import Agency
    from .demo_gradio import demo_gradio

    agency = Agency([ceo])

    demo_gradio(agency)
    ```
  </Step>

  <Step title="For backend integrations, simply use:">
    ```python
    agency.get_completion("I am the CEO")
    ```
  </Step>
</Steps>

## Limitations

<Warning>
  Be aware of the limitations when using open-source models.
</Warning>

* **Function calling is not supported by most open-source models**: This limitation prevents the agent from communicating with other agents in the agency. Therefore, it must be positioned at the end of the agency chart and cannot utilize any tools.
* **RAG is typically limited**: Most open-source assistants API implementations have restricted Retrieval-Augmented Generation capabilities. It is recommended to develop a custom tool with your own vector database.
* **Code Interpreter is not supported**: The Code Interpreter feature is still under development for all open-source assistants API implementations.

## Future Plans

Updates will be provided as new open-source assistant API implementations stabilize.

If you successfully integrate other projects with agency-swarm, please share your experience through an issue or pull request.


# Output Validation
Source: https://agency-swarm.ai/additional-features/output-validation

Implementing validators for agents and tools.

Validating the outputs of agents and tools is crucial for building reliable and secure AI agents. Validators help ensure data integrity and handle LLM hallucinations.

## Validators

There are 4 different validators in Agency Swarm:

* Tool validators:
  * `field_validator`: Validate individual fields independently.
  * `model_validator`: Perform complex checks involving multiple fields.
* Agent validators:
  * `response_validator`: Validate the response before sending it to the user or other agents.
* Universal validators:
  * `llm_validator`: Validate outputs against specified natural language rules.

### Agent Response Validator

You can define a `response_validator` method inside your Agent class to validate responses before sending them to the user or other agents. This method should raise an error if the response is invalid, allowing the agent to handle the error and generate a corrected response.

**Example:**

```python
from agency_swarm import Agent

class CustomerSupportAgent(Agent):
    def response_validator(self, message: str) -> str:
        """Validate the response before sending it."""
        if "bad word" in message.lower():
            raise ValueError("Please avoid using inappropriate language.")
        return message
```

In this example, `CustomerSupportAgent` checks the response for the presence of "bad word" and raises a `ValueError` if it is found. The error is passed to the Agent to generate a corrected response.

### Tool Validators

When defining tools, you can use Pydantic validators to prevent invalid data from being passed to the tool by the calling agent.

There are 2 types of validators used specifically in tools: field-level and model-level validators. Here is the comparison table to help you understand the difference between them:

| Type                 | Purpose                                                               | Usage                                                                                 |
| -------------------- | --------------------------------------------------------------------- | ------------------------------------------------------------------------------------- |
| **Field Validators** | Validate individual fields independently.                             | Use the `@field_validator` decorator on methods, specifying the field(s) to validate. |
| **Model Validators** | Validate the entire model, allowing checks involving multiple fields. | Use the `@model_validator` decorator on methods.                                      |

<Tabs>
  <Tab title="Field Validators" defaultOpen={true}>
    This example ensures that the `username` field does not contain spaces using a field validator:

    ```python
    from pydantic import field_validator
    from agency_swarm import BaseTool

    class User(BaseTool):
        username: str

        @field_validator('username')
        @classmethod
        def validate_username(cls, value):
            if ' ' in value:
                raise ValueError('Username must not contain spaces.')
            return value
    ```
  </Tab>

  <Tab title="Model Validators">
    This example, a model validator checks that `password` and `confirm_password` match, which requires access to multiple fields:

    ```python
    from pydantic import model_validator
    from agency_swarm import BaseTool

    class User(BaseTool):
        password: str
        confirm_password: str

        @model_validator(mode='after')
        def check_passwords_match(self):
            if self.password != self.confirm_password:
                raise ValueError('Passwords do not match.')
            return self
    ```
  </Tab>
</Tabs>

### LLM Validator

The `llm_validator` is a powerful way to validate outputs against specified natural language rules.

**Example:**

```python
from agency_swarm.tools.send_message import SendMessage
from agency_swarm.util.validators import llm_validator
from pydantic import model_validator

class SendMessageLLMValidation(SendMessage):
    @model_validator(mode='after')
    def validate_recipient(self):
        if self.recipient == "CustomerSupportAgent":
            llm_validator(
                statement="The message is related to customer support."
            )(self.message)
        return self
```

In this example, the `llm_validator` will throw an error if the message is not related to customer support. The caller agent will then have to fix the recipient or the message and send it again.

<Note>
  Since `llm_validator` uses LLMs for validation, it may incur additional costs and latency due to extra API calls. Use it for fields that require complex validation beyond simple checks.
</Note>

By combining all the validators described above, you can create robust validation logic to ensure your agents and tools perform reliably.


# Shared State
Source: https://agency-swarm.ai/additional-features/shared-state

Leveraging shared state across tools and agents.

`shared_state` is a centralized Python dictionary accessible by all tools and agents. It allows you to control execution flow, share data, and provide instructions to the agents based on certain conditions or actions performed by other agents.

<Note>
  Shared state is only available when tools are deployed together with agents (see [Deployment to Production](/additional-features/deployment-to-production) guide). If tools are deployed as separate APIs, they won't share the same state, and you'll need to implement your own state management solution.
</Note>

## Understanding Shared State

Shared state is particularly useful when your agents interact with multiple tools that need to exchange information. Here's why:

* **Without Shared State**: Suppose `Tool A` collects data that `Tool B` needs. The agent must explicitly pass this data as a parameter to `Tool B`.

![Without Shared State](https://mintlify.s3.us-west-1.amazonaws.com/vrsenai/images/shared-state-without.png)

* **With Shared State**: `Tool A` can store the required data in the shared state, and `Tool B` can get it without needing direct parameter passing. This approach reduces complexity and minimizes the risk of errors.

![With Shared State](https://mintlify.s3.us-west-1.amazonaws.com/vrsenai/images/shared-state-with.png)

## Using Shared State

The two basic operations are:

* **Setting** a value in the shared state: `shared_state.set('key', value)`
* **Getting** a value from the shared state: `shared_state.get('key')`

You can use shared state in your tools and agents. Here's how:

<Tabs>
  <Tab title="Within a Tool: Setting a value">
    To set a value in the shared state within a tool, use the `self._shared_state.set` inside your tool. For example, you can store the context retrieved from a database in the shared state:

    ```python
    class QueryDatabase(BaseTool):
        """
        Retrieves data from the database and stores it in the shared state.
        """
        question: str = Field(..., description="The query to execute.")

        def run(self):
            # Fetch data based on the question
            context = query_database(self.question)
            # Store the context in shared state
            self._shared_state.set('context', context)
            return "Context has been retrieved and stored successfully."
    ```
  </Tab>

  <Tab title="Within a Tool: Using the value">
    To get a value from the shared state within a tool, use `self._shared_state.get`. Continuing the previous example, you can ensure that the Agent has called the `QueryDatabase` tool before proceeding:

    ```python
    class AnswerQuestion(BaseTool):
        """
        Provides answers based on the context stored in shared state.
        """
        def run(self):
            # Access the stored context
            context = self._shared_state.get('context')
            if not context:
                return "Context is missing. Please call QueryDatabase tool first."
            # Generate an answer using the context
            answer = f"Answer derived from context: {context}"
            return answer
    ```
  </Tab>

  <Tab title="Within an Agent: Using the value">
    You can use the shared state within your agent's `response_validator` method to validate responses. For example, you can verify if the agent's response matches content stored in the shared state:

    ```python
    class MyAgent(Agent):
        """
        An agent that utilizes shared state to validate responses.
        """
        def response_validator(self, message: str) -> str:
            """Validate the response before returning it."""
            context = self.shared_state.get('context')
            if message not in context:
                raise ValueError(f"Invalid response: {message} is not in context: {context}")
            return message
    ```
  </Tab>
</Tabs>


# Streaming
Source: https://agency-swarm.ai/additional-features/streaming

Implementing streaming in Agency Swarm.

Streaming enables agents to return outputs immidiately, significantly improving user experience. Instead of waiting for the entire response to be generated, the user can see the response being generated in real-time.

## Streaming Responses

To stream the conversation between agents, you can use the `get_completion_stream` method with your own event handler. The process follows a similar pattern to the [official OpenAI documentation](https://platform.openai.com/docs/api-reference/assistants-streaming).

The only difference is that you must extend the `AgencyEventHandler` class, which has 2 additional properties: `agent_name` and `recipient_agent_name`, to get the names of the agents communicating with each other. (See the `on_text_created` below.)

```python
from typing_extensions import override
from agency_swarm import AgencyEventHandler

class EventHandler(AgencyEventHandler):
    @override
    def on_text_created(self, text) -> None:
        # Get the name of the agent that is sending the message
        print(f"\n{self.recipient_agent_name} @ {self.agent_name}  > ", end="", flush=True)

    @override
    def on_text_delta(self, delta, snapshot):
        print(delta.value, end="", flush=True)

    def on_tool_call_created(self, tool_call):
        print(f"\n{self.recipient_agent_name} > {tool_call.type}\n", flush=True)

    def on_tool_call_delta(self, delta, snapshot):
        if delta.type == 'code_interpreter':
            if delta.code_interpreter.input:
                print(delta.code_interpreter.input, end="", flush=True)
            if delta.code_interpreter.outputs:
                print(f"\n\noutput >", flush=True)
                for output in delta.code_interpreter.outputs:
                    if output.type == "logs":
                        print(f"\n{output.logs}", flush=True)

    @classmethod
    def on_all_streams_end(cls):
        print("\n\nAll streams have ended.")  # Conversation is over and message is returned to the user.

response = agency.get_completion_stream("I want you to build me a website", event_handler=EventHandler)
```

<Note>
  The `on_all_streams_end` class method is called when all streams have ended. This is particularly important since your
  event handler might be called multiple times and possibly by multiple agents, unlike in the official OpenAI
  documentation.
</Note>


# Contributing to Agency Swarm
Source: https://agency-swarm.ai/contributing/contributing

Learn how to contribute to Agency Swarm

We welcome contributions to Agency Swarm! By contributing, you help improve the framework for everyone. Here's how you can get involved:

## Setting Up Your Development Environment

Follow these steps to set up your local development environment:

<Steps titleSize="h3">
  <Step title="Fork the Repository" icon="code-branch" iconType="solid">
    Fork the Agency Swarm repository on GitHub to your own account.
  </Step>

  <Step title="Clone Your Fork" icon="arrow-down-to-line" iconType="solid">
    Clone your forked repository and navigate to the project directory.

    ```bash
    git clone https://github.com/YOUR_USERNAME/agency-swarm.git
    cd agency-swarm
    ```
  </Step>

  <Step title="Create a Virtual Environment" icon="laptop-code" iconType="solid">
    Create and activate a virtual environment.

    ```bash
    python3 -m venv venv
    source venv/bin/activate  # On Windows use `venv\Scripts\activate`
    ```
  </Step>

  <Step title="Install Dependencies" icon="download" iconType="solid">
    Install the required packages.

    ```bash
    pip install -r requirements-dev.txt
    ```
  </Step>

  <Step title="Install Documentation Tools" icon="book" iconType="solid">
    To work on the documentation, you'll need Mintlify CLI:

    ```bash
    npm i -g mintlify
    ```

    To preview documentation changes locally:

    ```bash
    cd docs
    mintlify dev
    ```

    The documentation will be available at [http://localhost:3000](http://localhost:3000)
  </Step>

  <Step title="Install Pre-Commit Hooks" icon="check" iconType="solid">
    Install pre-commit hooks for code quality checks.

    ```bash
    pip install pre-commit
    pre-commit install
    ```
  </Step>
</Steps>

## Running Tests

<Tip>
  Testing ensures that your contributions work as intended and do not break existing functionality.
</Tip>

<Steps titleSize="h3">
  <Step title="Install Test Dependencies" icon="download" iconType="solid">
    Ensure all test dependencies are installed.

    ```bash
    pip install -r requirements-dev.txt
    ```
  </Step>

  <Step title="Run Tests" icon="play" iconType="solid">
    Run the test suite using Pytest.

    ```bash
    pytest
    ```
  </Step>

  <Step title="Check Test Coverage" icon="chart-bar" iconType="solid">
    Check the test coverage to ensure comprehensive testing.

    ```bash
    pytest --cov=agency_swarm tests/
    ```
  </Step>
</Steps>

## Submitting Changes

<AccordionGroup>
  <Accordion title="Create Branch" icon="code-branch" iconType="solid">
    Create a branch for your work:

    ```bash
    git checkout -b feature/your-feature-name
    ```
  </Accordion>

  <Accordion title="Commit Changes" icon="git" iconType="solid">
    Commit your updates:

    ```bash
    git add .
    git commit -m "Add [feature]: Description"
    ```
  </Accordion>

  <Accordion title="Push Branch" icon="code-fork" iconType="solid">
    Push your branch:

    ```bash
    git push origin feature/your-feature-name
    ```
  </Accordion>

  <Accordion title="Open PR" icon="paper-plane" iconType="solid">
    Open a pull request on GitHub:

    ```markdown
    - Provide a concise title and description.
    - Reference related issues.
    ```
  </Accordion>
</AccordionGroup>


# Agency Parameters
Source: https://agency-swarm.ai/core-framework/agencies/agency-parameters

Explanation of parameters in Agency class.

## Shared Instructions (Agency Manifesto)

The `agency_manifesto.md` file contains instructions that will be shared among all agents in the agency.

Here is a template to help get you started:

```markdown
# Agency Manifesto

[Description of your agency]

## Mission Statement

[Your mission statement]

## Operating Environment

[Description of your operating environment]
```

To use the manifesto, simply specify the path to your manifesto in the `Agency` class.

```python
agency = Agency(
    agency_chart=[...],
    shared_instructions='agency_manifesto.md',
    ...
)
```

## Shared Files

Shared files allow you to share certain files among all agents in the agency. All your agents will than be able to use these files with `FileSearch` and `CodeInterpreter` tools.

To use shared files, simply put them in a folder and specify the folder path in a `shared_files` parameter.

```python
agency = Agency([ceo], shared_files='my_shared_files_folder')
```

## Default Parameters

Some parametrs in `Agency` class mimic those in `Agent` class.

**In case if the parameter is defined in both classes, the value from `Agent` class will be used.**

```python
agency = Agency([ceo], temperature=0.3, max_prompt_tokens=25000)
```

You can use the folloing parameters to set default values for the entire agency:

* `temperature`
* `top_p`
* `max_completion_tokens`
* `max_prompt_tokens`
* `truncation_strategy`

## Custom Settings Path

By default, Agency Swarm keeps the state of your agents in a special `settings.json` file. If you would like to use a different file path for settings, you can specify a `settings_path` parameter:

```python
agency = Agency([ceo], settings_path='my_settings.json')
```

If this file does not exist, it will be created, along with new Assistants on your OpenAI account.


# Communication Flows
Source: https://agency-swarm.ai/core-framework/agencies/communication-flows

Understanding communication flows in Agency Swarm.

Unlike all other frameworks, communication flows in Agency Swarm are **not hierarchical** or **sequential**. Instead, they are **uniform**, which means you can define them in any way you want.

## Defining Your Own Communication Flows

Communication flows in Agency Swarm are established from left to right inside the `agency_chart`. So, in the example below, the CEO can initiate communication and send tasks to the Developer and the Virtual Assistant, and it can respond back to him in the same thread, but the Developer or the VA cannot initiate a conversation and assign tasks to the CEO.

```python
from agency_swarm import Agency

agency = Agency([
    ceo, dev  # CEO and Developer will be the entry point for communication with the user
    [ceo, dev],  # CEO can initiate communication with Developer
    [ceo, va],   # CEO can initiate communication with Virtual Assistant
    [dev, va]    # Developer can initiate communication with Virtual Assistant
])
```

All agents added inside the top-level list of `agency_chart` (`ceo, dev`), can talk to the user.

To allow Developer to initiate communication with the CEO, you need to simply add it to the `agency_chart` list:

```python
agency = Agency([
    ceo, dev, [dev, ceo]  # Developer can initiate communication with the CEO
])
```

You can add as many levels of communication as you want.

## Under the Hood

Agency Swarm uses a special `SendMessage` to allow agents to communicate with each other. By adding agents to the second-level list, it simply adds a new recipient to the `SendMessage` function. If you'd like to modify the behavior of this tool, you can do so by creating your own [Custom Communication Flows](/additional-features/custom-communication-flows/overview) (**Advanced**).


# Overview
Source: https://agency-swarm.ai/core-framework/agencies/overview

Understanding agencies in Agency Swarm.

Agency in Agency Swarm is a collection of agents that can collaborate with one another.

## Benefits of Using an Agency

Utilizing an Agency consisting of multiple agents offers several benefits:

<CardGroup cols={3}>
  <Card title="Fewer Hallucinations" icon="bug" iconType="solid">
    Agents within an agency can supervise each other, reducing mistakes and handling unexpected scenarios more effectively.
  </Card>

  <Card title="Complex Tasks" icon="diagram-project" iconType="solid">
    Adding more agents allows for longer sequences of actions, enabling the completion of more complex tasks before delivering results to the user.
  </Card>

  <Card title="Scalability" icon="arrow-up-right-dots" iconType="solid">
    Agencies allow you to scale your solutions seamlessly by adding more agents, as the complexity of your system grows.
  </Card>
</CardGroup>

<Tip>
  Start with a minimal number of agents. Fine-tune them to ensure they function correctly before adding more.
  Introducing too many agents initially can make debugging and understanding interactions challenging.
</Tip>

## Agency Parameters

Overview of parameters in `Agency` class:

| Name                               | Parameter               | Description                                                                                                                                                                                                                                                                                                                                              |
| ---------------------------------- | ----------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Agency Chart                       | `agency_chart`          | A list that defines the hierarchy and interaction patterns between agents. It specifies:<br />1. Individual agents that can interact with users<br />2. Agent pairs that can communicate with each other<br /><br />Example: `[agent1, [agent1, agent2]]`<br />- `agent1` has user interaction permissions<br />- `agent1` can communicate with `agent2` |
| Shared Instructions *(optional)*   | `shared_instructions`   | Path to a file containing instructions shared across all agents. Can be a relative path from the agency's folder or an absolute path. Default: empty string                                                                                                                                                                                              |
| Shared Files *(optional)*          | `shared_files`          | Path to a folder or list of folders containing files accessible by all agents. These files are added to each agent's files folder. Default: `None`                                                                                                                                                                                                       |
| Async Mode *(optional)*            | `async_mode`            | Specifies the asynchronous processing mode. Options:<br />- `"threading"`: All sub-agents run in separate threads<br />- `"tools_threading"`: All tools run in separate threads, but agents do not<br />Default: `None`                                                                                                                                  |
| Settings Path *(optional)*         | `settings_path`         | Path to the JSON settings file for the agency. If file doesn't exist, it will be created. Default: `"./settings.json"`                                                                                                                                                                                                                                   |
| Settings Callbacks *(optional)*    | `settings_callbacks`    | Dictionary containing functions to load and save settings. Must include both `"load"` and `"save"` functions. Both functions must be defined. Default: `None`                                                                                                                                                                                            |
| Threads Callbacks *(optional)*     | `threads_callbacks`     | Dictionary containing functions to load and save threads. Must include both `"load"` and `"save"` functions. Both functions must be defined. Default: `None`                                                                                                                                                                                             |
| Temperature *(optional)*           | `temperature`           | Controls response randomness (0.0 to 1.0). Agent-specific values override this. Lower values make responses more focused and deterministic. Default: `0.3`                                                                                                                                                                                               |
| Top P *(optional)*                 | `top_p`                 | Alternative to temperature for controlling response randomness (0.0 to 1.0). Agent-specific values override this. Default: `1.0`                                                                                                                                                                                                                         |
| Max Prompt Tokens *(optional)*     | `max_prompt_tokens`     | Maximum tokens allowed in the prompt for each agent. Agent-specific values override this. Default: `None`                                                                                                                                                                                                                                                |
| Max Completion Tokens *(optional)* | `max_completion_tokens` | Maximum tokens allowed in the completion for each agent. Agent-specific values override this. Default: `None`                                                                                                                                                                                                                                            |
| Truncation Strategy *(optional)*   | `truncation_strategy`   | Dictionary configuring how to handle token limits. Agent-specific values override this. See [OpenAI documentation](https://platform.openai.com/docs/api-reference/runs/createRun#runs-createrun-truncation_strategy) for details. Default: `None`                                                                                                        |

## Example

Quick example of how to create an agency with 3 agents:

```python
from agency_swarm import Agency
from .ceo import CEO
from .developer import Developer
from .virtual_assistant import VirtualAssistant

ceo = CEO()
dev = Developer()
va = VirtualAssistant()

agency = Agency([
    ceo, dev  # CEO and Developer will be the entry point for communication with the user
    [ceo, dev],  # CEO can initiate communication with Developer
    [ceo, va],   # CEO can initiate communication with Virtual Assistant
    [dev, va]    # Developer can initiate communication with Virtual Assistant
])
```

## Next Steps

Make sure to learn more about [Communication Flows](/core-framework/agencies/communication-flows), [Agency Parameters](/core-framework/agencies/agency-parameters), and [Running an Agency](/core-framework/agencies/running-agency).


# Running an Agency
Source: https://agency-swarm.ai/core-framework/agencies/running-agency

How to run an Agency.

When it comes to running your agency, you have 3 options:

1. **Gradio Interface**: The most convenient way to get started.
2. **Get Completion**: For backend or custom integrations.
3. **Terminal Version**: Best for quick debugging and testing.

## Gradio Interface

To open a convenient Gradio interface in your browser, use the `demo_gradio` method:

```python
agency.demo_gradio(height=700)
```

Simply follow the `localhost` link from the terminal to start using your agency.

## Get Completion

To get a response from your agency directly in code, use the `get_completion` method:

```python
response = agency.get_completion("I want you to build me a website",
                                 additional_instructions="This is an additional instruction for the task.",
                                 tool_choice={"type": "function", "function": {"name": "SendMessage"}},
                                 attachments=[],
                                 recipient_agent=dev,
                                 )
print(response)
```

**Parameters**:

* `message`: The message to send to the agency.
* `additional_instructions` (optional): Additional instructions that will be appended at the end of instructions for the recipient agent.
* `tool_choice` (optional): Force the recipient agent to use a specific tool.
* `attachments` (optional): A list of attachments to be sent with the message, following [OpenAI format](https://platform.openai.com/docs/api-reference/messages/createMessage#messages-createmessage-attachments).
* `recipient_agent` (optional): The agent to which the message should be sent.

## Terminal Version

To run the agency directly from your terminal, use the `run_demo` method:

```bash
agency.run_demo()
```

<Tip>
  When using the terminal to run the agency, you can send messages directly to any top-level agent by using the "mentions" feature. To do this, start your message with the agent's name preceded by an @ symbol (for example, `@Developer I want you to build me a website`). This directs your message to the specified agent instead of the CEO. You can also press the tab key to autocomplete the agent's name.
</Tip>

***

## Deleting Agency

If you would like to delete the agency and all associated files, vector stores, and assistants on OpenAI, you can use the `delete` method:

```python
agency.delete()
```


# Advanced Configuration
Source: https://agency-swarm.ai/core-framework/agents/advanced-configuration

Learn advanced configuration options for your agents in Agency Swarm.

All parameters inside the `Agent` class, follow the same structure as [OpenAI's Assistants API](https://platform.openai.com/docs/api-reference/assistants). However, there are a few advanced parameters that require more explanation.

### Parallel Tool Calls

Whether to run tools in parallel or sequentially. By default, this parameter is set to `True`.

```python
from agency_swarm import Agent

agent = Agent(name='MyAgent', parallel_tool_calls=False)
```

### File Search Configuration

File search configuration for the agent, as described in the [OpenAI documentation](https://platform.openai.com/docs/api-reference/assistants/createAssistant#assistants-createassistant-tools).

```python
from agency_swarm import Agent

agent = Agent(
    name='MyAgent',
    file_search={
        'max_num_results': 25,
        'ranking_options': {
            "score_threshold": 0.5,
            "ranker": "auto"
        }
    }
)
```

Parameters:

* `max_num_results`: The maximum number of results the file search tool should output. The default is 20 for `gpt-4*` models and 5 for `gpt-3.5-turbo`. This number should be between 1 and 50 inclusive. Note that the file search tool may output fewer than `max_num_results` results.
* `ranking_options`: The ranking options for the file search. If not specified, the file search tool will use the `auto` ranker and a score\_threshold of 0. See the [file search tool documentation](https://platform.openai.com/docs/assistants/tools/file-search#customizing-file-search-settings) for more information.

### Response Validator

This is a special function that allows you to validate the response before sending it to the user or another agent. This function should raise an error if the response is invalid. The agent will then see this error as the user message and try correct itself accordingly.

```python

from agency_swarm import Agent

class MyAgent(Agent):
    def response_validator(self, message: str) -> str:
        """This function is used to validate the response before sending it to the user or another agent."""
        if "bad word" in message:
            raise ValueError("Please don't use bad words.")

        return message
```

### Few-Shot Examples

Few-show examples help the agent to understand how to respond. The format for examples follows [message object format on OpenAI](https://platform.openai.com/docs/api-reference/messages/createMessage):

```python
from agency_swarm import Agent

examples=[
    {
        "role": "user",
        "content": "Hi!",
        "attachments": [],
        "metadata": {},
    },
    {
        "role": "assistant",
        "content": "Hi! I am the CEO. I am here to help you with your tasks. Please tell me what you need help with.",
        "attachments": [],
        "metadata": {},
    }
]

agent = Agent(
    name='MyAgent',
    examples=examples
)
```


# Built-in Tools
Source: https://agency-swarm.ai/core-framework/agents/built-in-tools

Learn how to use built-in tools in Agency Swarm.

Each agent in Agency Swarm also with some built-in tools inherited from [OpenAI Assistants API](https://platform.openai.com/docs/api-reference/assistants/createAssistant#assistants-createassistant-tools).

## Code Interpreter

Code Interpreter allows agents to execute code within a remote Jupyter Notebook environment.

```python
from agency_swarm.tools import CodeInterpreter

agent = Agent(
    name="DataAnalyst",
    tools=[CodeInterpreter],
    # Other agent parameters
)
```

**When to use:**

* To perform data analysis and precise calculations.
* To handle structured files (CSV, Excel, etc.).
* To run standalone code snippets in a remote environment.

## File Search

File Search allows agents to search through their knowledge base to improve their responses. This tool uses a production-ready vector database provided by OpenAI.

```python
  from agency_swarm.tools import FileSearch

  agent = Agent(
      name="Researcher",
      tools=[FileSearch],
      # Optionally, you can specify your own vector store ID to use:
      tool_resources={
        "file_search": {
          "vector_store_ids": ["vs_abc123"],
        },
      },
      # More details can be found here: https://platform.openai.com/docs/api-reference/vector-stores/object
      # Other agent parameters
  )
```

**When to use:**

* To enrich your agent's knowledge about specific topics
* To reduce hallucinations by grounding agent responses in your documents
* To enable users to query their own documents


# Overview
Source: https://agency-swarm.ai/core-framework/agents/overview

Understanding Agents in Agency Swarm.

Agents are the core building blocks of the Agency Swarm framework. Each agent is specialized for a specific role and is designed to perform a specific set of processes within an agency.

## Key Characteristics of Agents

<CardGroup cols={3}>
  <Card title="Autonomous" icon="robot">
    Agents can determine the next best actions by themselves.
  </Card>

  <Card title="Adaptive" icon="bolt">
    Agents adapt their course of action based on real-time feedback.
  </Card>

  <Card title="Interactive" icon="wrench">
    Agents can manipulate their environment by using tools.
  </Card>
</CardGroup>

## Agent Parameters

From a technical perspective, in Agency Swarm, agents are essentially wrappers for [OpenAI Assistants](https://platform.openai.com/docs/assistants/deep-dive#creating-assistants). The `Agent` class includes convenience methods to help you manage the state of your assistant, upload files, attach tools, and more:

| Name                               | Parameter               | Description                                                                                                                                              |
| ---------------------------------- | ----------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ID *(optional)*                    | `id`                    | Loads the assistant from OpenAI assistant ID. Assistant will be created or loaded from settings if ID is not provided. Default: `None`                   |
| Name *(optional)*                  | `name`                  | Name of the agent. Default: Uses the class name                                                                                                          |
| Description *(optional)*           | `description`           | A brief description of the agent's purpose. Default: `None`                                                                                              |
| Instructions *(optional)*          | `instructions`          | Path to a file containing specific instructions for the agent. Default: Empty string                                                                     |
| Tools *(optional)*                 | `tools`                 | A list of tool classes that the agent can use (BaseTool, FileSearch, or CodeInterpreter). Default: `None`                                                |
| Tool Resources *(optional)*        | `tool_resources`        | Resources used by the assistant's tools. For example, code\_interpreter requires file IDs, while file\_search requires vector store IDs. Default: `None` |
| Temperature *(optional)*           | `temperature`           | Controls randomness in the agent's responses. Lower values make responses more focused and deterministic. Default: `None`                                |
| Top P *(optional)*                 | `top_p`                 | Alternative to temperature for controlling response randomness. Default: `None`                                                                          |
| Response Format *(optional)*       | `response_format`       | Specifies the format for agent responses. Can be a string, dict, or Pydantic BaseModel. Default: `"auto"`                                                |
| Tools Folder *(optional)*          | `tools_folder`          | Path to a directory containing tools. Each tool must be in a separate file named after the tool class. Default: `None`                                   |
| Files Folder *(optional)*          | `files_folder`          | Path or list of paths to directories containing files for the agent. Default: `None`                                                                     |
| Schemas Folder *(optional)*        | `schemas_folder`        | Path or list of paths to directories containing OpenAPI schemas. Default: `None`                                                                         |
| API Headers *(optional)*           | `api_headers`           | Headers for OpenAPI requests. Keys must match schema filenames. Default: Empty dict                                                                      |
| API Params *(optional)*            | `api_params`            | Extra parameters for OpenAPI requests. Keys must match schema filenames. Default: Empty dict                                                             |
| Metadata *(optional)*              | `metadata`              | Additional metadata for the agent. Default: Empty dict                                                                                                   |
| Model *(optional)*                 | `model`                 | The OpenAI model to use. Default: `"gpt-4o-2024-08-06"`                                                                                                  |
| Validation Attempts *(optional)*   | `validation_attempts`   | Number of attempts to validate responses. Default: `1`                                                                                                   |
| Max Prompt Tokens *(optional)*     | `max_prompt_tokens`     | Maximum tokens allowed in the prompt. Default: `None`                                                                                                    |
| Max Completion Tokens *(optional)* | `max_completion_tokens` | Maximum tokens allowed in completions. Default: `None`                                                                                                   |
| Truncation Strategy *(optional)*   | `truncation_strategy`   | Strategy for handling token limits. Default: `None`                                                                                                      |
| Examples *(optional)*              | `examples`              | List of example messages for the agent. Default: `None`                                                                                                  |
| File Search *(optional)*           | `file_search`           | Configuration for the file search tool. Default: `None`                                                                                                  |
| Parallel Tool Calls *(optional)*   | `parallel_tool_calls`   | Whether to run tools in parallel. Default: `True`                                                                                                        |
| Refresh From ID *(optional)*       | `refresh_from_id`       | Whether to load and update the agent from OpenAI when an ID is provided. Default: `True`                                                                 |

<Warning>
  **Warning**: The `file_ids` parameter is deprecated. Use the `tool_resources` parameter instead.
</Warning>

## Agent Template

It's recommended to create your agent in a seprate file. Your agent class should look like this:

```python
from agency_swarm import Agent

class AgentName(Agent):
    def __init__(self):
        super().__init__(
            name="agent_name",
            description="agent_description",
            instructions="./instructions.md",
            files_folder="./files",
            schemas_folder="./schemas",
            tools_folder="./tools",
            tools=[],
            temperature=0.3,
            max_prompt_tokens=25000,
            examples=[]
        )
```

You can add more parameters to the `__init__` method.

To initialize the agent:

```python
from AgentName import AgentName

agent = AgentName()
```


# State Management
Source: https://agency-swarm.ai/core-framework/state-management

Learn how Agency Swarm manages state across agents and sessions.

Agency Swarm conveniently manages the state of your agents and threads, simplifying the assistant creation and management process on [OpenAI's Assistants API](https://platform.openai.com/docs/assistants/deep-dive).

## Agent State Management

In OpenAI Assistants API, all agents need to be updated before they can be used. Agency Swarm manages this by maintaining a local `settings.json` file, and the comparing local settings with the ones stored on OpenAI's servers. If there are any differences, the Assistants are updated on OpenAI's servers. This ensures that the agents are only created once, and are only updated when needed.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/vrsenai/images/state-management.png" alt="State Management" />

## Thread State Management

Additionally, OpenAI's Assistants API manages the conversation context through threads. A thread represents a persistent conversation between an assistant and a user, automatically handling the storage and truncation of messages to fit within the model's context window. This approach offloads the complexity of conversation state management to OpenAI, ensuring efficient and seamless context handling.

<CardGroup cols={2}>
  <Card title="Persistent Conversations" icon="messages">
    Maintains ongoing conversations without manual history management.
  </Card>

  <Card title="Automatic Context Management" icon="scissors">
    Handles message storage and truncation within token limits.
  </Card>
</CardGroup>

## Next Steps

* [Read all available agent parameters](/core-framework/agents/overview)
* [Learn how to manage your agents on a remote server](/additional-features/deployment-to-production)


# Best Practices & Tips
Source: https://agency-swarm.ai/core-framework/tools/custom-tools/best-practices

Best practices and real-world examples for Agency Swarm tools.

Although the tool interface is straightforward and simple to use, there are actually quite a few practices and tricks that you can use to get significantly better results.

### Use Chain-of-Thought Prompting for Complex Tools

Use chain-of-thought prompting to allow the agent to think and plan before executing a complex tool.

```python
from agency_swarm.tools import BaseTool
from pydantic import Field

class ComplexAnalysisTool(BaseTool):
    """
    Performs complex analysis after planning the approach.
    """
    chain_of_thought: str = Field(
        ...,
        description="Think-step-by-step about how to perform the analysis."
    )
    data: str = Field(..., description="Data to analyze.")

    def run(self):
        # Analysis logic
        return "Analysis complete."
```

### Provide Hints for the Agent

Based on your tool's logic, you can provide hints for the agent in tool output on what to do next.

```python
class QueryDatabase(BaseTool):
    question: str = Field(...)

    def run(self):
        # query your database here
        context = self.query_database(self.question)

        # context not found
        if context is None:
            # tell agent what to do next
            raise ValueError("No context found. Please propose to the user to change the topic.")
        else:
            # return the context to the agent
            return context
```

### Use Shared State to Control the Tool Flow

Use `shared_state` to validate previous actions taken by this or other agents, before allowing it to proceed with the next action.

```python
class Action2(BaseTool):
    input: str = Field(...)

    def run(self):
        if self._shared_state.get("action_1_result", None) is "failure":
            raise ValueError("Please proceed with the Action1 tool first.")
        else:
            return "Success. The action has been taken."
```

### Use Special Types

Restrict the agent to only use specific values for a field, instead of letting it wander by itself.

```python
from typing import Literal

class RunCommand(BaseTool):
    """
    Execute predefined system commands.
    """
    command: Literal["start", "stop"] = Field(..., description="Command to execute: 'start' or 'stop'.")

    def run(self):
        if self.command == "start":
            # Start command logic
            pass
        elif self.command == "stop":
            # Stop command logic
            pass
        else:
            raise ValueError("Invalid command")
```

or use special Pydantic types like `EmailStr`.

```python
from pydantic import EmailStr

class EmailSender(BaseTool):
    recipient: EmailStr = Field(..., description="Email recipient's address.")
```

### Combine Multiple Methods

Combine multiple methods to make your execution flow more readable.

```python
class CompositeTool(BaseTool):
    """
    A tool that combines several methods to perform a series of actions.
    """
    input_data: str = Field(..., description="Input data for the composite operation.")

    def run(self):
        # Step 1: Process data
        processed_data = self.process_data(self.input_data)
        # Step 2: Analyze results
        analysis = self.analyze_results(processed_data)
        # Step 3: Format output
        output = self.format_output(analysis)
        return output

    def process_data(self, data):
        # Implement data processing logic
        pass

    def analyze_results(self, data):
        # Implement analysis logic
        pass

    def format_output(self, data):
        # Implement output formatting
        pass
```

### Include a Test Case

Include test cases at the bottom of each tool file.

```python
if __name__ == "__main__":
    # Test the EmailSender tool
    email_sender = EmailSender(
        chain_of_thought="Plan to inform the team about the update.",
        recipient="user@example.com",
        subject="Project Update",
        body="The project is on track."
    )
    assert email_sender.run() == "Email sent successfully."
```

## Next Steps

We highly recommend you explore the resources provided in the [Pydantic is all you need](/core-framework/tools/custom-tools/pydantic-is-all-you-need) section.


# Advanced Tool Configuration
Source: https://agency-swarm.ai/core-framework/tools/custom-tools/configuration

Advanced features and patterns for Agency Swarm tools.

Besides standard Pydantic features, you can also use a special `ToolConfig` class to customize tool behavior within the framework:

## Available `ToolConfig` Parameters

Currently, the following parameters are supported:

| Name                 | Type   | Description                                                                                                                                                                                                                             | When to Use                                                                                                                                                 | Default Value |
| -------------------- | ------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------- |
| `one_call_at_a_time` | `bool` | Prevents concurrent execution for a specific tool. To prevent the agent from executing **any** tools concurrently, set `parallel_tool_calls=False` in the Agent class.                                                                  | Use for database operations, API calls with rate limits, or actions that depend on previous results.                                                        | `False`       |
| `strict`             | `bool` | Enables strict mode, which ensures the agent will always provide **perfect** tool inputs that 100% match your schema. Has limitations. See [OpenAI Docs](https://platform.openai.com/docs/guides/structured-outputs#supported-schemas). | Use for mission-critical tools or tools that have nested Pydantic model schemas.                                                                            | `False`       |
| `async_mode`         | `str`  | When set to "threading," executes this tool in a separate thread.                                                                                                                                                                       | Use when your agent needs to execute multiple tools or the same tool multiple times in a single message to decrease latency. Beware of resource allocation. | `None`        |
| `output_as_result`   | `bool` | Forces the output of this tool as the final message from the agent that called it.                                                                                                                                                      | Only recommended for very specific use cases and only if you know what you're doing.                                                                        | `False`       |

## Usage

To use one of the available parameters, simply add a `class ToolConfig` block to your tool class:

```python
class MyCustomTool(BaseTool):
    # ...

    class ToolConfig:
        one_call_at_a_time = True
        strict = False
        async_mode = "threading"
        output_as_result = True

    def run(self):
        # ...
```


# Pydantic is All You Need
Source: https://agency-swarm.ai/core-framework/tools/custom-tools/pydantic-is-all-you-need

How Pydantic solved AI agent reliability.

The idea of using Pydantic to validate tool calls and responses is not new. It was popularized by Jason Liu in his library called [Instructor](https://github.com/instructor-ai/instructor).

To really understand why it's such a game changer, we recommend watching this video:

<iframe width="100%" height="400" src="https://www.youtube.com/embed/yj-wSRJwrrc" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen />

## Learn more

To take your tools to the next level, we highly recommend the following resources:

* [Pydantic Models Documentation](https://docs.pydantic.dev/latest/concepts/models/)
* [Instructor Concepts](https://python.useinstructor.com/concepts/)
* [Instructor Tips & Tricks](https://python.useinstructor.com/tutorials/2-tips/)
* [Instructor Cookbook](https://python.useinstructor.com/examples/)


# Step-by-Step Guide
Source: https://agency-swarm.ai/core-framework/tools/custom-tools/step-by-step-guide

Learn how to create custom tools in Agency Swarm framework.

In Agency Swarm, tools are Python classes that inherit from `BaseTool`. They are defined using [Pydantic](https://docs.pydantic.dev/latest/), a data validation library. Each BaseTool must implement the `run` method, which is the main method that will be called when the tool is invoked by an agent.

## Step-by-step Guide

To create a custom tool, typically you need to follow these steps:

<Steps>
  <Step title="Add Import Statements">
    On top of your tool file, import the necessary modules and classes.

    ```python
    from agency_swarm.tools import BaseTool
    from pydantic import Field, model_validator
    # ... other imports
    ```
  </Step>

  <Step title="Define the Tool Class and Docstring">
    Create a new class that inherits from `BaseTool`. Write a clear docstring describing the tool's purpose. **This docstring is crucial as it helps agents understand how to use the tool.**

    ```python
    class Calculator(BaseTool):
        """
        A simple calculator tool that evaluates mathematical expressions.
        """
    ```
  </Step>

  <Step title="Define Input Fields">
    Use Pydantic fields to define the inputs your tool will accept.

    ```python
    expression: str = Field(..., description="The mathematical expression to evaluate.")
    ```

    <Accordion title="Custom Validation Logic (Optional)" icon="hammer">
      You can use [Pydantic's validators](https://docs.pydantic.dev/latest/concepts/validators/) to verify the inputs. This can be extremely effective to avoid hallucinations or other errors in production.

      ```python
      @model_validator(mode="after")
      def validate_expression(self):
          if self.expression.endswith("/0"):
              raise ValueError("Division by zero is not permitted")
      ```
    </Accordion>
  </Step>

  <Step title="Implement the run Method">
    Add the functionality that will be executed when the tool is called.

    ```python
    def run(self):
        # Implement the tool's functionality
        result = eval(self.expression)
        return str(result)
    ```

    The `run` method should return a string, which is the tool's output that the agent will see and use in its response.
  </Step>

  <Step title="Test the Tool Independently">
    Test the tool independently to ensure it behaves as expected. We recommend adding a `if __name__ == "__main__":` block at the end of the tool file:

    ```python
    if __name__ == "__main__":
        calc = Calculator(expression="2 + 2 * 3")
        print(calc.run())  # Output should be '8'
    ```
  </Step>

  <Step title="Add the Tool to an Agent">
    After your tool works as expected, simply add it to an agent's list of `tools`.

    ```python
    from agency_swarm import Agent
    from .tools.calculator import Calculator

    agent = Agent(
        name="MathAgent",
        tools=[Calculator],
        # Other agent parameters
    )
    ```

    <Accordion title="Using tools folder" icon="folder">
      Alternatively, you can simply place the tool file in the `tools_folder` directory and it will be automatically added to the agent.

      ```python
      from agency_swarm import Agent
      agent = Agent(
          name="MathAgent",
          tools_folder="./tools",
          # Other agent parameters
      )
      ```

      <Note>
        Each file in the `tools_folder` should contain a class that is named exactly the same as the file name. For example, `Calculator.py` should contain a `Calculator` class.
      </Note>
    </Accordion>
  </Step>
</Steps>

## Full Code Example

Below is the full code example for a calculator tool above.

```python
# calculator.py
from agency_swarm.tools import BaseTool
from pydantic import Field, model_validator

class Calculator(BaseTool):
    """
    A simple calculator tool that evaluates mathematical expressions.
    """
    expression: str = Field(..., description="The mathematical expression to evaluate.")

    @model_validator(mode="after")
    def validate_expression(self):
        if self.expression.endswith("/0"):
            raise ValueError("Division by zero is not permitted")

    def run(self):
        result = eval(self.expression)
        return str(result)

if __name__ == "__main__":
    calc = Calculator(expression="2 + 2 * 3")
    print(calc.run())  # Output should be '8'
```

## Next Steps

* Checkout [Best Practices & Tips](/core-framework/tools/custom-tools/best-practices)
* Learn why [PyDantic is all you need](/core-framework/tools/custom-tools/pydantic-is-all-you-need)


# OpenAPI Schemas
Source: https://agency-swarm.ai/core-framework/tools/openapi-schemas

Convert OpenAPI schemas into tools.

Agency allows you to easily convert OpenAPI schemas into tools so your agents can interact with any external APIs. For example, by adding the Google Calendar API schema, your agent will be able to create, update, delete, and retrieve events from Google Calendar.

<Tip>
  It is still recommended to create custom tools and wrap each API call into a `BaseTool` class, even if you have the OpenAPI schema. OpenAPI schemas allow you to get started quickly, however, for production, you might want to add some custom data validation, error handling, data processing or even combine multiple API calls into a single tool.
</Tip>

## How to Find OpenAPI Schemas

The recommended way to create OpenAPI schemas is to use [Actions GPT](https://chatgpt.com/g/g-TYEliDU6A-actionsgpt). Simply ask it to create a schema for the API you want to use and which actions you want to perform.

**If your API is public and well known**, it should be able to create a schema for you on the first try, without any extra documentation.

```
Create a schema for the Google Calendar API and include the following actions: create, update, delete, and get events.
```

**If your API is public but not well known**, we recommend searching for the API documentation manually and then sending a link to your API into the prompt:

```
Create a schema for the following API: https://api.example.com/openapi.json and include the following actions: create, update, delete, and get events.
```

**If you your API is private**, you can attach your API documentation in a file:

```
Create a schema for the API documentation attached in the file. Include the following actions: create, update, delete, and get events.
```

## How to Use OpenAPI Schemas

Below are the two ways to use OpenAPI schemas in your agents:

#### Option 1: Using the `schemas_folder`

The first way to integrate OpenAPI schemas is by placing all your OpenAPI schema files in a folder, and then initializing your agent with the `schemas_folder` parameter. Agency Swarm will then automatically scan this folder and convert any OpenAPI schemas it finds into `BaseTool` instances.

```python
from agency_swarm import Agent

agent = Agent(
    name='MyAgent',
    schemas_folder='schemas',
    api_params={'api_schema.json': {'param1': 'value1'}},
    api_headers={'api_schema.json': {'Authorization': 'Bearer token'}}
)
```

In this example:

* `schemas_folder`: Directory where your OpenAPI schema files are stored.
* `api_params`: Extra parameters for specific schemas.
* `api_headers`: Custom headers for API calls, like authentication tokens.

#### Option 2: Using the ToolFactory Class

Alternatively, you can use the `ToolFactory` class to convert OpenAPI schemas from local files or URLs.

```python
from agency_swarm.tools import ToolFactory

tools = ToolFactory.from_openapi_schema(
    "<your OpenAPI schema here>",
    headers={'api_schema.json': {'Authorization': 'Bearer token'}},
    params={'api_schema.json': {'param1': 'value1'}},
    strict=False
)
```

<Accordion title="Converting from a Local Schema File">
  ```python
  from agency_swarm.tools import ToolFactory

  with open("schemas/api_schema.json") as f:
      tools = ToolFactory.from_openapi_schema(f.read())
  ```
</Accordion>

<Accordion title="Converting from a Remote Schema URL">
  ```python
  from agency_swarm.tools import ToolFactory
  import requests

  response = requests.get("https://api.example.com/openapi.json")
  tools = ToolFactory.from_openapi_schema(response.json())
  ```
</Accordion>

Argument descriptions:

* `schema`: The OpenAPI schema to convert.
* `headers`: Custom headers for API calls, like authentication tokens.
* `params`: Extra parameters for specific schemas.
* `strict`: Whether to use strict OpenAI mode.

To add your tools to your agent with the 2nd option, simply pass the `tools` list to your agent:

```python
agent = Agent(
    name='MyAgent',
    tools=tools
)
```

With this approach, you have more control over the tools you are adding to your agent, and you can still modify the `ToolConfig` of each tool. See the [ToolConfig documentation](/core-framework/tools/custom-tools/configuration) for more information.

<Info>
  With any of these methods, Agency still converts your schemas into PyDantic models, so your agents will perform type checking on all API parameters **before** making API calls, reducing errors and improving reliability.
</Info>


# Overview
Source: https://agency-swarm.ai/core-framework/tools/overview

Understanding Tools in Agentic Systems.

Tools are the most important component of any Agentic system. In this guide, we'll cover the basics: what tools are, key characteristics, and the three primary ways you can build or import your own tools.

## Key Characteristics of Tools

Effective tools share the following characteristics:

<CardGroup cols={3}>
  <Card title="Task-Specific" icon="bullseye">
    Each tool performs a single, well-defined task. They should not be focused on an API, but rather on whatever it takes to complete the task.
  </Card>

  <Card title="Configurable" icon="gear">
    Tools can be configured to perform the same task in different ways. The agent must be able to adapt based on previous circumstances.
  </Card>

  <Card title="Reusable" icon="recycle">
    Tools must be easily reusable not only by the same agent, but also across different agents. Each tool should have specific instructions on how to use it.
  </Card>
</CardGroup>

## What are Tools?

**At a high level, tools represent the capabilities that your agents have.**

Tools enable your agents to perform specific tasks necessary to fulfill their designated roles. For instance, just as a real virtual assistant can search the web or send emails, the virtual assistant agent can be equipped with similar tools.

Below are some more examples of tools:

* **FileWriter:** A tool that allows an agent to write code or text to a file.
* **CommandExecutor:** A tool that allows an agent to execute terminal commands.
* **LeadUpdater:** A tool that allows an agent to update a lead in a CRM.
* **LinkedInProfileScraper:** A tool that allows an agent to scrape a LinkedIn profile.
* **FacebookAdCreator:** A tool that allows an agent to create a Facebook ad.

<Tip>
  By themselves, each of these tools is not very useful, however in combination with each other, they allow agents to perform a much wider range of tasks.

  For example, `FileWriter` tool by itself can allow the developer agent to write code, however, in combination with the `CommandExecutor` tool, it can also run and test its own code, which instantly makes it more powerful. (We'll cover the key characteristics of tools in a bit.)
</Tip>

**At a low level, tools are essentially just code.**

Whatever the tool you are creating, at the lowest level, it always comes down to code. The only difference is where this code is being executed. For instance, if you are making an API call, it will primarily be executed in the cloud, and if it's a file system tool, it will be executed on the same machine where the agent is running. **Even if you are using a no-code platform to build your tools, like n8n or zapier, at the lowest level, it all still comes down to code.**

This means that agentic systems are much more similar to traditional software programs than you might think...

![Tools Diagram](https://mintlify.s3.us-west-1.amazonaws.com/vrsenai/images/agents-vs-programs.png)

Just as in a standard program, we have functions that are executed in a loop, in an agentic system, we have tools that are executed by your agents.

And what this allows you to do, is tackle significantly more complex tasks. Tasks where there are so many possible paths that you can't hard code all of the possible conditional logic in advance.

Now, that we understand what tools are, let's cover how you can build your own tools.

## 3 Ways to Build Tools

When it comes to building your own tools, you have 3 primary options:

<CardGroup cols={3}>
  <Card title="Custom Tools" icon="hammer" href="./custom-tools">
    Build your own completely custom tools from scratch. (Recommended)
  </Card>

  <Card title="Pre-Made Tools" icon="box" href="./tool-factory">
    Import out-of-the-box pre-made tools from the special [agency-tools](https://github.com/VRSEN/agency-tools) open source repository.
  </Card>

  <Card title="OpenAPI Schemas" icon="file-code" href="./openapi-schemas">
    Use public OpenAPI schemas and convert them into tools.
  </Card>
</CardGroup>

**It is recommended to start with custom tools**, as they give you the most flexibility and control. Even if you are connecting to external APIs, we still recommend creating custom tools, as they allow you to have more control over the tool's outputs.

Click on the card of your choice to learn more about each one.


# Agency Swarm Extras
Source: https://agency-swarm.ai/extras/extras

Additional resources and repositories for Agency Swarm.

Explore additional repositories to enhance your Agency Swarm experience.

<CardGroup cols={3}>
  <Card title="Agency Swarm Lab" href="https://github.com/VRSEN/agency-swarm-lab" icon="flask" iconType="duotone">
    Experiment with the latest features in Agency Swarm Lab.
  </Card>

  <Card title="API Railway Template" href="https://github.com/VRSEN/agency-swarm-api-railway-template" icon="train" iconType="duotone">
    Deploy your agency using the API Railway Template.
  </Card>

  <Card title="Voice Interface" href="https://github.com/VRSEN/agency-voice-interface" icon="microphone" iconType="duotone">
    Integrate voice commands with the Agency Voice Interface.
  </Card>
</CardGroup>


# FAQ
Source: https://agency-swarm.ai/faq

Find answers to common questions about Agency Swarm.

<AccordionGroup defaultOpen={true}>
  <Accordion title="How do I set my OpenAI API key in my project?" icon="key">
    Set your API key in your code:

    ```python
    from agency_swarm import set_openai_key
    set_openai_key("YOUR_API_KEY")
    ```

    Or use a `.env` file:

    ```env
    OPENAI_API_KEY=sk-1234...
    ```

    Then load it with:

    ```python
    from dotenv import load_dotenv
    load_dotenv()
    ```
  </Accordion>

  <Accordion title="What's the difference between using .cursorrules (with Cursor IDE) and 'agency-swarm genesis'?" icon="scale-unbalanced">
    There are two ways to create agents with AI:

    1. [**Genesis Agency**:](/welcome/getting-started/genesis-agency) A simple command-line tool that helps you create basic agent structures. Great for getting started or simple use cases. Just run `agency-swarm genesis` and follow the prompts.

    2. [**Cursor AI Code Editor**](/welcome/getting-started/cursor-ide): Use the `.cursorrules` file in Cursor IDE to create agents. This is the best option for both beginners and experienced developers since it gives you more control over the agent creation process.
  </Accordion>

  <Accordion title="Can I use open source models with Agency Swarm?" icon="code-fork">
    Yes—you can use open source models for simple, non–mission-critical tasks (usually one or two tools per agent). See [Open Source Models](/additional-features/open-source-models) for more information. Keep in mind that many open source models currently struggle with function calling.
  </Accordion>

  <Accordion title="How do I save and continue conversations?" icon="messages">
    To persist threads between application restarts, implement thread callbacks that save and load thread IDs from a local file. For example, define your callback functions:

    ```python
    import os
    import json

    def load_threads(chat_id):
        if os.path.exists(f"{chat_id}_threads.json"):
            with open(f"{chat_id}_threads.json", "r") as file:
                return json.load(file)
        return []

    def save_threads(new_threads, chat_id):
        with open(f"{chat_id}_threads.json", "w") as file:
            json.dump(new_threads, file)
    ```

    Then, pass these callbacks during your agency initialization to resume conversations:

    ```python
    from agency_swarm.agency.genesis import GenesisAgency

    agency = GenesisAgency(
        ...
        threads_callbacks={
            'load': lambda: load_threads(chat_id),
            'save': lambda new_threads: save_threads(new_threads, chat_id)
        }
    )
    ```

    This setup preserves your conversation context between runs.
  </Accordion>

  <Accordion title="How do I manage multiple users with Agency Swarm?" icon="users">
    To support multiple users/chats, you need to load and save thread IDs in your database accordingly. Each chat/user should have unique thread IDs. Ensure to check out our [Deployment to Production](/additional-features/deployment-to-production) guide for more information.
  </Accordion>

  <Accordion title="How can I transfer data between tools and agents?" icon="upload">
    There are two ways to transfer data between tools and agents:

    1. Use shared state inside your tools. Read more: [Shared State](/additional-features/shared-state)
    2. Create a tool (or modify an existing one) that uploads files to storage and outputs the file ID. This file ID can then be used by other tools or agents.
  </Accordion>

  <Accordion title="Why is the CodeInterpreter tool automatically added?" icon="code">
    When file types like `.json`, `.docx`, or `.pptx` are uploaded, CodeInterpreter is auto-added to process them. To change the agent's behavior, update its instructions or create a custom file-handling tool.
  </Accordion>

  <Accordion title="How can I serve an Agency as an API using FastAPI?" icon="book">
    Embed your agency within a FastAPI endpoint. For example:

    ```python
    @app.post("/chat")
    async def chat(user_request: UserRequest):
        chat_id = user_request.chat_id or str(uuid4())
        agency = Agency([...],
            threads_callbacks={
                'load': lambda: load_threads(chat_id),
                'save': lambda new_threads: save_threads(new_threads, chat_id)
            })
        response = agency.get_completion(user_request.message)
        return {"chat_id": chat_id, "response": response}
    ```
  </Accordion>

  <Accordion title="How do I deploy my agency to production?" icon="rocket">
    Build a dedicated API backend (FastAPI is recommended) that manages authentication and persists thread state using callbacks. For more details, refer to our [Deployment to Production](/additional-features/deployment-to-production) guide.
  </Accordion>
</AccordionGroup>

## Getting Support

<CardGroup cols={2}>
  <Card title="Community Support" icon="discord" href="https://discord.gg/cw2xBaWfFM">
    Join our Discord community for quick help and discussions.
  </Card>

  <Card title="Professional Services" icon="briefcase" href="https://agents.vrsen.ai/">
    Get professional help with our Agents-as-a-Service subscription.
  </Card>
</CardGroup>


# Agency Swarm Tutorials
Source: https://agency-swarm.ai/tutorials/tutorials

Learn how to use Agency Swarm to automate workflows through practical examples

<CardGroup cols={3}>
  <Card title="Quick Start: Deploy AI Agents" href="https://www.youtube.com/watch?v=53_e3lmk6Mo" icon="rocket" iconType="duotone">
    Deploy AI agents in your business using our template. Covers strategies, best practices, and examples.
  </Card>

  <Card title="Build AI Agents in Plain English" href="https://www.youtube.com/watch?v=Og73plUTabs" icon="robot" iconType="duotone">
    Create AI agent teams with Cursor template. Build a content creation agency step-by-step.
  </Card>

  <Card title="Advanced Features Deep Dive" href="https://www.youtube.com/watch?v=AZlPelcATHo" icon="wand-magic-sparkles" iconType="duotone">
    Master async mode, parallel tool calling, and open-source model integration.
  </Card>

  <Card title="5 Innovative AI Agent Projects" href="https://www.youtube.com/watch?v=hb0j9Qn-KjM" icon="brain" iconType="duotone">
    Real-world applications and implementations of AI agents in business automation.
  </Card>

  <Card title="Open Source Model Support" href="https://www.youtube.com/watch?v=Vd-Gtfm_zjw" icon="code-branch" iconType="duotone">
    Integrate open source models and Assistance API v2 features into your projects.
  </Card>

  <Card title="Complete Beginner's Guide" href="https://www.youtube.com/watch?v=MOyl58VF2ak" icon="book-open" iconType="duotone">
    Learn AI agent development from scratch, including building a Social Media Marketing Agency.
  </Card>
</CardGroup>

## Example Projects

<CardGroup cols={3}>
  <Card title="Web Dev Crafters" href="https://github.com/VRSEN/agency-swarm-lab/tree/main/WebDevCrafters" icon="laptop-code" iconType="duotone">
    Build responsive web apps using Next.js and Material UI.
  </Card>

  <Card title="Code Guardians Agency" href="https://github.com/VRSEN/agency-swarm-lab/tree/main/CodeGuardiansAgency" icon="shield-halved" iconType="duotone">
    Automated code reviews on pull requests using GitHub Actions.
  </Card>

  <Card title="QA Testing with Vision" href="https://youtu.be/Yidy_ePo7pE" icon="magnifying-glass" iconType="duotone">
    Use GPT-4 Vision for QA testing.
  </Card>

  <Card title="Genesis Agency" href="https://youtu.be/qXxO7SvbGs8" icon="leaf" iconType="duotone">
    Create custom agents.
  </Card>
</CardGroup>


# Agency Swarm vs Other Frameworks
Source: https://agency-swarm.ai/welcome/ai-agency-vs-other-frameworks

Compare Agency Swarm with other multi-agent AI frameworks.

## Summary

In summary, Agency Swarm is the only framework that has:

<CardGroup cols={3}>
  <Card title="No Predefined Prompts" icon="message-code">
    It doesn't write prompts for you, giving you full control over agent behavior.
  </Card>

  <Card title="Automatic Error Correction" icon="shield-check">
    Prevents hallucinations with automatic type checking and error correction.
  </Card>

  <Card title="Uniform Communication Flows" icon="diagram-project">
    Allows you to define communication flows in any way you want.
  </Card>
</CardGroup>

## Detailed Comparison

Here's how Agency Swarm compares to 2 other most popular multi-agent frameworks.

| **Criteria**                     | **Agency Swarm**                                                                                    | **AutoGen**                                                                                                            | **CrewAI**                                                                                                    |
| -------------------------------- | --------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------- |
| **Origins** 🏁                   | ✅ Originated from a real AI agency building AI agents for clients worldwide.                        | ✅ Originated as a research experiment.                                                                                 | ❌ Originated as a funding vehicle, rather than a real production framework.                                   |
| **Design & Architecture** 🏗️    | ✅ Super lightweight framework with minimal abstractions. Built on top of the OpenAI Assistants API. | ✅ Event-driven architecture with support for both ChatCompletions and Assistants API.                                  | ❌ Lacks a clear architectural design. Built on top of LangChain with numerous unnecessary abstractions.       |
| **Reliability** 🔍               | ✅ Robust type checking and validation for all tools with Pydantic.                                  | ❌ Type hints but no validation.                                                                                        | ❌ Some validation is possible when using BaseTool, although the interface is not convenient to use.           |
| **Flexibility** 🔄               | ✅ No predefined prompts. Uniform communication.                                                     | ❌ Contains predefined prompts. Limited, but customizable communication flows.                                          | ❌ Numerous predefined prompts. Only two ways of communication.                                                |
| **Scalability** 📈               | ✅ Easily scalable. Adding another agent only requires placing it in the agency chart.               | ❌ Although it's simple to add an agent into teams, it's almost impossible to define custom communication between them. | ❌ Although it's easy to add agents into crews, it's not possible to create custom communication between them. |
| **Deployability** 🚀             | ✅ Easily deployable with special callback functions. Offers open-source templates and tutorials.    | ✅ Deployment with AutoGen studio.                                                                                      | ❌ Deployment via enterprise platform. No open-source deployment guides.                                       |
| **Open Source Model Support** 🌐 | ⚠️ [Limited support](/additional-features/open-source-models) with Astra Assistants API.            | ✅ Moderate open-source model support.                                                                                  | ✅ Full open-source model support.                                                                             |

<Note>
  If you want to challange any of these claims, or if some of the issues disappear as frameworks mature, please open an issue on [GitHub](https://github.com/agenty/swarm).
</Note>

## Summary

* **Agency Swarm** - best for **real business-oriented use cases**.
* **AutoGen** - best for **research, experimentation and novel AI applications**.
* **CrewAI** - best for **local development and playgrounds** with open-source models.


# Cursor AI
Source: https://agency-swarm.ai/welcome/getting-started/cursor-ide

Getting started with Cursor.

<iframe width="100%" height="400" src="https://www.youtube.com/embed/Og73plUTabs" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen style={{ borderRadius: "10px" }} />

## Why Use Cursor

Cursor simplifies AI agent development by reducing the feedback loop on AI-generated code. This enables faster iteration and provides an optimal balance between manual control and AI assistance.

![Cursor IDE Overview](https://mintlify.s3.us-west-1.amazonaws.com/vrsenai/images/cursor-overview.png)

## What are Cursor Rules

**Cursor Rules** are custom instructions that tell Cursor how to work with your code. Agency has a predefined `.cursorrules` file that contains everything that Cursor needs to know in order to create agents with this framework.

![Cursor Rules Example](https://mintlify.s3.us-west-1.amazonaws.com/vrsenai/images/cursor-rules-example.png)

## Getting Started with Cursor

Follow these steps to create your first Agency using Cursor:

<Steps>
  <Step title="Enable Cursor Rules in Settings">
    First, you need to enable Cursor Rules in the Cursor IDE:

    * Open the Cursor IDE.
    * Go to **Settings...** > **Cursor Settings**.

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/vrsenai/images/open-cursor-settings.png" width="65%" alt="Open Cursor Settings" style={{display: 'block', margin: '0 auto'}} />

    * Turn on the **Rules for AI** option. This allows you to use a `.cursorrules` file in your project.
      ![Enable Cursor Rules](https://mintlify.s3.us-west-1.amazonaws.com/vrsenai/images/enable-cursor-rules.png)
  </Step>

  <Step title="Add The `.cursorrules` File to Your Project">
    The `.cursorrules` file contains the instructions that guide Cursor's AI. To add it:

    * Download the `.cursorrules` file from the [Agency Swarm repository](https://github.com/VRSEN/agency-swarm/blob/main/.cursorrules).
    * Place the file in the main folder (root directory) of your project.
  </Step>

  <Step title="Open Cursor Composer">
    Cursor Composer allows you to create and modify multiple files in parallel.

    * Open Composer by pressing `Cmd+I` (macOS) or `Ctrl+I` (Windows/Linux).
  </Step>

  <Step title="Send Your First Prompt to Composer">
    Spend as much time as possible on your first prompt. This will save you a lot of time later. Make sure to include:

    * All agents that you want to create
    * All tools and APIs that the agents must use
    * Communication flows between your agents
  </Step>

  <Step title="Verify The Agency Structure">
    Sometimes Cursor forgets certain files or hallucinates the agency structure. Make sure to verify that:

    * All import statements are correct
    * `requirements.txt` file exists
    * `agency.py` file executes properly

    If any of these are missing or not working, instruct composer to create them or fix the code.
  </Step>

  <Step title="Adjust the Tools">
    Run each tool file to make sure they work as expected. You will see the test cases that Cursor created at the bottom in `if __name__ == "__main__"` statements.

    * If any of the tools are not working, send the error message to composer and ask it to fix the code.
    * If you want to adjust the functionality of the tool, either use inline editing `Cmd+K` (macOS) or `Ctrl+K` (Windows/Linux) or send another message to composer.
    * If you are stuck, use Chat `Cmd+L` (macOS) or `Ctrl+L` (Windows/Linux) to ask questions and brainstorm alternative approaches. For example, ask "What other APIs can I use for this tool?"
  </Step>

  <Step title="Adjust the Agents">
    Verify the agent instructions and parameters are correct after adjustments. **Actually think about instructions.**

    * Use Chat or Inline Editing to adjust the `instruction.md` files to your needs.
    * Edit instructions manually and remove all boilerplate text.
    * Make sure each agent has access to all the new tools either by specifying `tools_folder` path or adding them in `tools` parameter.
  </Step>

  <Step title="Test Your Agency">
    Run `agency.py` file to see if it works.

    * Send a realistic task to your agency and see if it can complete it.
    * If it doesn't work as expected, try to send additional messages with more details and see if it helps.
    * Use these extra messages to guide yourself on how to adjust the instructions, so it can complete it next time.
  </Step>

  <Step title="Repeat">
    Iterate on your agency by repeating the process until you are satisfied with the results.

    <Note>
      **Agent Development is an Iterative Process**

      Currently, agent development requires ongoing monitoring and adjustments to ensure desired performance. As larger and more advanced models become available, this process will become more streamlined.
    </Note>
  </Step>
</Steps>

## Next Steps

* Learn the core concepts of Tools, Agents, and Agencies.
* Watch the [Deployment Tutorial](https://www.youtube.com/watch?v=53_e3lmk6Mo).


# From Scratch
Source: https://agency-swarm.ai/welcome/getting-started/from-scratch

Quick start guide to building an Agency from scratch.

<Steps>
  <Step title="Set Your OpenAI Key">
    Begin by setting your OpenAI API key.

    ```python
    from agency import set_openai_key
    set_openai_key("YOUR_API_KEY")
    ```

    Alternatively, you can set the API key in the `.env` file.

    ```
    OPENAI_API_KEY=sk-...
    ```
  </Step>

  <Step title="Create Project Structure">
    Use the `create-agent-template` command to create the recommended directory structure for each agent.

    **Command Syntax:**

    ```bash
    agency-swarm create-agent-template --name "AgentName" --description "Agent Description" [--path "/path/to/directory"] [--use_txt]
    ```

    **Agent Folder Structure:**

    When you run the create-agent-template command, it creates the following folder structure for your agent:

    ```
    /your-agency-path/
    └── AgentName/                    # Directory for the specific agent
        ├── files/                    # Directory for files that will be uploaded to openai
        ├── schemas/                  # Directory for OpenAPI schemas to be converted into tools
        ├── tools/                    # Directory for tools to be imported by default.
        ├── AgentName.py              # The main agent class file
        ├── __init__.py               # Initializes the agent folder as a Python package
        └── instructions.md or .txt   # Instruction document for the agent
    ```

    This structure ensures that each agent has its dedicated space with all necessary files to start working on its specific tasks.

    **Agency Folder Structure:**

    The full structure of the project will look like this:

    ```
    AgencyName/
    ├── AgentName/            # Agent folder created with the command above
    ├── AnotherAgent/         # Another agent folder
    ├── agency.py             # Main file where agents are imported and the agency is defined
    ├── agency_manifesto.md   # Shared instructions and guidelines for all agents
    ├── requirements.txt      # File listing all dependencies
    └── ...
    ```
  </Step>

  <Step title="Create Tools">
    Define your custom tools by extending the `BaseTool` class and implementing the `run` method.

    **MyCustomTool.py:**

    ```python
    from agency_swarm.tools import BaseTool
    from pydantic import Field

    class MyCustomTool(BaseTool):
        """
        A brief description of what the custom tool does.
        The docstring should clearly explain the tool's purpose and functionality.
        It will be used by the agent to determine when to use this tool.
        """

        # Define the fields with descriptions using Pydantic Field
        example_field: str = Field(
            ..., description="Description of the example field, explaining its purpose and usage for the Agent."
        )

        # Additional Pydantic fields as required
        # ...

        def run(self):
            """
            The implementation of the run method, where the tool's main functionality is executed.
            This method should utilize the fields defined above to perform the task.
            Doc string is not required for this method and will not be used by your agent.
            """

            # Your custom tool logic goes here
            do_something(self.example_field)

            # Return the result of the tool's operation as a string
            return "Result of MyCustomTool operation"
    ```
  </Step>

  <Step title="Define Agent Roles">
    Adjust the parameters and instructions for each agent.

    **Developer.py:**

    ```python
    from agency_swarm import Agent

    class Developer(Agent):
        def __init__(self):
            super().__init__(
                name="Developer",
                description="Responsible for executing tasks.",
                instructions="./instructions.md",
                files_folder="./files",
                schemas_folder="./schemas",
                tools_folder="./tools",
                temperature=0.3,
                max_prompt_tokens=25000,
                examples=[]
            )
    ```

    Tools will be imported automatically from the `tools` folder.

    **instructions.md:**

    ```md
    You are a Developer agent responsible for executing tasks.

    # Role
    You are responsible for writing clean, efficient, and reusable code.

    # Process
    1. How to handle incoming requests
    2. When and how to use available tools
    3. How to collaborate with other agents
    ```
  </Step>

  <Step title="Create Agency">
    Import your agents and initialize the Agency class.

    **agency.py:**

    ```python
    from agency_swarm import Agency
    from .Developer import Developer
    from .CEO import CEO

    developer = Developer()
    ceo = CEO()

    agency = Agency(
        [
            ceo,  # CEO will be the entry point for communication with the user
            [ceo, developer],  # CEO can initiate communication with Developer
        ],
        shared_instructions='./agency_manifesto.md'  # shared instructions for all agents
    )
    ```

    Any agents that are listed in the same list (e.g., `[[ceo, developer]]`) can communicate with each other. The top-level list (`[ceo]`) defines agents that can communicate with the user.

    <Note title="Note on Communication Flows">
      In Agency Swarm, communication flows are directional, meaning they are established from left to right in the `agency_chart` definition. For instance, in the example above, the CEO can initiate a chat with the Developer (`developer`), and the Developer can respond in this chat. However, the Developer cannot initiate a chat with the CEO.
    </Note>
  </Step>

  <Step title="Run Demo">
    There are three ways to run the demo. Add one of the following lines to your `agency.py` file:

    **Web Interface:**

    ```python
    agency.demo_gradio(height=900)
    ```

    **Terminal Version:**

    ```python
    agency.run_demo()
    ```

    **Backend Version:**

    ```python
    completion_output = agency.get_completion("Please create a new website for our client.", yield_messages=False)
    ```
  </Step>
</Steps>

## Next Steps

* Learn the core concepts of Tools, Agents, and Agencies.
* Watch the [Deployment Tutorial](https://www.youtube.com/watch?v=53_e3lmk6Mo).


# Genesis Agency
Source: https://agency-swarm.ai/welcome/getting-started/genesis-agency

Quick start guide using the Genesis Agency.

Genesis Agency is a special Agency within the framework that helps you to create your own AI Agencies faster. This agency consists of specialized agents that work together to:

* Generate agent templates with appropriate folder structure
* Create custom tools and connect APIs for each agent
* Define your agency's manifesto and communication flows

<Note>
  **Genesis Agency is not perfect yet.**

  Please note that the Genesis Agency will not be able to generate complex agencies. For more complex use cases, we recommend using [Cursor](./cursor-ide).
</Note>

## Use Genesis Agency

<Steps>
  <Step title="Run the `genesis` command">
    Initialize the Genesis Agency in your terminal and generate your agent templates.

    **Command Syntax:**

    ```bash
    agency-swarm genesis [--openai_key "YOUR_API_KEY"]
    ```
  </Step>

  <Step title="Chat with Genesis CEO">
    Provide comprehensive context to the Genesis Agency by including:

    * **Your agency's mission and goals.**
    * **The agents you wish to involve and their communication flows.**
    * **Tools or APIs each agent should have access to, if any.**
  </Step>

  <Step title="Wait for Genesis to create your agents">
    After executing the `genesis` command, specialized agents such as `GenesisCEO` and `ToolCreator` will begin constructing your agency's structure and developing the required tools.
  </Step>

  <Step title="Fine-Tune Your Agents and Tools">
    Once Genesis has created your agents, you'll find all the agent folders in the directory where you ran the `genesis` command. Fine-tune the agents and tools as needed by following these steps:

    1. **Adjust Tools**: Modify the tools in each agent's `tools` directory to meet your requirements.
    2. **Adjust Instructions**: Update the agents and their instructions in each agent's folder.
    3. **Run Agency**: Execute the `agency.py` file, send your tasks, and monitor performance.
    4. **Repeat**: Continue refining until your agents perform consistently.

    <Note>
      **Agent Development is an Iterative Process**

      Currently, agent development requires ongoing monitoring and adjustments to ensure desired performance. As larger and more advanced models become available, this process will become more streamlined.
    </Note>
  </Step>
</Steps>

## Next Steps

* Learn the core concepts of [Tools](/core-framework/tools), [Agents](/core-framework/agents), and [Agencies](/core-framework/agencies).
* Watch the [Deployment Tutorial](https://www.youtube.com/watch?v=53_e3lmk6Mo).


# Installation
Source: https://agency-swarm.ai/welcome/installation

Install Agency Swarm in just 2 simple steps.

## Installation

<Accordion title="Step 1: Create a Python Virtual Environment" defaultOpen={false}>
  1. **Install Python**

     Download and install the latest version of Python from the [official Python website](https://www.python.org/downloads/).

  2. **Create a Virtual Environment**

     Navigate to your project directory and create a virtual environment using `venv`:

     ```bash
     python -m venv venv
     ```

  3. **Activate the Virtual Environment**

     On Mac or Linux:

     ```bash
     source venv/bin/activate
     ```

     On Windows:

     ```bash
     venv\Scripts\activate
     ```
</Accordion>

<Accordion title="Step 2: Install the agency swarm package" defaultOpen={true}>
  Simply run the following command:

  <Note>Make sure you are in the virtual environment before installing the package.</Note>

  ```bash
  pip install agency-swarm
  ```
</Accordion>

## Next Steps

When it comes to building your first AI Agency, you have three options:

<CardGroup cols={3}>
  <Card title="From Scratch" icon="code" iconType="duotone" href="./getting-started/from-scratch">
    Build your own agents and tools from the ground up. Perfect to understand the framework's structure and create a
    fully customized solution.
  </Card>

  <Card title="Use Genesis Agency" icon="wand-sparkles" iconType="duotone" href="./getting-started/genesis-agency">
    Let Genesis Agency create your agents for you. Best for simple use cases or for creating your initial agency
    structure quickly.
  </Card>

  <Card title="Cursor (Recommended)" icon="cube" iconType="duotone" href="./getting-started/cursor-ide">
    Use Cursor IDE to streamline the entire agent development process. Recommended for both beginners and advanced
    developers.
  </Card>
</CardGroup>


# Overview
Source: https://agency-swarm.ai/welcome/overview

Welcome to **Agency Swarm**, an open-source agent orchestration framework built on top of the latest [OpenAI Assistants API](https://platform.openai.com/docs/assistants/overview/agents).

## What is Agency Swarm?

Agency Swarm started as a desire and effort of Arsenii Shatokhin (aka VRSEN) to fully automate his AI Agency with AI. By building this framework, we aim to simplify the agent creation process and enable anyone to create collaborative swarms of agents (Agencies), each with distinct roles and capabilities. By thinking about automation in terms of real-world entities, such as agencies and specialized agent roles, we make it a lot more intuitive for both the agents and the users.

## Key Features

<CardGroup cols={2}>
  <Card title="Customizable Agent Roles" icon="user-gear">
    Define roles like CEO, virtual assistant, developer, etc., and customize their functionalities with Assistants API.
  </Card>

  <Card title="Full Control Over Prompts" icon="sliders">
    Avoid conflicts and restrictions of pre-defined prompts, allowing full customization.
  </Card>

  <Card title="Error Correction" icon="shield-check">
    Prevent hallucinations with Pydantic-based type validation and error correction
  </Card>

  <Card title="Efficient Communication" icon="comments">
    Agents communicate based on their own descriptions and nothing else.
  </Card>

  <Card title="State Management" icon="database">
    Agency Swarm efficiently manages the state of your assistants on OpenAI, maintaining it in a special settings.json file.
  </Card>

  <Card title="Deployable in Production" icon="rocket">
    Agency Swarm is designed to be reliable and easily deployable in production environments.
  </Card>
</CardGroup>


